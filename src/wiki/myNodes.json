[
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index::port",
    "language": "typescript",
    "label": "port",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "port = 8001",
    "importStatements": [],
    "codeNoBody": "port ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index::fs",
    "language": "typescript",
    "label": "fs",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index",
    "totalTokens": 6,
    "inDegree": 0,
    "outDegree": 1,
    "code": "fs = require(\"fs\")",
    "importStatements": [],
    "codeNoBody": "fs ={\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index::app",
    "language": "typescript",
    "label": "app",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index",
    "totalTokens": 371,
    "inDegree": 0,
    "outDegree": 1,
    "code": "app = new Hono()\napp.use(\"*\", prettyJSON())\napp.use(\"/v1/*\", cors())\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n})\napp.route(\"/v1/repo\", createGraph)\napp.route(\"/v1/graphs\", graphs)\napp.route(\"v1/repo-test\", createGraphTest)",
    "importStatements": [],
    "codeNoBody": "app = \napp.use(\"*\", prettyJSON())\napp.use(\"/v1/*\", cors())\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n})\napp.route(\"/v1/repo\", createGraph)\napp.route(\"/v1/graphs\", graphs)\napp.route(\"v1/repo-test\", createGraphTest){\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer.getCallsFromNode",
    "language": "typescript",
    "label": "CallsCapturer.getCallsFromNode",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 628,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class CallsCapturer\n    ...\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody() : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n            if (i.names.length === 0) nameAliasReplacements[i.moduleAlias] = i.module\r\n            for (const importName of i.names) nameAliasReplacements[importName.alias] = `${importName.name}`\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`\\\\b${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(?<!\\\\.)\\\\b${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, v.right)\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]}{\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer.captureCalls",
    "language": "typescript",
    "label": "CallsCapturer.captureCalls",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 411,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    let callName = c.replace(/\\?/g, '')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]{\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer.captureAssignments",
    "language": "typescript",
    "label": "CallsCapturer.captureAssignments",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 426,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n                    \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[]{\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer.constructor",
    "language": "typescript",
    "label": "CallsCapturer.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 116,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false){\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "language": "typescript",
    "label": "CallsCapturer",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
    "totalTokens": 1617,
    "inDegree": 9,
    "outDegree": 4,
    "code": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n                    \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    let callName = c.replace(/\\?/g, '')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody() : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n            if (i.names.length === 0) nameAliasReplacements[i.moduleAlias] = i.module\r\n            for (const importName of i.names) nameAliasReplacements[importName.alias] = `${importName.name}`\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`\\\\b${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(?<!\\\\.)\\\\b${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, v.right)\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\r\n\r\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\n        //...\n    }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::Call.constructor",
    "language": "typescript",
    "label": "Call.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::Call",
    "totalTokens": 28,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Call\n    ...\n    constructor(nodeId: string, lines: number[] = []) {\r\n        this.nodeId = nodeId\r\n        this.lines = lines\r\n    }",
    "importStatements": [],
    "codeNoBody": "class Call\n    ...\n    constructor(nodeId: string, lines: number[] = []){\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::Call",
    "language": "typescript",
    "label": "Call",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
    "totalTokens": 44,
    "inDegree": 4,
    "outDegree": 2,
    "code": "class Call {\r\n    nodeId: string\r\n    lines: number[]\r\n\r\n    constructor(nodeId: string, lines: number[] = []) {\r\n        this.nodeId = nodeId\r\n        this.lines = lines\r\n    }\r\n}",
    "importStatements": [],
    "codeNoBody": "class Call {\r\n    nodeId: string\r\n    lines: number[]\r\n    constructor(nodeId: string, lines: number[] = []) {\r\n        this.nodeId = nodeId\r\n        this.lines = lines\r\n    }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallIdentifier.constructor",
    "language": "typescript",
    "label": "CallIdentifier.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallIdentifier",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number){\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallIdentifier",
    "language": "typescript",
    "label": "CallIdentifier",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
    "totalTokens": 45,
    "inDegree": 6,
    "outDegree": 2,
    "code": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::VariableAssignment",
    "language": "typescript",
    "label": "VariableAssignment",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
    "totalTokens": 36,
    "inDegree": 4,
    "outDegree": 2,
    "code": "class VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}",
    "importStatements": [],
    "codeNoBody": "class VariableAssignment{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.resolveHeaderC",
    "language": "typescript",
    "label": "Codebase.resolveHeaderC",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 156,
    "inDegree": 1,
    "outDegree": 6,
    "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (\r\n      headerNode.type !== \"header\" ||\r\n      ![\"c\", \"cpp\"].includes(headerNode.language)\r\n    )\r\n      return;\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id);\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode\r\n        .getAllChildren()\r\n        .find((c) => c.id === id.replace(\"::header\", \"\"));\r\n      if (nodeRef) {\r\n        delete this.nodesMap[id];\r\n        headerNode.removeChild(headerNode.children[id]);\r\n        headerNode.addChild(nodeRef);\r\n        headerNode.children[nodeRef.id] = nodeRef;\r\n        headerNode.inDegree++;\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
    "language": "typescript",
    "label": "Codebase.resolveImportStatementsNodes",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 321,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (![\"file\", \"header\"].includes(n.type)) return;\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`];\r\n        });\r\n        const namesIds = i.names.map((n) => n.node?.id || \"\");\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren([\"file\", \"class\", \"interface\", \"mod\", \"namespace\"])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        });\r\n        if ([\"c\", \"cpp\"].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path];\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode);\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        }\r\n      });\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes(){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
    "language": "typescript",
    "label": "Codebase.resolvePythonInitImportStatements",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 176,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (n.type !== \"file\" || n.language !== \"python\") return;\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements];\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith(\"__init__\")) {\r\n          newImportStatements = newImportStatements.filter(\r\n            (s) => s.path != i.path\r\n          );\r\n          newImportStatements = [\r\n            ...this.nodesMap[i.path].importStatements,\r\n            ...newImportStatements,\r\n          ];\r\n        }\r\n      });\r\n      n.importStatements = newImportStatements;\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements(){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.getLinks",
    "language": "typescript",
    "label": "Codebase.getLinks",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 138,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getLinks(): Link[] {\r\n    const links: Link[] = [];\r\n    const nodes = Object.values(this.nodesMap);\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = \"defines\";\r\n        links.push({ source: n.parent.id, target: n.id, label });\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({ source: n.id, target: c.id, label: \"calls\" })\r\n        );\r\n    }\r\n    return links;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[]{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.simplify",
    "language": "typescript",
    "label": "Codebase.simplify",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes));\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.getCalls",
    "language": "typescript",
    "label": "Codebase.getCalls",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 330,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId];\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`);\r\n        return;\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose);\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()];\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(fileId, n);\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId];\r\n          if (calledNode) {\r\n            n.calls.push(calledNode);\r\n            n.outDegree++;\r\n            calledNode.inDegree++;\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              );\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.parseFolder",
    "language": "typescript",
    "label": "Codebase.parseFolder",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 230,
    "inDegree": 0,
    "outDegree": 7,
    "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {};\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    const allFiles = await getAllFiles(this.rootFolderPath);\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split(\".\").slice(0, -1).join(\".\");\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(\r\n          filePath\r\n        );\r\n        this.addNodeMap(nodesMap);\r\n        id = isHeader ? `${id}::header` : id;\r\n        const fileNode = nodesMap[id];\r\n        fileNodesMap[id] = fileNode;\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles);\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`);\r\n        console.log(error.message);\r\n        throw error;\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements();\r\n    this.resolveImportStatementsNodes();\r\n    return fileNodesMap;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }>{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
    "language": "typescript",
    "label": "Codebase.generateNodesFromFilePath",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 335,
    "inDegree": 1,
    "outDegree": 7,
    "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split(\".\").pop();\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false };\r\n    const data = await fs.readFile(filePath);\r\n    const dataString = Buffer.from(data).toString();\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split(\".\").slice(0, -1).join(\".\");\r\n\r\n    let fileNode;\r\n    let isHeader = false;\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === \"h\") {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        \"header\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n      isHeader = true;\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        \"file\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n    }\r\n    fileNode.name = filePath;\r\n    fileNode.alias = filePath.split(\"/\").pop() || \"\";\r\n    const nodesMap = fileNode.getChildrenDefinitions();\r\n    fileNode.generateImports();\r\n    fileNode.parseExportClauses(this.nodesMap);\r\n    nodesMap[fileNode.id] = fileNode;\r\n\r\n    // get tokens\r\n    Object.values(nodesMap).forEach(\r\n      (n) => (n.totalTokens = enc.encode(n.code, \"all\", []).length)\r\n    );\r\n\r\n    return { nodesMap, isHeader };\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }>{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.addNodeMap",
    "language": "typescript",
    "label": "Codebase.addNodeMap",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 32,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap };\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.getNode",
    "language": "typescript",
    "label": "Codebase.getNode",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 18,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id];\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.addNode",
    "language": "typescript",
    "label": "Codebase.addNode",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 19,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNode(node: Node) {\r\n    this.nodesMap[node.id] = node;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase.constructor",
    "language": "typescript",
    "label": "Codebase.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
    "language": "typescript",
    "label": "Codebase",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 1851,
    "inDegree": 26,
    "outDegree": 4,
    "code": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = \"\";\r\n  nodesMap: { [id: string]: Node } = {};\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node;\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id];\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap };\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split(\".\").pop();\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false };\r\n    const data = await fs.readFile(filePath);\r\n    const dataString = Buffer.from(data).toString();\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split(\".\").slice(0, -1).join(\".\");\r\n\r\n    let fileNode;\r\n    let isHeader = false;\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === \"h\") {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        \"header\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n      isHeader = true;\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        \"file\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n    }\r\n    fileNode.name = filePath;\r\n    fileNode.alias = filePath.split(\"/\").pop() || \"\";\r\n    const nodesMap = fileNode.getChildrenDefinitions();\r\n    fileNode.generateImports();\r\n    fileNode.parseExportClauses(this.nodesMap);\r\n    nodesMap[fileNode.id] = fileNode;\r\n\r\n    // get tokens\r\n    Object.values(nodesMap).forEach(\r\n      (n) => (n.totalTokens = enc.encode(n.code, \"all\", []).length)\r\n    );\r\n\r\n    return { nodesMap, isHeader };\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {};\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    const allFiles = await getAllFiles(this.rootFolderPath);\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split(\".\").slice(0, -1).join(\".\");\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(\r\n          filePath\r\n        );\r\n        this.addNodeMap(nodesMap);\r\n        id = isHeader ? `${id}::header` : id;\r\n        const fileNode = nodesMap[id];\r\n        fileNodesMap[id] = fileNode;\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles);\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`);\r\n        console.log(error.message);\r\n        throw error;\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements();\r\n    this.resolveImportStatementsNodes();\r\n    return fileNodesMap;\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId];\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`);\r\n        return;\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose);\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()];\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(fileId, n);\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId];\r\n          if (calledNode) {\r\n            n.calls.push(calledNode);\r\n            n.outDegree++;\r\n            calledNode.inDegree++;\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              );\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes));\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = [];\r\n    const nodes = Object.values(this.nodesMap);\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = \"defines\";\r\n        links.push({ source: n.parent.id, target: n.id, label });\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({ source: n.id, target: c.id, label: \"calls\" })\r\n        );\r\n    }\r\n    return links;\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (n.type !== \"file\" || n.language !== \"python\") return;\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements];\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith(\"__init__\")) {\r\n          newImportStatements = newImportStatements.filter(\r\n            (s) => s.path != i.path\r\n          );\r\n          newImportStatements = [\r\n            ...this.nodesMap[i.path].importStatements,\r\n            ...newImportStatements,\r\n          ];\r\n        }\r\n      });\r\n      n.importStatements = newImportStatements;\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (![\"file\", \"header\"].includes(n.type)) return;\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`];\r\n        });\r\n        const namesIds = i.names.map((n) => n.node?.id || \"\");\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren([\"file\", \"class\", \"interface\", \"mod\", \"namespace\"])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        });\r\n        if ([\"c\", \"cpp\"].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path];\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode);\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (\r\n      headerNode.type !== \"header\" ||\r\n      ![\"c\", \"cpp\"].includes(headerNode.language)\r\n    )\r\n      return;\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id);\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode\r\n        .getAllChildren()\r\n        .find((c) => c.id === id.replace(\"::header\", \"\"));\r\n      if (nodeRef) {\r\n        delete this.nodesMap[id];\r\n        headerNode.removeChild(headerNode.children[id]);\r\n        headerNode.addChild(nodeRef);\r\n        headerNode.children[nodeRef.id] = nodeRef;\r\n        headerNode.inDegree++;\r\n      }\r\n    });\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = \"\";\r\n  nodesMap: { [id: string]: Node } = {};\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }\r\n  addNode(node: Node) {\n      //...\n  }\r\n  getNode(id: string): Node | undefined {\n      //...\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\n      //...\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n      //...\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\n      //...\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n\r\n  getLinks(): Link[] {\n      //...\n  }\r\n\r\n  resolvePythonInitImportStatements() {\n      //...\n  }\r\n\r\n  resolveImportStatementsNodes() {\n      //...\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\n      //...\n  }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.simplify",
    "language": "typescript",
    "label": "Node.simplify",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 270,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && [\"class\", \"interface\"].includes(this.parent?.type)\r\n          ? `${this.parent.code\r\n              .replace(this.parent.body, \"\")\r\n              .trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n    };\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes;\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr];\r\n      }\r\n      return acc;\r\n    }, {});\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = []){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.getChildrenDefinitions",
    "language": "typescript",
    "label": "Node.getChildrenDefinitions",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 1306,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (![\"file\", \"header\"].includes(this.type)) return {};\r\n    const unnecessaryNodeTypes = [\"export\"]; // exclude it from the analysis\r\n    const captures = captureQuery(\r\n      this.language,\r\n      \"constructorDefinitions\",\r\n      this.code\r\n    );\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let exportable = [\"python\"].includes(this.language) ? true : false;\r\n    let childrenNodes: Node[] = [];\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(\r\n          this.id,\r\n          c.node.text,\r\n          c.name as AllowedTypes,\r\n          this.language\r\n        );\r\n\r\n        newNode.startPosition = c.node.startPosition;\r\n        newNode.endPosition = c.node.endPosition;\r\n        newNode.exportable = exportable;\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling;\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text;\r\n          }\r\n        }\r\n        childrenNodes.push(newNode);\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === \"python\") {\r\n          prevTreeSitterNode = c.node.previousSibling;\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              [\"decorator\"].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row ===\r\n                newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + \"\\n\" + newNode.code;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code;\r\n      if ([\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) {\r\n        if (n.type === \"method\") {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`;\r\n          n.type = \"function\";\r\n        } else if (n.type === \"assignment\") code = `const ${n.code}`;\r\n      } else if ([\"java\"].includes(this.language)) {\r\n        if (n.type == \"function\") {\r\n          const firstLine = code.split(\"(\")[0];\r\n          const firstLineSplit = firstLine.split(\" \");\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, \"definitionTemplate\", code);\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(\r\n        captures,\r\n        n.language === \"java\" ? \"modifier\" : \"name\"\r\n      );\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"modifier\": // java only\r\n            if (n.language == \"java\" && c.node.text.includes(\"public\"))\r\n              n.exportable = true;\r\n            break;\r\n          case \"name\":\r\n            n.name = c.node.text;\r\n            n.id = `${n.id}::${n.name}`;\r\n            break;\r\n          case \"alias\":\r\n            n.alias = c.node.text;\r\n            break;\r\n          case \"documentation\":\r\n            n.documentation = c.node.text;\r\n            if (n.language === \"python\") {\r\n              n.code = n.code.replace(n.documentation, \"\");\r\n              n.body = n.body.replace(n.documentation, \"\");\r\n            }\r\n            break;\r\n          case \"body\":\r\n            n.body = c.node.text;\r\n            break;\r\n        }\r\n      });\r\n      if (!n.alias) n.alias = n.name;\r\n\r\n      if (n.type === \"assignment\") {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          \"extraAssignmentCode\",\r\n          this.code,\r\n          n.name\r\n        );\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === \"code\") n.code += \"\\n\" + c.node.text;\r\n        });\r\n      }\r\n    });\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name);\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j]);\r\n        childrenNodes[j].addNodeRelationship(n);\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n);\r\n    });\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n;\r\n      return map;\r\n    }, {});\r\n    return nodesMap;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node }{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.resolveImportStatementsPath",
    "language": "typescript",
    "label": "Node.resolveImportStatementsPath",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 319,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== \"file\") return;\r\n    const suffix = indexSuffixesMap[this.language];\r\n    const fileSet = new Set(\r\n      allFiles.map((p) => p.split(\".\").slice(0, -1).join(\".\"))\r\n    );\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(\r\n            `${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`\r\n          )\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path),\r\n      ];\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith(\"@/\")) {\r\n        importStatement.path = path.join(\r\n          rootFolderPath,\r\n          importStatement.path.slice(2)\r\n        );\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.parseExportClauses",
    "language": "typescript",
    "label": "Node.parseExportClauses",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 572,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (![\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) return;\r\n    const captures = captureQuery(this.language, \"exportClauses\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let name = \"\";\r\n    let alias = \"\";\r\n    let moduleName = this.id;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"module\":\r\n          moduleName = path.join(\r\n            this.id.split(\"/\").slice(0, -1).join(\"/\"),\r\n            c.node.text\r\n          );\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          name = c.node.text;\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0];\r\n          if (importedName) moduleName = importedName.path;\r\n          const node =\r\n            this.children[`${this.id}::${name}`] ||\r\n            nodesMap[`${moduleName}::${name}`];\r\n          if (node) {\r\n            node.exportable = true;\r\n            node.alias = alias ? alias : name;\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            node.id = `${this.id}::${node.alias}`;\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`];\r\n              this.children[node.id] = node;\r\n              const childrenNodes = Object.values(node.children);\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias);\r\n                delete node.children[n.id];\r\n                n.id = `${this.id}::${n.alias}`;\r\n                node.children[n.id] = n;\r\n              });\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    parseExportClauses(nodesMap: { [id: string]: Node } = {}){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.generateImports",
    "language": "typescript",
    "label": "Node.generateImports",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 395,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Node\n    ...\n    generateImports() {\r\n    if (this.type !== \"file\") return;\r\n    const captures = captureQuery(this.language, \"importStatements\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = [];\r\n    let newImportStatement = new ImportStatement();\r\n    let alias: string;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"module\":\r\n          newImportStatement.module = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          const name = c.node.text;\r\n          if (!alias) alias = name;\r\n          const newImportName = new ImportName(name, alias);\r\n          newImportStatement.names.push(newImportName);\r\n          alias = \"\";\r\n          break;\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case \"import_statement\":\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias;\r\n            alias = \"\";\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module;\r\n          }\r\n\r\n          newImportStatement.path = renameSource(\r\n            this.id,\r\n            newImportStatement.module,\r\n            this.language\r\n          );\r\n          newImportStatement.code = c.node.text\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement);\r\n          newImportStatement = new ImportStatement();\r\n          break;\r\n      }\r\n    });\r\n    this.importStatements = importStatements.reverse();\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    generateImports(){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.getCodeWithoutBody",
    "language": "typescript",
    "label": "Node.getCodeWithoutBody",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 519,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getCodeWithoutBody() {\r\n    let code = this.code;\r\n\r\n    if (this.body || this.type === \"file\") {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== \"java\"\r\n            ? newClassMethodsMap[this.language]\r\n            : this.name;\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === \"class\") {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return;\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(bodyToRemove, `\\n${spaces}    ...`);\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}`\r\n                );\r\n              }\r\n            }\r\n          } else if (\r\n            this.type === \"file\" &&\r\n            ![\"assignment\", \"type\", \"enum\"].includes(n.type)\r\n          ) {\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(bodyToRemove, `${spaces}...`);\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}//...\\n${spaces}}`\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else {\r\n        const spaces = \" \".repeat(this.startPosition.column);\r\n        if (this.language === \"python\") {\r\n          code = code.replace(this.body, \"\").trim() + `\\n${spaces}    ...`;\r\n        } else {\r\n          code =\r\n            code.replace(this.body, \"\").trim() +\r\n            `{\\n${spaces}    //...\\n${spaces}}`;\r\n        }\r\n      }\r\n    }\r\n    code = code.trim().replace(/\\n\\s*\\n/, \"\\n\");\r\n    if (this.parent && [\"class\", \"interface\"].includes(this.parent?.type))\r\n      code = `${this.parent.code\r\n        .replace(this.parent.body, \"\")\r\n        .trim()}\\n    ...\\n    ${code}`;\r\n    return code;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.addNodeRelationship",
    "language": "typescript",
    "label": "Node.addNodeRelationship",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 231,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === \"export\") {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true;\r\n        if (!this.documentation) this.documentation = node.documentation;\r\n        return;\r\n      }\r\n      if (this.type === \"export\") return; // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (\r\n        [\"class\", \"interface\"].includes(node.type) &&\r\n        this.type === \"function\"\r\n      ) {\r\n        this.type = \"method\";\r\n        this.name = `${node.name}.${this.name}`;\r\n        this.alias = this.name; // methods has no alias\r\n      }\r\n      this.id = `${this.id.split(\"::\")[0]}::${this.name}`;\r\n      node.addChild(this);\r\n    }\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.isWithin",
    "language": "typescript",
    "label": "Node.isWithin",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 37,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    );\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.addImportStatement",
    "language": "typescript",
    "label": "Node.addImportStatement",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement);\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.addCall",
    "language": "typescript",
    "label": "Node.addCall",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 31,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addCall(node: Node) {\r\n    // this -> node\r\n    this.calls.push(node);\r\n    node.inDegree++;\r\n    this.outDegree++;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addCall(node: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.removeChild",
    "language": "typescript",
    "label": "Node.removeChild",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 48,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id];\r\n      this.inDegree--;\r\n      child.outDegree--;\r\n    }\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    removeChild(child: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.addChild",
    "language": "typescript",
    "label": "Node.addChild",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 39,
    "inDegree": 3,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child;\r\n    child.parent = this;\r\n    this.inDegree++;\r\n    child.outDegree++;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addChild(child: Node){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.getAllChildren",
    "language": "typescript",
    "label": "Node.getAllChildren",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 74,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = [];\r\n    if (parentTypes && !parentTypes.includes(this.type)) return [];\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child);\r\n      children.push(...child.getAllChildren());\r\n    }\r\n    return children;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[]{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.getChild",
    "language": "typescript",
    "label": "Node.getChild",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId];\r\n    } else if (this.type === \"file\") {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId);\r\n        if (result) return result;\r\n      }\r\n    }\r\n    return;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined{\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node.constructor",
    "language": "typescript",
    "label": "Node.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 59,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
    "language": "typescript",
    "label": "Node",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 4211,
    "inDegree": 41,
    "outDegree": 3,
    "code": "class Node {\r\n  id: string = \"\"; // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = \"function\";\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  language: string = \"\";\r\n  importStatements: ImportStatement[] = []; // only for files\r\n  totalTokens: number = 0;\r\n  documentation: string = \"\";\r\n  code: string = \"\";\r\n  body: string = \"\";\r\n  exportable: boolean = false;\r\n  parent?: Node;\r\n  children: { [key: string]: Node } = {};\r\n  calls: Node[] = [];\r\n  startPosition: Point = { row: 0, column: 0 };\r\n  endPosition: Point = { row: 99999, column: 0 };\r\n  inDegree: number = 0;\r\n  outDegree: number = 0;\r\n\r\n  constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId];\r\n    } else if (this.type === \"file\") {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId);\r\n        if (result) return result;\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = [];\r\n    if (parentTypes && !parentTypes.includes(this.type)) return [];\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child);\r\n      children.push(...child.getAllChildren());\r\n    }\r\n    return children;\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child;\r\n    child.parent = this;\r\n    this.inDegree++;\r\n    child.outDegree++;\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id];\r\n      this.inDegree--;\r\n      child.outDegree--;\r\n    }\r\n  }\r\n\r\n  addCall(node: Node) {\r\n    // this -> node\r\n    this.calls.push(node);\r\n    node.inDegree++;\r\n    this.outDegree++;\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement);\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    );\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === \"export\") {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true;\r\n        if (!this.documentation) this.documentation = node.documentation;\r\n        return;\r\n      }\r\n      if (this.type === \"export\") return; // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (\r\n        [\"class\", \"interface\"].includes(node.type) &&\r\n        this.type === \"function\"\r\n      ) {\r\n        this.type = \"method\";\r\n        this.name = `${node.name}.${this.name}`;\r\n        this.alias = this.name; // methods has no alias\r\n      }\r\n      this.id = `${this.id.split(\"::\")[0]}::${this.name}`;\r\n      node.addChild(this);\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody() {\r\n    let code = this.code;\r\n\r\n    if (this.body || this.type === \"file\") {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== \"java\"\r\n            ? newClassMethodsMap[this.language]\r\n            : this.name;\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === \"class\") {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return;\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(bodyToRemove, `\\n${spaces}    ...`);\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}`\r\n                );\r\n              }\r\n            }\r\n          } else if (\r\n            this.type === \"file\" &&\r\n            ![\"assignment\", \"type\", \"enum\"].includes(n.type)\r\n          ) {\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(bodyToRemove, `${spaces}...`);\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}//...\\n${spaces}}`\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else {\r\n        const spaces = \" \".repeat(this.startPosition.column);\r\n        if (this.language === \"python\") {\r\n          code = code.replace(this.body, \"\").trim() + `\\n${spaces}    ...`;\r\n        } else {\r\n          code =\r\n            code.replace(this.body, \"\").trim() +\r\n            `{\\n${spaces}    //...\\n${spaces}}`;\r\n        }\r\n      }\r\n    }\r\n    code = code.trim().replace(/\\n\\s*\\n/, \"\\n\");\r\n    if (this.parent && [\"class\", \"interface\"].includes(this.parent?.type))\r\n      code = `${this.parent.code\r\n        .replace(this.parent.body, \"\")\r\n        .trim()}\\n    ...\\n    ${code}`;\r\n    return code;\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== \"file\") return;\r\n    const captures = captureQuery(this.language, \"importStatements\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = [];\r\n    let newImportStatement = new ImportStatement();\r\n    let alias: string;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"module\":\r\n          newImportStatement.module = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          const name = c.node.text;\r\n          if (!alias) alias = name;\r\n          const newImportName = new ImportName(name, alias);\r\n          newImportStatement.names.push(newImportName);\r\n          alias = \"\";\r\n          break;\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case \"import_statement\":\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias;\r\n            alias = \"\";\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module;\r\n          }\r\n\r\n          newImportStatement.path = renameSource(\r\n            this.id,\r\n            newImportStatement.module,\r\n            this.language\r\n          );\r\n          newImportStatement.code = c.node.text\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement);\r\n          newImportStatement = new ImportStatement();\r\n          break;\r\n      }\r\n    });\r\n    this.importStatements = importStatements.reverse();\r\n  }\r\n\r\n  parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (![\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) return;\r\n    const captures = captureQuery(this.language, \"exportClauses\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let name = \"\";\r\n    let alias = \"\";\r\n    let moduleName = this.id;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"module\":\r\n          moduleName = path.join(\r\n            this.id.split(\"/\").slice(0, -1).join(\"/\"),\r\n            c.node.text\r\n          );\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          name = c.node.text;\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0];\r\n          if (importedName) moduleName = importedName.path;\r\n          const node =\r\n            this.children[`${this.id}::${name}`] ||\r\n            nodesMap[`${moduleName}::${name}`];\r\n          if (node) {\r\n            node.exportable = true;\r\n            node.alias = alias ? alias : name;\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            node.id = `${this.id}::${node.alias}`;\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`];\r\n              this.children[node.id] = node;\r\n              const childrenNodes = Object.values(node.children);\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias);\r\n                delete node.children[n.id];\r\n                n.id = `${this.id}::${n.alias}`;\r\n                node.children[n.id] = n;\r\n              });\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== \"file\") return;\r\n    const suffix = indexSuffixesMap[this.language];\r\n    const fileSet = new Set(\r\n      allFiles.map((p) => p.split(\".\").slice(0, -1).join(\".\"))\r\n    );\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(\r\n            `${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`\r\n          )\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path),\r\n      ];\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith(\"@/\")) {\r\n        importStatement.path = path.join(\r\n          rootFolderPath,\r\n          importStatement.path.slice(2)\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (![\"file\", \"header\"].includes(this.type)) return {};\r\n    const unnecessaryNodeTypes = [\"export\"]; // exclude it from the analysis\r\n    const captures = captureQuery(\r\n      this.language,\r\n      \"constructorDefinitions\",\r\n      this.code\r\n    );\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let exportable = [\"python\"].includes(this.language) ? true : false;\r\n    let childrenNodes: Node[] = [];\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(\r\n          this.id,\r\n          c.node.text,\r\n          c.name as AllowedTypes,\r\n          this.language\r\n        );\r\n\r\n        newNode.startPosition = c.node.startPosition;\r\n        newNode.endPosition = c.node.endPosition;\r\n        newNode.exportable = exportable;\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling;\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text;\r\n          }\r\n        }\r\n        childrenNodes.push(newNode);\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === \"python\") {\r\n          prevTreeSitterNode = c.node.previousSibling;\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              [\"decorator\"].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row ===\r\n                newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + \"\\n\" + newNode.code;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code;\r\n      if ([\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) {\r\n        if (n.type === \"method\") {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`;\r\n          n.type = \"function\";\r\n        } else if (n.type === \"assignment\") code = `const ${n.code}`;\r\n      } else if ([\"java\"].includes(this.language)) {\r\n        if (n.type == \"function\") {\r\n          const firstLine = code.split(\"(\")[0];\r\n          const firstLineSplit = firstLine.split(\" \");\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, \"definitionTemplate\", code);\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(\r\n        captures,\r\n        n.language === \"java\" ? \"modifier\" : \"name\"\r\n      );\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"modifier\": // java only\r\n            if (n.language == \"java\" && c.node.text.includes(\"public\"))\r\n              n.exportable = true;\r\n            break;\r\n          case \"name\":\r\n            n.name = c.node.text;\r\n            n.id = `${n.id}::${n.name}`;\r\n            break;\r\n          case \"alias\":\r\n            n.alias = c.node.text;\r\n            break;\r\n          case \"documentation\":\r\n            n.documentation = c.node.text;\r\n            if (n.language === \"python\") {\r\n              n.code = n.code.replace(n.documentation, \"\");\r\n              n.body = n.body.replace(n.documentation, \"\");\r\n            }\r\n            break;\r\n          case \"body\":\r\n            n.body = c.node.text;\r\n            break;\r\n        }\r\n      });\r\n      if (!n.alias) n.alias = n.name;\r\n\r\n      if (n.type === \"assignment\") {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          \"extraAssignmentCode\",\r\n          this.code,\r\n          n.name\r\n        );\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === \"code\") n.code += \"\\n\" + c.node.text;\r\n        });\r\n      }\r\n    });\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name);\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j]);\r\n        childrenNodes[j].addNodeRelationship(n);\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n);\r\n    });\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n;\r\n      return map;\r\n    }, {});\r\n    return nodesMap;\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && [\"class\", \"interface\"].includes(this.parent?.type)\r\n          ? `${this.parent.code\r\n              .replace(this.parent.body, \"\")\r\n              .trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n    };\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes;\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr];\r\n      }\r\n      return acc;\r\n    }, {});\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class Node {\r\n  id: string = \"\"; // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = \"function\";\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  language: string = \"\";\r\n  importStatements: ImportStatement[] = []; // only for files\r\n  totalTokens: number = 0;\r\n  documentation: string = \"\";\r\n  code: string = \"\";\r\n  body: string = \"\";\r\n  exportable: boolean = false;\r\n  parent?: Node;\r\n  children: { [key: string]: Node } = {};\r\n  calls: Node[] = [];\r\n  startPosition: Point = { row: 0, column: 0 };\r\n  endPosition: Point = { row: 99999, column: 0 };\r\n  inDegree: number = 0;\r\n  outDegree: number = 0;\r\n  constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\n      //...\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n      //...\n  }\r\n\r\n  addChild(child: Node) {\n      //...\n  }\r\n\r\n  removeChild(child: Node) {\n      //...\n  }\r\n\r\n  addCall(node: Node) {\n      //...\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\n      //...\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\n      //...\n  }\r\n\r\n  addNodeRelationship(node: Node) {\n      //...\n  }\r\n\r\n  getCodeWithoutBody() {\n      //...\n  }\r\n\r\n  generateImports() {\n      //...\n  }\r\n\r\n  parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\n      //...\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n      //...\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Link",
    "language": "typescript",
    "label": "Link",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 19,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Link {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n}",
    "importStatements": [],
    "codeNoBody": "interface Link{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportStatement.constructor",
    "language": "typescript",
    "label": "ImportStatement.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportStatement",
    "totalTokens": 72,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code\r\n  }",
    "importStatements": [],
    "codeNoBody": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportStatement",
    "language": "typescript",
    "label": "ImportStatement",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 105,
    "inDegree": 8,
    "outDegree": 3,
    "code": "class ImportStatement {\r\n  module: string;\r\n  names: ImportName[];\r\n  moduleAlias: string;\r\n  path: string;\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class ImportStatement {\r\n  module: string;\r\n  names: ImportName[];\r\n  moduleAlias: string;\r\n  path: string;\r\n  code?: string\r\n  constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code\r\n  }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportName.constructor",
    "language": "typescript",
    "label": "ImportName.constructor",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportName",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string){\n      //...\n  }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportName",
    "language": "typescript",
    "label": "ImportName",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 58,
    "inDegree": 8,
    "outDegree": 3,
    "code": "class ImportName {\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  node?: Node;\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class ImportName {\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  node?: Node;\r\n  // subpath: string = ''\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }\r\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::enc",
    "language": "typescript",
    "label": "enc",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "enc = encoding_for_model(\"gpt-4-turbo\")",
    "importStatements": [],
    "codeNoBody": "enc ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::treeSitterCommentTypes",
    "language": "typescript",
    "label": "treeSitterCommentTypes",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": [],
    "codeNoBody": "treeSitterCommentTypes ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::indexSuffixesMap",
    "language": "typescript",
    "label": "indexSuffixesMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 54,
    "inDegree": 0,
    "outDegree": 1,
    "code": "indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '' // java has no index\r\n}",
    "importStatements": [],
    "codeNoBody": "indexSuffixesMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::itselfClassMap",
    "language": "typescript",
    "label": "itselfClassMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 48,
    "inDegree": 0,
    "outDegree": 1,
    "code": "itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this'\r\n}",
    "importStatements": [],
    "codeNoBody": "itselfClassMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::newClassMethodsMap",
    "language": "typescript",
    "label": "newClassMethodsMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 65,
    "inDegree": 0,
    "outDegree": 1,
    "code": "newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new'\r\n}",
    "importStatements": [],
    "codeNoBody": "newClassMethodsMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::languageExtensionMap",
    "language": "typescript",
    "label": "languageExtensionMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 86,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n}",
    "importStatements": [],
    "codeNoBody": "languageExtensionMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::languages",
    "language": "typescript",
    "label": "languages",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 23,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C\r\n}",
    "importStatements": [],
    "codeNoBody": "languages ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::excludedExtensions",
    "language": "typescript",
    "label": "excludedExtensions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']",
    "importStatements": [],
    "codeNoBody": "excludedExtensions ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::excludedFolders",
    "language": "typescript",
    "label": "excludedFolders",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']",
    "importStatements": [],
    "codeNoBody": "excludedFolders ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::AllowedTypesArray",
    "language": "typescript",
    "label": "AllowedTypesArray",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 57,
    "inDegree": 0,
    "outDegree": 2,
    "code": "AllowedTypesArray: AllowedTypes[] = [\r\n    'function', 'class', 'interface', 'method', 'enum', \r\n    'struct', 'export', 'type', 'assignment', 'file', 'union',\r\n    'namespace', 'mod', 'header'\r\n  ]",
    "importStatements": [],
    "codeNoBody": "AllowedTypesArray: AllowedTypes[] ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::AllowedTypes",
    "language": "typescript",
    "label": "AllowedTypes",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 60,
    "inDegree": 3,
    "outDegree": 2,
    "code": "type AllowedTypes = 'function' | 'class' | 'interface' | 'method' | 'enum' | 'struct' | 'export' | 'type' | 'assignment' | 'file' | 'union' | 'namespace' | 'mod' | 'header' ;",
    "importStatements": [],
    "codeNoBody": "type AllowedTypes =  ;{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::C",
    "language": "typescript",
    "label": "C",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "C = require(\"tree-sitter-c\")",
    "importStatements": [],
    "codeNoBody": "C ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::Java",
    "language": "typescript",
    "label": "Java",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Java = require(\"tree-sitter-java\")",
    "importStatements": [],
    "codeNoBody": "Java ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::TSX",
    "language": "typescript",
    "label": "TSX",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TSX = require(\"tree-sitter-typescript\").tsx",
    "importStatements": [],
    "codeNoBody": "TSX ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::TypeScript",
    "language": "typescript",
    "label": "TypeScript",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TypeScript  = require('tree-sitter-typescript').typescript",
    "importStatements": [],
    "codeNoBody": "TypeScript  ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::Python",
    "language": "typescript",
    "label": "Python",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Python = require(\"tree-sitter-python\")",
    "importStatements": [],
    "codeNoBody": "Python ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts::JavaScript",
    "language": "typescript",
    "label": "JavaScript",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
    "totalTokens": 10,
    "inDegree": 0,
    "outDegree": 1,
    "code": "JavaScript = require(\"tree-sitter-javascript\")",
    "importStatements": [],
    "codeNoBody": "JavaScript ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::getCalledNode",
    "language": "typescript",
    "label": "getCalledNode",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 87,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
    "importStatements": [],
    "codeNoBody": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n){\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::cleanAndSplitContent",
    "language": "typescript",
    "label": "cleanAndSplitContent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
    "importStatements": [],
    "codeNoBody": "const cleanAndSplitContent = (content: string): string[] => ;{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::firstConsecutiveDots",
    "language": "typescript",
    "label": "firstConsecutiveDots",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 38,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
    "importStatements": [],
    "codeNoBody": "function firstConsecutiveDots(s: string): number{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::renameSource",
    "language": "typescript",
    "label": "renameSource",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 378,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}",
    "importStatements": [],
    "codeNoBody": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::cleanDefCaptures",
    "language": "typescript",
    "label": "cleanDefCaptures",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 162,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
    "importStatements": [],
    "codeNoBody": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[]{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::captureQuery",
    "language": "typescript",
    "label": "captureQuery",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 291,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}",
    "importStatements": [],
    "codeNoBody": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[]{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::getRequiredDefinitions",
    "language": "typescript",
    "label": "getRequiredDefinitions",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 213,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
    "importStatements": [],
    "codeNoBody": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n}{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::getTotalSize",
    "language": "typescript",
    "label": "getTotalSize",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 87,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils::getAllFiles",
    "language": "typescript",
    "label": "getAllFiles",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
    "totalTokens": 270,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\") //esto para que el Guille pueda correr el codigo de grafos.\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  //console.log(\"matchingFiles\", matchingFiles);\r\n  return matchingFiles;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::cQueries",
    "language": "typescript",
    "label": "cQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 47,
    "inDegree": 0,
    "outDegree": 2,
    "code": "cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments\r\n}",
    "importStatements": [],
    "codeNoBody": "cQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 38,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 46,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
    "totalTokens": 41,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index::treeSitterQueries",
    "language": "typescript",
    "label": "treeSitterQueries",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index",
    "totalTokens": 55,
    "inDegree": 2,
    "outDegree": 2,
    "code": "interface treeSitterQueries {\r\n    importStatements: string\r\n    constructorDefinitions: string\r\n    definitionTemplate: string\r\n    exportClauses: string\r\n    extraAssignmentCode: (name: string) => string\r\n    calls: string\r\n    assignments: string\r\n}",
    "importStatements": [],
    "codeNoBody": "interface treeSitterQueries{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index::languageQueries",
    "language": "typescript",
    "label": "languageQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index",
    "totalTokens": 36,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries\r\n}",
    "importStatements": [],
    "codeNoBody": "languageQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::javaQueries",
    "language": "typescript",
    "label": "javaQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 47,
    "inDegree": 0,
    "outDegree": 2,
    "code": "javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments\r\n}",
    "importStatements": [],
    "codeNoBody": "javaQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 50,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => ``",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 25,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 3,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = ``",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::jsQueries",
    "language": "typescript",
    "label": "jsQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 47,
    "inDegree": 0,
    "outDegree": 2,
    "code": "jsQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments\r\n}",
    "importStatements": [],
    "codeNoBody": "jsQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 289,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 117,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 51,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::arrowFunctionConstructor",
    "language": "typescript",
    "label": "arrowFunctionConstructor",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 1,
    "code": "arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"",
    "importStatements": [],
    "codeNoBody": "arrowFunctionConstructor ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 94,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) ; to exclude arrow functions\r\n        ) @assignment\r\n    )\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) @assignment\r\n        )\r\n    )\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 210,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @name\r\n          (object_pattern (_) @name)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @submodule\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::pyQueries",
    "language": "typescript",
    "label": "pyQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 50,
    "inDegree": 0,
    "outDegree": 2,
    "code": "pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments \r\n   }",
    "importStatements": [],
    "codeNoBody": "pyQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 303,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 138,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 18,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 80,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 31,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
    "totalTokens": 143,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::tsQueries",
    "language": "typescript",
    "label": "tsQueries",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 2,
    "code": "tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments\r\n}",
    "importStatements": [],
    "codeNoBody": "tsQueries : treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 51,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 37,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "extraAssignmentCode = jsQueries.extraAssignmentCode",
    "importStatements": [],
    "codeNoBody": "extraAssignmentCode ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = jsQueries.exportClauses",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 103,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 126,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 7,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = jsQueries.importStatements",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test::createGraphTest",
    "language": "typescript",
    "label": "createGraphTest",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 433,
    "inDegree": 0,
    "outDegree": 3,
    "code": "createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n})",
    "importStatements": [],
    "codeNoBody": "createGraphTest = \ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n}){\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 63,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test::secret",
    "language": "typescript",
    "label": "secret",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "importStatements": [],
    "codeNoBody": "secret ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph::processGraphCreation",
    "language": "typescript",
    "label": "processGraphCreation",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 693,
    "inDegree": 2,
    "outDegree": 1,
    "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\r\n  let graphId = uuidv4()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    // create a uuid for each node\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\r\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\r\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\r\n        }, ${fullName}, ${node.label})\r\n    `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label)\r\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label})\r\n    `\r\n    })\r\n\r\n    await Promise.all(insertNodePromises)\r\n    await Promise.all(insertLinkPromises)\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph::createGraph",
    "language": "typescript",
    "label": "createGraph",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 932,
    "inDegree": 0,
    "outDegree": 4,
    "code": "createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n})",
    "importStatements": [],
    "codeNoBody": "createGraph = \ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n}){\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 74,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph::secret",
    "language": "typescript",
    "label": "secret",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "importStatements": [],
    "codeNoBody": "secret ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs::updateGraph",
    "language": "typescript",
    "label": "updateGraph",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 716,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName}, ${node.label}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs::UpdateGraph",
    "language": "typescript",
    "label": "UpdateGraph",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 55,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n}",
    "importStatements": [],
    "codeNoBody": "interface UpdateGraph{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs::graphs",
    "language": "typescript",
    "label": "graphs",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 832,
    "inDegree": 0,
    "outDegree": 2,
    "code": "graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})",
    "importStatements": [],
    "codeNoBody": "graphs = \ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n}){\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token",
    "totalTokens": 245,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db::sql",
    "language": "typescript",
    "label": "sql",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
    "totalTokens": 106,
    "inDegree": 0,
    "outDegree": 1,
    "code": "sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "importStatements": [],
    "codeNoBody": "sql ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::getAccessToken",
    "language": "typescript",
    "label": "getAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 217,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::getCommitHash",
    "language": "typescript",
    "label": "getCommitHash",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
    "importStatements": [],
    "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::getCommitRepo",
    "language": "typescript",
    "label": "getCommitRepo",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 616,
    "inDegree": 0,
    "outDegree": 3,
    "code": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n\r\n      }\r\n\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::downloadAndExtractRepo",
    "language": "typescript",
    "label": "downloadAndExtractRepo",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 555,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(tmpFolderPath, `${commitSha}_${repoOrg}_${repoName}_${branch}`)\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = await getTotalSize(finalPath) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(`Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`)\r\n   }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::MAXSIZE",
    "language": "typescript",
    "label": "MAXSIZE",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "MAXSIZE = 2",
    "importStatements": [],
    "codeNoBody": "MAXSIZE ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git::GitServiceType",
    "language": "typescript",
    "label": "GitServiceType",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
    "totalTokens": 18,
    "inDegree": 5,
    "outDegree": 2,
    "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "importStatements": [],
    "codeNoBody": "type GitServiceType ={\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token",
    "totalTokens": 237,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any>{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils::getEnv",
    "language": "typescript",
    "label": "getEnv",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils",
    "totalTokens": 50,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "importStatements": [],
    "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS){\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils::ENV_VARS",
    "language": "typescript",
    "label": "ENV_VARS",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils",
    "totalTokens": 145,
    "inDegree": 1,
    "outDegree": 1,
    "code": "ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "importStatements": [],
    "codeNoBody": "ENV_VARS ={\n                 //...\n             }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::generateFolderDocumentation",
    "language": "typescript",
    "label": "generateFolderDocumentation",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 460,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder which are the following:\\n\r\n  ${folderContent}`;\r\n\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::documentFolders",
    "language": "typescript",
    "label": "documentFolders",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 166,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    const folderPath = path2.dirname(filePath);\r\n\r\n    if (!folders[folderPath]) {\r\n      folders[folderPath] = [];\r\n    }\r\n    folders[folderPath].push(filesDocumentation[filePath]); //push the documentation of the file\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    const folderContent = folders[folderPath].join(\"\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function documentFolders(filesDocumentation: any){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::generateFileDocumentation",
    "language": "typescript",
    "label": "generateFileDocumentation",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 564,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type} is the following:`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::classifyAndDocumentFiles",
    "language": "typescript",
    "label": "classifyAndDocumentFiles",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 346,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const nodePath = node.id;\r\n    const until = nodePath.lastIndexOf(\"::\");\r\n    const correspondingFile = nodePath.slice(0, until);\r\n    //console.log(\"CF: \", correspondingFile);\r\n    if (!fileToNodes[correspondingFile]) {\r\n      fileToNodes[correspondingFile] = [];\r\n    }\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.id === filePath)!; //it should always be there\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::generateNodeDocumentation",
    "language": "typescript",
    "label": "generateNodeDocumentation",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 619,
    "inDegree": 1,
    "outDegree": 5,
    "code": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::bfs",
    "language": "typescript",
    "label": "bfs",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 323,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  callGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = callGraph[currentNodeId] || [];\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED\");\r\n  return usedNodes;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  callGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::findStartNodes",
    "language": "typescript",
    "label": "findStartNodes",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 48,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}",
    "importStatements": [],
    "codeNoBody": "function findStartNodes(callGraph: { [key: string]: string[] }){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::buildCallGraph",
    "language": "typescript",
    "label": "buildCallGraph",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 139,
    "inDegree": 1,
    "outDegree": 3,
    "code": "function buildCallGraph(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    callGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (link.label === \"calls\") {\r\n      if (\r\n        callGraph[link.source] &&\r\n        link.source.includes(\"::\") && //so that links that include files are not included\r\n        link.target.includes(\"::\")\r\n      ) {\r\n        callGraph[link.source].push(link.target);\r\n      }\r\n    }\r\n  }\r\n\r\n  return callGraph;\r\n}",
    "importStatements": [],
    "codeNoBody": "function buildCallGraph(nodes: wikiNode[], links: wikiLink[]){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::readJson",
    "language": "typescript",
    "label": "readJson",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 83,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function readJson(filePath: string){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::findFileParent",
    "language": "typescript",
    "label": "findFileParent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 93,
    "inDegree": 2,
    "outDegree": 3,
    "code": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::tokenizer",
    "language": "typescript",
    "label": "tokenizer",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 86,
    "inDegree": 0,
    "outDegree": 2,
    "code": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};",
    "importStatements": [],
    "codeNoBody": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => ;{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::timeElapsedInSecconds",
    "language": "typescript",
    "label": "timeElapsedInSecconds",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 76,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};",
    "importStatements": [],
    "codeNoBody": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => ;{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::totalTokensUsed",
    "language": "typescript",
    "label": "totalTokensUsed",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 6,
    "inDegree": 1,
    "outDegree": 1,
    "code": "totalTokensUsed = 0",
    "importStatements": [],
    "codeNoBody": "totalTokensUsed ={\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::linksPath",
    "language": "typescript",
    "label": "linksPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "linksPath: string = `${forder_path}/${projectId}/links.json`",
    "importStatements": [],
    "codeNoBody": "linksPath: string ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::nodesPath",
    "language": "typescript",
    "label": "nodesPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodesPath: string = `${forder_path}/${projectId}/nodes.json`",
    "importStatements": [],
    "codeNoBody": "nodesPath: string ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::forder_path",
    "language": "typescript",
    "label": "forder_path",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "forder_path = `../../test_files/`",
    "importStatements": [],
    "codeNoBody": "forder_path ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::projectId",
    "language": "typescript",
    "label": "projectId",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 8,
    "inDegree": 0,
    "outDegree": 1,
    "code": "projectId = \"codebase-index-ts\"",
    "importStatements": [],
    "codeNoBody": "projectId ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::onlyLogs",
    "language": "typescript",
    "label": "onlyLogs",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 4,
    "inDegree": 0,
    "outDegree": 1,
    "code": "onlyLogs = false",
    "importStatements": [],
    "codeNoBody": "onlyLogs ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::response_format",
    "language": "typescript",
    "label": "response_format",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 11,
    "inDegree": 0,
    "outDegree": 1,
    "code": "response_format = { type: \"json_object\" }",
    "importStatements": [],
    "codeNoBody": "response_format ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::max_tokens",
    "language": "typescript",
    "label": "max_tokens",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 6,
    "inDegree": 0,
    "outDegree": 1,
    "code": "max_tokens = 1024",
    "importStatements": [],
    "codeNoBody": "max_tokens ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::temperature",
    "language": "typescript",
    "label": "temperature",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 4,
    "inDegree": 0,
    "outDegree": 1,
    "code": "temperature = 0",
    "importStatements": [],
    "codeNoBody": "temperature ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::model",
    "language": "typescript",
    "label": "model",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "model = \"gpt-3.5-turbo\"",
    "importStatements": [],
    "codeNoBody": "model ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::startTime",
    "language": "typescript",
    "label": "startTime",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 5,
    "inDegree": 1,
    "outDegree": 1,
    "code": "startTime = new Date()",
    "importStatements": [],
    "codeNoBody": "startTime ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::client2",
    "language": "typescript",
    "label": "client2",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 47,
    "inDegree": 3,
    "outDegree": 2,
    "code": "client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n})",
    "importStatements": [],
    "codeNoBody": "client2 ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::wikiLink",
    "language": "typescript",
    "label": "wikiLink",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 21,
    "inDegree": 3,
    "outDegree": 2,
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiLink = ;{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::wikiNode",
    "language": "typescript",
    "label": "wikiNode",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 84,
    "inDegree": 8,
    "outDegree": 2,
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiNode = ;{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::cl100k_base",
    "language": "typescript",
    "label": "cl100k_base",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 19,
    "inDegree": 1,
    "outDegree": 1,
    "code": "cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\")",
    "importStatements": [],
    "codeNoBody": "cl100k_base ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::OpenAI2",
    "language": "typescript",
    "label": "OpenAI2",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 9,
    "inDegree": 2,
    "outDegree": 1,
    "code": "OpenAI2 = require(\"openai\")",
    "importStatements": [],
    "codeNoBody": "OpenAI2 ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::path2",
    "language": "typescript",
    "label": "path2",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "path2 = require(\"path\")",
    "importStatements": [],
    "codeNoBody": "path2 ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2::fs2",
    "language": "typescript",
    "label": "fs2",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 9,
    "inDegree": 2,
    "outDegree": 1,
    "code": "fs2 = require(\"fs\").promises",
    "importStatements": [],
    "codeNoBody": "fs2 ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::improveWiki",
    "language": "typescript",
    "label": "improveWiki",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 427,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function improveWiki(wiki: string) {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. Imagine that you are a developer who is an expert in code documentation. You have been given the wiki for a project (whole repository). Based on your experience, use your expertise to improve the delivered wiki`s content. You will receive a documentation of the whole repository and its components (documentation of the folders and files) in markdown format. You will have to improve the content of the wiki page. The new documentation should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to improve the wiki page that I will give you. The wiki page I will give you corresponds to the documentation of a whole repository as a wikipedia page in markdown format. The improvements I want are the following:\\n\\n 1. Create an index of the documentation. \\n\\n 2. Clearer sections: Divide documentation into clearer and more concise sections \\n\\n 3. Include References and links: Include links to additional resources, such as documentation of the libraries used and relevant articles.\\n\\n 4. Overview a bit too general. Talk about what Wikipedia is about generic code. You should explain what the code solves.\\n\\n 5. Use paragraphs, no bullet points, just like in a wikipedia page. Concise paragraphs without loosing important information. \\n\\n The wiki page for the whole repo that I need you to improve is the following: \\n\\n${wiki} `;\r\n  contents += `This is the wiki page of the whole repository which will be used as input to improve it: \\n\\n${wiki}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function improveWiki(wiki: string){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::buildWiki",
    "language": "typescript",
    "label": "buildWiki",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 309,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function buildWiki(finalMarkdown: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the documentation of a whole repository, you will generate a wiki page. Take into account that the whole documentation of a repository is made of the summary of files inside folders. Please be systematic and organized in your documentation and remember to give a markdown document and in prose\";\r\n\r\n  const promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files). Use prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of the whole repository that you need to convert into a wiki page is the following: \\n\\n${finalMarkdown} `;\r\n  contents += `This is the final markdown of the whole repository which will be used as input to convert it to a wiki: \\n\\n${finalMarkdown}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function buildWiki(finalMarkdown: string): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::buildFinalMarkdown",
    "language": "typescript",
    "label": "buildFinalMarkdown",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 163,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function buildFinalMarkdown(generalSummary: string): Promise<string> {\r\n  const nodes: wikiNode[] = await readNodes(\"./folderContents.json\");\r\n\r\n  let finalMarkdown = ` The following is the general documentation of the whole repository: \\n\\n ${generalSummary}\\n\\n`;\r\n  const keys = Object.keys(folderContents);\r\n  const reversedKeys = keys.reverse(); // Reverse the array of keys\r\n  for (const key of reversedKeys) {\r\n    if (key === \"root\") {\r\n      continue; // Skip the current iteration if key is \"root\"\r\n    }\r\n    const nodesInsideKey = folderContents[key];\r\n    for (const node of nodesInsideKey) {\r\n      finalMarkdown += node.summary;\r\n    }\r\n  }\r\n  //console.log(finalMarkdown);\r\n  return finalMarkdown;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function buildFinalMarkdown(generalSummary: string): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::createRepoSummary",
    "language": "typescript",
    "label": "createRepoSummary",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 615,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function createRepoSummary(allCode: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style markdown documentation for the contents of a repository. Given the code of a whole repository, you will generate a documentation and description of the whole code of the repo. Take into account that the whole code of a repository is made of code of files inside folders which is why I am going to give the whole code of the repo but the code will be separated by what the path (label) of the code file where you can find the code. Please be systematic and organized in your description and documentation and remember to give a markdown document.\";\r\n\r\n  const promptUser1 = `I need you to document the following content (code) of a repository (it is the whole code): ${allCode}. Keep in mind that a code from a repo is the collection code from files that are in that repo. Be organized and systematic, taking into account that this is for a wiki page of a repository. Don't add code to the documentation. Start by identifying the folder and then continue by documenting it. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. Also, the combined code from all files inside the repo will be given as the file path (label) and then the code of that file. The documentation should be in Markdown format and cohesive, organized and structured. Has to be precise but without loosing important information. Use prose (except when showing folder structure). The summary should be between 350 and 400 words. There should be 6-10 lines of an overview. In the overview talk  about the objective of the project (repo) and what problem does it solve and with what does it solve it. Give a bit (just a bit) of details on the purpose and functionality. Then comment on the most important parts of the repo (this should be 6-9 lines). Then comment on each of the important parts (2-6 lines each) and then finally comment on the Key algorithms and technologies the repository relies on (6 - 10 lines).`;\r\n  contents += `This is the collection of code of the whole repository which will be the input to try to summarize the repo as a whole at first: \\n\\n${allCode}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createRepoSummary(allCode: string): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::getSummaryOfAllRepoForContext",
    "language": "typescript",
    "label": "getSummaryOfAllRepoForContext",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 137,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string> {\r\n  //need the number of tokens\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        allCode += `\\n\\nThis file has as label (path): ${node.label} and the code in the file with that label is:\r\n        \r\n        ${node.code}\\n\\n`;\r\n      }\r\n    })\r\n  );\r\n\r\n  //console.log(\"ALLCODE: \", allCode);\r\n\r\n  const repoSummary = await createRepoSummary(allCode);\r\n  return repoSummary;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::processAllFolders",
    "language": "typescript",
    "label": "processAllFolders",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 343,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function processAllFolders(generalSummary: string): Promise<void> {\r\n  const folderPaths = Object.keys(folderContents).sort(\r\n    (a, b) => b.length - a.length\r\n  );\r\n\r\n  for (const folderPath of folderPaths) {\r\n    const folderNodes = folderContents[folderPath];\r\n    const summaries = folderNodes\r\n      .map((node) => node.summary)\r\n      .filter((summary) => summary !== undefined);\r\n    const subfolderSummaries = Object.keys(folderContents)\r\n      .filter(\r\n        (subfolder) =>\r\n          subfolder.startsWith(folderPath + \"\\\\\") && subfolder !== folderPath\r\n      )\r\n      .map((subfolder) =>\r\n        folderContents[subfolder]\r\n          .map((node) => node.summary)\r\n          .filter((summary) => summary !== undefined)\r\n          .join(\"\\n\")\r\n      );\r\n\r\n    const combinedSummary = [...summaries, ...subfolderSummaries].join(\"\\n\");\r\n\r\n    const folderSummary = await createFolderSummary(\r\n      folderPath,\r\n      combinedSummary,\r\n      generalSummary\r\n    );\r\n    let parentFolder = path.dirname(folderPath);\r\n    if (folderPath === codebasePath) {\r\n      parentFolder = \"root\";\r\n    }\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n\r\n    folderContents[parentFolder].push({\r\n      id: folderPath,\r\n      label: path.basename(folderPath),\r\n      type: \"folder\",\r\n      totalTokens: combinedSummary.length,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      code: \"\",\r\n      summary: folderSummary,\r\n    });\r\n  }\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processAllFolders(generalSummary: string): Promise<void>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::createFolderSummary",
    "language": "typescript",
    "label": "createFolderSummary",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 622,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  contents += `This is the collection of summaries of the files inside the folder ${folderPath}:\\n\\n${combinedSummary}\\n\\n`;\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a folder. Given the collection of documentations (in markdown format) of all files of a folder, you will generate a documentation of the folder taking into account that the code of a folder is made of code of files inside that folder. Please be systematic and organized in your documentation. The documentation of that folder should be in Markdown format and be between 300-400 words. Use prose and should be precise but without loosing any important information. You will receive a documentation of the whole repository to give context to the folder you are documenting.\";\r\n\r\n  const promptUser1 = `I need you to document the content of a folder. The content of this folder I want you to document will contain a collection of the documentations of all files inside that folder. This folder is part of a repository, which is why as context I am going to give you a documentation of the whole repository where the folder is. The documentation of the whole repo is the following: \\n\\n ${generalSummary}\\n\\n. Don't add code to the documentation. The contents of the folder (or the collection of documentations of the files inside that folder) you need to document in Markdown Format is:  \\n\\n${combinedSummary}\\n. The folder has as path ${folderPath}. Keep in mind that a code from a folder in this context is made up of one or more pieces of code of other files. Be organized and systematic, taking into account that this is for a wiki page of a repository. Start by identifying the folder and then continue with the documentation. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Remember it has to be between 300 and 400 words. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. The documentation should be in Markdown format. Keep in mind that the idea of this is to be a wiki page so the documentation should be like a wikipedia page in markdown format. Also, it is very important that you know that the documentation you give me for the folder should be in prose, in paragraphs 25-30 lines long.`;\r\n\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::getParentFolder",
    "language": "typescript",
    "label": "getParentFolder",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 54,
    "inDegree": 1,
    "outDegree": 2,
    "code": "function getParentFolder(node: wikiNode): string {\r\n  const nodePath = node.id;\r\n  const until = nodePath.lastIndexOf(\"\\\\\");\r\n  const parentFolder = nodePath.slice(0, until);\r\n  //console.log(parentFolder);\r\n  return parentFolder;\r\n}",
    "importStatements": [],
    "codeNoBody": "function getParentFolder(node: wikiNode): string{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::createFileSummary",
    "language": "typescript",
    "label": "createFileSummary",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 389,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a file. Given the code of a file, you will generate a documentation of the file. Please be systematic and organized in your documentation. The documentation should be like a Wikipedia page style. You will receive a documentation and overview of the whole repository to give context to the file you are documenting. The documentation you make should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to document and describe the content of a file, which is part of a repository. The repository as a whole, has a documentation which is: ${generalSummary}\\n\\n. Don't add code to the documentation. The file that I want you to document and describe about is the following: \\n\\n ${node.code}\\n\\n. Mention the file path which is: ${node.id}. Be systematic and keep in mind this is for a wiki page of a whole repository. Start by identifying the file and then continue by summarizing it. Crucial: At every opportunity you will link to other relative paths of this website. The documentation of the file should be between 330 words and 400 words. Use prose!!!! Be organized and systematic with the organization of the content. The documentation should be in Markdown format and it should be in prose.`;\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n  node.summary = completion.choices[0].message.content;\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::processFile",
    "language": "typescript",
    "label": "processFile",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 120,
    "inDegree": 1,
    "outDegree": 5,
    "code": "async function processFile(node: wikiNode, generalSummary: string) {\r\n  const fileSummary = await createFileSummary(node, generalSummary);\r\n  if (fileSummary !== null) {\r\n    contents += `This is the summary of file ${node.label}:\\n\\n${fileSummary}\\n\\n`;\r\n    const parentFolder = getParentFolder(node);\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n    //console.log(\"I AM HEREEE\");\r\n    folderContents[parentFolder].push(node);\r\n    //console.log(folderContents);\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processFile(node: wikiNode, generalSummary: string){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::processAllFiles",
    "language": "typescript",
    "label": "processAllFiles",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 96,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void> {\r\n  // Process each node and wait for all to complete\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        await processFile(node, generalSummary);\r\n      }\r\n    })\r\n  );\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void>{\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::readNodes",
    "language": "typescript",
    "label": "readNodes",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 82,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function readNodes(nodesFilePath: string) {\r\n  let nodes: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(nodesFilePath, \"utf8\");\r\n    nodes = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${nodesFilePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodes;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function readNodes(nodesFilePath: string){\n    //...\n}"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::allCode",
    "language": "typescript",
    "label": "allCode",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 4,
    "inDegree": 2,
    "outDegree": 1,
    "code": "allCode = \"\"",
    "importStatements": [],
    "codeNoBody": "allCode ={\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::contents",
    "language": "typescript",
    "label": "contents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 3,
    "inDegree": 1,
    "outDegree": 1,
    "code": "contents = \"\"",
    "importStatements": [],
    "codeNoBody": "contents ={\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::folderContents",
    "language": "typescript",
    "label": "folderContents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 15,
    "inDegree": 4,
    "outDegree": 2,
    "code": "folderContents: { [key: string]: wikiNode[] } = {}",
    "importStatements": [],
    "codeNoBody": "folderContents: { [key: string]: wikiNode[] } ={\n        //...\n    }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::nodesFilePath",
    "language": "typescript",
    "label": "nodesFilePath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 34,
    "inDegree": 2,
    "outDegree": 1,
    "code": "nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\"",
    "importStatements": [],
    "codeNoBody": "nodesFilePath: string ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::wikiNode",
    "language": "typescript",
    "label": "wikiNode",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 60,
    "inDegree": 9,
    "outDegree": 2,
    "code": "type wikiNode = {\r\n  id: string;\r\n  label: string;\r\n  type: string;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiNode = ;{\n           //...\n       }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::codebasePath",
    "language": "typescript",
    "label": "codebasePath",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\\"",
    "importStatements": [],
    "codeNoBody": "codebasePath ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::client",
    "language": "typescript",
    "label": "client",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 45,
    "inDegree": 5,
    "outDegree": 2,
    "code": "client = new OpenAI({\r\n  apiKey: \"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\",\r\n})",
    "importStatements": [],
    "codeNoBody": "client ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::OpenAI",
    "language": "typescript",
    "label": "OpenAI",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 8,
    "inDegree": 2,
    "outDegree": 1,
    "code": "OpenAI = require(\"openai\")",
    "importStatements": [],
    "codeNoBody": "OpenAI ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::path",
    "language": "typescript",
    "label": "path",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 6,
    "inDegree": 1,
    "outDegree": 1,
    "code": "path = require(\"path\")",
    "importStatements": [],
    "codeNoBody": "path ={\n          //...\n      }"
  },
  {
    "id": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki::fs",
    "language": "typescript",
    "label": "fs",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\wiki",
    "totalTokens": 8,
    "inDegree": 1,
    "outDegree": 1,
    "code": "fs = require(\"fs\").promises",
    "importStatements": [],
    "codeNoBody": "fs ={\n          //...\n      }"
  }
]