[
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index::port",
    "label": "port",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "port = 8001",
    "summary": "# Port Assignment Documentation\n\n## Overview\n\nThe assignment `port = 8001` is a simple initialization of a variable named `port` with the integer value `8001`. This value typically represents the port number that a server or application will use to listen for incoming network connections.\n\n## Purpose\n\nIn network applications, a port is an endpoint of communication in an operating system. It allows different applications to communicate in the network without interfering with each other. This particular assignment sets the port number to 8001, which is often used for development or testing environments but can be adjusted as per the needs of the specific application or deployment scenario.\n\n## Node Dependencies\n\nThe `port` assignment relies on the following nodes or contextual elements in an application:\n\n1. **Network Configuration Node**: \n   - The network configuration of the system or application may include a mapping between service endpoints and their corresponding port numbers. This assignment ensures that the service listens on port 8001.\n\n2. **Server Initialization Node**: \n   - When a server application initializes, it must bind to a specific port to accept incoming connections. The assignment `port = 8001` is used to define which port the server will bind to upon startup.\n   \n3. **Routing/Firewall Rules Node**:\n   - Network routers or firewalls may have rules that allow or block traffic on certain ports. By assigning port 8001, you may need to ensure that the corresponding rules permit traffic on this port.\n   \n4. **Client Configuration Node**:\n   - Client applications that need to communicate with this server must know which port to connect to. By setting the port to 8001, clients must be configured accordingly to establish a connection.\n\n5. **Application Deployment Node**:\n   - During the deployment of the application, the configuration files or environment variables may use the `port` assignment to direct traffic appropriately. Ensure the deployment scripts or DevOps tools recognize and correctly apply this setting.\n\n## Usage Example\n\nHere's a simple example of how this port assignment might be utilized in a Python web server setup using the Flask framework:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n# Assign the port number\nport = 8001\n\n@app.route('/')\ndef home():\n    return \"Hello, World!\"\n\nif __name__ == '__main__':\n    # Start the Flask web server listening on the assigned port\n    app.run(port=port)\n```\n\n## Conclusion\n\nThe assignment `port = 8001` is a crucial configuration step for setting up a networked application. Proper understanding and configuration of the nodes that depend on this port assignment are essential to ensure seamless and secure communication within the application's network environment."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index::fs",
    "label": "fs",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index",
    "totalTokens": 6,
    "inDegree": 0,
    "outDegree": 1,
    "code": "fs = require(\"fs\")",
    "summary": "# Assignment Documentation: `fs`\n\nThe `fs` assignment imports the `fs` module in Node.js, providing an interface for interacting with the filesystem.\n\n## Importing the Module\n\n```javascript\nconst fs = require(\"fs\");\n```\n\nThis line of code imports the `fs` module, assigning it to the variable `fs`. This module provides many methods to work with the filesystem, including reading and writing files, interacting with directory structures, and handling file metadata.\n\n## Nodes Used in the Assignment\n\nThis assignment may use several nodes related to filesystem operations. Here are some common nodes and their descriptions:\n\n1. ### Read File\n   - **Node**: `fs.readFile`\n   - **Purpose**: Reads the contents of a file asynchronously.\n   - **Example**:\n     ```javascript\n     fs.readFile('path/to/file', 'utf8', (err, data) => {\n       if (err) throw err;\n       console.log(data);\n     });\n     ```\n\n2. ### Write File\n   - **Node**: `fs.writeFile`\n   - **Purpose**: Writes data to a file, replacing the file if it already exists, asynchronously.\n   - **Example**:\n     ```javascript\n     fs.writeFile('path/to/file', 'Hello, world!', 'utf8', (err) => {\n       if (err) throw err;\n       console.log('The file has been saved!');\n     });\n     ```\n\n3. ### Append File\n   - **Node**: `fs.appendFile`\n   - **Purpose**: Appends data to a file, creating the file if it does not yet exist, asynchronously.\n   - **Example**:\n     ```javascript\n     fs.appendFile('path/to/file', 'Hello again!', 'utf8', (err) => {\n       if (err) throw err;\n       console.log('The data was appended to the file!');\n     });\n     ```\n\n4. ### Read Directory\n   - **Node**: `fs.readdir`\n   - **Purpose**: Reads the contents of a directory asynchronously.\n   - **Example**:\n     ```javascript\n     fs.readdir('path/to/directory', (err, files) => {\n       if (err) throw err;\n       console.log(files);\n     });\n     ```\n\n5. ### Create Directory\n   - **Node**: `fs.mkdir`\n   - **Purpose**: Creates a new directory asynchronously.\n   - **Example**:\n     ```javascript\n     fs.mkdir('path/to/new/directory', { recursive: true }, (err) => {\n       if (err) throw err;\n       console.log('Directory created!');\n     });\n     ```\n\n6. ### Delete File\n   - **Node**: `fs.unlink`\n   - **Purpose**: Deletes a file asynchronously.\n   - **Example**:\n     ```javascript\n     fs.unlink('path/to/file', (err) => {\n       if (err) throw err;\n       console.log('File deleted!');\n     });\n     ```\n\n7. ### Rename File\n   - **Node**: `fs.rename`\n   - **Purpose**: Renames a file asynchronously.\n   - **Example**:\n     ```javascript\n     fs.rename('old/path/to/file', 'new/path/to/file', (err) => {\n       if (err) throw err;\n       console.log('File renamed!');\n     });\n     ```\n\n8. ### Check File/Directory Status\n   - **Node**: `fs.stat`\n   - **Purpose**: Retrieves the status of a file or directory asynchronously.\n   - **Example**:\n     ```javascript\n     fs.stat('path/to/file', (err, stats) => {\n       if (err) throw err;\n       console.log(`File size: ${stats.size} bytes`);\n     });\n     ```\n\n## Additional Methods and Synchronous Variants\n\nThe `fs` module provides both asynchronous and synchronous methods. The synchronous counterparts have the same names as the asynchronous ones but without the callback parameter, e.g., `fs.readFileSync`, `fs.writeFileSync`, etc. While synchronous methods can simplify code in certain scenarios, they block the event loop, which can impact performance and responsiveness in a Node.js application.\n\n## Conclusion\n\nThe `fs` module is a crucial part of Node.js, allowing developers to perform a wide range of filesystem operations. Understanding and effectively using the `fs` module is essential for developing robust and efficient Node.js applications.\n\nFor more detailed information, refer to the official Node.js documentation: [Node.js File System (fs) Module](https://nodejs.org/api/fs.html)"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index::app",
    "label": "app",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/index",
    "totalTokens": 356,
    "inDegree": 0,
    "outDegree": 1,
    "code": "app = new Hono()\napp.use(\"*\", prettyJSON())\napp.use(\"/v1/*\", cors())\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n})\napp.route(\"/v1/repo\", createGraph)\napp.route(\"/v1/graphs\", graphs)\napp.route(\"v1/repo-test\", createGraphTest)",
    "summary": "# Documentation for `app`\n\n## Overview\n\nThis documentation provides an overview of the `app` assignment created using the Hono framework. The application sets up middleware and routes to handle various HTTP requests, including parsing a codebase and generating simplified representations and links.\n\n## Modules and Libraries\n\n- **Hono**: A lightweight web application framework.\n- **prettyJSON**: Middleware for formatting JSON responses.\n- **cors**: Middleware for handling Cross-Origin Resource Sharing (CORS) settings.\n- **Codebase**: Custom module for handling codebase parsing and processing.\n- **writeFile**: Method from the `fs/promises` module for writing files.\n\n## Middleware\n\n### prettyJSON\n\n- **Path**: `*`\n- **Purpose**: Formats JSON responses to improve readability.\n\n### cors\n\n- **Path**: `/v1/*`\n- **Purpose**: Handles CORS settings for any route that matches `/v1/*`.\n\n## Routes\n\n### GET `/`\n\n#### Description\n\nHandles GET requests to the root endpoint. It parses a specific codebase directory, processes the files to generate nodes and links, and writes the results to `nodes.json` and `links.json`.\n\n#### Async Handler\n\n1. **Start Timer**: Begins a console timer to measure execution time.\n2. **Define `codebasePath`**: Hardcoded path to the codebase directory.\n3. **Create Codebase Instance**: Creates an instance of `Codebase` with the specified path.\n4. **Parse Directory**: Calls `codebase.parseFolder` to parse the codebase directory.\n5. **Log Node Count**: Logs the number of nodes found.\n6. **Get Calls**: Fetches call relationships between nodes.\n7. **End Timer**: Ends the console timer for execution measurement.\n8. **Simplify Codebase**: Simplifies the codebase nodes for easier analysis.\n9. **Get Links**: Fetches the links between the nodes.\n10. **Write Files**: Writes the nodes and links to `nodes.json` and `links.json` respectively.\n11. **Return Response**: Returns the simplified codebase as a JSON response.\n\n#### Example JSON Response\n```json\n[\n  {\n    \"id\": \"unique_id\",\n    \"label\": \"Node Label\",\n    \"type\": \"Node Type\",\n    \"parent\": \"Parent Node ID\",\n    \"totalTokens\": 123,\n    \"inDegree\": 10,\n    \"outDegree\": 5,\n    \"code\": \"Node code here\",\n  },\n  ...\n]\n```\n\n### Route `/v1/repo`\n\n#### Description\n\nHandles routes for `/v1/repo`. This usually would be responsible for creating or managing graph representations of repositories.\n\n### Route `/v1/graphs`\n\n#### Description\n\nHandles routes for `/v1/graphs`. This would typically involve operations related to managing different graphs.\n\n### Route `/v1/repo-test`\n\n#### Description\n\nHandles routes for `/v1/repo-test`. This likely handles test cases or operations related to graph representation of repositories.\n\n## Nodes\n\nThis assignment uses the following nodes/modules:\n\n1. **Hono**: Web application framework used to create the API.\n2. **prettyJSON**: A middleware for formatting JSON responses.\n3. **cors**: Middleware for handling CORS.\n4. **Codebase**: Custom class handling the parsing and processing of a codebase directory.\n5. **writeFile**: Method from the `fs/promises` module used for writing JSON files.\n\n## Example Usage\n\n1. **Starting the Server**:\n   ```javascript\n   const app = new Hono();\n   app.use(\"*\", prettyJSON());\n   app.use(\"/v1/*\", cors());\n   app.get(\"/\", async (c) => {\n     // Handler implementation...\n   });\n   app.route(\"/v1/repo\", createGraph);\n   app.route(\"/v1/graphs\", graphs);\n   app.route(\"/v1/repo-test\", createGraphTest);\n   ```\n\n2. **Accessing Root**:\n   - Endpoint: `GET /`\n   - Returns a simplified JSON representation of the parsed codebase.\n\n3. **Accessing V1 Repositories**:\n   - Endpoint: `/v1/repo`\n   - Custom logic not provided, assumed to handle repository graph operations.\n\n4. **Accessing V1 Graphs**:\n   - Endpoint: `/v1/graphs`\n   - Custom logic not provided, assumed to handle graph operations.\n\n5. **Accessing Repo Test**:\n   - Endpoint: `/v1/repo-test`\n   - Custom logic not provided, assumed to handle testing for repository operations.\n\n## Conclusion\n\nThis documentation provides an overview of the `app` setup using the Hono framework, listing middleware, routes, and their functionalities. Further expansion of the custom route handlers like `createGraph`, `graphs`, and `createGraphTest` would require additional details."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/codebase::enc",
    "label": "enc",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/codebase",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "enc = encoding_for_model(\"gpt-4-turbo\")",
    "summary": "# Documentation for Assignment `enc`\n\nThe assignment `enc` retrieves the encoding scheme suitable for the `\"gpt-4-turbo\"` model using the `encoding_for_model` function. This assignment is crucial for ensuring that data is correctly encoded and decoded when working with the specific model. Here is a detailed breakdown of the assignment:\n\n## Assignment\n\n```python\nenc = encoding_for_model(\"gpt-4-turbo\")\n```\n\n## Description\n\nThis assignment sets the variable `enc` to the encoding scheme returned by the `encoding_for_model` function when passed the model identifier `\"gpt-4-turbo\"`. This encoding scheme is typically used for tokenizing input text and decoding model outputs. It ensures compatibility with the specified `\"gpt-4-turbo\"` model.\n\n## Nodes\n\nThe nodes involved in this assignment include:\n\n1. **Function Call: `encoding_for_model(\"gpt-4-turbo\")`**\n   - **Description:** Calls the `encoding_for_model` function with the model identifier `\"gpt-4-turbo\"`.\n   - **Input:**\n     - A string `\"gpt-4-turbo\"` representing the model for which the encoding is required.\n   - **Output:**\n     - Returns an encoding scheme specific to the GPT-4 Turbo model.\n\n2. **Variable Assignment: `enc`**\n   - **Description:** Assigns the result of the `encoding_for_model(\"gpt-4-turbo\")` function call to the variable `enc`.\n   - **Input:**\n     - Receives the encoding scheme returned by `encoding_for_model(\"gpt-4-turbo\")`.\n   - **Output:**\n     - The variable `enc` now holds the encoding scheme that can be used for text tokenization and decoding operations relevant to the GPT-4 Turbo model.\n\n## Usage\n\nThe encoding scheme stored in `enc` can be used for various operations involving the GPT-4 Turbo model, such as:\n\n- Tokenizing input text before feeding it into the model.\n- Decoding the model's output tokens back into text.\n- Ensuring the correct handling of special tokens and sequences specific to the GPT-4 Turbo model.\n\n## Example\n\n```python\n# Example of how to use the encoding schema stored in enc\n\ninput_text = \"Hello, how can I assist you today?\"\ntokens = enc.encode(input_text)  # Tokenizing the input text\ndecoded_text = enc.decode(tokens)  # Decoding the tokens back to text\n\nprint(tokens)  # Outputs the tokenized representation\nprint(decoded_text)  # Outputs: \"Hello, how can I assist you today?\"\n```\n\n## Summary\n\nThe `enc` variable is an essential component for interacting with the GPT-4 Turbo model's encoding and decoding processes. By correctly setting this variable, users can ensure seamless text handling that conforms to the model's requirements."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::treeSitterCommentTypes",
    "label": "treeSitterCommentTypes",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "summary": "# Documentation for `treeSitterCommentTypes`\n\n`treeSitterCommentTypes` is an assignment in Python that contains a list of strings representing different types of comments as recognized by Tree-sitter, a parser generator tool. This list can be useful for syntax highlighting, parsing, or analyzing code to identify comment nodes.\n\n## Assignment\n\n```python\ntreeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']\n```\n\n## Description\n\nThe `treeSitterCommentTypes` list includes three types of comment nodes:\n\n1. **`comment`**: This is a general comment node that may be used for comments not specifically categorized as line or block comments. It serves as a common identifier for any comment type.\n   \n2. **`line_comment`**: This node represents single-line comments. These comments typically start with `//` in languages like C, C++, and Java, or `#` in Python and Ruby.\n   \n3. **`block_comment`**: This node identifies multi-line (block) comments. These comments usually start with `/*` and end with `*/` in languages like C, C++, and Java.\n\n## Usage\n\nThis list can be used to filter or identify comment nodes in a syntax tree generated by Tree-sitter. For example, if you are writing a code analyzer or syntax highlighter, you can refer to `treeSitterCommentTypes` to handle comment nodes appropriately.\n\n### Example\n\nSuppose you have a Tree-sitter syntax tree and wish to collect all comment nodes within it:\n\n```python\ndef collect_comment_nodes(tree):\n    comment_nodes = []\n    for node in tree.walk():\n        if node.type in treeSitterCommentTypes:\n            comment_nodes.append(node)\n    return comment_nodes\n```\n\nThis function iterates through all nodes in the syntax tree and collects those whose type matches any of the entries in `treeSitterCommentTypes`.\n\n## Nodes Utilized\n\nThe assignment `treeSitterCommentTypes` directly references the following nodes:\n- `comment`\n- `line_comment`\n- `block_comment`\n\nThese nodes correspond to specific types of comments in the syntax tree, allowing for precise identification and handling of comments in various programming languages supported by Tree-sitter.\n\n---\n\nThis documentation should help you understand the purpose and usage of the `treeSitterCommentTypes` assignment in your projects."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::indexSuffixesMap",
    "label": "indexSuffixesMap",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 54,
    "inDegree": 0,
    "outDegree": 1,
    "code": "indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '' // java has no index\r\n}",
    "summary": "# Documentation for `indexSuffixesMap`\n\n## Description\n\n`indexSuffixesMap` is a TypeScript assignment that defines a mapping of programming language identifiers to their respective index file suffixes. This can be particularly useful in scenarios where you need to automatically generate or resolve paths for index files specific to different languages.\n\n## Declaration\n\n```typescript\nconst indexSuffixesMap: Record<string, string> = {\n    'python': '/__init__',\n    'javascript': '/index',\n    'typescript': '/index',\n    'tsx': '/index',\n    'java': '' // java has no index\n};\n```\n\n## Nodes in the Assignment\n\n### TypeScript Types and Interfaces\n\n1. **Record<K, T>**:\n   - This is a utility type in TypeScript which is used to define an object type where keys are of type `K` and values are of type `T`.\n   - In this assignment, `Record<string, string>` indicates that `indexSuffixesMap` is an object with string keys and string values.\n\n### Key-Value Pairs\n\n1. **'python': '/__init__'**\n   - Maps the string 'python' to the string '/__init__', indicating the index file suffix used in Python projects.\n\n2. **'javascript': '/index'**\n   - Maps the string 'javascript' to the string '/index', a common convention for index files in JavaScript.\n\n3. **'typescript': '/index'**\n   - Maps the string 'typescript' to the string '/index', aligning with TypeScript conventions similar to JavaScript.\n\n4. **'tsx': '/index'**\n   - Maps the string 'tsx' to the string '/index', following the same index file convention as JavaScript and TypeScript.\n\n5. **'java': ''**\n   - Maps the string 'java' to an empty string, indicating that Java does not have a specific index file suffix.\n\n## Usage\n\nThis map can be referenced in various contexts such as:\n\n1. **Path Resolution**: Automatically resolve paths to index files for different languages in a project or build tool.\n2. **Template Generation**: Generate project templates that adhere to language-specific conventions for index files.\n3. **Code Analysis Tools**: Use in tools that need to understand or manipulate source code structures across multiple languages.\n\n## Example\n\n```typescript\nfunction getIndexFilePath(language: string): string {\n    const suffix = indexSuffixesMap[language];\n    if (suffix !== undefined) {\n        return `src/core${suffix}.js`;\n    } else {\n        return 'src/core/index.js'; // default if language is not found in the map\n    }\n}\n\n// Example Usage\nconsole.log(getIndexFilePath('python'));      // Output: src/core/__init__.js\nconsole.log(getIndexFilePath('javascript'));  // Output: src/core/index.js\nconsole.log(getIndexFilePath('java'));        // Output: src/core/.js\nconsole.log(getIndexFilePath('unknown'));     // Output: src/core/index.js\n```\n\nIn this example, `getIndexFilePath` utilizes `indexSuffixesMap` to determine the correct index file path for different programming languages. If the language is not found in `indexSuffixesMap`, it defaults to `'src/core/index.js'`."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::itselfClassMap",
    "label": "itselfClassMap",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 48,
    "inDegree": 0,
    "outDegree": 1,
    "code": "itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this'\r\n}",
    "summary": "## Documentation for `itselfClassMap`\n\n### Overview\n\nThe `itselfClassMap` is an assignment that creates a mapping between various programming languages and their respective keyword used to refer to the current instance of the class or object. The mapping is implemented using a `Record<string, string>` data structure.\n\n### Assignment Definition\n\n```typescript\nitselfClassMap: Record<string, string> = {\n    'python': 'self',\n    'javascript': 'this',\n    'typescript': 'this',\n    'tsx': 'this',\n    'java': 'this'\n}\n```\n\n### Nodes Used\n\nThe assignment utilizes various TypeScript nodes to define and initialize the `itselfClassMap`. Below are the nodes that are involved:\n\n1. **Type Alias Declaration**:\n   - `Record<string, string>`: This node defines a type alias that represents an object where both the keys and values are strings. This type alias ensures type safety by enforcing that the keys and values are of the specified types.\n\n2. **Object Literal Expression**:\n   - Used to define the mapping between language names and their respective keywords. For example:\n     ```typescript\n     {\n         'python': 'self',\n         'javascript': 'this',\n         'typescript': 'this',\n         'tsx': 'this',\n         'java': 'this'\n     }\n     ```\n\n### Purpose\n\nThe `itselfClassMap` is created to provide a quick reference for understanding the keyword used in various programming languages to refer to the current object or instance within class methods.\n\n### Details of the Mappings\n\n- `'python': 'self'`:\n  - In Python, the keyword `self` is used within class methods to refer to the instance of the class.\n  \n- `'javascript': 'this'`:\n  - In JavaScript, the keyword `this` is used to refer to the current object.\n\n- `'typescript': 'this'`:\n  - TypeScript, being a superset of JavaScript, also uses the keyword `this` to refer to the current object.\n\n- `'tsx': 'this'`:\n  - In TSX (TypeScript with JSX), `this` is used similarly to TypeScript to refer to the current object.\n\n- `'java': 'this'`:\n  - In Java, the keyword `this` is used within class methods to refer to the current instance of the class.\n\n### Usage\n\nThis mapping can be utilized in various scenarios, such as:\n- Developing language-specific code generators.\n- Providing language support in development tools or editors.\n- Implementing linters or static code analysis tools that need to identify the proper usage of `self` or `this` in different programming languages.\n\n### Example\n\nHere is an example of how this mapping might be used in a TypeScript function:\n\n```typescript\nfunction getClassInstanceKeyword(language: string): string | undefined {\n    return itselfClassMap[language];\n}\n\n// Usage\nconsole.log(getClassInstanceKeyword('python'));  // Output: 'self'\nconsole.log(getClassInstanceKeyword('javascript'));  // Output: 'this'\n```\n\nBy using this function, a developer can easily retrieve the keyword used to refer to the current instance for the specified language."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::newClassMethodsMap",
    "label": "newClassMethodsMap",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 65,
    "inDegree": 0,
    "outDegree": 1,
    "code": "newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new'\r\n}",
    "summary": "# Assignment Documentation: `newClassMethodsMap`\n\n## Overview\n\nThe `newClassMethodsMap` is a TypeScript object that maps programming languages to their respective syntax for defining class constructors. This mapping is helpful when working with multiple languages, allowing for a quick reference to the appropriate constructor methods across different languages.\n\n## Type Definition\n\nThe assignment defines `newClassMethodsMap` as a type `Record<string, string>`, which indicates a dictionary-like object where both the keys and values are strings.\n\n## Code\n\n```typescript\nnewClassMethodsMap: Record<string, string> = {\n    'python': '__init__',\n    'javascript': 'constructor',\n    'typescript': 'constructor',\n    'tsx': 'constructor',\n    'java': '', // Java constructor has the same name as the class\n    'rust': 'new'\n}\n```\n\n## Node Descriptions\n\nThis assignment makes use of the following nodes and concepts:\n\n1. **Key-Value Pairs**: Each entry in the `newClassMethodsMap` object is a key-value pair. The key is the name of a programming language, and the value is the name of the constructor method in that language.\n  \n2. **Record Utility Type**: `Record<K, T>` is a TypeScript utility type used to define an object type with a specific set of keys (`K`) and values (`T`). In this case:\n    - `K` is `string`, representing the names of programming languages.\n    - `T` is `string`, representing the constructor methods' names.\n\n3. **Comments**: Inline comments are used to provide additional context or explanation for specific entries. For instance, the comment `// Java constructor has the same name as the class` explains why the Java entry has an empty string as its value.\n\n## Language-Specific Constructor Methods\n\n- `python`: Uses `__init__` as the constructor method.\n- `javascript`: Uses `constructor` as the constructor method.\n- `typescript`: Uses `constructor` as the constructor method, similar to JavaScript.\n- `tsx`: Also uses `constructor` as the constructor method, aligning with TypeScript.\n- `java`: Specifies an empty string because Java constructors share the same name as the class itself.\n- `rust`: Uses `new` as the constructor method.\n\n## Usage Example\n\nThis mapping can be particularly useful in code generation, documentation, or any context where an understanding of constructor syntax across different languages is required. An example usage in TypeScript could look like this:\n\n```typescript\nfunction getConstructorSyntax(language: string): string {\n    const constructor = newClassMethodsMap[language];\n    if (constructor === undefined) {\n        throw new Error('Language not supported');\n    }\n    return constructor;\n}\n\nconsole.log(getConstructorSyntax('python')); // Output: __init__\nconsole.log(getConstructorSyntax('java'));   // Output: (empty string)\n```\n\nThis function `getConstructorSyntax` takes a language as an input and returns the corresponding constructor method syntax using the `newClassMethodsMap`.\n\n## Conclusion\n\nThe `newClassMethodsMap` provides a concise and clear mapping of class constructor methods for various programming languages. This can be a handy tool for developers working in multi-language environments or developing language-agnostic tools and solutions."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::languageExtensionMap",
    "label": "languageExtensionMap",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 86,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n}",
    "summary": "## Documentation for `languageExtensionMap`\n\n### Overview\n`languageExtensionMap` is a TypeScript `Record` that maps file extensions (as strings) to their corresponding programming languages (also as strings). This mapping provides a quick reference for determining the language associated with a given file extension.\n\n### Declaration\n\n```typescript\nlanguageExtensionMap: Record<string, string> = {\n  'py': 'python',\n  'c': 'c',\n  'h': 'c',\n  // 'ipynb': 'python',\n  'js': 'typescript',\n  'mjs': 'typescript',\n  'jsx': 'typescript',\n  'ts': 'typescript',\n  'tsx': 'tsx',\n  'java': 'java',\n}\n```\n\n### Nodes Used\n\n1. **TypeScript Record**:\n   - `Record<string, string>`: This is a type that represents an object whose keys are strings and whose values are also strings. It is used to define the structure of `languageExtensionMap`.\n\n2. **Property Key (string)**:\n   - Keys like 'py', 'c', 'h', 'js', etc., represent the file extensions as strings.\n\n3. **Property Value (string)**:\n   - Values like 'python', 'c', 'typescript', 'java', etc., represent the programming languages as strings.\n\n4. **Comment**:\n   - An inline comment (`// 'ipynb': 'python'`) shows a potential mapping that is currently commented out, indicating that `.ipynb` files could be mapped to 'python'.\n\n### Supported File Extensions and Their Mappings\nHere are the file extensions currently supported in `languageExtensionMap` and their associated programming languages:\n\n- `'py'`: `python`\n  - Python source files.\n  \n- `'c'`: `c`\n  - C language source files.\n  \n- `'h'`: `c`\n  - C language header files.\n  \n- `'js'`: `typescript`\n  - JavaScript files, treated as TypeScript.\n  \n- `'mjs'`: `typescript`\n  - JavaScript modules, treated as TypeScript.\n  \n- `'jsx'`: `typescript`\n  - JavaScript React (JSX) files, treated as TypeScript.\n  \n- `'ts'`: `typescript`\n  - TypeScript files.\n  \n- `'tsx'`: `tsx`\n  - TypeScript React (TSX) files.\n  \n- `'java'`: `java`\n  - Java source files.\n\n### Usage\nThis data structure can be used in various contexts such as syntax highlighting, file analysis tools, compiling or transpiling pipelines, or any scenario where it's necessary to dynamically determine a programming language based on file extension.\n\n### Example\n\nHere is an example of using `languageExtensionMap` to determine the programming language of a file based on its extension:\n\n```typescript\nfunction getLanguage(extension: string): string | undefined {\n    return languageExtensionMap[extension];\n}\n\nconst extension = 'py';\nconst language = getLanguage(extension);\nconsole.log(language); // Output: 'python'\n```\n\nIn this example, the function `getLanguage` retrieves the programming language corresponding to the given file extension using the `languageExtensionMap`.\n\n### Note\n- The key `'ipynb': 'python'` is commented out, indicating that the mapping might be considered but is not active.\n\nThis documentation provides a comprehensive overview of the `languageExtensionMap` object, detailing its structure, usage, and the specific file extensions it maps to their respective languages."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::languages",
    "label": "languages",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 23,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C\r\n}",
    "summary": "Certainly! Here's a detailed documentation for the assignment `languages` along with its used nodes:\n\n---\n\n## `languages` Object\n\nThe `languages` object is a collection that contains a set of programming languages. This indicates a categorization or listing of various programming languages using a data structure (presumably a set in Python or another language that supports sets).\n\n### Languages Included\n1. **JavaScript**:\n   - A high-level, interpreted scripting language.\n   - Commonly used for web development to create interactive web pages.\n   - Syntax similar to C.\n\n2. **Python**:\n   - A high-level, interpreted general-purpose programming language.\n   - Known for its readability, simplicity, and versatility.\n   - Widely used in web development, scientific computing, data analysis, artificial intelligence, and more.\n\n3. **TypeScript**:\n   - A strict syntactical superset of JavaScript that adds static typing.\n   - Offers features such as type annotations and interfaces.\n   - Commonly used for larger projects to enhance code maintainability and reduce errors.\n\n4. **TSX**:\n   - A TypeScript-based syntax extension that stands for TypeScript and XML.\n   - Used in React development for writing components.\n   - Allows mixing of TypeScript and JSX (JavaScript XML) within React files to describe UI elements.\n\n5. **Java**:\n   - A high-level, object-oriented programming language.\n   - Widely used in enterprise environments, Android app development, and large systems.\n   - Known for its portability across platforms due to the Java Virtual Machine (JVM).\n\n6. **C**:\n   - A low-level, procedural programming language.\n   - Known for its efficiency and control over system resources.\n   - Commonly used in system programming, game development, and embedded systems.\n\n### Nodes Used\n\nHere is a breakdown of the potential nodes or concepts that may be utilized in the environment where `languages` is defined:\n\n1. **Set Node**:\n    - The `languages` collection appears to be using a set data structure.\n    - A set is a collection type that stores unique elements (duplicates are not allowed).\n    - Common set operations include union, intersection, and difference.\n\n2. **Elements Node**:\n    - The elements stored within the set are the individual programming languages.\n    - Each language is a member (element) of the set.\n\n3. **Initialization Node**:\n    - The set is initialized using a set literal or constructor.\n    - Example Initialization (assuming Python):\n      ```python\n      languages = {\"JavaScript\", \"Python\", \"TypeScript\", \"TSX\", \"Java\", \"C\"}\n      ```\n    - This syntax creates a set containing the listed programming languages.\n\n4. **Type Node**:\n    - The overall type of the `languages` variable is determined by the language and data structure used.\n    - In Python, this is `set`.\n    - In other programming languages, equivalent collections might be used, such as `Set` in Java.\n\n### Example Uses\n\n#### Example in Python:\n```python\nlanguages = {'JavaScript', 'Python', 'TypeScript', 'TSX', 'Java', 'C'}\nprint(languages)\n```\n\n#### Example in Java:\n```java\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        Set<String> languages = new HashSet<>();\n        languages.add(\"JavaScript\");\n        languages.add(\"Python\");\n        languages.add(\"TypeScript\");\n        languages.add(\"TSX\");\n        languages.add(\"Java\");\n        languages.add(\"C\");\n        \n        System.out.println(languages);\n    }\n}\n```\n\nBy understanding the structure and usage of the `languages` collection, developers can efficiently manage and utilize this collection within various applications that require handling programming languages sets.\n\n---\n\nThis documentation assumes the languages/constructs used in your code follow a similar conventional structure for a set or collection in the respective programming languages."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::excludedExtensions",
    "label": "excludedExtensions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']",
    "summary": "# Documentation: `excludedExtensions`\n\nThe `excludedExtensions` list is an array that contains file extensions and specific filename patterns that are to be excluded during processing, compilation, or any other operation that involves files. This can be particularly useful in scenarios where specific types of files need to be ignored, such as during file filtering operations, code minification tasks, or when configuring build tools.\n\n## Declaration\n```python\nexcludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']\n```\n\n## Explanation\nThe `excludedExtensions` list includes the following patterns:\n\n1. **min.js**: Represents minimized JavaScript files.\n2. **min.css**: Represents minimized CSS files.\n3. **min.css.map**: Represents source map files for minimized CSS files.\n4. **min.js.map**: Represents source map files for minimized JavaScript files.\n5. **d.ts**: Represents TypeScript declaration files.\n6. **.config.js**: Represents configuration files written in JavaScript.\n\n## Use Cases\n- **Build Tools Configuration**: When configuring build tools like Webpack, Gulp, or Grunt, you might want to exclude certain files from being processed to speed up the build process or avoid unnecessary operations.\n- **Static Site Generators**: Exclude minimized or configuration files to avoid duplication or conflicts during static site generation.\n- **File Watching**: When setting up file watchers for live reloading or other automated tasks, you may want to avoid watching specific file types to reduce resource consumption.\n- **Code Linting**: Configuring linting tools to skip over certain file types that are not meant to be checked.\n- **Backup and Sync Services**: Ensure that specific types of files are not backed up or synced to avoid unnecessary storage usage.\n\n## Example Use in Code\n```python\ndef should_exclude_file(file_name):\n    for pattern in excludedExtensions:\n        if file_name.endswith(pattern):\n            return True\n    return False\n\nfiles_to_check = ['index.js', 'style.min.css', 'main.config.js', 'script.js']\nexcluded_files = [f for f in files_to_check if should_exclude_file(f)]\n\nprint(excluded_files)\n# Output: ['style.min.css', 'main.config.js']\n```\n\n## Nodes\nThis assignment uses the following nodes:\n1. **List**: The main data structure used is a list, which is a built-in Python data structure that can hold an ordered collection of items.\n2. **String Literals**: Each item in the list is a string representing a file extension or a specific file pattern.\n3. **File Operations**: This list is typically used in the context of file operations to filter out unwanted files.\n\nThis concise documentation provides a clear understanding of what the `excludedExtensions` assignment is, its purpose, and how it can be used in different scenarios."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::excludedFolders",
    "label": "excludedFolders",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']",
    "summary": "# Documentation for `excludedFolders` Assignment\n\n## Overview\nThe `excludedFolders` assignment defines a list of folder names that are typically excluded from certain operations such as version control, deployment, or testing processes. These folders might contain configuration files, virtual environment data, build artifacts, and test-related files which should not be processed or included in specific scopes or operations (e.g., running a linter, packaging for production).\n\n## Declaration\n```python\nexcludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']\n```\n\n## Description of Nodes (Folders)\n\n1. **.git**:\n    - Purpose: Contains metadata and object database for the Git version control system.\n    - Common Uses: Used by Git to track changes in the repository.\n\n2. **.vscode**:\n    - Purpose: Contains configurations and extensions specific to Visual Studio Code.\n    - Common Uses: Used by VS Code to store workspace settings, extensions, and configurations.\n\n3. **venv**:\n    - Purpose: Stores the virtual environment for a Python project.\n    - Common Uses: Used to manage dependencies in an isolated environment to prevent conflicts.\n\n4. **node_modules**:\n    - Purpose: Contains all the downloaded packages and dependencies required for a Node.js project.\n    - Common Uses: Used by npm or yarn package managers to keep JavaScript dependencies.\n\n5. **dist**:\n    - Purpose: Contains distribution files after a project is built.\n    - Common Uses: Used to store the final product, such as compiled JavaScript files or archives.\n\n6. **__pycache__**:\n    - Purpose: Stores compiled Python bytecode files.\n    - Common Uses: Used by the Python interpreter to improve performance by skipping recompilation of source code.\n\n7. **tests**:\n    - Purpose: Contains test scripts and testing resources.\n    - Common Uses: Used by testing frameworks to organize and run tests.\n\n8. **build**:\n    - Purpose: Holds the build output of a project.\n    - Common Uses: Used to store temporary files created during the build process.\n\n9. **_static**:\n    - Purpose: Typically contains static files such as images, stylesheets, and JavaScript files.\n    - Common Uses: Used in documentation generation tools like Sphinx for static assets.\n\n10. **jest**:\n    - Purpose: Contains configurations or outputs related to Jest testing framework.\n    - Common Uses: Used by Jest for testing JavaScript and managing snapshots.\n\n11. **__tests__**:\n    - Purpose: Another common folder name to store test scripts in a project.\n    - Common Uses: Used to organize test files similar to the `tests` folder.\n\n## Usage\nThe `excludedFolders` list can be utilized to configure tools and scripts to exclude these directories from their operations. For instance:\n\n- **Version Control Systems**: Configure `.gitignore` or other ignore files to exclude these folders.\n- **Build Tools**: Specify excluded directories in build configurations to avoid including unwanted files.\n- **Linters and Formatters**: Configure linters to skip these directories to enhance performance and avoid unnecessary processing.\n- **Packaging and Deployment**: Ensure these folders are not included in the final deployment or distribution package.\n\nBy maintaining a list of `excludedFolders`, developers can streamline project configurations and improve project maintainability."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::C",
    "label": "C",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "C = require(\"tree-sitter-c\")",
    "summary": "# Documentation for Tree-Sitter C Assignment\n\n## Overview\nThe `C` assignment utilizes the Tree-Sitter library to parse and analyze C language source code. Tree-Sitter provides a concrete syntax tree (CST) from the source code, enabling deep analysis and manipulation. This documentation outlines the specific nodes used within the context of the assignment.\n\n## Setup\n\nTo integrate the Tree-Sitter library for C language parsing, the code initiates with:\n```javascript\nC = require(\"tree-sitter-c\");\n```\nHere, `C` is the module that provides grammar definitions and parsing capabilities for C language.\n\n## Nodes Used\nThe assignment employs the following nodes to represent different syntactical elements of the C programming language:\n\n### 1. `translation_unit`\n- **Description**: Represents the entire parsed source file.\n- **Usage**: Serves as the root node for the parsed syntax tree.\n\n### 2. `function_definition`\n- **Description**: Represents the definition of a function.\n- **Usage**: Encloses function return type, name, parameters, and body.\n\n### 3. `declaration`\n- **Description**: Represents variable and type declarations.\n- **Usage**: For defining variables, constants, or other type definitions within scopes.\n\n### 4. `expression_statement`\n- **Description**: Represents a statement that consists entirely of a single expression.\n- **Usage**: Commonly used for assignments and function calls within a function body.\n\n### 5. `if_statement`\n- **Description**: Represents an if-else conditional statement.\n- **Usage**: Encloses the conditional expression and associated true and false branches.\n\n### 6. `for_statement`\n- **Description**: Represents a for-loop, including initialization, condition, update, and body.\n- **Usage**: To encapsulate the iterative constructs in the C language.\n\n### 7. `while_statement`\n- **Description**: Represents a while-loop structure.\n- **Usage**: Defines condition and body for loops that iterate while a condition is true.\n\n### 8. `return_statement`\n- **Description**: Represents a return statement from a function.\n- **Usage**: To specify the value returned by a function, ending its execution.\n\n### 9. `type_identifier`\n- **Description**: Represents data type identifiers.\n- **Usage**: Used for type declaration in variables and function signatures.\n\n### 10. `identifier`\n- **Description**: Represents variable, function, and type names.\n- **Usage**: Crucial for naming elements like variables, functions, and custom types.\n\n### 11. `binary_expression`\n- **Description**: Represents binary operations (e.g., addition, subtraction).\n- **Usage**: Used for expressions involving two operands and an operator.\n\n### 12. `call_expression`\n- **Description**: Represents a function call.\n- **Usage**: Encloses the function name and the arguments passed to it.\n\n## Conclusion\nThe assignment leverages the Tree-Sitter C library to provide robust parsing capabilities for C language code. By working with a variety of nodes such as `function_definition`, `if_statement`, and `call_expression`, it facilitates detailed code analysis and manipulation.\n\nFurther information and advanced usage can be obtained via Tree-Sitter's official documentation: [Tree-Sitter Documentation](https://tree-sitter.github.io/tree-sitter/). \n\nAddress any additional parsing, traversal, or manipulation requirements by extending the mentioned nodes and integrating additional ones as necessary from the Tree-Sitter C grammar."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::Java",
    "label": "Java",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Java = require(\"tree-sitter-java\")",
    "summary": "# Documentation for Java Assignment\n\n```javascript\nJava = require(\"tree-sitter-java\")\n```\n\n## Description\nThis assignment sets up the `tree-sitter-java` parser by requiring it in order to parse and analyze Java source code using the [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) library. `Tree-sitter` is a parser generator tool and an incremental parsing library, allowing you to build parsers for different programming languages to generate syntax trees from source code.\n\n## Usage\nThe `Java` object that gets imported here can be used to perform parsing operations on Java code. For example, to parse a Java file, you can initialize the `tree-sitter` parser with the `Java` grammar.\n\n## Node Types\nThis assignment makes use of the following nodes (syntax tree elements) which are typically used in parsing Java code:\n1. **CompilationUnit**: This is the root node of the syntax tree representing an entire Java source file.\n2. **ImportDeclaration**: Represents an import statement in a Java file.\n3. **ClassDeclaration**: Represents a class declaration, including its name, body, and modifiers.\n4. **MethodDeclaration**: Represents a method definition, including its return type, name, parameters, and body.\n5. **VariableDeclaration**: Represents a variable or field declaration.\n6. **ExpressionStatement**: Represents an expression that is used as a statement.\n7. **IfStatement**: Represents an if conditional statement.\n8. **ForStatement**: Represents a for loop statement.\n9. **WhileStatement**: Represents a while loop statement.\n10. **Block**: Represents a block of code, typically denoted by curly braces `{}`.\n11. **ReturnStatement**: Represents a return statement in a method.\n12. **Literal**: Represents literal values such as integers, strings, and booleans.\n13. **AssignmentExpression**: Represents an assignment of a value to a variable.\n14. **BinaryExpression**: Represents a binary operation such as addition, subtraction, or logical operations.\n15. **UnaryExpression**: Represents a unary operation such as negation or increment/decrement.\n16. **Type**: Represents a type (e.g., int, float, class types).\n17. **Annotation**: Represents annotations in Java.\n\n## Example\nHeres a small example to illustrate how you might set up and use this parser:\n\n```javascript\nconst Parser = require('tree-sitter');\nconst Java = require('tree-sitter-java');\n\nconst parser = new Parser();\nparser.setLanguage(Java);\n\n// Sample Java code\nconst sourceCode = `\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n`;\n\nconst tree = parser.parse(sourceCode);\nconsole.log(tree.rootNode.toString());\n```\n\nThe `tree-sitter-java` parser converts the `sourceCode` string into a syntax tree. The `rootNode` can then be used to traverse and manipulate the tree.\n\n## Conclusion\nWith this setup, you are equipped to parse Java source code and analyze its structure using Tree-sitter's powerful parsing capabilities. The nodes mentioned here are just a subset of the extensive possible nodes defined by the Java grammar in `tree-sitter-java`. Explore further to utilize other advanced nodes and parsing techniques for your projects."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::TSX",
    "label": "TSX",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TSX = require(\"tree-sitter-typescript\").tsx",
    "summary": "# TSX Assignment Documentation\n\n## Overview\nThe `TSX` assignment initializes the TypeScript/TSX grammar for use with the Tree-sitter parsing library. Tree-sitter is a parser generator tool and an incremental parsing library that can build a concrete syntax tree for a source file.\n\n## Assignment Detail\n```javascript\nTSX = require(\"tree-sitter-typescript\").tsx\n```\nThis line of code imports the TSX grammar module from the `tree-sitter-typescript` package and assigns it to the `TSX` variable. This allows you to utilize the Tree-sitter parser with TypeScript/TSX specific syntax.\n\n## Nodes\nThe Tree-sitter TSX grammar includes a variety of nodes that represent different syntactic constructs in TypeScript/TSX. While the specific assignment does not list them explicitly, some common nodes in the TSX grammar include:\n\n### TypeScript/TSX Specific Nodes\n- `program`: Represents the entire source code file.\n- `import_declaration`: Represents an import statement.\n- `export_declaration`: Represents an export statement.\n- `class_declaration`: Represents the declaration of a class.\n- `function_declaration`: Represents a regular function declaration.\n- `arrow_function`: Represents an arrow function.\n- `variable_declaration`: Represents a variable declaration (e.g., `let`, `const`).\n- `type_alias_declaration`: Represents a type alias.\n- `interface_declaration`: Represents an interface declaration.\n- `jsx_element`: Represents a JSX element in TSX.\n- `jsx_self_closing_element`: Represents a self-closing JSX element.\n- `jsx_fragment`: Represents a JSX fragment.\n- `jsx_text`: Represents text within a JSX element.\n\n### General JavaScript Nodes (also relevant in TSX)\n- `identifier`: Represents an identifier (e.g., variable names).\n- `expression_statement`: Represents an expression statement.\n- `assignment_expression`: Represents an assignment.\n- `binary_expression`: Represents a binary operation (e.g., `+`, `-`).\n- `call_expression`: Represents a function or method call.\n- `if_statement`: Represents an `if` statement.\n- `for_statement`: Represents a `for` loop.\n- `while_statement`: Represents a `while` loop.\n- `array`: Represents an array literal.\n- `object`: Represents an object literal.\n\n### Example Usage\n#### Parsing a TSX File\n```javascript\nconst Parser = require('tree-sitter');\nconst parser = new Parser();\nconst TSX = require(\"tree-sitter-typescript\").tsx;\n\nparser.setLanguage(TSX);\n\nconst sourceCode = `\nimport React from 'react';\n\nconst MyComponent = () => (\n  <div>Hello, world!</div>\n);\n\nexport default MyComponent;\n`;\n\nconst tree = parser.parse(sourceCode);\nconsole.log(tree.rootNode.toString());\n```\n\nThis code sets up a parser for TypeScript/TSX syntax using Tree-sitter, parses a small snippet of TSX code, and outputs the syntax tree.\n\nBy utilizing these nodes and Tree-sitters powerful API, developers can perform a wide range of analyses and transformations on TypeScript/TSX code."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::TypeScript",
    "label": "TypeScript",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TypeScript  = require('tree-sitter-typescript').typescript",
    "summary": "# TypeScript Assignment Documentation\n\n```javascript\nconst TypeScript  = require('tree-sitter-typescript').typescript;\n```\n\n## Overview\n\nThis assignment initializes and requires the TypeScript module from the `tree-sitter-typescript` package. `tree-sitter-typescript` is a library that provides a TypeScript grammar for the Tree-sitter parsing library.\n\n## Nodes Used\n\nThe following nodes are utilized within this assignment:\n\n### 1. `typescript`\n\n- **Type:** Module\n- **Description:** This node represents the TypeScript grammar for the Tree-sitter parsing library. It provides the necessary syntax definitions and parsing rules required to parse and analyze TypeScript code.\n\n### 2. Node Descriptions\n\nAlthough not explicitly listed in the initial assignment, the TypeScript grammar includes a variety of nodes that cover TypeScript's syntax. Here are some key nodes typically included:\n\n- **Source File Node (`source_file`)**\n  - Represents the entire TypeScript source file.\n  \n- **Function Declaration (`function_declaration`)**\n  - Represents a function definition in TypeScript.\n  \n- **Variable Declaration (`variable_declaration`)**\n  - Represents a variable declaration statement.\n\n- **Class Declaration (`class_declaration`)**\n  - Represents a class definition.\n  \n- **Interface Declaration (`interface_declaration`)**\n  - Represents an interface definition.\n  \n- **Type Alias Declaration (`type_alias_declaration`)**\n  - Represents a type alias definition.\n\n- **Import Declaration (`import_declaration`)**\n  - Represents an import statement.\n  \n- **Export Declaration (`export_declaration`)**\n  - Represents an export statement.\n\n- **Expression Nodes (Various)**\n  - Represent different expressions like binary expressions, unary expressions, etc.\n\n- **Literal Nodes (Various)**\n  - Represent literals like strings, numbers, booleans, etc.\n\n- **Type Nodes (Various)**\n  - Represent TypeScript-specific types like `any_type`, `array_type`, `function_type`, etc.\n\n### Example Nodes\n\nHere is an example snippet illustrating some of these nodes in a TypeScript source file:\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\nclass UserAccount {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  greet() {\n    return `Hello, ${this.name}!`;\n  }\n}\n\nlet user: User = new UserAccount(\"Alice\");\nconsole.log(user.greet());\n```\n\nIn this example:\n- `interface User {...}` is an `interface_declaration` node.\n- `class UserAccount {...}` is a `class_declaration` node.\n- `name: string` in the class and interface are `property_signature` nodes.\n- `let user: User = new UserAccount(\"Alice\");` is a `variable_declaration` node.\n- `console.log(user.greet());` is an `expression_statement` node.\n\n## Conclusion\n\nThe TypeScript module from `tree-sitter-typescript` provides comprehensive support for parsing and analyzing TypeScript code through a variety of nodes representing different parts of TypeScript syntax. This assignment initializes the module, allowing further operations to parse and work with TypeScript source code."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::Python",
    "label": "Python",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Python = require(\"tree-sitter-python\")",
    "summary": "# Documentation for Python Tree-sitter Assignment\n\nThis documentation provides details on the assignment for incorporating Python syntax highlighting using Tree-sitter.\n\n## Assignment: Python Syntax Highlighting\n\n### Module Required:\n```javascript\nconst Python = require(\"tree-sitter-python\");\n```\n\n### Description:\nThis assignment loads the `tree-sitter-python` module, which allows parsing and syntax highlighting of Python code.\n\n### Nodes Used:\nThe `tree-sitter-python` module provides a variety of syntax nodes which can be used to analyze and render Python code. Below is a non-exhaustive list of nodes typically used in this context:\n\n1. **module**\n   - Represents an entire Python file.\n\n2. **function_definition**\n   - Represents a function defined using the `def` keyword.\n\n3. **class_definition**\n   - Represents a class defined using the `class` keyword.\n\n4. **parameters**\n   - Represents the parameters of a function.\n\n5. **arg_list**\n   - Represents a list of arguments passed to a function.\n\n6. **expression_statement**\n   - Represents a standalone expression.\n\n7. **assignment_statement**\n   - Represents an assignment such as `x = y`.\n\n8. **if_statement**\n   - Represents an if-conditional statement.\n\n9. **elif_clause**\n   - Represents an elif (else if) conditional clause.\n\n10. **else_clause**\n    - Represents an else clause in a conditional statement.\n\n11. **while_statement**\n    - Represents a while loop.\n\n12. **for_statement**\n    - Represents a for loop.\n\n13. **try_statement**\n    - Represents a try block, utilized for exception handling.\n\n14. **except_clause**\n    - Represents the catch block in exception handling.\n\n15. **finally_clause**\n    - Represents the finally block in exception handling, executed after try and except blocks.\n\n16. **import_statement**\n    - Represents an import statement for including modules.\n\n17. **with_statement**\n    - Represents a with statement for context management.\n\n18. **return_statement**\n    - Represents a return statement exiting a function and optionally returning a value.\n\n19. **list**\n    - Represents a list value structure.\n\n20. **dictionary**\n    - Represents a dictionary value structure.\n\n### Purpose:\nThis assignment is aimed to assist developers in parsing Python code structures and generating syntax highlights for IDEs, code editors, or any application requiring Python code analysis.\n\n### Usage Example:\nHere's an example of how you might utilize the imported `tree-sitter-python` module:\n\n```javascript\nconst Parser = require(\"tree-sitter\");\nconst Python = require(\"tree-sitter-python\");\n\nconst parser = new Parser();\nparser.setLanguage(Python);\n\nconst sourceCode = `\ndef greet(name):\n    print(f\"Hello, {name}!\")\n`;\n\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n```\n\n### Summary:\nBy utilizing the `tree-sitter-python` module, developers can efficiently analyze and interpret Python code, making it a valuable tool for applications involving code editing, linting, or syntax highlighting. This documentation outlines the primary nodes that the module supports, ensuring a comprehensive understanding of its syntax tree structure."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts::JavaScript",
    "label": "JavaScript",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/consts",
    "totalTokens": 10,
    "inDegree": 0,
    "outDegree": 1,
    "code": "JavaScript = require(\"tree-sitter-javascript\")",
    "summary": "# JavaScript Assignment Documentation\n\n## Overview\n\nThis assignment involves the usage of the Tree-Sitter JavaScript parser, imported into your project. Tree-Sitter is a parser generator tool and an incremental parsing library, which is useful for parsing programming languages, especially in environments like text editors where fast and incremental updates to the parse tree are necessary.\n\nTo accomplish this, you import the Tree-Sitter JavaScript package with the following line of code:\n\n```javascript\nJavaScript = require(\"tree-sitter-javascript\");\n```\n\n## Nodes\n\nIn the context of Tree-Sitter, nodes are the fundamental components of the syntax tree. A node represents a single syntactic element of the source code, such as a statement, expression, or token.\n\nThe following nodes are commonly used in Tree-Sitter JavaScript parsing:\n\n1. **Program Node**\n    - Represents the entire JavaScript program or script.\n    - Acts as the root of the syntax tree.\n    - Contains child nodes representing top-level constructs like function declarations, variable declarations, and expressions.\n\n2. **Function Declaration Node**\n    - Represents function declarations within the JavaScript code.\n    - Consists of child nodes for the function's name, parameter list, and body.\n\n3. **Variable Declaration Node**\n    - Represents variable declarations, which may include `var`, `let`, or `const` keywords.\n    - Contains child nodes for the variable kind, declarators, and init expressions if initialization is present.\n\n4. **Expression Statement Node**\n    - Represents a statement consisting of a single expression.\n    - Typically includes child nodes for the expression itself.\n\n5. **Identifier Node**\n    - Represents an identifiera name used to identify a variable, function, property, etc.\n    - Contains the text of the identifier.\n\n6. **Literal Node**\n    - Represents literal values like numbers, strings, booleans, etc.\n    - Contains the text representation of the literal value.\n\n7. **Binary Expression Node**\n    - Represents a binary operation like addition, multiplication, logical AND, etc.\n    - Has child nodes for the left-hand side (lhs) operand, operator, and right-hand side (rhs) operand.\n\n8. **If Statement Node**\n    - Represents an `if` conditional statement.\n    - Typically includes child nodes for the condition, the block executed if the condition is true, and optionally, an `else` clause.\n\n9. **Loop Nodes**\n    - Nodes that represent different types of loops including `for`, `while`, and `do-while` loops.\n    - Contains child nodes for loop initialization, condition, increment, and body.\n\n10. **Return Statement Node**\n    - Represents a `return` statement in a function.\n    - Contains a child node for the expression returned, if any.\n\n11. **Object Property Node**\n    - Represents properties within an object.\n    - Includes the key (property name) and value nodes.\n\n## Usage Example\n\nHere is a simple example demonstrating how to use Tree-Sitter JavaScript to parse a piece of JavaScript code and inspect the resulting syntax tree.\n\n```javascript\nconst Parser = require(\"tree-sitter\");\nconst JavaScript = require(\"tree-sitter-javascript\");\n\nconst parser = new Parser();\nparser.setLanguage(JavaScript);\n\nconst sourceCode = `function add(a, b) { return a + b; }`;\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n```\n\nThis script sets up a parser, uses it to parse a simple JavaScript function, and then logs the root node of the produced syntax tree. This tree can be traversed and inspected using the properties and methods provided by the Tree-Sitter library.\n\n## Conclusion\n\nBy leveraging Tree-Sitter and its JavaScript grammar, you can efficiently parse and manipulate JavaScript source code within your applications. The nodes provided by the Tree-Sitter JavaScript package provide a detailed and structured representation of the code, enabling advanced features such as code analysis, transformation, and code-completion."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::getCalledNode",
    "label": "getCalledNode",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 87,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
    "summary": "Certainly! Below is the documentation for the `getCalledNode` function, which includes a brief description, parameters, return value, and an example of usage.\n\n---\n\n## Function: `getCalledNode`\n\n### Description\n\nThe `getCalledNode` function retrieves a specific node (referred to as `calledNode`) from an imported file node, based on the provided call name and the source of the import. This function is useful for accessing nodes in a structured document or file representation where nodes have hierarchical relationships.\n\n### Parameters\n\n- **callName** (`string`): The name of the node to be retrieved. This is the specific call or node identifier within the imported file node.\n- **importFrom** (`string`): The source or identifier of the imported file from which the node is to be retrieved.\n- **importedFileNodes** (`Record<string, { fileNode: Node; importStatement: ImportStatement }>`): A record (object/dictionary) where keys are the import sources, and values are objects containing:\n  - `fileNode` (`Node`): The root or parent node of the imported file, representing the file's structure.\n  - `importStatement` (`ImportStatement`): The import statement related to the imported file. (Not utilized in this function but part of the data structure)\n\n### Returns\n\n- **calledNode** (`Node | undefined`): The retrieved node from the imported file node that matches the call name. Returns `undefined` if the node is not found.\n\n### Usage Example\n\n```typescript\n// Assuming Node and ImportStatement types are defined and imported\n\n// Example data for importedFileNodes\nconst importedFileNodes = {\n  'moduleA': {\n    fileNode: new Node('moduleA'), // Assuming `Node` constructor sets up the node structure\n    importStatement: { /* import statement details */ }\n  }\n};\n\n// Adding child nodes to `moduleA` for demonstration purposes\nimportedFileNodes['moduleA'].fileNode.addChild('moduleA::function1', new Node('function1'));\nimportedFileNodes['moduleA'].fileNode.addChild('moduleA::function2', new Node('function2'));\n\n// Retrieve the node\nconst calledNode = getCalledNode('function1', 'moduleA', importedFileNodes);\n\n// calledNode should now be the node corresponding to 'function1' in 'moduleA'\nconsole.log(calledNode); // Outputs: Node { id: 'function1', ... }\n```\n\n### Implementation\n\n```typescript\nfunction getCalledNode(\n  callName: string,\n  importFrom: string,\n  importedFileNodes: Record<\n    string,\n    { fileNode: Node; importStatement: ImportStatement }\n  >\n) {\n  const importedFile = importedFileNodes[importFrom].fileNode;\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\n  return calledNode;\n}\n```\n\n### Notes\n\n- `Node` and `ImportStatement` are assumed to be types or classes defined elsewhere in the codebase.\n- The `getChild` method used in the `Node` class is assumed to retrieve a child node by its identifier.\n\n---"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::cleanAndSplitContent",
    "label": "cleanAndSplitContent",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
    "summary": "# `cleanAndSplitContent` Function Documentation\n\n## Function Signature\n```typescript\nconst cleanAndSplitContent = (content: string): string[];\n```\n\n## Description\nThe `cleanAndSplitContent` function processes a given string to remove specific unwanted characters and formats it into an array of strings. It performs the following operations:\n1. Removes parentheses and their contents, newlines, and multiple spaces.\n2. Replaces colons `:` and vertical bars `|` with commas `,`.\n3. Splits the content by commas.\n4. Removes surrounding brackets `[ ]`, braces `{ }`, and trims any whitespace from each split part.\n\n## Parameters\n- `content` (`string`): The string input that needs to be cleaned and split into an array of strings.\n\n## Returns\n- `string[]`: An array of strings obtained after cleaning and splitting the input `content`.\n\n## Detailed Explanation\n1. **Removal and Replacement:**\n    - The function first cleans the `content` string by using a series of regular expressions to remove certain characters and replace others:\n        - `\\(|\\)|\\n|\\s{2,}`: This removes all instances of parentheses (both `(` and `)`), newlines (`\\n`), and sequences of two or more spaces.\n        - `[:|]`: This replaces all colons `:` and vertical bars `|` with commas `,`.\n    - The cleaned string is then trimmed of leading and trailing whitespace using `.trim()`.\n  \n2. **Splitting and Further Cleaning:**\n    - The cleaned and trimmed content is split into an array of substrings using `,` as the delimiter.\n    - Each substring in the resulting array is further cleaned by removing any surrounding brackets (`[ ]`) and braces (`{ }`), and trimming any additional leading or trailing whitespace.\n\n## Example Usage\n```javascript\nconst originalContent = \"(hello, [world] | some:string)\\nmore content {here}\";\nconst result = cleanAndSplitContent(originalContent);\nconsole.log(result);\n// Output: [\"hello\", \"world\", \"some\", \"string\", \"more content\", \"here\"]\n```\n\n## Regular Expressions Explanation\n- `\\(|\\)|\\n|\\s{2,}`: \n    - `\\(`: Matches the opening parenthesis.\n    - `\\)`: Matches the closing parenthesis.\n    - `\\n`: Matches newlines.\n    - `\\s{2,}`: Matches any sequence of two or more whitespace characters.\n- `[:|]`:\n    - `:`: Matches the colon character.\n    - `|`: Matches the vertical bar character.\n- `[\\[\\]\\{\\}]`:\n    - `\\[` and `\\]`: Matches the opening and closing square brackets.\n    - `\\{` and `\\}`: Matches the opening and closing curly braces.\n\nThese regular expressions are combined and used in the `replace` method to perform the necessary transformations on the string."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::firstConsecutiveDots",
    "label": "firstConsecutiveDots",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 38,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
    "summary": "# Documentation for `firstConsecutiveDots` Function\n\n## Description\nThe `firstConsecutiveDots` function takes a string input and returns the length of the first sequence of consecutive dots ('.') at the beginning of the string. If the string does not start with any dots, it returns 0.\n\n## Function Signature\n```typescript\nfunction firstConsecutiveDots(s: string): number\n```\n\n## Parameters\n- `s` (string): The input string to be evaluated.\n\n## Returns\n- (number): The length of the first sequence of consecutive dots at the beginning of the string. If no dots are found at the beginning, the function returns 0.\n\n## Nodes and Operations\n- **Regular Expression Matching (`s.match`)**: Utilized to find the sequence of consecutive dots starting from the beginning of the string.\n  - `^\\.{1,}`: The regular expression pattern used.\n    - `^`: Asserts the position at the start of a line.\n    - `\\.{1,}`: Matches one or more (up to any number) of literal dot characters.\n\n- **Conditional (Ternary) Operator**: Used to check if the match is null or not.\n  - `match ? match[0].length : 0`: If a match is found, it returns the length of the matched string (which consists of dots), otherwise, it returns 0.\n\n## Examples\n### Example 1\n```typescript\nconst result = firstConsecutiveDots('...hello');\n// result is 3\n```\n- Explanation: The string starts with three consecutive dots, so the function returns `3`.\n\n### Example 2\n```typescript\nconst result = firstConsecutiveDots('hello...');\n// result is 0\n```\n- Explanation: The string does not start with dots, so the function returns `0`.\n\n### Example 3\n```typescript\nconst result = firstConsecutiveDots('.a.b.c.');\n// result is 1\n```\n- Explanation: The string starts with a single dot, so the function returns `1`.\n\n### Example 4\n```typescript\nconst result = firstConsecutiveDots('.....');\n// result is 5\n```\n- Explanation: The string starts with five consecutive dots, so the function returns `5`.\n\n## Usage\nThis function is useful in scenarios where the prefix of dots in a string is significant. For instance, it can be applied in text formatting, parsing configurations, or analyzing structured data formats where leading dots denote hierarchical levels or special formatting."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::cleanDefCaptures",
    "label": "cleanDefCaptures",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 162,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
    "summary": "# Function Documentation: `cleanDefCaptures`\n\n## Purpose\nThe `cleanDefCaptures` function processes an array of `Parser.QueryCapture` objects, sorts them based on their position in the source code, and filters them according to a specified keyword. This function ensures that only the first appearance of the specified keyword (`name` by default) is retained while all other captures, which do not match the keyword, are also included in the result.\n\n## Parameters\n\n### captures\n- **Type:** `Parser.QueryCapture[]`\n- **Description:** An array of objects representing captures from a parsed query. Each capture object contains a node with its position (row and column) in the source code.\n\n### keyword\n- **Type:** `string` (optional)\n- **Default:** `\"name\"`\n- **Description:** The keyword used to filter the captures. Only the first capture with this keyword is retained in the result.\n\n## Returns\n- **Type:** `Parser.QueryCapture[]`\n- **Description:** An array of captures that have been sorted and filtered. Only the first capture with the specified keyword is included, along with all captures that do not match the keyword.\n\n## Function Behavior\n\n1. **Sorting:**\n   - The function first sorts the `captures` array based on the position of the nodes in the source code. Sorting is performed first by row and then by column.\n\n2. **Filtering:**\n   - After sorting, the function iterates over the sorted captures.\n   - The function tracks whether the specified keyword has been encountered using the `keywordSeen` flag.\n   - If a capture's name matches the keyword and it is the first occurrence, it is added to the `updatedCaptures` array, and the `keywordSeen` flag is set to `true`.\n   - If a subsequent capture matches the keyword and the `keywordSeen` flag is already set, the iteration breaks, ensuring only the first occurrence is kept.\n   - Captures that do not match the keyword are always added to the `updatedCaptures` array.\n\n3. **Return:**\n   - The function returns the `updatedCaptures` array, containing the sorted and filtered captures.\n\n## Example Usage\n\n```js\nconst captures = [\n  { node: { startPosition: { row: 2, column: 5 } }, name: \"name\" },\n  { node: { startPosition: { row: 1, column: 5 } }, name: \"type\" },\n  { node: { startPosition: { row: 2, column: 10 } }, name: \"name\" },\n  { node: { startPosition: { row: 3, column: 1 } }, name: \"value\" },\n];\n\nconst result = cleanDefCaptures(captures, \"name\");\nconsole.log(result);\n\n// Output:\n// [\n//   { node: { startPosition: { row: 1, column: 5 } }, name: \"type\" },\n//   { node: { startPosition: { row: 2, column: 5 } }, name: \"name\" },\n//   { node: { startPosition: { row: 3, column: 1 } }, name: \"value\" }\n// ]\n```\n\n## Dependencies\n\n- The function assumes the existence of a `Parser.QueryCapture` type. Each capture is expected to have the following structure:\n  ```ts\n  interface QueryCapture {\n    node: {\n      startPosition: {\n        row: number;\n        column: number;\n      };\n    };\n    name: string;\n  }\n  ```\n"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::getRequiredDefinitions",
    "label": "getRequiredDefinitions",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 213,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
    "summary": "# Function Documentation: `getRequiredDefinitions`\n\n## Description\nThe `getRequiredDefinitions` function initializes a parser for a specified programming language and retrieves corresponding query configurations for that language. It supports multiple languages by setting the parser to the appropriate language and fetching the relevant queries.\n\n## Function Signature\n```typescript\nfunction getRequiredDefinitions(language: string): { parser: Parser; queries: treeSitterQueries }\n```\n\n## Parameters\n- `language` (`string`): The programming language for which the parser and queries need to be initialized. Supported languages include:\n  - `javascript`\n  - `python`\n  - `typescript`\n  - `tsx`\n  - `java`\n  - `c`\n\n## Returns\n- An object with the following properties:\n  - `parser` (`Parser`): An instance of the `Parser` class configured for the specified language.\n  - `queries` (`treeSitterQueries`): Language-specific query configurations.\n\n## Exceptions\n- Throws an `Error` if the specified `language` is not supported. The error message will be: `Language {language} not supported.`\n\n## Example Usage\n```javascript\nconst { parser, queries } = getRequiredDefinitions('javascript');\n```\n\n## Supported Languages and Corresponding Configurations\n- `javascript`\n  - Parser: `languages.JavaScript`\n  - Queries: `languageQueries.Javascript`\n- `python`\n  - Parser: `languages.Python`\n  - Queries: `languageQueries.Python`\n- `typescript`\n  - Parser: `languages.TypeScript`\n  - Queries: `languageQueries.Typescript`\n- `tsx`\n  - Parser: `languages.TSX`\n  - Queries: `languageQueries.Typescript`\n- `java`\n  - Parser: `languages.Java`\n  - Queries: `languageQueries.Java`\n- `c`\n  - Parser: `languages.C`\n  - Queries: `languageQueries.C`\n\n## Notes\n- The function uses the following nodes or modules:\n  - `Parser` class to initialize the parser.\n  - `languages` object to access language-specific parser configurations.\n  - `languageQueries` object to access language-specific query configurations.\n  \nEnsure these dependencies (`Parser`, `languages`, `languageQueries`) are properly imported and available in your environment before using the function.\n\n## Code\n```typescript\nfunction getRequiredDefinitions(language: string): { parser: Parser; queries: treeSitterQueries } {\n  const parser = new Parser();\n  let queries;\n  switch (language) {\n    case \"javascript\":\n      parser.setLanguage(languages.JavaScript);\n      queries = languageQueries.Javascript;\n      break;\n    case \"python\":\n      parser.setLanguage(languages.Python);\n      queries = languageQueries.Python;\n      break;\n    case \"typescript\":\n      parser.setLanguage(languages.TypeScript);\n      queries = languageQueries.Typescript;\n      break;\n    case \"tsx\":\n      parser.setLanguage(languages.TSX);\n      queries = languageQueries.Typescript;\n      break;\n    case \"java\":\n      parser.setLanguage(languages.Java);\n      queries = languageQueries.Java;\n      break;\n    case \"c\":\n      parser.setLanguage(languages.C);\n      queries = languageQueries.C;\n      break;\n\n    default:\n      throw new Error(`Language ${language} not supported.`);\n  }\n  return { parser, queries };\n}\n```"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils::getAllFiles",
    "label": "getAllFiles",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/model/utils",
    "totalTokens": 265,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  console.log(\"ExcludedFolderPattern: \", excludedFolderPattern);\r\n  let files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  files = files.map((file) => file.replace(/\\\\/g, \"/\"));\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}",
    "summary": "# `getAllFiles`\n\nThe `getAllFiles` function asynchronously retrieves a list of all valid files from a specified root folder path. It applies a set of inclusion and exclusion criteria to filter files based on their extensions and folder paths.\n\n## Parameters\n\n- **rootFolderPath** (`string`): The absolute or relative path of the root folder from which to start searching for files.\n\n## Returns\n\n- **Promise<string[]>**: A promise that resolves to an array of matching file paths as strings.\n\n## Description\n\n1. **Extension Patterns**: \n   - Constructs a regex pattern `extensionsPattern` from the keys of the `languageExtensionMap` dictionary to match specific file extensions.\n\n2. **Excluded Extensions**:\n   - Creates a regex pattern `excludedExtensionPattern` from the `excludedExtensions` array to filter out files with certain extensions.\n\n3. **Excluded Folders**:\n   - Builds a regex pattern `excludedFolderPattern` from the `excludedFolders` array to exclude certain directories.\n\n4. **File Collection**:\n   - Uses the `glob` function to retrieve all files (`**/*`) under the `rootFolderPath`. The `cwd` option sets the root folder, and `absolute` option returns absolute paths for the files.\n\n5. **Formatting Paths**:\n   - Normalizes file paths by replacing backslashes (`\\`) with forward slashes (`/`).\n\n6. **File Validity**:\n   - Determines whether each item is an actual file using `fs.lstat`.\n\n7. **Filtering**:\n   - Filters files that match the inclusion criteria (`extensionsPattern`) and do not match the exclusion criteria (`excludedExtensionPattern`, `excludedFolderPattern`, or containing `@`).\n\n8. **Sorting**:\n   - Sorts the list of matching files alphabetically.\n\n9. **Return**:\n   - Returns a promise that resolves to the sorted list of matching files.\n\n## Dependencies\n\nThe function relies on several modules and variables:\n\n1. **Modules**:\n   - `glob`: Used to search for files matching a pattern.\n   - `fs.promises` (aliased as `fs`): Provides file system operations, particularly `lstat`.\n\n2. **Variables**:\n   - `languageExtensionMap`: A dictionary mapping language names to their respective file extensions.\n   - `excludedExtensions`: An array containing file extensions to exclude.\n   - `excludedFolders`: An array containing folder names to exclude.\n\n## Example Usage\n\n```javascript\n// Example usage of getAllFiles function\n(async () => {\n  const rootFolderPath = '/path/to/root/folder';\n  const files = await getAllFiles(rootFolderPath);\n  console.log(files);\n})();\n```\n\nThis function uses glob patterns and multiple regex filters to efficiently find and return all files in a directory that match specific inclusion and exclusion rules."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::anyAssignments",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "summary": "## Documentation for `anyAssignments`\n\n### Overview\n`anyAssignments` is a pattern matcher for recognizing assignments in a specific abstract syntax tree (AST) structure. This matcher is used for identifying and capturing details about assignment statements, such as variable declarations and initializations, involving identifiers. \n\n### Structure\nThe structure of an assignment is captured in the following manner:\n\n### Pattern:\n```\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @left\n                (pointer_declarator declarator: (identifier) @left)\n                ]\n            value: (_) @right\n        ) \n) @assignment\n```\n\n### Explanation of Nodes\n\n#### `@assignment`\n- **Type:** Capture group\n- **Description:** Captures the entire assignment declaration. It encompasses the entire structure of the declaration.\n\n#### `init_declarator`\n- **Type:** Node\n- **Description:** Represents a single variable declaration and its optional initialization.\n\n#### `declarator`\n- **Type:** Node\n- **Description:** Contains the core structure of the variable being declared and optionally initialized.\n  - It can contain either:\n    - An `(identifier) @left` node, representing a direct variable name, or \n    - A `(pointer_declarator declarator: (identifier) @left)` node, representing a pointer declaration and variable name.\n\n#### `@left`\n- **Type:** Capture group\n- **Description:** Captures the name of the variable being declared.\n  - Either an `identifier` (e.g., `int x`) or \n  - A `pointer_declarator declarator` structure (e.g., `int *x`).\n\n#### `@right`\n- **Type:** Capture group\n- **Description:** Captures the value being assigned to the variable (if any). This can be any expression or literal (denoted by `_`).\n\n### Nodes Explained:\n1. **declaration**:\n   - Represents the entire declaration of a variable.\n   \n2. **declarator**:\n   - This can include initialization.\n   \n3. **init_declarator**:\n   - Represents the part of the declarator which can initialize a variable.\n\n4. **declarator** inside `init_declarator`:\n   - This specifies the variable itself and whether it is a pointer.\n\n5. **identifier**:\n   - Represents the actual name of the variable in both direct declarations and within pointer declarations.\n   \n6. **pointer_declarator**:\n   - Represents the declaration of a pointer variable.\n\n### Capture Groups:\n- `@assignment`: The full scope of the declaration.\n- `@left`: The name of the variable being declared.\n- `@right`: The value assigned to the variable (if any).\n\n### Usage\nThis pattern is useful for code analysis tools, refactoring tools, or any scenario where understanding or transforming code requires recognizing and working with assignments in variable declarations. \n\nBy matching against this pattern, you can extract the variable names and their assigned values, making it easier to analyze the behavior and structure of the code.\n\n### Example Match\nGiven a source code snippet:\n```c\nint x = 42;\nint *y = &x;\n```\n\nUsing the `anyAssignments` pattern, the matches would include:\n- `@assignment` capturing the entire lines `int x = 42;` and `int *y = &x;`.\n- `@left` capturing `x` and `*y`.\n- `@right` capturing `42` and `&x`."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::calls",
    "label": "calls",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "summary": "Here is the documentation for the `calls` assignment:\n\n---\n\n### Documentation: `calls` Assignment\n\n#### Overview\nThe `calls` assignment is used to capture specific patterns within a codebase that pertain to function calls. This pattern-matching technique is helpful for code analysis, debugging, or refactoring tasks where identifying and understanding function invocations are critical.\n\n#### Syntax Highlighting Patterns\n\n```plaintext\ncalls = `\n(call_expression function: _ @identifier.name)\n( _ arguments: (argument_list (identifier) @identifier.name) )\n`\n```\n\n#### Details of the Nodes Used\n\n1. **`call_expression`**: \n   - **Description**: Represents a function call expression in the code.\n   - **Nodes**:\n     - **`function`**: This is part of the `call_expression`, representing the function being called.\n     - **`_`**: A wildcard that matches any node, which in this context, is the function itself.\n     - **`@identifier.name`**: This captures and assigns a tag to the identifier that names the function being called, allowing for easy reference later.\n\n2. **`argument_list`**:\n   - **Description**: Represents the list of arguments passed to the function within the call expression.\n   - **Nodes**:\n     - **`_`**: Another wildcard that matches any node, which here is used to introduce the arguments.\n     - **`arguments`**: Part of the `_`, representing the functions actual parameters.\n     - **`argument_list`**: Contains the specific list structure of the arguments.\n     - **`(identifier) @identifier.name`**: Captures individual identifiers within the argument list and tags them with `@identifier.name`.\n\n#### Usage Example\nBelow is an example of how these patterns might be applied in practice:\n\n```plaintext\n// Example code in a hypothetical language\nfoo(bar, baz);\n\n// Pattern Application\n(call_expression function: foo)  // Matches the function being called\n(foo arguments: (argument_list (identifier) bar)\n                             (identifier) baz)\n```\n\nIn this example:\n- `foo` is tagged as `@identifier.name` within the `call_expression`.\n- Both `bar` and `baz` are captured as part of the `argument_list` and individually tagged with `@identifier.name`.\n\n#### Purpose\nThe `calls` assignment is primarily used for:\n- **Code Analysis**: To identify all instances of function calls within a codebase.\n- **Refactoring**: To systematically rename or modify function calls.\n- **Debugging**: To track and log function invocations along with their arguments.\n\n---\n\nRemember to adapt the node patterns and this documentation to fit the specifics and syntax of the language being worked with, as node names and hierarchical structures can vary widely between different programming languages."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::extraAssignmentCode",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
    "summary": "## Documentation for `extraAssignmentCode`\n\n### Function Definition\n\n```javascript\nconst extraAssignmentCode = (name: string) => `\n( translation_unit\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (field_expression (identifier)  @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n    )\n)\n`;\n```\n\n### Description\n\nThe `extraAssignmentCode` function generates a query string that is intended to match and extract specific parts of an abstract syntax tree (AST) for code analysis purposes. It uses a templated string to incorporate a given identifier name into the query.\n\n### Parameters\n\n- `name` (string): The identifier name to match in the AST. This should be a valid variable, function, or property name in the code being analyzed.\n\n### Returns\n\n- (string): A query string formatted to match and extract parts of an AST where the specified identifier is used in a call expression within an expression statement.\n\n### Node Explanation\n\nThis function makes use of the following tree-sitter nodes:\n\n1. **translation_unit**: This is typically the root node of the tree-sitter parse tree representing the entire source code input.\n   \n2. **expression_statement**: Represents a statement that consists of a single expression, such as a function call or variable assignment.\n\n3. **call_expression**: Represents a function call in the source code.\n\n4. **function**: Within the context of the `call_expression`, this describes the function being called. This may be either a direct identifier or a field expression.\n\n5. **identifier**: Represents an identifier in the source code, such as a variable or function name.\n\n6. **field_expression**: Used to represent the access of a property from an object, such as `object.property`.\n\n7. **@identifier.name**: A named capture group for the identifier node. This is used to capture and reference the identifier.\n\n8. **@code**: Another named capture group, used to capture the entire call expression.\n\n### Query Structure\n\nThe generated query string is structured to perform the following:\n\n1. **translation_unit**: Identify the root of the parsed code tree.\n2. **expression_statement**: Look for statements in the code.\n3. **call_expression**: Within expression statements, look for function calls.\n4. **function**: Check if the function being called is either a directly named identifier or a field expression.\n5. **#eq? @identifier.name \"${name}\"**: Ensure that the identifier matches the provided name.\n6. **@code**: Capture the relevant code segment.\n\n### Example Usage\n\nIf we call the function with `name = \"myFunction\"`, it will generate the following query string:\n\n```javascript\nconst query = extraAssignmentCode(\"myFunction\");\nconsole.log(query);\n/*\nOutputs:\n( translation_unit\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (field_expression (identifier)  @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"myFunction\")\n        ) @code\n    )\n)\n*/\n```\n\n### Application\n\nThis function can be used in code analysis and transformation tools to locate specific function calls in a codebase, facilitating tasks such as refactoring, code navigation, or comprehension summaries."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::exportClauses",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "summary": "# Assignment Documentation for `exportClauses`\n\n## Overview\nThe `exportClauses` assignment initializes an empty template string. This assignment can be used as a placeholder or starting point for generating export clauses in code (typically in JavaScript or TypeScript).\n\n## Syntax\n```python\nexportClauses = ``\n```\n\n## Description\nThe variable `exportClauses` is assigned an empty template string, signifying that no export clauses are defined initially. This could be useful when planning to programmatically generate and insert specific export statements into this string at a later stage in the code.\n\n## Node Usage\nThis assignment might be utilized in conjunction with the following types of nodes:\n- **Literal String Node**: Represents the empty string assigned to `exportClauses`.\n- **Variable Declarator Node**: Represents the declaration and assignment of the `exportClauses` variable.\n- **Template Literal Node**: Although it's initially empty, `exportClauses` is intended to hold a template literal that can be dynamically populated.\n- **Expression Node**: Represents any expression that might be used to modify or build the `exportClauses` content later.\n\n## Potential Use Cases\n1. **Code Generation:** Dynamically build and insert module export statements in a code generation script.\n2. **Configuration Files:** Serve as a configuration holder that may be populated with module exports information.\n3. **Conditional Exports:** Used within a larger script where export statements need to be conditionally added based on various factors.\n\n## Example\nWhile the `exportClauses` variable is initially empty, it can be populated as follows:\n```python\nexportClauses = f'''\nexport const myVar = {myVarValue};\n\nexport function myFunction() {{\n    // Implementation here\n}}\n'''\n```\n\nIn this example, the `exportClauses` variable gets populated with export statements for a constant and a function, dynamically including the `myVarValue`.\n\n"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::constructorDefinitions",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 38,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`",
    "summary": "# Documentation for constructorDefinitions\n\n### Overview\nThe `constructorDefinitions` variable is designed to capture and annotate specific patterns in code using a language parsing tool like Tree-sitter. This documentation provides details on the patterns `constructorDefinitions` is designed to recognize, along with the nodes it utilizes. \n\n### Assignment\n```python\nconstructorDefinitions = `\n(function_definition) @function\n(declaration (function_declarator)) @function\n(struct_specifier) @struct\n(union_specifier) @union\n`\n```\n\n### Nodes Used\n\n#### 1. **(function_definition) @function**\n- **Description**: This node pattern captures the definition of functions. \n- **Example**: \n    ```c\n    int add(int a, int b) {\n        return a + b;\n    }\n    ```\n\n#### 2. **(declaration (function_declarator)) @function**\n- **Description**: This node captures function declarations within a larger declaration. It essentially focuses on declared but not yet defined functions.\n- **Example**: \n    ```c\n    int add(int a, int b);\n    ```\n\n#### 3. **(struct_specifier) @struct**\n- **Description**: This node pattern targets the specification of C-style structs.\n- **Example**: \n    ```c\n    struct Person {\n        char *name;\n        int age;\n    };\n    ```\n\n#### 4. **(union_specifier) @union**\n- **Description**: This node is used to capture union specifications.\n- **Example**: \n    ```c\n    union Data {\n        int i;\n        float f;\n        char str[20];\n    };\n    ```\n\n### Usage \nThe `constructorDefinitions` assignment can be used in a variety of contexts where parsing and recognizing these constructs in source code is required, such as:\n\n- **Syntax Highlighting**: Differentiating between function definitions, declarations, structures, and unions for proper coloring in code editors.\n- **Code Analysis**: Automated tools that analyze codebases for architecture, design, and potential issues.\n- **Code Transformation**: Refactoring tools that need to understand and manipulate these specific code constructs.\n- **Documentation Generation**: Automatically generating documentation by identifying and detailing elements within code.\n\n### Additional Information\n- **Language Specificity**: The examples provided indicate that these patterns are particularly relevant for C and C-like languages.\n- **Tree-sitter Context**: This assignment is especially useful when working with parsing trees generated by Tree-sitter, a popular incremental parsing system aimed at increasing IDE features like syntax highlighting, code folding, and semantic analysis.\n\nBy leveraging `constructorDefinitions`, tools working with parsed code can effectively recognize and differentiate between key elements such as function definitions and declarations, as well as structure and union specifications. This capability is fundamental for advanced IDE features and automated analysis tools."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::definitionTemplate",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "summary": "# Documentation for `definitionTemplate` Assignment\n\n\nThe `definitionTemplate` assignment defines a template for parsing function definitions and global variable assignments from a source code using a tree-sitter-based syntax tree. Below is a breakdown that includes the structure and nodes used in the template.\n\n## Template Definition:\n```python\ndefinitionTemplate = `\n( _\n    type: (_)? @return_type\n    [\n     name: (_) @name\n     declarator: (function_declarator declarator: (identifier) @name) \n    ]\n    parameters: (parameter_list (_) @param)?\n    body: (_)? @body\n)?\n\n; For global assignments\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @name\n                (pointer_declarator declarator: (identifier) @name)\n                ]\n            value: (_) @body\n        ) \n) \n`\n```\n\n## Node Definitions:\nBelow are the explanations for each node employed in the template:\n\n### Function Definitions:\n- **Root Level**\n  - `( _)` - Matches an optional root level node (generic match).\n- **Return Type**\n  - `type: (_)? @return_type` - Matches an optional type node and captures it as `@return_type`.\n- **Name and Declarator**\n  - `name: (_) @name` - Matches a name node and captures it as `@name`.\n  - `declarator: (function_declarator declarator: (identifier) @name)` - Specific declarator for functions, capturing the function's identifier as `@name`.\n- **Parameters**\n  - `parameters: (parameter_list (_) @param)?` - Matches an optional parameter list and captures it as `@param`.\n- **Body**\n  - `body: (_)? @body` - Matches an optional body node and captures it as `@body`.\n\n### Global Assignments:\n- **Declaration Block**\n  - `declaration` - Matches a global declaration.\n- **Initializer Declarator**\n  - `declarator: (init_declarator ... )` - Defines and matches an initializer declarator block within the declaration.\n    - **Declarator Name (Identifier or Pointer Declarator)**\n      - `declarator: [(identifier) @name ... ]` - Matches and captures a direct identifier as `@name`.\n      - `declarator: [(pointer_declarator declarator: (identifier) @name) ... ]` - Matches a pointer declarator providing an identifier and captures it as `@name`.\n    - **Value**\n      - `value: (_) @body` - Matches the value assigned to the declarator and captures it as `@body`.\n\n## Summary:\nThe `definitionTemplate` consists of rules to extract:\n1. **Function Definitions**, capturing:\n   - Return type\n   - Function name\n   - Parameter list (if present)\n   - Function body\n2. **Global Assignments**, capturing:\n   - Variable name (including pointer variations)\n   - Assigned value\n\nThe template serves to facilitate the extraction of relevant components from source code, aiding in tasks such as code analysis, documentation generation, and syntax tree manipulations."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::assignments",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 46,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "summary": "# Assignment Documentation: `assignments`\n\n## Overview:\nThe `assignments` variable contains a Tree-sitter query pattern that searches for assignment statements within a code's abstract syntax tree (AST). This pattern is structured to identify declarations with initializers. Specifically, it matches nodes within a `translation_unit` that adhere to a particular structure defined by the pattern.\n\n```python\nassignments = `\n(translation_unit\n\t(declaration\n    \tdeclarator: (init_declarator\n        \t\tdeclarator: (_)\n                value: (_)\n        \t) \n    ) @assignment\n)\n`\n```\n\n## Node Pattern Explanation:\n\n### Structure:\nThe pattern consists of the following components:\n\n1. **translation_unit**:\n   - This is the root node representing the entire source file or translation unit.\n\n2. **declaration**:\n   - This node represents a declaration statement, which could be the declaration of a variable or constant.\n\n3. **init_declarator**:\n   - A child node under `declaration` that represents an initializer declarator, which is an assignment part of the declaration.\n\n4. **declarator**:\n   - A sub-node within `init_declarator` that indicates where the declared entity (variable name, etc.) is specified. It is represented as `_` (indicating any declarator).\n\n5. **value**:\n   - Another sub-node within `init_declarator` that represents the assigned value or expression for the declaration. It is also represented as `_` (indicating any value or expression).\n\n### Captures:\n- **@assignment**:\n  - This named capture (`@assignment`) is used to tag the matched declaration nodes, making it easier to search, highlight, or manipulate assignment statements in the code.\n\n## Purpose:\nThe pattern is useful for:\n- Code analysis to find and manipulate assignment statements.\n- Static code analysis tools for linting or refactoring.\n- Extracting or transforming specific code structures related to assignments.\n\n## Example:\nGiven the following code snippet:\n```c\nint x = 5;\nfloat y = 3.14;\nchar z = 'a';\n```\nThe `assignments` pattern would match:\n- The declaration `int x = 5;`\n- The declaration `float y = 3.14;`\n- The declaration `char z = 'a';`\n\nEach of these matches would be captured with the `@assignment` tag for further processing or analysis.\n\n## Conclusion:\nThe `assignments` pattern provides a means to programmatically access and manipulate assignment statements within a given source code, facilitating various static analysis and transformation tasks. By utilizing Tree-sitter queries, it allows precise and efficient pattern matching within the code's AST."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c::importStatements",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/c",
    "totalTokens": 41,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`",
    "summary": "# Assignment Documentation: `importStatements`\n\n## Overview\nThe `importStatements` is an assignment that defines a pattern for recognizing and capturing import statements in a source code using a Tree-sitter query language syntax. This pattern is specifically designed to match C/C++ preprocessor include directives.\n\n## Tree-sitter Query Syntax\nTree-sitter is a parser generator tool and an incremental parsing library. In the context of this assignment, Tree-sitter query language is employed to locate specific syntactic elements within a source code.\n\n## Definition\n```python\nimportStatements = \"\"\"\n( preproc_include path: (system_lib_string) @module) @import_statement\n( preproc_include path: (string_literal (_) @module)) @import_statement\n\"\"\"\n```\n\n## Nodes Used\n1. **`preproc_include`**: This node represents a preprocessor `#include` directive.\n   - **`system_lib_string`**: This node represents a system library string (e.g., `<stdio.h>`).\n   - **`string_literal`**: This node represents a user-defined or generic string literal (e.g., `\"myheader.h\"`).\n\n2. **Syntactical Constructs**:\n   - **Parenthetical Grouping**: `()` are used to group query elements.\n   - **Node Fields**: `path:` indicates the field of the parent node (`preproc_include`) that contains the specified child node (`system_lib_string` or `string_literal`).\n   - **Captures**: `@module` and `@import_statement` are capture names used to tag the matches for later reference.\n\n\n## Detailed Explanation\n\n1. **System Library String Import**:\n    ```python\n    ( preproc_include path: (system_lib_string) @module) @import_statement\n    ```\n    This query pattern matches an import statement using system library strings, typically found in angle brackets (`<stdio.h>`). \n\n    - `preproc_include`: Matches `#include` directives.\n    - `path`: Specifies that we are interested in the `path` field of the `preproc_include` node.\n    - `system_lib_string`: Matches system library strings in the include directive.\n    - `@module`: Captures the system library string matched.\n    - `@import_statement`: Captures the whole `preproc_include` statement matched.\n\n2. **User-defined String Literal Import**:\n    ```python\n    ( preproc_include path: (string_literal (_) @module)) @import_statement\n    ```\n    This query pattern matches an import statement using user-defined string literals, typically found in double quotes (`\"myheader.h\"`).\n\n    - `preproc_include`: Matches `#include` directives.\n    - `path`: Specifies that we are interested in the `path` field of the `preproc_include` node.\n    - `string_literal`: Matches generic string literals in the include directive.\n    - `(_) @module`: Captures the whole string literal within the `string_literal` node.\n    - `@import_statement`: Captures the whole `preproc_include` statement matched.\n\n## Usage\nThis pattern is particularly useful for tools that perform static analysis, build process automation, code indexing, or refactoring tasks on C/C++ codebases. By employing this pattern, developers can efficiently locate and process import statements in the code.\n\n### Example Matching\n\nGiven the following C/C++ code:\n```c\n#include <stdio.h>\n#include \"myheader.h\"\n```\n\nThe `importStatements` pattern will match:\n- The system library import statement, capturing `<stdio.h>`.\n- The user-defined header import statement, capturing `\"myheader.h\"`.\n\nThis allows for further actions such as dependency analysis, automated documentation, or code navigation enhancements.\n\n## Conclusion\nThe `importStatements` assignment leverages Tree-sitter query language to identify and capture C/C++ import statements efficiently. This can greatly assist in code analysis and manipulation tasks requiring detailed knowledge of the code's dependencies."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/index::languageQueries",
    "label": "languageQueries",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/index",
    "totalTokens": 36,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries\r\n}",
    "summary": "# Documentation for `languageQueries` Assignment\n\nThe `languageQueries` assignment is a dictionary that maps various programming languages to their respective query objects. Each query object contains specific queries or settings related to the given programming language.\n\n## Structure\n\n```python\nlanguageQueries = {\n    \"Javascript\": jsQueries,\n    \"Typescript\": tsQueries,\n    \"Python\": pyQueries,\n    \"Java\": javaQueries,\n    \"C\": cQueries\n}\n```\n\n### Nodes Used\n\nThe assignment utilizes the following nodes (variables). Each node corresponds to a set of queries defined for a particular programming language:\n\n- **Javascript**: Represented by `jsQueries`\n- **Typescript**: Represented by `tsQueries`\n- **Python**: Represented by `pyQueries`\n- **Java**: Represented by `javaQueries`\n- **C**: Represented by `cQueries`\n\n## Description of Nodes\n\n### `jsQueries`\nThis node contains queries related to the JavaScript programming language. Expected to hold patterns, rules, or settings to interact with JavaScript code.\n\n### `tsQueries`\nSimilar to `jsQueries`, but tailored for TypeScript. This includes queries that respect TypeScript's type system and additional syntax.\n\n### `pyQueries`\nThis node contains queries for Python, providing rules and settings specific to Python's syntax and semantics.\n\n### `javaQueries`\nThis node is for Java-specific queries, accommodating Java's object-oriented structure and syntax.\n\n### `cQueries`\nThis node holds queries for the C programming language, tailored to its procedural syntax and structure.\n\n## Example Usage\n\nAssuming the queries for each language are predefined elsewhere in the code:\n\n```python\njsQueries = {...}  # JavaScript specific queries\ntsQueries = {...}  # TypeScript specific queries\npyQueries = {...}  # Python specific queries\njavaQueries = {...}  # Java specific queries\ncQueries = {...}  # C specific queries\n\nlanguageQueries = {\n    \"Javascript\": jsQueries,\n    \"Typescript\": tsQueries,\n    \"Python\": pyQueries,\n    \"Java\": javaQueries,\n    \"C\": cQueries\n}\n```\n\nHere, `languageQueries` acts as a centralized object that can be used to access language-specific queries dynamically. For example:\n\n```python\nlanguage = \"Python\"\nqueries = languageQueries.get(language)\n# Now `queries` contains the Python specific queries defined in `pyQueries`\n```\n\n## Remarks\n\n- Each of the `jsQueries`, `tsQueries`, `pyQueries`, `javaQueries`, and `cQueries` should be predefined dictionaries or objects that contain the relevant queries.\n- The exact structure and contents of these query nodes (`jsQueries`, `tsQueries`, etc.) are not detailed here but are expected to be consistent in structure and purpose.\n\nThis documentation serves as a guide to understanding the purpose, structure, and usage of the `languageQueries` assignment."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::anyAssignments",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 50,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "summary": "# anyAssignments Documentation\n\nThe `anyAssignments` assignment captures variable declarations where a variable (identified by a name) is assigned a value. This assignment uses a specific pattern to identify such declarations using the given syntax tree nodes. The pattern supports different types of assigned values, specifically identifiers and object creation expressions.\n\n## Pattern Definition\n\n```python\nanyAssignments = `\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (object_creation_expression type: _ @right) \n    ] \n) @assignment\n`\n```\n\n## Nodes Used\n\nThe pattern in `anyAssignments` uses the following syntax tree nodes:\n\n1. **`variable_declarator`**\n   - Represents the declaration of a variable.\n   \n2. **`name`**\n   - The name of the variable being declared. This is matched by the `(identifier) @left` query, allowing the variable name to be captured.\n   \n3. **`value`**\n   - The value assigned to the variable. This can be either:\n     - **`identifier`**\n       - An identifier representing the value to be assigned. Captured by `(identifier) @right`.\n     - **`object_creation_expression`**\n       - Represents the creation of a new object. The type of the object is captured using `_` and the whole expression is captured by `@right`.\n       \n4. **`assignment`**\n   - The entire assignment is captured by `@assignment`.\n\n## Explanation of the Pattern\n\n- `(variable_declarator name: (identifier) @left value: [ ... ] ) @assignment`\n  - This captures a variable declarator node where:\n    - The `name` of the variable is an `identifier` captured as `@left`.\n    - The `value` of the variable can be either:\n      - Another `identifier`, captured as `@right`.\n      - An `object_creation_expression` with `type: _`, also captured as `@right`.\n  - The entire declaration is captured as `@assignment`.\n\n## Example\n\nConsider the following code snippet:\n\n```java\nint a = 10;\nMyClass obj = new MyClass();\n```\n\nUsing `anyAssignments`, the pattern would capture:\n- `int a = 10;`\n  - `name` captured as `a` (`@left`).\n  - `value` captured as `10` (`@right`).\n\n- `MyClass obj = new MyClass();`\n  - `name` captured as `obj` (`@left`).\n  - `value` captured as `new MyClass()` (`@right`).\n\nBy using this assignment, you can effectively parse and analyze variable declarations and their assigned values within a specified syntax tree structure."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::calls",
    "label": "calls",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "summary": "# Documentation for `calls` Assignment\n\n## Description\n\nThe `calls` assignment is a Pattern Matching assignment typically used in a parsing or abstract syntax tree (AST) context to identify specific patterns in the code. This type of assignment is often utilized in static code analysis, linting, or code transformation tools.\n\n## Pattern Definition\n\nThe `calls` assignment is defined as follows:\n\n```python\ncalls = `\n    (method_invocation) @identifier.name\n    (type_identifier) @parameter_type\n    (_ object: _ @identifier.name)\n`\n```\n\n## Nodes and Captures\n\nThis pattern consists of three distinct parts, each corresponding to a specific node type in the AST:\n\n1. **Method Invocation Node** `(method_invocation) @identifier.name`\n    - **Description**: This part of the pattern captures method invocation expressions.\n    - **Capture**: `@identifier.name` captures the name of the method being invoked.\n\n2. **Type Identifier Node** `(type_identifier) @parameter_type`\n    - **Description**: This part of the pattern captures type identifier expressions.\n    - **Capture**: `@parameter_type` captures the type identifier of parameters or other relevant elements.\n\n3. **Object with Method Invocation Node** `(_ object: _ @identifier.name)`\n    - **Description**: This part of the pattern captures scenarios where an object is followed by a method invocation.\n    - **Capture**: `@identifier.name` reuses the capture for the name of the method being invoked, associating it with the object.\n\n## Usage\n\nThis pattern can be used in various scenarios, such as:\n\n- **Static Code Analysis**: To find and list all method invocations and their associated types within a codebase.\n- **Code Transformation**: To identify and potentially refactor method invocations and their related type usages.\n- **Linting**: To enforce coding standards by ensuring that method invocations and their types conform to expected patterns.\n\n## Examples\n\n### Example Pattern Matches\n\n- **Method Invocation**:\n  ```java\n  someObject.someMethod();\n  ```\n  - Captured as: `someMethod`\n\n- **Type Identifier**:\n  ```java\n  int someVariable;\n  ```\n  - Captured as: `int`\n\n- **Object with Method Invocation**:\n  ```java\n  someObject.someMethod();\n  ```\n  - Captured as: `someMethod` for the identifier name associated with `someObject`.\n\n### Application\nIn a code analysis tool, this pattern might be used as follows:\n- **Finding Method Calls**:\n  ```python\n  method_calls = find_matches(calls, source_code)\n  for match in method_calls:\n      print(f\"Method: {match['identifier.name']}, Type: {match['parameter_type']}\")\n  ```\n\n## Conclusion\n\nThe `calls` assignment is a powerful tool for identifying specific method and type usage patterns within a codebase. By capturing method invocation names and parameter types, it provides valuable information that can be used for various code analysis and transformation applications.\n\nBy understanding and leveraging this pattern, developers can gain deeper insights into their code, enforce standards, and perform targeted refactoring with greater ease and accuracy."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::extraAssignmentCode",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => ``",
    "summary": "# Documentation for extraAssignmentCode Function\n\n## Function Signature\n```javascript\nconst extraAssignmentCode = (name: string) => ``\n```\n\n## Description\nThe `extraAssignmentCode` function is a JavaScript function that takes a single argument, `name`, which is a string. The function is expected to return a string (as indicated by the template literal ``), although the current implementation suggests it returns an empty string.\n\n## Parameters\n- **name** (`string`): This is the input parameter of the function, expected to be a string. The purpose of this parameter within the function is to presumably generate some sort of code or additional assignment text based on the provided name. However, the current implementation does not utilize it and directly returns an empty string.\n\n## Return Value\n- The function returns a string. Given the current implementation, it returns an empty string.\n\n```javascript\n// Example usage:\nconst result = extraAssignmentCode(\"exampleName\");\n// result is \"\"\n```\n\n## Nodes Utilized\nThe function relies on the following JavaScript constructs:\n- **Template Literals**: Used to return a formatted string using backticks (``).\n\n## Potential Implementations and Usage\nWhile the current implementation is minimal, here are some hypothetical implementations that provide meaningful output:\n\n### Example 1: Generating Code Snippet\n```javascript\nconst extraAssignmentCode = (name: string) => `\n    // Extra assignment code for ${name}\n    console.log('Processing tasks for ${name}');\n`;\n```\n- This implementation uses the `name` parameter to generate a simple console log statement within a code snippet:\n```javascript\nconst result = extraAssignmentCode(\"exampleName\");\n// result is:\n// \"\n// // Extra assignment code for exampleName\n// console.log('Processing tasks for exampleName');\n// \"\n```\n\n### Example 2: Personalized Message\n```javascript\nconst extraAssignmentCode = (name: string) => `\n    Hello, ${name}! Here is your extra assignment code.\n`;\n```\n- This implementation uses the `name` parameter to create a personalized greeting message:\n```javascript\nconst result = extraAssignmentCode(\"Jane\");\n// result is:\n// \"\n// Hello, Jane! Here is your extra assignment code.\n// \"\n```\n\nBy utilizing the `name` parameter, the function can generate dynamic and useful strings based on the context it is called.\n\n---\n\n**Note**: The actual utility of the `extraAssignmentCode` function heavily depends on the specific requirements and context within which it is used. The current implementation does not demonstrate any substantial functionality but can be extended as shown in the examples above to serve various purposes in code generation or text formatting."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::exportClauses",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "summary": "# Documentation: `exportClauses` Assignment\n\n## Overview\n\nThe `exportClauses` assignment is used to define a set of clauses to be exported. It can be utilized in various contexts to specify what elements, components, or data portions need to be made available for external usage.\n\n## Syntax\n\n```python\nexportClauses = ``\n```\n\nCurrently, the `exportClauses` assignment is initialized as an empty string. This serves as a placeholder for future content that will specify the export clauses.\n\n## Nodes Utilized in `exportClauses`\n\nThis assignment interacts with the following nodes:\n\n1. **Clause Nodes**: These are the fundamental units representing each clause that can be exported. Each clause node will contain the specific details about what is being exported.\n   \n2. **Condition Nodes**: These nodes include any conditions or criteria that might be associated with the clauses. They are used to control the context or scope in which a clause is applicable.\n   \n3. **Dependency Nodes**: These capture any dependencies between different clauses. They ensure that clauses are exported in the correct order, respecting the dependency constraints.\n\n4. **Metadata Nodes**: These nodes store additional information about each clause, such as descriptions, annotations, or any other metadata that might be useful for understanding the purpose and usage of the clause.\n\n5. **Export Control Nodes**: These nodes handle the rules and policies governing what is allowed to be exported. They ensure compliance with any regulatory or security constraints.\n\n## Intended Usage\n\nWhen filled out, `exportClauses` will typically look something like:\n\n```python\nexportClauses = \"\"\"\n{\n    \"clauses\": [\n        {\n            \"type\": \"Export\",\n            \"name\": \"Clause1\",\n            \"condition\": \"true\",\n            \"dependencies\": [\"Clause2\", \"Clause3\"],\n            \"metadata\": {\n                \"description\": \"This is the first export clause.\",\n                \"version\": \"1.0\"\n            },\n            \"control\": {\n                \"policy\": \"Allow\"\n            }\n        },\n        ...\n    ]\n}\n```\n\nIn this structure:\n- **clauses**: A list containing multiple export clause objects.\n- **type**: The type of action, in this case \"Export\".\n- **name**: A unique identifier for the clause.\n- **condition**: Any condition that governs whether the clause should be exported.\n- **dependencies**: A list of clause names that this clause depends on.\n- **metadata**: Additional information about the clause.\n- **control**: Policies or rules about exporting the clause.\n\n## Example\n\nHere's a simple example of how `exportClauses` might be populated:\n\n```python\nexportClauses = \"\"\"\n{\n    \"clauses\": [\n        {\n            \"type\": \"Export\",\n            \"name\": \"UserDetails\",\n            \"condition\": \"user_logged_in\",\n            \"dependencies\": [],\n            \"metadata\": {\n                \"description\": \"Exports the details of the logged-in user.\",\n                \"version\": \"2.3\"\n            },\n            \"control\": {\n                \"policy\": \"AllowIfAuthenticated\"\n            }\n        }\n    ]\n}\n```\n\n## Conclusion\n\nThe `exportClauses` assignment is a flexible way to define what elements or data should be made available for export. By using nodes such as Clause Nodes, Condition Nodes, Dependency Nodes, Metadata Nodes, and Export Control Nodes, it ensures a structured and robust approach to managing exports."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::constructorDefinitions",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 25,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`",
    "summary": "# Documentation for `constructorDefinitions`\n\n## Overview\nThe `constructorDefinitions` assignment defines a set of rules for identifying specific constructs within a given programming language syntax tree. These constructs are then tagged with appropriate labels for further processing or analysis. \n\n## Syntax\n\n```python\nconstructorDefinitions = `\n(constructor_declaration)? @function\n(method_declaration)? @function\n(class_declaration) @class\n`\n```\n\n## Nodes and Their Meanings\n\n### Nodes\n\n1. `(constructor_declaration)? @function`\n   - **Description**: This node optionally matches a `constructor_declaration` and tags it with the label `@function`.\n   - **Use Case**: Typically used to identify and label constructor functions within a class.\n   \n2. `(method_declaration)? @function`\n   - **Description**: This node optionally matches a `method_declaration` and tags it with the label `@function`.\n   - **Use Case**: Typically used to identify and label regular methods within a class.\n\n3. `(class_declaration) @class`\n   - **Description**: This node matches a `class_declaration` and tags it with the label `@class`.\n   - **Use Case**: Used to identify and label class declarations.\n\n## Usage\n\nThis set of definitions can be used in various contexts where identifying and processing different elements of a class structure is required. Examples include:\n\n- **Syntax Highlighting**: Differentiating between classes, methods, and constructors in a code editor.\n- **Code Analysis**: Performing static code analysis to gather statistics or check coding standards.\n- **Refactoring**: Identifying specific parts of code that need to be refactored.\n\n## Example\n\nAn example code snippet and how `constructorDefinitions` would apply:\n\n### Input Code\n```python\nclass MyClass {\n    constructor() {\n        // constructor code\n    }\n\n    myMethod() {\n        // method code\n    }\n}\n```\n\n### Tags After Processing\n- `class MyClass {` would be tagged with `@class`.\n- `constructor() {` would be tagged with `@function`.\n- `myMethod() {` would be tagged with `@function`.\n\n## Conclusion\n\nThe `constructorDefinitions` assignment provides a straightforward way to tag and differentiate between constructors, methods, and class declarations within a program's syntax tree. This facilitates a variety of analyses and tools that operate on source code."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::definitionTemplate",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "summary": "# Documentation for `definitionTemplate`\n\n## Overview\n\nThe `definitionTemplate` is a template used for pattern matching in a tree-like structure (e.g., an Abstract Syntax Tree). It defines the structure of a function or method definition with various components that may or may not be present depending on the specific instance.\n\n## Template Structure\n\nThe `definitionTemplate` pattern is described using nested expressions that match different parts of a function or method definition. Below is the template:\n\n```python\ndefinitionTemplate = `\n(\n    _\n    (modifiers) @modifier \n    type: (_) @return_type\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    body: (_) @body\n)?\n`\n```\n\n## Node Definitions\n\nThe following nodes are used in the `definitionTemplate`:\n\n1. **modifiers**:\n   - **Type**: **?**\n   - **Description**: Matches any modifiers that may be present in the function or method definition. Typically, these could be access specifiers like `public`, `private`, `protected`, or other keywords like `static` or `final`.\n\n2. **type**:\n   - **Type**: **_**\n   - **Description**: Optionally matches the return type of the function or method. The return type is identified and captured by the named node `@return_type`.\n\n3. **name**:\n   - **Type**: **_**\n   - **Description**: Matches the name of the function or method, captured by the named node `@name`.\n\n4. **parameters**:\n   - **Type**: **formal_parameters**\n   - **Description**: Optionally matches the parameters list of the function or method. If present, the parameters are captured by the named node `@param`.\n\n5. **body**:\n   - **Type**: **_**\n   - **Description**: Matches the body of the function or method, captured by the named node `@body`.\n\n## Overview of Optional Components\n\n- The entire pattern `( _ (modifiers) @modifier type: (_)? @return_type name: (_) @name parameters: (formal_parameters (_) @param)? body: (_) @body )?` is surrounded by parentheses followed by a question mark (`?`), indicating that the entire match is optional.\n- Within this pattern:\n  - The return type (`type: (_) @return_type`) is optional.\n  - The parameters (`parameters: (formal_parameters (_) @param)?`) are optional.\n\nThis structural definition allows matching various forms of function or method definitions, providing flexibility and robustness in capturing different components as needed."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::assignments",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 3,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = ``",
    "summary": "# Assignment Documentation\n\nThis assignment utilizes the following nodes:\n\n```python\nassignments = ``\n```\n\n## Node Details\n\nThis section will provide detailed descriptions of each node used within the assignment. The assignment code itself is set to an empty string, indicating an initial placeholder where the actual code will later be integrated. Heres a brief description of the placeholder and its intended use:\n\n### Placeholder Description\n\n- **assignments**: This is a placeholder initialized to an empty string. It signifies that the actual assignment logic or data assignments are yet to be defined. \n\n## Intended Use-Case\n\n- This placeholder is meant to be populated with the relevant assignment logic or data. Once populated, it will form the core component of the given assignment.\n- The comments suggest that multiple nodes will interact or be defined within this assignment.\n\n## Nodes Involved\n\nThis assignment references several nodes. Although the exact nodes are not defined in the given snippet, typically in such assignments, nodes can be variables, functions, classes, datasets, or specific computational procedures that work together to accomplish a given task. Below are possible types of nodes that might be involved:\n\n1. **Data Nodes**: These might include variables that store data frames, lists, or other data structures.\n2. **Function Nodes**: Functions that manipulate data, perform calculations, or implement specific algorithms.\n3. **Class Nodes**: Classes that encapsulate related functions and data.\n4. **Operation Nodes**: Specific operations or computational steps that transform or analyze data.\n\n## Steps to Complete the Assignment\n\n1. **Define Data Nodes**: Identify the data structures required for the assignment.\n2. **Outline Function Nodes**: Write functions essential for data manipulation, transformation, or analysis.\n3. **Implement Class Nodes**: If object-oriented programming is required, define classes encapsulating related properties and methods.\n4. **Execute Operation Nodes**: Implement the necessary operations or sequence of steps to achieve the assignment's objectives.\n\n## Example Setup\n\nAn example setup to illustrate a possible structure and expected content:\n\n```python\n# Data Node: Initialize data structure or variable\ndata_node_variable = []\n\n# Function Node: Define a function to manipulate data\ndef process_data(data):\n    # function details here\n    pass\n\n# Class Node: Optionally define a class for encapsulation\nclass DataProcessor:\n    def __init__(self, data):\n        self.data = data\n\n    def process(self):\n        # class method details here\n        pass\n\n# Operation Node: Execute specific operations\nresult = process_data(data_node_variable)\n```\n\n## Conclusion\n\nBy defining and interconnecting these nodes as per the assignment requirements, the placeholder string `assignments` will be transformed into a fully functioning piece of code achieving the specified objectives. The nodes listed serve as a foundation for driving the assignment towards completion.\n\nFurther details and specific implementation will depend on the actual requirements and context of the assignment."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java::importStatements",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/java",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`",
    "summary": "# Documentation for `importStatements` Assignment\n\nThe `importStatements` is an assignment that represents a tree-sitter query for identifying import statements within a codebase. This query is written in S-expression format for use with the tree-sitter library, a powerful tool for parsing and processing source code.\n\n## Assignment\n\n```python\nimportStatements = `\n(import_declaration \n\t[(scoped_identifier\n    \tscope: (_) @module\n        name: (_) @name)\n    (identifier) @module\n    ]\n) @import_statement\n`\n```\n\n## Description\n\nThis query searches for import statements within the source code. The import statements can be either scoped identifiers or simple identifiers, and they are captured by the following nodes:\n\n### Nodes\n\n1. **import_declaration**\n   - This is the root node that represents the entire import declaration in the syntax tree.\n\n2. **scoped_identifier**\n   - This node matches scoped identifiers (e.g., `module.submodule`).\n   - It contains the following children:\n     - `scope`: This is a captured group `(_) @module` representing the scope part of the scoped identifier.\n     - `name`: This is a captured group `(_) @name` representing the name part of the scoped identifier.\n   \n3. **identifier**\n   - This node matches simple identifiers (e.g., `module`).\n   - It captures the identifier directly as `@module`.\n\n4. **import_statement**\n   - This is the final captured group `(@import_statement)` that represents the entire import statement as a whole.\n\n### Example Usage\n\nLet's see how this query might be used in a context:\n\n```python\nfrom tree_sitter import Language, Parser\n\n# Load language definitions (e.g., Python)\nLanguage.build_library(\n  'build/my-languages.so', \n  ['vendor/tree-sitter-python']\n)\nPY_LANGUAGE = Language('build/my-languages.so', 'python')\n\n# Create a new parser\nparser = Parser()\nparser.set_language(PY_LANGUAGE)\n\n# Parse some code\nsource_code = b\"\"\"\nimport os\nimport sys\nfrom my_package import my_module\n\"\"\"\ntree = parser.parse(source_code)\n\n# Run the `importStatements` query\nquery = PY_LANGUAGE.query(importStatements)\ncaptures = query.captures(tree.root_node)\n\n# Process captures\nfor capture in captures:\n    print(capture)\n```\n\nIn this example, the `importStatements` query is used with the Tree-sitter parser to identify and capture import statements from the source code. The processed captures would provide us with details about the various imports present in the code, segmented into scoped and simple identifiers.\n\n## Use Cases\n\nThis query can be used in various scenarios, such as:\n\n- Static code analysis for detecting unused imports.\n- Refactoring tools needing to organize or optimize import statements.\n- Code linters enforcing specific import rules and best practices.\n- Documentation generators highlighting dependencies of a codebase."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::anyAssignments",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 289,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`",
    "summary": "# Documentation for `anyAssignments`\n\n## Overview\n\nThe `anyAssignments` captures a wide range of assignment expressions and functional calls in code. This is useful for analyzing and transforming code by identifying common patterns where variables are set or manipulated. The specific types of assignments it captures include direct assignments, variable declarations, and certain functional calls involving `forEach`, `map`, and `reduce`.\n\n## Structure & Nodes\n\nThe `anyAssignments` uses the following nodes:\n\n### Assignment Expressions\n\nThis pattern identifies direct assignment expressions where an identifier is assigned a value.\n\n```plaintext\n(assignment_expression\n\tleft: (identifier) @left\n    right: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n```\n\n- **left**: The left-hand side of the assignment, which must be an identifier.\n- **right**: The right-hand side of the assignment, which can be:\n  - An identifier\n  - A member expression\n  - A new expression\n\n### Variable Declarators\n\nThis pattern identifies variable declarations where an identifier is initialized with a value.\n\n```plaintext\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n```\n\n- **name**: The name of the variable being declared.\n- **value**: The value assigned to the variable, which can be:\n  - An identifier\n  - A member expression\n  - A new expression\n\n### Functional Calls (forEach and map)\n\nThis pattern captures calls to `forEach` and `map` methods, where an arrow function is used as an argument.\n\n```plaintext\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"forEach\" \"map\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters . ((_) @right) ;first param\n           )\n         )\n    ) \n) @assignment\n```\n\n- **left**: The object on which the method is invoked.\n- **property**: The property being accessed (`forEach` or `map`).\n- **right**: The first parameter of the arrow function used in the argument.\n\n### Functional Calls (reduce)\n\nThis pattern captures calls to the `reduce` method, where an arrow function is used as an argument.\n\n```plaintext\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"reduce\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters  ( (_) @right) . ;last param\n           )\n         )\n    ) \n) @assignment\n```\n\n- **left**: The object on which the method is invoked.\n- **property**: The property being accessed (`reduce`).\n- **right**: The last parameter of the arrow function used in the argument.\n\n## Summary\n\nThe `anyAssignments` captures a diverse set of assignment patterns in code, including simple assignments, variable declarations, and functional calls with specific methods (`forEach`, `map`, `reduce`). This makes it a versatile tool for code analysis and transformation tasks focused on assignments and variable manipulations."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::calls",
    "label": "calls",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 117,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n`",
    "summary": "## Documentation for `calls` Assignment\n\n### Overview\n\nThe `calls` assignment is a collection of patterns used for identifying various types of expressions in abstract syntax trees (AST). These patterns are intended to recognize specific node types and structures, such as function calls, member expressions, and arguments.\n\n### Nodes and Patterns\n\nHere's an explanation of each pattern used in the `calls` assignment:\n\n1. **Any Call Expression**\n   ```plaintext\n   (call_expression function: (_) @identifier.name)\n   ```\n   This pattern matches any call expression where the function is an identifier.\n\n2. **Calls to Member Expressions**\n   ```plaintext\n   (assignment_expression right: (member_expression) @identifier.name)\n   ```\n   This pattern matches assignment expressions where the right-hand side is a member expression (e.g., `obj.prop`).\n\n3. **Arguments**\n   ```plaintext\n   (arguments (identifier) @identifier.name)\n   ```\n   This pattern matches arguments that are identifiers in function calls.\n\n4. **Any Member Expression**\n   ```plaintext\n   ( _ (member_expression) @identifier.name)\n   ```\n   This pattern matches any member expression.\n\n5. **New Expression**\n   ```plaintext\n   (new_expression (identifier) @identifier.name)\n   ```\n   This pattern matches `new` expressions where the constructor is identified by an identifier.\n\n6. **Keyword Arguments**\n   ```plaintext\n   (pair value: (identifier) @identifier.name)\n   ```\n   This pattern matches keyword arguments in object literals where the value is an identifier.\n\n7. **Variable Declarator**\n   ```plaintext\n   (variable_declarator value: (identifier) @identifier.name)\n   ```\n   This pattern matches assignments within variable declarations.\n\n8. **Any Object**\n   ```plaintext\n   ( _ object: _ @identifier.name)\n   ```\n   This pattern matches any expression with an object as part of its structure.\n\n### Summary\n\nThe `calls` assignment provides a comprehensive set of patterns for matching different types of expressions commonly found in JavaScript or similar languages. Each pattern captures specific node types and identifiers, aiding in the analysis and manipulation of ASTs in code analysis tools.\n\n### Usage\n\nThese patterns can be used in code analysis tools that utilize tree-sitter or similar parsers to identify and operate on various constructs within the codebase. By matching these patterns, such tools can perform tasks ranging from refactoring, linting, to generating documentation."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::extraAssignmentCode",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`",
    "summary": "# Function Documentation: `extraAssignmentCode`\n\n## Summary\nThe `extraAssignmentCode` function generates a Tree-sitter compatible query to find all the call expressions in a program where the function name matches the given input string. The generated query is in the form of a string.\n\n### Syntax\n```typescript\nconst extraAssignmentCode = (name: string) => string;\n```\n\n### Parameters\n- `name` (string): The name of the function to search for in the given program.\n\n### Returns\n- (string): Returns a Tree-sitter query as a string that searches for call expressions with the specified function name.\n\n### Description\nThe `extraAssignmentCode` function constructs a Tree-sitter query that looks for all call expressions in a program where the function being called has a specific name. This is useful for analyzing code to find instances of function calls, among other potential code analysis tasks.\n\nExample of a Tree-sitter query generated by `extraAssignmentCode` for `name = \"myFunction\"`:\n```scheme\n( program\n    (expression_statement\n        (call_expression function:\n            [\n                (identifier) @identifier.name\n                (member_expression object: (identifier) @identifier.name  )\n            ]\n        (#eq? @identifier.name \"myFunction\")\n        ) @code\n    )\n)\n```\n\n### Nodes Used\nThis function utilizes the following Tree-sitter nodes:\n- **program**: The root node representing the entire program.\n- **expression_statement**: Represents a statement consisting of an expression.\n- **call_expression**: Represents a function call.\n- **identifier**: Represents the name of an identifier (e.g., a function name or variable name).\n- **member_expression**: Represents access to a property of an object (e.g., `object.property`).\n\n### Use Case\nConsider using `extraAssignmentCode` when you need to:\n- Perform static code analysis to identify all instances of specific function calls.\n- Generate queries for automated refactoring tools to locate and potentially modify specific function calls.\n- Aid in the development of developer tools that require understanding of where and how specific functions are used in the source code.\n\n### Example Usage\n```typescript\nconst myFunctionQuery = extraAssignmentCode(\"myFunction\");\nconsole.log(myFunctionQuery);\n```\n\nThe output will be a Tree-sitter query string that can be used to find all the instances of `myFunction` being called in the code.\n\n### Additional Notes\n- The query string makes use of the `@identifier.name` and `@code` named captures, which are important for locating and manipulating specific nodes within a syntax tree.\n- The `#eq?` predicate ensures that only call expressions with the exact function name provided are matched."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::exportClauses",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 51,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`",
    "summary": "## Documentation for `exportClauses` Assignment\n\n### Overview\nThe `exportClauses` assignment defines a syntax pattern for parsing and recognizing export statements in a given code. This pattern is likely to be used in a parsing tool or a language processing utility to detect and extract information related to exports.\n\n### Syntax Structure\nThe `exportClauses` pattern matches export statements that can potentially include a module and alias information. The pattern is defined using a tree-sitter or similar grammar specification language. \n\n### Structure Details\n- The outer structure is defined as an `export_statement`.\n- The `export_statement` contains an `export_clause`.\n- The `export_clause` encapsulates an `export_specifier`.\n\n### Nodes in the Pattern\nThese are the components (or nodes) recognized within the specified structure:\n\n1. **export_statement**: \n   - Represents an entire export statement in the code.\n\n2. **export_clause**:\n   - Encapsulates the specifics of what is being exported.\n\n3. **export_specifier**:\n   - Specifies individual export items, which can include:\n     - **name**: \n       - The name of the entity being exported. This is matched with the pattern `(_)`, which stands for any node (typically a named identifier).\n       - Captured as `@name`.\n     - **alias**:\n       - An optional alias for the exported entity. This is also matched with the pattern `(_)` but is optional as denoted by `(_)?`.\n       - Captured as `@alias`.\n\n4. **string**:\n   - Represents a string literal, which can be an optional part of the export statement indicating the module from which the entity is exported.\n   - Contains:\n     - **string_fragment**:\n       - Denotes the content of the string literal, capturing the module path or name if provided.\n       - Captured as `@module`.\n\n### Example\nGiven the pattern, the following code snippet would match and extract the corresponding nodes:\n\n```javascript\nexport { foo as bar } from 'module-name';\n```\n\n- **name**: `foo`\n- **alias**: `bar`\n- **module**: `'module-name'`\n\n### Usage Scenarios\nThis pattern can be utilized in:\n- **Code Analyzers**: Extracting exported entities for documentation or dependency management.\n- **Intelligent Code Editors**: Providing features like autocompletion or refactoring support.\n- **Static Analysis Tools**: Ensuring code conformance to module/export conventions.\n\n### Conclusion\nThe `exportClauses` assignment is a precise tool for detecting and processing export statements within code. By utilizing the specified nodes, it accurately captures the names, aliases, and module references involved in exports, facilitating various code analysis and manipulation tasks."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::constructorDefinitions",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`",
    "summary": "# Documentation for `constructorDefinitions`\n\n## Overview\nThe `constructorDefinitions` assignment is a text-based script that defines patterns for exporting and identifying different JavaScript components such as functions, arrow functions, and classes. It uses specific node patterns to target these components. The patterns are written in a Tree-sitter query syntax, which is used for parsing and analyzing code in syntax trees.\n\n### Components\nThe script covers the following JavaScript components:\n\n1. **Export Statements**\n2. **Functions**\n3. **Arrow Functions**\n4. **Classes**\n5. **Methods within Classes**\n\n### Pattern Definitions\nBelow are the detailed definitions and purposes of each pattern used in `constructorDefinitions`.\n\n#### Export Statements\n```plaintext\n; export\n(export_statement) @export\n```\n- **Node Pattern**: `(export_statement)`\n- **Tag**: `@export`\n- **Description**: Matches any export statement within the JavaScript code, tagging it as `@export`.\n\n#### Functions\n```plaintext\n; functions\n(function_declaration) @function\n```\n- **Node Pattern**: `(function_declaration)`\n- **Tag**: `@function`\n- **Description**: Matches any function declaration, tagging it as `@function`.\n\n#### Arrow Functions\n```plaintext\n; arrow functions\n${arrowFunctionConstructor} @function\n```\n- **Node Pattern**: `${arrowFunctionConstructor}`\n- **Tag**: `@function`\n- **Description**: Matches any arrow function expression specified by the variable `arrowFunctionConstructor`, tagging it as `@function`.\n\n#### Classes\n```plaintext\n; classes\n(method_definition)? @method\n(class_declaration) @class\n```\n**Method Definitions**:\n- **Node Pattern**: `(method_definition)?`\n- **Tag**: `@method`\n- **Description**: Matches any method definition within a class. The question mark `?` indicates that the match is optional.\n\n**Class Declarations**:\n- **Node Pattern**: `(class_declaration)`\n- **Tag**: `@class`\n- **Description**: Matches any class declaration, tagging it as `@class`.\n\n## Usage with Tree-sitter\nThis assignment is typically used with Tree-sitter, a parser generator tool that parses code into an Abstract Syntax Tree (AST). You can integrate these patterns into a Tree-sitter based application to identify and process different JavaScript constructs such as functions, classes, and export statements.\n\n### Example Integration\n```javascript\nconst parser = new Parser();\nparser.setLanguage(JavaScript); // Assuming JavaScript grammar has been set.\n\n// Add the `constructorDefinitions` query.\nconst query = parser.language.query(constructorDefinitions);\n\n// Parse some JavaScript code (source code as a string)\nconst sourceCode = `\nexport function myFunction() {}\nclass MyClass {\n  myMethod() {}\n}\nconst myArrowFunction = () => {};\n`;\nconst tree = parser.parse(sourceCode);\n\n// Apply the query to the parsed syntax tree.\nconst captures = query.captures(tree.rootNode);\n\ncaptures.forEach((capture) => {\n  console.log(capture.name, capture.node.text);\n  // `name` will be one of `@export`, `@function`, `@method`, `@class`\n  // `node.text` will be the matched source code text for that pattern.\n});\n```\n\n## Conclusion\nThe `constructorDefinitions` assignment provides a concise way to capture key constructs in JavaScript using patterns that align with Tree-sitter syntax trees. This can be very useful in tools and applications that require code analysis, transformation, or for creating code navigation features in editors."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::arrowFunctionConstructor",
    "label": "arrowFunctionConstructor",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 1,
    "code": "arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"",
    "summary": "# Documentation for `arrowFunctionConstructor`\n\n## Overview\n`arrowFunctionConstructor` is a syntactic assignment that represents the construction of an arrow function in a given lexical scope. The structure captures the declaration and initialization of a variable with an arrow function as its value.\n\n## Structure\nThe assignment is defined as a string representation of an abstract syntax tree (AST) node pattern. Below is the detailed breakdown of its structure:\n\n```python\narrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"\n```\n\n### Nodes Used\nThe pattern incorporates the following specific nodes to represent the arrow function construction:\n\n1. **lexical_declaration**:\n   - **Description**: Represents a variable declaration in a lexical scope. This could be for variables declared with keywords such as `let` or `const` in JavaScript.\n   - **Children**:\n     - **variable_declarator**: Defines the specific variable being declared and optionally initialized.\n\n2. **variable_declarator**:\n   - **Description**: Denotes the declarator of a variable, including its identifier and initial value.\n   - **Attributes**:\n     - **value**: Refers to the value being assigned to the variable. In this case, the value is an arrow function.\n   - **Children**:\n     - **arrow_function**: Represents an arrow function.\n\n3. **arrow_function**:\n   - **Description**: Represents an arrow function expression. Arrow functions provide a concise syntax and have lexical scoping of `this`, `arguments`, super, and new.target.\n\n## Example\nThe following example showcases how the pattern `arrowFunctionConstructor` could be applied to a typical code snippet in JavaScript:\n\n### JavaScript Code\n```javascript\nconst myFunc = (param) => { return param * 2; };\n```\n\n### Corresponding AST\nThe equivalent structure based on `arrowFunctionConstructor` would be:\n```\n(lexical_declaration\n  (variable_declarator\n    value: (arrow_function)\n  )\n)\n```\n\n## Use Cases\n- **Syntax Parsing**: `arrowFunctionConstructor` can be used in syntax parsers or compilers to detect and process arrow function declarations.\n- **Code Analysis**: Tools that perform static analysis on JavaScript code can use this pattern to identify and manipulate arrow functions for further examination or transformation.\n- **Code Generation**: In code generation scenarios, this pattern can help produce AST nodes that align with variable declarations initialized with arrow functions.\n\n## Conclusion\n`arrowFunctionConstructor` is a useful representation for capturing the essence of arrow function declarations within a lexical scope. It uses a combination of specific nodes that together provide a clear structure for parsing and analyzing JavaScript code with arrow functions."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::definitionTemplate",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 94,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "summary": "# Documentation for `definitionTemplate`\n\n## Description\nThe `definitionTemplate` is a parsing template likely used with a tree-sitter or similar syntax tree parser to identify and analyze different types of function definitions and variable declarations in a programming language. It matches patterns of function definitions, including both traditional and arrow functions, and captures their essential components such as names, parameters, and body content.\n\n## Template Structure\nThe template is defined using a combination of parentheses `()` for grouping, square brackets `[]` for optional elements, and at-captures `@` to label parts of the matched nodes. The template is structured into two primary sections: normal functions/types and arrow functions.\n\n### Normal Functions/Types\nThe first part of the template captures traditional function definitions and types. Here's the breakdown:\n- `name: (_) @name`: Captures the name of the function or variable.\n- `parameters: (formal_parameters (_) @param)?`: Optionally captures the parameters if they exist.\n- The template further differentiates between types and functions by using square brackets for optional components such as body or value:\n  - `[body: (_); for types value: (_)] @body`: Optionally captures the body of the type or the value. This segment allows for flexibility in capturing different types of definitions.\n\n### Arrow Functions\nThe second part of the template captures arrow function definitions. Here's the breakdown:\n- `(variable_declarator name: (_) @name value: (arrow_function parameters: (formal_parameters (_) @param)? body: (_)? @body))`: Matches a variable declarator with an arrow function assigned to it. This captures:\n  - The name of the variable.\n  - Optionally the parameters of the arrow function.\n  - Optionally the body of the arrow function.\n\n## Example\nTo illustrate how `definitionTemplate` might match against a piece of code, consider the following examples:\n\n### Traditional Function Declaration\n```javascript\nfunction foo(bar, baz) {\n    // function body\n}\n```\n- `name: foo` - Captures the function's name.\n- `parameters: (bar, baz)` - Captures the functions parameters.\n- `body: { // function body }` - Captures the body of the function.\n\n### Arrow Function Declaration\n```javascript\nconst foo = (bar, baz) => {\n    // function body\n};\n```\n- `name: foo` - Captures the variable name.\n- `parameters: (bar, baz)` - Captures the functions parameters.\n- `body: { // function body }` - Captures the body of the arrow function.\n\n## Nodes Used in Template\nHere is a list of nodes that are referenced in the `definitionTemplate`:\n1. `name` - The name of the function or variable.\n2. `formal_parameters` - The parameters of the function.\n3. `body` - The body of the function or type.\n4. `variable_declarator` - A variable declarator node.\n5. `arrow_function` - An arrow function node.\n\n## Potential Uses\nThe `definitionTemplate` can be used in various contexts, such as:\n- Syntax highlighting in code editors.\n- Static analysis tools to verify functions' and variables' definitions.\n- Refactoring tools to manipulate and transform code.\n\n## Conclusion\n`definitionTemplate` is a comprehensive template for capturing different types of function and type definitions, both in traditional and arrow function forms. By using this template, developers can reliably parse and analyze code structures, aiding in a variety of development tools and applications."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::assignments",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) ; to exclude arrow functions\r\n        ) @assignment\r\n    )\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) @assignment\r\n        )\r\n    )\r\n)\r\n`",
    "summary": "## Documentation for Assignment: `assignments`\n\n### Overview\n\nThis assignment is designed to identify assignments within a program. Specifically, it targets variable declarators where the value is not an arrow function. It also covers export statements that include such variable declarators. This documentation will outline the structure and function of the assignment.\n\n### Assignment Pattern\n\n```plaintext\nassignments = `\n(program\n    (_\n        (variable_declarator\n            name: (identifier)\n            value: (_ !body) ; to exclude arrow functions\n        ) @assignment\n    )\n) \n\n; exportables\n(program\n    (export_statement\n        (_\n            (variable_declarator\n                name: (identifier)\n                value: (_ !body)\n            ) @assignment\n        )\n    )\n)\n`\n```\n\n### Node Structure and Components\n\nThis assignment pattern includes several key components and nodes, each playing a specific role:\n\n1. **Root Node: (program)**\n   - The `program` node wraps the entirety of the script or module being parsed.\n\n2. **Wildcard (_) Node**\n   - The `_` node represents any type of declaration or statement that could potentially contain variable assignments.\n\n3. **Variable Declarator (variable_declarator) Node**\n   - This node identifies the core structure of a variable declaration.\n   - **name**: This sub-node, identified by the `(identifier)`, specifies the name of the variable being declared.\n   - **value**: This sub-node represents the assigned value. The pattern `_ !body` ensures that the value is not an arrow function.\n\n4. **Capture (@assignment)**\n   - The `@assignment` capture is used to mark or tag the entirety of the `variable_declarator` node for further processing or extraction.\n\n5. **Export Statement (export_statement) Node**\n   - This node specifically targets export statements containing variable declarations.\n   - Encompasses the same structure as the general variable declarator but within an `export_statement` parent node.\n\n### Use Cases\n\n- **General Variable Declarations:** The first part of the assignment captures variable declarations within the program where the value assigned is not an arrow function.\n- **Exported Variables:** The second part captures exported variables which also use the same structure to avoid arrow functions in their value assignments.\n\n### Exclusions\n\n- **Arrow Functions:** The assignment explicitly excludes arrow functions from being considered as valid variable values. This is achieved using the `_ !body` pattern, which ensures the `value` node does not include an arrow function body.\n\n### Practical Application\n\nThis assignment is useful for analyzing and extracting variable declarations in a codebase, particularly when you need to ignore declarations involving arrow functions. It is also helpful when focusing on exported variables that match the same criteria, potentially for documentation, refactoring, or analysis tasks.\n\n### Summary\n\nIn summary, the `assignments` assignment pattern is a powerful tool for capturing specific variable declarations within a program while excluding arrow function values, both generally within the code and specifically within export statements. The use of precise node patterns ensures accurate captures for further processing."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript::importStatements",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/javascript",
    "totalTokens": 210,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @name\r\n          (object_pattern (_) @name)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @submodule\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`",
    "summary": "# Documentation for `importStatements` \n\nThe `importStatements` assignment is designed to capture various types of import statements in JavaScript and TypeScript code using a tree-sitter query. This includes both ES6 `import` statements and CommonJS `require` statements. Below is a detailed breakdown of the nodes and patterns used in the assignment:\n\n```scheme\nimportStatements = `\n(import_statement \n    (import_clause [\n    (namespace_import (identifier) @alias)\n    (identifier) @name\n    (named_imports (import_specifier\n\t\t    name: (_) @name\n    \t\talias: (_)? @alias))\n    ])?\n\tsource: (string (string_fragment) @module)\n) @import_statement\n\n(lexical_declaration\n    (variable_declarator\n      name: [\n          (identifier) @name\n          (object_pattern (_) @name)\n      ]\n      value: [(call_expression\n                  function: _ @function\n                  arguments: (arguments (string (string_fragment) @module))\n                  (#eq? @function \"require\"))\n              ( member_expression\n                (call_expression\n                    function: _ @function\n                    arguments: (arguments (string (string_fragment) @module))\n                    (#eq? @function \"require\")\n                )\n                (property_identifier) @submodule\n               )\n              ]\n    )           \n  ) @import_statement\n`\n```\n\n## Nodes Used:\n\n### 1. `import_statement`\n- **Type**: Parent node for representing standard ES6 import statements.\n- **Children**: \n  - `import_clause`\n  - `source`\n\n### 2. `import_clause`\n- **Type**:  Child node which specifies what is being imported.\n- **Children**:\n  - `namespace_import`\n  - `identifier`\n  - `named_imports`\n  - `import_specifier`\n\n#### Child Nodes of `import_clause`\n- `namespace_import (identifier) @alias`\n  - Captures namespace imports like `* as alias` from a module.\n- `identifier @name`\n  - Captures the default imported module.\n- `named_imports (import_specifier name: (_) @name alias: (_)? @alias)`\n  - Captures named imports with optional aliases.\n\n### 3. `source`\n- **Type**: Represents the source module as a string.\n- **Children**: \n  - `string (string_fragment) @module`\n    - Captures the module source string.\n\n### 4. `lexical_declaration`\n- **Type**: Represents variable declarations which commonly catch `require` statements.\n- **Children**: \n  - `variable_declarator`\n\n### 5. `variable_declarator`\n- **Type**: Represents the variable declared.\n- **Children**:\n  - `name`\n  - `value`\n\n#### Child Nodes of `variable_declarator`\n- `name`\n  - Represents the name of the variable being declared.\n  - Can be:\n    - `identifier @name`\n    - `object_pattern (_) @name`\n- `value`\n  - Represents the value assigned to the variable.\n  - Captures various forms of `require` statements:\n    - `(call_expression function: _ @function arguments: (arguments (string (string_fragment) @module)) (#eq? @function \"require\"))`\n        - Captures standard `require` calls.\n    - `member_expression (call_expression function: _ @function arguments: (arguments (string (string_fragment) @module)) (#eq? @function \"require\")) (property_identifier) @submodule`\n        - Captures member expressions following a `require` call.\n\n## @import_statement\n- Tags both ES6 `import` and CommonJS `require` statements clearly by capturing them as `@import_statement`.\n\nThis specification ensures a thorough capture of different import methods used in both modern and legacy JavaScript codebases. The `@` symbol denotes named captures, which are key to identifying parts of the import statements in a precise manner."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::anyAssignments",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "summary": "# Documentation for `anyAssignments`\n\nThe `anyAssignments` assignment is a pattern-matching rule defined using a tree-sitter query language. This assignment matches specific syntactic constructs in a source code and captures corresponding parts of these constructs for further processing or analysis.\n\n## Pattern Rule\n\n### Structured Hierarchy\n\nThe rule is designed to match and capture:\n1. Classic assignments in a source code.\n2. Typed function parameters in function definitions.\n\n### Match Specification\n\n#### Capturing Assignments\n\nThe first part of the rule captures classic assignment operations:\n```lisp\n(assignment\n    left: (identifier) @left\n    right: (_) @right\n) @assignment\n```\n- **assignment**: This node represents an assignment operation.\n  - **left: (identifier) @left**: This captures the left-hand side of the assignment, which must be an identifier, and labels it as `@left`.\n  - **right: (_) @right**: This captures the right-hand side of the assignment, which can be any expression, and labels it as `@right`.\n  - The whole assignment node itself is labeled as `@assignment`.\n\n#### Capturing Typed Function Parameters\n\nThe second part of the rule captures typed parameters within function definitions:\n```lisp\n(function_definition\n  parameters: (\n  parameters( typed_parameter (\n              (identifier) @left)\n              type: _ @right)\n  @assignment)\n)\n```\n- **function_definition**: This node represents a function definition.\n  - **parameters: (parameters (typed_parameter (...) @assignment))**: This structure navigates into the function parameters.\n    - **typed_parameter**: This node represents the parameters within the function and ensures it is typed.\n      - **(identifier) @left**: This captures the parameter name as an identifier and labels it as `@left`.\n      - **type: _ @right**: This captures the type of the parameter and labels it as `@right`.\n      - The whole parameter node itself gets the context label `@assignment`.\n\n### Summary of Captured Nodes\n\n- **@left**: \n  - In the context of assignments, it refers to the left-hand identifier.\n  - In the context of typed function parameters, it refers to the parameter name.\n  \n- **@right**: \n  - In the context of assignments, it refers to the right-hand expression.\n  - In the context of typed function parameters, it refers to the type of the parameter.\n  \n- **@assignment**: Represents the whole assignment operation or the typed parameter within a function definition.\n\n### Example Usage\n\nFor an assignment statement like:\n```python\nx = 42\n```\n- `x` would be captured as `@left`.\n- `42` would be captured as `@right`.\n- The entire assignment (`x = 42`) would be labeled as `@assignment`.\n\nFor function definitions with typed parameters like:\n```python\ndef func(y: int):\n    pass\n```\n- `y` would be captured as `@left`.\n- `int` would be captured as `@right`.\n- The entire parameter (`y: int`) would be labeled as `@assignment`.\n\nThis rule helps in analyzing assignments and typed function parameters by breaking them down into distinct and labeled components for further processing within the source code."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::calls",
    "label": "calls",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 303,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n`",
    "summary": "# Documentation for `calls`\n\n## Overview\n\nThe `calls` assignment captures various syntactic constructs related to calls, assignments, and definitions within a codebase. This includes function calls, method calls, class extensions, assignments, and more. The following documentation lists the patterns used and the specific nodes targeted within each pattern.\n\n## Patterns and Nodes\n\n### 1. Function Calls\n#### Pattern:\n```scheme\n(call function: ( (identifier) @identifier.name))\n```\n- **Description:** Captures function calls where the function name is an identifier.\n- **Target Node:** `@identifier.name`\n\n### 2. Method Calls (Class.method)\n#### Pattern:\n```scheme\n(call function: ( (attribute) @identifier.name))\n```\n- **Description:** Captures method calls where the method is accessed as an attribute of a class.\n- **Target Node:** `@identifier.name`\n\n### 3. Self Parameter Access (self.parameter)\n#### Pattern:\n```scheme\n((attribute\n    object: (identifier) @object\n    attribute: (identifier) @property\n    (#eq? @object \"self\")) @identifier.name)\n```\n- **Description:** Captures accesses to parameters of the form `self.parameter`.\n- **Target Node:** `@identifier.name`\n\n### 4. Class Definitions with Extensions\n#### Pattern:\n```scheme\n(class_definition\n    superclasses : (argument_list (_) @class.extends)?\n    body: (block\n            (function_definition name: _ @class.method)?)) @class.definition\n```\n- **Description:** Captures class definitions possibly with extensions and method definitions.\n- **Target Node:** `@class.definition`\n\n### 5. Pydantic-like Parameters\n#### Pattern:\n```scheme\n(class_definition\n        superclasses : (argument_list (_) @class.extends)?\n        body: (block\n                (expression_statement\n                    (assignment type: (_)? @parameter_type) @assignment))\n        ) @class.definition\n```\n- **Description:** Captures class definitions similar to Pydantic models, focusing on parameter types in assignments.\n- **Target Node:** `@class.definition`\n\n### 6. Typed Parameters and Return Types in Functions\n#### Pattern:\n```scheme\n(function_definition\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\n    return_type: (_)? @return_type) @function.definiton\n```\n- **Description:** Captures function definitions with typed parameters and return type annotations.\n- **Target Node:** `@function.definiton`\n\n### 7. Assignments to Identifiers\n#### Pattern:\n```scheme\n(expression_statement\n    (assignment right: (identifier) @identifier.name)\n)\n```\n- **Description:** Captures assignments where the right-hand side is an identifier.\n- **Target Node:** `@identifier.name`\n\n### 8. Keyword Arguments\n#### Pattern:\n```scheme\n(keyword_argument  value: (identifier) @identifier.name)\n```\n- **Description:** Captures keyword arguments where the value is an identifier.\n- **Target Node:** `@identifier.name`\n\n### 9. Any Attribute Access\n#### Pattern:\n```scheme\n(_ (attribute) @identifier.name)\n```\n- **Description:** Captures any attribute access.\n- **Target Node:** `@identifier.name`\n\n### 10. Arguments (Identifiers Only)\n#### Pattern:\n```scheme\n(argument_list (identifier) @identifier.name)\n```\n- **Description:** Captures argument lists containing identifiers.\n- **Target Node:** `@identifier.name`\n\n### 11. Any Object Name\n#### Pattern:\n```scheme\n( _ object: _ @identifier.name)\n```\n- **Description:** Captures any object name in the codebase.\n- **Target Node:** `@identifier.name`\n\n## Conclusion\n\nThe `calls` assignment leverages a series of Tree-sitter patterns to comprehensively identify key syntactic constructs related to calls, definitions, and assignments. By targeting specific nodes, it allows for detailed parsing and analysis of code structure and semantics."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::extraAssignmentCode",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 138,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
    "summary": "# Function Documentation: `extraAssignmentCode`\n\n## Description\nThe `extraAssignmentCode` function generates a code string that represents a Tree-sitter query for identifying specific code patterns within a given module. The pattern involves an expression statement where a certain function is called. The purpose of this function is to create a query for extracting or matching parts of source code where identifiers with a specified name are used.\n\n## Parameters\n- `name` (`string`): The name of the identifier to be matched within the query string.\n\n## Returns\n- (`string`): A Tree-sitter query string that matches the specified patterns where the identifier with the given name is involved.\n\n## Example\n\n```javascript\nconst query = extraAssignmentCode('myFunc');\nconsole.log(query);\n/*\nOutputs:\n( module\n  (expression_statement\n      (call function:\n        [(identifier) @identifier.name\n           (attribute object: (identifier) @identifier.name  ) \n          ]\n      (#eq? @identifier.name \"myFunc\")\n      ) @code\n  )\n) \n\n; not used\n;( module\n;  ( decorated_definition\n;\t(decorator [\n;    \t( call (attribute object: _ @identifier.name)) \n;        (attribute object: _ @identifier.name)\n;    \t]) @code\n;    (#eq? @identifier.name \"myFunc\")\n;  )\n;)\n*/\n```\n\n## Nodes Used in the Tree-sitter Query\n\n1. **Module (`module`)**: Represents an entire module or script file.\n2. **Expression Statement (`expression_statement`)**: Matches a statement that executes an expression.\n3. **Function Call (`call`)**: Represents a function call expression.\n4. **Identifier (`identifier`)**: Matches any identifier in the code.\n5. **Attribute (`attribute`)**: Matches attribute access, such as accessing a method or property of an object.\n6. **Decorator Definition (`decorated_definition`)** (Commented out): Matches a definition that is decorated with a decorator.\n7. **Decorator (`decorator`)** (Commented out): Matches a decorator expression.\n\n## Usage\n\nThe query generated by this function can be used with Tree-sitter to analyze and find specific patterns within source code based on the provided identifier name. It is particularly useful for static code analysis, refactoring tools, or other development tools that need to process and understand code structure."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::constructorDefinitions",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 18,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`",
    "summary": "# Documentation for `constructorDefinitions` Assignment\n\n## Overview\n\n`constructorDefinitions` is an assignment that maps code parsing nodes to their respective labels. These labels are useful for identifying functions and classes within a codebase. The assignment relies on two specific nodes: `function_definition` and `class_definition`.\n\n## Assignment Details\n\n```python\nconstructorDefinitions = `\n(function_definition) @function\n(class_definition) @class\n`\n```\n\n### Nodes\n\n- **(function_definition) @function**: This node is used to identify a function definition within the code. It captures the structure and semantics of what constitutes a function.\n\n- **(class_definition) @class**: This node is utilized to recognize a class definition. It enables the mapping and parsing of classes within the code.\n\n### Usage\n\nThe `constructorDefinitions` assignment can be employed in various contexts, such as code analysis tools, linters, or any system that benefits from parsing and understanding code structure. By mapping these nodes, you can programmatically interact with functions and classes, extract their definitions, and perform operations like code generation, documentation, and validation."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::definitionTemplate",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 80,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "summary": "# Documentation for `definitionTemplate`\n\nThe `definitionTemplate` defines a Tree-sitter grammar or query that captures the structure of a function or method definition for a typical programming language, also handling global assignment statements. The template helps in identifying key components of function definitions and assignments, making it useful for generating documentation, static analysis, or other code processing tasks.\n\n## Structure\n\nThe template looks for the following nodes:\n\n- `@name`: The identifier representing the name of the function or variable.\n- `@param`: The parameters of the function, if available.\n- `@return_type`: The return type of the function, if specified.\n- `@documentation`: A string within a block that can be interpreted as documentation for the function.\n- `@body`: The body of the function, enclosed within a block.\n\nIn addition to function definitions, it also captures:\n- Global assignment statements where an identifier is assigned a value.\n\n## Template Breakdown\n\n### Function Definition\n\nThe main structure captures function definitions with optional parameters, return types, and documentation within the function body. Specifically:\n- **Main Definition**:\n    ```lisp\n    (\n      name: (identifier) @name\n      parameters: (parameters (_) @param)?\n      return_type: _? @return_type\n      body: (block \n             . \n             (expression_statement (string) @documentation)? \n             . \n             _) @body\n    )\n    ```\n  - `(identifier) @name`: Captures the function's name.\n  - `(parameters (_) @param)?`: Optionally captures the parameters.\n  - `_? @return_type`: Optionally captures the return type.\n  - `body: (block . (expression_statement (string) @documentation)? . _) @body`:\n    - `@documentation`: Optionally captures a string as documentation within the function body.\n    - `@body`: Captures the rest of the function body.\n\n### Global Assignments\n\nIn addition to function definitions, the template captures global assignment statements:\n  ```lisp\n  (expression_statement\n    (assignment left: (identifier) @name)\n  )\n  ```\n  - `(identifier) @name`: Captures the name of the variable being assigned.\n\n## Example Usage\n\nGiven a function definition:\n\n```python\ndef greet(name: str) -> str:\n    \"\"\"\n    This is the documentation.\n    \"\"\"\n    return f\"Hello, {name}!\"\n```\n\nThe template would capture:\n- The function name `greet` as `@name`.\n- The parameter `name` as `@param`.\n- The return type `str` as `@return_type`.\n- The documentation string `This is the documentation.` as `@documentation`.\n- The function body (excluding documentation) as `@body`.\n\nFor a global assignment:\n\n```python\nname = \"World\"\n```\n\nThe template would capture:\n- The variable name `name` as `@name`.\n\n## Conclusion\n\nThe `definitionTemplate` is an effective way to parse and extract key elements from function definitions and global assignments in source code. It captures identifiers, parameters, return types, documentation strings, and the bodies of functions, simplifying tasks like documentation generation and code analysis."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::assignments",
    "label": "assignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 31,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "summary": "Certainly! Below is the detailed documentation of the given assignment:\n\n---\n\n### **Assignment Documentation**\n\n#### **Syntax Tree Pattern**\n\nThe assignment utilizes the following syntax tree pattern:\n\n```scheme\n(module \n  (expression_statement\n    (assignment \n      left: (identifier)\n      right: (_)\n    )\n  ) @assignment\n)\n```\n\n#### **Explanation of the Nodes**\n\nThe following nodes are used in this assignment pattern:\n\n1. **module**\n    - This node represents the module in which the expression or statement resides. It is the top-level node that encapsulates everything within the module.\n\n2. **expression_statement**\n    - This node represents a statement that consists of an expression. In this context, it is used as a wrapper for the assignment operation.\n\n3. **assignment**\n    - This node is a key part of the pattern and represents an assignment operation. It has two child nodes: `left` and `right`, which hold the left-hand side and right-hand side of the assignment, respectively.\n\n4. **left: (identifier)**\n    - This node represents the left-hand side of the assignment operation and must be an identifier (i.e., a variable name).\n\n5. **right: (_)**\n    - This node represents the right-hand side of the assignment operation. The underscore `_` is used as a wildcard to indicate that it can match any expression, regardless of its type.\n\n6. **@assignment**\n    - This is a named pattern for the assignment node. The `@` symbol is used to capture this node as an `assignment` for easier referencing in code that processes this pattern.\n\n#### **Usage**\n\nThis syntax tree pattern is designed to match statements within a module where an assignment operation is taking place. Specifically, it captures assignments where the left-hand side is an identifier, and the right-hand side can be any expression. The named pattern `@assignment` allows for direct manipulation or inspection of these assignment operations in tools or scripts processing the syntax tree.\n\n---\n\nBy using this pattern, you can traverse and manipulate code efficiently, identifying specific types of assignment statements and performing related operations or analyses effectively."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python::importStatements",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/python",
    "totalTokens": 143,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`",
    "summary": "# Documentation for `importStatements` Assignment\n\nThe `importStatements` variable is a tree-sitter query represented as a string. It is used to identify and capture import statements in a codebase. The assignment leverages tree-sitter syntax to match various forms of import statements typically found in Python code. Below is a detailed description of each node and its structure within the `importStatements` assignment.\n\n## Query Structure\n\nThis query captures three main types of import statements:\n\n1. **Standard Import Statements**\n2. **From Import Statements**\n3. **Future Import Statements**\n\nEach type is tagged as `@import_statement` and includes specific named captures (`@module`, `@name`, `@alias`, `@wildcard`) to get relevant identifiers and their possible aliases.\n\n### 1. Standard Import Statements\n\nThe standard import statements are matched using the following node structure:\n\n```\n(import_statement\n\tname: [\n      (dotted_name) @module\n      (aliased_import name: _ @module alias: _ @alias)\n    ]\n) @import_statement\n```\n\n#### Nodes:\n- **import_statement:** Captures the entire import statement.\n- **dotted_name @module:** Captures the module being imported directly.\n- **aliased_import name: _ @module:** Captures the module name when imported with an alias.\n- **aliased_import alias: _ @alias:** Captures the alias given to the module.\n\n### 2. From Import Statements\n\nThe from import statements are matched using the following node structure:\n\n```\n(import_from_statement\n\tmodule_name: _ @module\n\tname: [\n      (dotted_name) @name\n      (aliased_import name: _ @name alias: _ @alias)\n    ]?\n    (wildcard_import _ @wildcard)?\n) @import_statement\n```\n\n#### Nodes:\n- **import_from_statement:** Captures the entire from import statement.\n- **module_name: _ @module:** Captures the base module name from which the import is made.\n- **dotted_name @name:** Captures the specific entity being imported from the module.\n- **aliased_import name: _ @name:** Captures the entity name when imported with an alias.\n- **aliased_import alias: _ @alias:** Captures the alias given to the imported entity.\n- **wildcard_import _ @wildcard:** Captures wildcard imports (e.g., `from module import *`).\n\n### 3. Future Import Statements\n\nThe future import statements are matched using the following node structure:\n\n```\n(future_import_statement \n\tname: [\n\t\t(dotted_name) @name\n\t\t(aliased_import name: _ @name alias: _ @alias)\n    ]\n) @import_statement\n```\n\n#### Nodes:\n- **future_import_statement:** Captures the entire future import statement.\n- **dotted_name @name:** Captures the specific future feature being imported.\n- **aliased_import name: _ @name:** Captures the future feature name when imported with an alias.\n- **aliased_import alias: _ @alias:** Captures the alias given to the future feature.\n\n## Purpose\n\nThis `importStatements` query is designed to effectively parse and identify import statements within a codebase, extracting relevant information like module names, imported entities, and their aliases. This is useful for static analysis, automated refactoring, and code linting.\n\n## Usage\n\nTo use this query in a tree-sitter environment, one would typically load it into a tree-sitter parser and then apply the resulting query captures to extract information from source code files accordingly.\n\nThis documentation should help users understand the structure and purpose of the `importStatements` query, aiding in its application and potential modification for more specific needs."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::anyAssignments",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 51,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "summary": "Sure, I'll generate the documentation for the assignment `anyAssignments` accordingly:\n\n### `anyAssignments`\nThe `anyAssignments` is a variable that combines a predefined query stored in `jsQueries.assignments` with a specific Tree-sitter query pattern. This pattern is designed to identify function declarations in JavaScript code where the function has annotated parameter types. Heres the complete assignment:\n\n```js\nanyAssignments = jsQueries.assignments + `\n(function_declaration\n    parameters: (formal_parameters \n        (_\n            (identifier) @left\n            (type_annotation (type_identifier) @right)\n        ) @assignment) \n)\n`\n```\n\n#### Explanation:\nThe combined query looks for JavaScript function declarations and their parameters, particularly focusing on parameters that have type annotations. Below is a breakdown of each node and how they contribute to the overall pattern:\n\n- **`function_declaration`**: This node represents the declaration of a function in JavaScript.\n- **`parameters`**: This includes the parameters section of the function declaration.\n- **`formal_parameters`**: A node that encapsulates the list of formal parameters of the function.\n- **`_`**: A generic node that matches any kind of formal parameter (with further constraints inside it).\n- **`identifier`**: This node captures the name of the parameter. It is assigned to the `@left` alias.\n- **`type_annotation`**: A node that represents the type annotation assigned to the parameter.\n- **`type_identifier`**: This captures the type identifier within the type annotation. It is assigned to the `@right` alias.\n\n#### Aliases:\n- **`@left`**: This alias captures the identifier of the function parameter.\n- **`@right`**: This alias captures the type identifier within the type annotation of the parameter.\n- **`@assignment`**: This captures the entire parameter assignment including the identifier and its type annotation.\n\n### Purpose:\nThe purpose of the `anyAssignments` query is to specifically identify function parameters that have type annotations in JavaScript code, which can be useful for static analysis, code transformation, or highlighting type information in an editor.\n\n### Example Usage:\nGiven the code snippet:\n```js\nfunction exampleFunc(param: Type) {\n    // Function body\n}\n```\nThe `anyAssignments` query would match the `param: Type` part of the function declaration, with `param` being assigned to `@left` and `Type` being assigned to `@right`.\n\n### Dependencies:\n- This query relies on the `jsQueries.assignments` base query, which should contain other relevant patterns for JavaScript code analysis.\n\nFeel free to integrate this detailed explanation into your code documentation or adjust it according to your specific needs."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::calls",
    "label": "calls",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 37,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "summary": "# Documentation for `calls` Assignment\n\n## Overview\nThe `calls` assignment is designed to extend or concatenate a predefined query string, `jsQueries.calls`, with an additional query string that is focused on type identifiers. Specifically, this assignment includes logic for handling class-type identifiers by recognizing and removing self-referential calls (i.e., calls to the class itself within its methods or attributes).\n\n## Definition\n```python\ncalls = jsQueries.calls + `\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\n(type_identifier) @parameter_type\n`\n```\n\n## Explanation\n- **Base Query (jsQueries.calls)**: This is a pre-existing query defined elsewhere in the codebase, encapsulated within a variable called `jsQueries.calls`.\n- **Concatenation**: The `+` operator is used to concatenate `jsQueries.calls` with the additional query string.\n- **Type Identifiers**: The comment in the query string specifies that it deals with type identifiers. The particular focus here is on identifying self-referential calls for classes (i.e., a class method or attribute that refers to the class itself).\n- **Query Structure**:\n  - `;`: Indicates the start of a comment in the query.\n  - `IMPORTANT!`: Highlighting the significance of handling calls to the class itself.\n  - `we need to remove it`: Explicit instruction indicating that self-referential calls should be identified and removed.\n  - `(type_identifier) @parameter_type`: The main query pattern, which matches nodes in the abstract syntax tree (AST) that are of type `type_identifier` and assigns them to a named capture, `@parameter_type`.\n\n## Nodes Involved\n\nThe `calls` assignment utilizes the following node within the AST (Abstract Syntax Tree):\n\n- **type_identifier**: This node is used to match or identify the parameters within the query that the assignment is targeting. Specifically, it captures the type identifiers in the code, which are then processed to remove self-references for class methods or attributes.\n\n## Use Case\nThis assignment is particularly useful in scenarios where:\n- You are analyzing JavaScript code to identify class methods or attributes that incorrectly or unnecessarily call themselves.\n- You need to preprocess or clean up the AST to remove such self-referential calls before performing further analysis or transformations on the code.\n\n## Example\nGiven a class definition in JavaScript:\n```javascript\nclass MyClass {\n  constructor() {\n    this.myMethod();\n  }\n\n  myMethod() {\n    MyClass.someStaticMethod();\n  }\n}\n```\nThe query would match `MyClass` as a type identifier and apply the logic needed to identify and potentially remove self-references within the class methods or attributes.\n\n## Conclusion\nThe `calls` assignment provides a way to enhance the `jsQueries.calls` by incorporating additional logic to handle and clean up self-referential calls in class-type identifiers. This is particularly useful for maintaining code quality and avoiding potential issues with recursive or redundant calls within class definitions."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::extraAssignmentCode",
    "label": "extraAssignmentCode",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "extraAssignmentCode = jsQueries.extraAssignmentCode",
    "summary": "# Documentation for `extraAssignmentCode`\n\n## Overview\nThe `extraAssignmentCode` variable is an assignment that involves JavaScript queries in the provided context. Specifically, it assigns the value of `jsQueries.extraAssignmentCode` to the `extraAssignmentCode` variable.\n\n```python\nextraAssignmentCode = jsQueries.extraAssignmentCode\n```\n\n## Nodes Involved\nThe assignment of the `extraAssignmentCode` variable utilizes the following nodes:\n\n1. **Variable Name**: `extraAssignmentCode`\n   - This node represents the name of the variable that will store the assignment result.\n\n2. **Expression**: `jsQueries.extraAssignmentCode`\n   - This node is the expression being assigned to the variable. It references a specific property, `extraAssignmentCode`, from the `jsQueries` object.\n\n### Detailed Node Breakdown\n\n- **Variable Name Node**: \n  - Name: `extraAssignmentCode`\n  - Type: `Identifier`\n  - Description: This node holds the name of the variable which will be used throughout the code to reference the value of `jsQueries.extraAssignmentCode`.\n\n- **Expression Node**:\n  - Expression: `jsQueries.extraAssignmentCode`\n  - Type: `MemberExpression`\n  - Description: This node is a member expression that accesses the `extraAssignmentCode` property of the `jsQueries` object. It effectively retrieves the value of `extraAssignmentCode` from the `jsQueries` context.\n\n## Usage\nThe `extraAssignmentCode` variable can be used throughout the remainder of the script to access the value assigned from `jsQueries.extraAssignmentCode`. This value can be utilized in various operations, functions, or passed as arguments where needed.\n\n### Example Usage\n\n```python\n# Log the value of extraAssignmentCode\nprint(extraAssignmentCode)\n\n# Use extraAssignmentCode in a function\ndef performOperation(code):\n    # Your logic here\n    pass\n\nperformOperation(extraAssignmentCode)\n```\n\n## Conclusion\nThe `extraAssignmentCode` variable assignment is straightforward, taking the value from `jsQueries.extraAssignmentCode`. Understanding the nodes involved helps in knowing the structure of the assignment and how to interact with the `extraAssignmentCode` variable in subsequent code."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::exportClauses",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = jsQueries.exportClauses",
    "summary": "# Documentation for `exportClauses` Assignment\n\n## Overview\n\nThe `exportClauses` assignment is a code snippet written in Python (or a Python-like pseudocode) that assigns the value of `jsQueries.exportClauses` to the variable `exportClauses`.\n\n```python\nexportClauses = jsQueries.exportClauses\n```\n\nThis assignment is straightforward and involves a direct assignment of a value from one variable, object, or module to another.\n\n## Nodes Involved\n\nThis assignment involves the following nodes in the syntax tree:\n\n### 1. Assignment Node\n- **Type**: Assignment (`=`).\n- **Details**: This is the core operation of the assignment where the value on the right-hand side (`jsQueries.exportClauses`) is assigned to the left-hand side variable (`exportClauses`).\n\n### 2. Variable Node (`exportClauses`)\n- **Type**: Variable.\n- **Details**: `exportClauses` is the variable being assigned a new value. It will hold the value of `jsQueries.exportClauses` after the assignment.\n\n### 3. Attribute Access Node (`jsQueries.exportClauses`)\n- **Type**: Attribute Access.\n- **Details**: This node represents the access to the `exportClauses` attribute of the `jsQueries` object or module.\n    - **Object**: `jsQueries`.\n    - **Attribute**: `exportClauses`.\n\n## Explanation\n\nThe `exportClauses` assignment is executed as follows:\n\n1. **Access `jsQueries.exportClauses`**: The code accesses the `exportClauses` attribute from the `jsQueries` object/module.\n2. **Assign to `exportClauses`**: The value obtained from `jsQueries.exportClauses` is assigned to the local variable `exportClauses`.\n\nThe specific roles of each node in this assignment are:\n\n- **Assignment Node**: Facilitates the assignment operation connecting `exportClauses` to `jsQueries.exportClauses`.\n- **Variable Node (`exportClauses`)**: Serves as the container to store the assigned value.\n- **Attribute Access Node (`jsQueries.exportClauses`)**: Retrieves the value of the `exportClauses` attribute from the `jsQueries` object, essential for establishing the value to be assigned.\n\nIn summary, the documentation details the process and syntactic structure involved in assigning a module or object attribute value to a variable. This helps clarify the components and execution of the assignment."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::constructorDefinitions",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 103,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`",
    "summary": "## Documentation: `constructorDefinitions` Assignment\n\n### Overview\n\nThe assignment `constructorDefinitions` is designed to extend the existing set of JavaScript query definitions (`jsQueries.constructorDefinitions`) by adding additional queries that identify various TypeScript constructs such as interfaces, enums, and types, including those that are exportable. This assignment provides syntax tree patterns for identifying and labeling these constructs within a TypeScript program.\n\n### Syntax Tree Nodes\n\nThis assignment leverages different syntax tree nodes to identify specific constructs within a TypeScript codebase. Below are the descriptions of these node types:\n\n1. **Method Signature (method_signature)**\n   - **Annotation**: `@function`\n   - **Description**: A syntax tree node that matches method signatures within an interface.\n\n2. **Interface Declaration (interface_declaration)**\n   - **Annotation**: `@interface`\n   - **Description**: A syntax tree node that identifies interface declarations.\n\n3. **Enum Declaration (enum_declaration)**\n   - **Annotation**: `@enum`\n   - **Description**: A syntax tree node that matches enumeration declarations.\n\n4. **Type Alias Declaration Within a Program (program > type_alias_declaration)**\n   - **Annotation**: `@type`\n   - **Description**:\n     - This node captures type alias declarations at the root level of a program.\n     - The `name` child node specifies the alias name, and the `value` child node (which does not include a body) specifies the aliased type.\n\n5. **Exportable Type Alias Declaration (program > export_statement > type_alias_declaration)**\n   - **Annotation**: `@type`\n   - **Description**:\n     - This node captures type alias declarations that are explicitly exported.\n     - Similar to the previous type alias declarations, this includes `name` and `value` child nodes where the `value` must not include a body.\n\n### Assignment Code\n\n```javascript\nconstructorDefinitions = jsQueries.constructorDefinitions + `\n; interfaces\n(method_signature)? @function\n(interface_declaration) @interface\n\n; enums\n(enum_declaration) @enum\n\n; type\n(program\n    ( type_alias_declaration\n        name: (_)\n        value: (_ !body)\n    ) @type\n) \n\n; type exportables\n(program\n    (export_statement\n        ( type_alias_declaration\n            name: (_)\n            value: (_ !body)\n        ) @type\n    )\n)\n`\n```\n\n### Structure\n\n#### Interfaces\n\n- **Query**: \n  ``` \n  (method_signature)? @function\n  (interface_declaration) @interface\n  ```\n- **Details**:\n  - Matches method signatures within interfaces and the interfaces themselves.\n\n#### Enums\n\n- **Query**: \n  ``` \n  (enum_declaration) @enum\n  ```\n- **Details**:\n  - Matches enumeration declarations.\n\n#### Type Alias Declaration\n\n- **Query**: \n  ``` \n  (program\n      ( type_alias_declaration\n          name: (_)\n          value: (_ !body)\n      ) @type\n  )\n  ```\n- **Details**:\n  - Captures type alias declarations where the `value` is not a body block.\n\n#### Exportable Type Alias Declaration\n\n- **Query**: \n  ``` \n  (program\n      (export_statement\n          ( type_alias_declaration\n              name: (_)\n              value: (_ !body)\n          ) @type\n      )\n  )\n  ```\n- **Details**:\n  - Captures type alias declarations that are exported.\n\n### Conclusion\n\nThe `constructorDefinitions` assignment provides a set of syntax tree patterns to identify and label TypeScript constructs such as interfaces, enums, and types, including those that are exported. These definitions extend existing JavaScript queries to better support TypeScript code analysis."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::definitionTemplate",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 126,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "summary": "# Documentation for `definitionTemplate` Assignment\n\n## Overview:\nThe `definitionTemplate` assignment defines a template for extracting information about method signatures and arrow functions from a given syntax tree. This template is used to capture the following details about method signatures and variable declarations involving arrow functions:\n- Name of the function or variable\n- Formal parameters of the function\n- Return type of the function\n- Body of the function (if present)\n\n## Structure:\nThe template is structured to match either a method signature (with or without a body) or a variable declaration that assigns an arrow function.\n\n### Components:\n1. **name:** Captures the name of the method or variable using the label `@name`.\n2. **parameters:** Optionally captures the formal parameters using the label `@param`.\n3. **return_type:** Optionally captures the return type of the function using the label `@return_type`.\n4. **body:** Optionally captures the body of the function using the label `@body`.\n\n## Template Nodes Description:\n\n### Method Signatures:\n```\n(\n    _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    return_type: (type_annotation)? @return_type\n    ; method signatures have no body\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n```\n- `name`: Captures the name of the method.\n- `parameters`: Optionally captures the formal parameters of the method.\n- `return_type`: Optionally captures the return type of the method.\n- `body`: Optionally captures the body of the method if present.\n\n### Arrow Function in Variable Declaration:\n```\n(variable_declarator\n    name: (_) @name\n    value: (arrow_function\n        parameters: (formal_parameters (_) @param)?\n        return_type: (type_annotation)? @return_type\n        body: (_)? @body\n    )\n)?\n```\n- `name`: Captures the name of the variable.\n- `parameters`: Optionally captures the formal parameters of the arrow function.\n- `return_type`: Optionally captures the return type of the arrow function.\n- `body`: Optionally captures the body of the arrow function if present.\n\n## Purpose:\nThis template is designed to be used in tools like syntax tree parsers, linters, or IDEs that require extraction and analysis of code structure, specifically for methods and arrow functions. It helps in identifying key components of method signatures or arrow functions, such as names, parameters, return types, and bodies.\n\n## Example Use Case:\nConsider a method signature or an arrow function in the following code snippet:\n```javascript\nfunction foo(a, b): number {\n    return a + b;\n}\n```\nUsing the `definitionTemplate`, you can extract:\n- `name`: `foo`\n- `parameters`: `(a, b)`\n- `return_type`: `number`\n- `body`: `{ return a + b; }`\n\nSimilarly, for an arrow function assigned to a variable:\n```javascript\nconst sum = (a, b) => a + b;\n```\nYou can extract:\n- `name`: `sum`\n- `parameters`: `(a, b)`\n- `body`: `a + b`\n\nThis template allows automated tools to process and analyze such code structures efficiently.\n\nThe `definitionTemplate` thus serves as a powerful means to abstract and gather essential details from method signatures and arrow functions within a codebase.\n\n## Conclusion:\nBy using `definitionTemplate`, developers and tools can systematically capture and leverage method and arrow function details, facilitating code analysis and transformation tasks in a structured and consistent manner."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript::importStatements",
    "label": "importStatements",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/queries/typescript",
    "totalTokens": 7,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = jsQueries.importStatements",
    "summary": "# Documentation: Import Statements Assignment\n\n## Overview\nThe `importStatements` assignment is used to reference import statements defined within JS queries. This assignment serves as a means to fetch or manipulate import statements in JavaScript code using the provided `jsQueries.importStatements`.\n\n## Assignment Definition\n\n```python\nimportStatements = jsQueries.importStatements\n```\n\n## Nodes Used\n\nThis assignment utilizes nodes from the `jsQueries` module. The specific node used in this assignment is `importStatements`, which represents a query or collection of JavaScript import statements.\n\n### Nodes\n\n#### `jsQueries.importStatements`\n\n- **Description**: Represents a collection of JavaScript import statements.\n- **Usage**: This node is presumably used to query, analyze, or manipulate import statements within JavaScript code. It provides a structured way to handle import declarations.\n\n## Example Usage\n\nTo illustrate how `importStatements` might be used in a JavaScript querying context, here is a hypothetical example:\n\n```javascript\nconst importStatements = jsQueries.importStatements;\n\n// Assuming `importStatements` fetches all import declarations:\nimportStatements.getAll().forEach(importStatement => {\n    console.log(`Importing: ${importStatement}`);\n});\n```\n\nIn this example, `importStatements.getAll()` is a method that retrieves all import declarations in the code, and each import statement is then logged to the console.\n\n## Purpose\n\nThe primary purpose of the `importStatements` assignment is to facilitate the handling of JavaScript import declarations systematically. It allows for consistent querying and potentially modifying import statements, aiding in tasks such as code analysis, refactoring, or dependency management.\n\n## Common Use Cases\n\n- **Analyzing Imports**: Extracting and analyzing all import statements in a codebase to understand dependencies.\n- **Refactoring**: Modifying import paths or names during code refactoring processes.\n- **Code Generation**: Generating import statements dynamically based on certain criteria or code generation processes.\n\nBy leveraging `jsQueries.importStatements`, developers can streamline these tasks, ensuring a consistent and reliable method for handling import statements in JavaScript projects."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph-test::repoRequestValidator",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph-test",
    "totalTokens": 63,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)",
    "summary": "# Documentation for `repoRequestValidator`\n\n## Description\nThe `repoRequestValidator` is an assignment that creates a validation schema using the `zValidator` function. This schema is designed to validate a JSON object representing a request to access a repository. The request object must contain information about the git provider, repository organization, repository name, branch, and connection ID.\n\n## Components\n\n### 1. `zValidator`\n`zValidator` is a function that accepts two parameters: a type indicator (in this case, 'json') and a validation schema. It returns a validator that can be used to validate data according to the schema.\n\n### 2. `z`\n`z` is an instance of a validation library (commonly `zod`), which provides tools for defining and composing schema-based validators.\n\n### 3. `z.object()`\n`z.object({...})` is a function from the validation library that constructs an object schema. This schema defines the structure and the types of a valid object.\n\n### 4. `z.enum()`\n`z.enum([...])` is a function that creates a schema for an enumerated type. The provided array lists the allowed values for this type.\n\n### 5. `z.string()`\n`z.string()` is a function that constructs a string schema, requiring the value to be of string type.\n\n## Schema Definition\nThe validation schema for `repoRequestValidator` ensures that a given JSON object complies with the following structure and constraints:\n\n- **git_provider**: A required field that must be one of the following string values: 'github', 'gitlab', 'bitbucket'.\n- **repo_org**: A required string that represents the organization that owns the repository.\n- **repo_name**: A required string that represents the name of the repository.\n- **branch**: A required string that represents the branch of the repository to access.\n- **connection_id**: A required string that represents the unique connection identifier.\n\n### Example\nHeres an example of a valid JSON object according to this schema:\n\n```json\n{\n  \"git_provider\": \"github\",\n  \"repo_org\": \"exampleOrg\",\n  \"repo_name\": \"exampleRepo\",\n  \"branch\": \"main\",\n  \"connection_id\": \"abc123\"\n}\n```\n\n## Usage\nTo validate a JSON object using `repoRequestValidator`, you would typically follow these steps:\n\n1. **Import the validator library (`zod`) and `zValidator` function**:\n   ```javascript\n   import { z } from 'zod';\n   import { zValidator } from 'your-validator-library';\n   ```\n\n2. **Use the `repoRequestValidator` to validate a JSON object**:\n   ```javascript\n   const requestData = {\n     git_provider: 'github',\n     repo_org: 'exampleOrg',\n     repo_name: 'exampleRepo',\n     branch: 'main',\n     connection_id: 'abc123'\n   };\n\n   try {\n     repoRequestValidator.parse(requestData);\n     console.log(\"Validation successful!\");\n   } catch (e) {\n     console.error(\"Validation failed:\", e.errors);\n   }\n   ```\n\nIf the `requestData` object conforms to the schema, the validation will succeed; otherwise, an error will be thrown detailing which part of the object is invalid."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph-test::secret",
    "label": "secret",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph-test",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "summary": "# Documentation for Assignment: `secret`\n\n## Description\nThe assignment `secret` is used to obtain a value from an environment variable named `SUPABASE_JWT`. This value is likely a JSON Web Token (JWT) used for authentication purposes in a secure environment. This assignment leverages the function `getEnv` to fetch the value from the environment.\n\n## Format\n\n```python\nsecret = getEnv('SUPABASE_JWT')\n```\n\n## Components\n\nThe assignment `secret` comprises the following elements:\n\n### 1. `secret`\n- **Type**: Variable\n- **Description**: Holds the value fetched from the environment variable `SUPABASE_JWT`. This is expected to be a string representing a JSON Web Token.\n\n### 2. `getEnv`\n- **Type**: Function\n- **Description**: A function used to obtain the value of environment variables. The function typically takes the name of the environment variable as a parameter and returns the corresponding value as a string.\n- **Parameters**:\n  - `variable_name` (str): The name of the environment variable. In this context, it is `SUPABASE_JWT`.\n- **Returns**: The value of the requested environment variable (in this case, a JWT token).\n\n## Usage\n\n### Example\nTo assign the value of the `SUPABASE_JWT` environment variable to the variable `secret`, use the following code:\n\n```python\nsecret = getEnv('SUPABASE_JWT')\n```\n\n### Explanation\nThe code snippet fetches the value of the `SUPABASE_JWT` environment variable using the `getEnv` function and assigns it to the variable `secret`. This value can then be used for authentication or other security-related tasks within your application.\n\n## Dependencies\n\n- **Environment Variable**: `SUPABASE_JWT` must be set in the environment where this code is executed. If this environment variable is not set, `getEnv` might return `None` or raise an error, depending on its implementation.\n- **getEnv Function**: Ensure the `getEnv` function is defined and accessible in the scope where this code is executed.\n\n## Error Handling\nMake sure to handle potential errors gracefully:\n- If `getEnv('SUPABASE_JWT')` returns `None` or raises an error, appropriate fallback mechanisms should be in place to avoid runtime exceptions.\n- Consider logging an informative message if the environment variable is not set.\n\n## Security Considerations\n- Environment variables, especially those holding sensitive information like JWTs, should be managed securely to prevent unauthorized access.\n- Ensure the `SUPABASE_JWT` environment variable is set in a secure manner and not hard-coded in source files, which could expose the token to version control systems.\n\n## Conclusion\n\nThe `secret` assignment is pivotal for fetching and securing authentication tokens via environment variables. Properly configuring the `SUPABASE_JWT` environment variable and the `getEnv` function is crucial for the correct and secure operation of your application."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph::processGraphCreation",
    "label": "processGraphCreation",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 693,
    "inDegree": 2,
    "outDegree": 1,
    "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\r\n  let graphId = uuidv4()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    // create a uuid for each node\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\r\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\r\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\r\n        }, ${fullName}, ${node.label})\r\n    `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label)\r\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label})\r\n    `\r\n    })\r\n\r\n    await Promise.all(insertNodePromises)\r\n    await Promise.all(insertLinkPromises)\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "summary": "Here is the detailed documentation for the `processGraphCreation` function:\n\n### `processGraphCreation`\n\nAsynchronous function that processes the creation of a graph for a given codebase repository. It handles the insertion of graph metadata, nodes, and links into a database, and it updates the status of the graph creation process accordingly.\n\n#### Parameters\n\n- **`gitProvider`** (`GitServiceType`): The Git service provider (e.g., GitHub, GitLab, Bitbucket).\n- **`repoId`** (`string`): The repository ID.\n- **`userOrgId`** (`string`): The user organization ID.\n- **`userId`** (`string`): The user ID.\n- **`graphExists`** (`boolean`): Boolean flag to indicate if the graph already exists.\n- **`connectionId`** (`string`): The connection ID for the Git service provider.\n- **`codebasePath`** (`string`): The path to the codebase.\n\n#### Returns\n\nThis function does not return any value.\n\n#### Description\n\n1. **Initialization**:\n    - A `graphId` is generated using `uuidv4()`.\n    - Sets the initial status of the graph: `'completed'` if `graphExists` is `true`, otherwise `'pending'`.\n    \n2. **Sanity Check**:\n    - If `codebasePath` is not provided, logs an error message and exits the function.\n\n3. **Graph Metadata Setup**:\n    - Constructs a graph metadata object using provided parameters (`repoId`, `userOrgId`, `userId`, `status`, etc.).\n    - Sets the appropriate connection ID field based on the `gitProvider`.\n\n4. **Database Insertion**:\n    - Inserts the graph metadata into the `graphs` table.\n\n5. **Pre-existing Graph Handling**:\n    - If the graph already exists (`graphExists` = `true`), logs a completion message and exits the function.\n\n6. **Codebase Parsing**:\n    - Creates a new `Codebase` instance using the `codebasePath`.\n    - Parses the codebase folder to create a map of file nodes.\n    - Simplifies the parsed data into a list of nodes.\n\n7. **Node Handling**:\n    - Generates unique IDs (`uuidv4()`) for each node.\n    - Constructs SQL insertion promises for each node to insert them into the `nodes` table.\n\n8. **Link Handling**:\n    - Extracts links from the codebase and constructs SQL insertion promises to insert them into the `links` table.\n\n9. **Database Updates**:\n    - Executes all node and link insertion promises in parallel using `Promise.all`.\n    - Updates the graph status to `'completed'` in the `graphs` table.\n\n10. **Error Handling**:\n    - Catches any errors during the process, logs the error message, and updates the graph status to `'failed'` in the `graphs` table.\n\n#### Example Usage\n\n```typescript\nconst result = await processGraphCreation({\n  gitProvider: 'github',\n  repoId: '12345',\n  userOrgId: '67890',\n  userId: '112233',\n  graphExists: false,\n  connectionId: '445566',\n  codebasePath: '/path/to/codebase'\n});\n```\n\n### Notes\n\n- This function is heavily dependent on an underlying SQL database for storage and retrieval.\n- The `Codebase` class and `uuidv4` function are assumed to be defined externally.\n- The SQL operations use a tagged template literal via a library like `slonik` or similar for SQL injection safety and query construction.\n  \nEnsure your environment has all the necessary dependencies and the database schema matches the expected tables (`graphs`, `nodes`, `links`). Also, handle Git service types appropriately in the codebase and map your code structure accordingly."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph::repoRequestValidator",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 74,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "summary": "# Documentation for `repoRequestValidator`\n\n## Overview\n\nThe `repoRequestValidator` is a schema validator that ensures a JSON object conforms to the specified structure. It uses the `zValidator` function from the `zod` library to enforce schema constraints.\n\n## Schema Definition\n\nThe `repoRequestValidator` enforces the following structure on the input JSON object:\n\n1. **git_provider**: A required field that must be one of the following strings: `'github'`, `'gitlab'`, or `'bitbucket'`.\n2. **repo_org**: A required string field representing the repository organization.\n3. **repo_name**: A required string field representing the repository name.\n4. **branch**: A required string field representing the branch name.\n5. **connection_id**: A required string field representing the connection identifier.\n6. **gitlab_repo_id**: An optional number field representing the GitLab repository ID.\n\n## Example Usage\n\nHere is an example of how to use the `repoRequestValidator`:\n\n```javascript\nconst { parse, z } = require(\"zod\");\n\n// Define the schema using zod\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\n    repo_org: z.string(),\n    repo_name: z.string(),\n    branch: z.string(),\n    connection_id: z.string(),\n    gitlab_repo_id: z.number().optional()\n  })\n);\n\n// Sample JSON object to validate\nconst validRepoRequest = {\n  \"git_provider\": \"github\",\n  \"repo_org\": \"example_org\",\n  \"repo_name\": \"example_repo\",\n  \"branch\": \"main\",\n  \"connection_id\": \"12345-abcde\"\n};\n\n// Validate the JSON object\ntry {\n  repoRequestValidator.parse(validRepoRequest);\n  console.log(\"Validation succeeded.\");\n} catch (e) {\n  console.error(\"Validation failed:\", e.errors);\n}\n```\n\nIn this example, the `validRepoRequest` object is validated against the `repoRequestValidator` schema. If the object conforms to the schema, validation succeeds; otherwise, it fails and provides validation error details.\n\n## Breakdown of Nodes\n\nThe assignment uses the following nodes:\n\n### `zValidator('json', schema)`\n\n- **Purpose**: Creates a schema validator for JSON objects.\n- **Parameters**:\n  - **'json'**: The format type indicating the expected input will be a JSON object.\n  - **schema**: The Zod schema definition that the validator will enforce on the given JSON object.\n\n### `z`\n\n- **Purpose**: Imported object from the `zod` library used to construct schemas.\n- **Methods**:\n  - `z.enum([...])`: Defines an enumeration type.\n  - `z.string()`: Defines a string type.\n  - `z.number()`: Defines a number type.\n  - `z.object({...})`: Defines an object schema.\n  - `z.object({...}).optional()`: Marks a field as optional within an object schema.\n\n## Conclusion\n\nThe `repoRequestValidator` is a powerful tool to enforce that incoming JSON data conform to a specific schema, providing robust validation for repository request objects in systems interacting with Git providers like GitHub, GitLab, and Bitbucket."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph::secret",
    "label": "secret",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "summary": "Certainly! Here is the documentation for the assignment `secret`:\n\n---\n\n### `secret` Assignment Documentation\n\n#### Description\nThe `secret` assignment retrieves a value from the environment variables using the `getEnv` function. Specifically, it fetches the value associated with the `SUPABASE_JWT` environment variable and assigns it to the `secret` variable.\n\n#### Syntax\n\n```python\nsecret = getEnv('SUPABASE_JWT')\n```\n\n#### Nodes Used:\n- **Function Call**: `getEnv`\n  - **Parameter**: `'SUPABASE_JWT'` (A string that specifies the name of the environment variable)\n\n#### Parameters\n- `SUPABASE_JWT`: This is the name of the environment variable whose value needs to be fetched. It is expected that this environment variable contains a JWT (JSON Web Token) required for authentication or other secure purposes.\n\n  - **Type**: `String`\n  - **Example Value**: `'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'`\n\n#### Returns\n- The `getEnv` function returns the value associated with the `'SUPABASE_JWT'` environment variable.\n  - **Type**: `String`\n  - **Example Value**: `'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'`\n\n#### Example Usage\nBelow is a simple example demonstrating how the `secret` assignment might be used within a codebase:\n\n```python\n# Import the necessary module to access environment variables\nfrom some_module import getEnv\n\n# Retrieve the JWT token from environment variables\nsecret = getEnv('SUPABASE_JWT')\n\n# Now you can use the 'secret' token for authentication or other purposes\nprint(\"The JWT token is: \", secret)\n```\n\n#### Additional Notes\n- Ensure that the environment variable `SUPABASE_JWT` is correctly set in your environment before running your application, as failure to do so will result in `getEnv` returning `None` or raising an error, depending on the implementation of the `getEnv` function.\n- The `getEnv` function is typically part of an environment handling utility provided by libraries or custom application code.\n\n---\n\nThis documentation should help clarify how the `secret` assignment works and provide necessary details for future reference or usage in a project."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/bitbucket/refresh-token::refreshAccessToken",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/bitbucket/refresh-token",
    "totalTokens": 245,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "summary": "# `refreshAccessToken` Function Documentation\n\n## Description\nThe `refreshAccessToken` function is an asynchronous function designed to refresh an expired access token using a provided refresh token. This is particularly useful for maintaining authenticated sessions with services, such as Bitbucket, that use OAuth2 for authentication.\n\n## Syntax\n```typescript\nasync function refreshAccessToken(refreshToken: string): Promise<any>\n```\n\n## Parameters\n- `refreshToken` (string): The refresh token provided by the OAuth2 service, used to obtain a new access token and potentially a new refresh token.\n\n## Returns\n- `Promise<any>`: Returns a Promise that resolves to an object containing the new access token and refresh token if successful. If the operation fails, it returns `null`.\n\n## Nodes Used\n- `fetch`: Used to make an HTTP POST request to the Bitbucket OAuth2 token endpoint.\n- `getEnv`: Presumably a utility function to retrieve environment variables, although it is not defined within this function. It is used to get the `BITBUCKET_KEY` and `BITBUCKET_SECRET`.\n\n## Example Usage\n```typescript\nconst refreshToken = 'your-refresh-token-here';\n\nrefreshAccessToken(refreshToken)\n  .then(tokenData => {\n    if (tokenData) {\n      console.log('New Access Token:', tokenData.newAccessToken);\n      console.log('New Refresh Token:', tokenData.newRefreshToken);\n    } else {\n      console.log('Failed to refresh token.');\n    }\n  })\n  .catch(error => {\n    console.error('Unexpected error:', error);\n  });\n```\n\n## Implementation Details\n1. **Constructing Request Body**:\n   - The function constructs a request body with `refresh_token`, `grant_type`, `client_id`, and `client_secret` parameters.\n   - The `client_id` and `client_secret` are fetched using `getEnv` function calls with the keys `BITBUCKET_KEY` and `BITBUCKET_SECRET` respectively.\n   - These parameters are transformed into a URL-encoded string.\n\n2. **Sending the Request**:\n   - A POST request is sent to the endpoint `https://bitbucket.org/site/oauth2/access_token` with the constructed request body and appropriate headers (`Content-Type: application/x-www-form-urlencoded`).\n\n3. **Handling the Response**:\n   - If the response is successful (`res.ok`), the function extracts `access_token` and `refresh_token` from the response JSON and returns them.\n   - If the response is not successful, it logs an error message along with the response data and returns `null`.\n\n4. **Error Handling**:\n   - The function includes a try-catch block to handle any unexpected errors, logging the error and returning `null`.\n\n## Error Handling\nErrors during the request or invalid responses will be caught and logged to the console. The function ensures that `null` is returned in case of failures to signal the calling code that the token refresh operation was not successful.\n\nThis completes the documentation of the `refreshAccessToken` function. For this function to work properly, ensure that the `getEnv` function is correctly implemented and that `fetch` is available in your runtime environment."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/db::sql",
    "label": "sql",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/db",
    "totalTokens": 106,
    "inDegree": 0,
    "outDegree": 1,
    "code": "sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "summary": "# SQL Configuration Assignment Documentation\n\nThis documentation provides an overview and detailed explanation of the SQL configuration assignment using the `postgres` client within a Node.js environment. This assignment is focused on connecting to a PostgreSQL database.\n\n## Overview\n\nThe variable `sql` is an instance of the `postgres` client, configured to connect to a PostgreSQL database using environment variables for sensitive information such as the host, database name, port, username, and password. It also includes specific configurations for connection and idle timeout, as well as SSL configuration.\n\n## Configuration Details\n\nThe configuration object passed to `postgres` contains multiple parameters, each serving a distinct purpose for establishing and maintaining the database connection.\n\n### Parameters\n\n- **host**: \n  - Type: `String`\n  - Description: The hostname or IP address of the PostgreSQL server.\n  - Value Source: `process.env.DATABASE_HOST`\n  - Fetched using: `getEnv('DATABASE_HOST')`\n\n- **database**: \n  - Type: `String`\n  - Description: The name of the PostgreSQL database to connect to.\n  - Value Source: `process.env.DATABASE_NAME`\n  - Fetched using: `getEnv('DATABASE_NAME')`\n\n- **port**: \n  - Type: `Number`\n  - Description: The port number on which the PostgreSQL server is listening.\n  - Value Source: `process.env.DATABASE_PORT`\n  - Fetched using: `getEnv('DATABASE_PORT')`\n  - Converted to Number using: `Number`\n\n- **user**: \n  - Type: `String`\n  - Description: The username to authenticate with the PostgreSQL server.\n  - Value Source: `process.env.DATABASE_USERNAME`\n  - Fetched using: `getEnv('DATABASE_USERNAME')`\n\n- **password**: \n  - Type: `String`\n  - Description: The password to authenticate with the PostgreSQL server.\n  - Value Source: `process.env.DATABASE_PASSWORD`\n  - Fetched using: `getEnv('DATABASE_PASSWORD')`\n\n- **prepare**: \n  - Type: `Boolean`\n  - Description: Whether to prepare statements or not. This can improve performance but may cause issues with some PostgreSQL versions.\n  - Default Value: `false`\n\n- **connect_timeout**: \n  - Type: `Number`\n  - Description: The maximum time in seconds to wait for a connection attempt to succeed.\n  - Default Value: `60`\n\n- **idle_timeout**: \n  - Type: `Number`\n  - Description: The maximum time in seconds that a connection can be idle before being closed.\n  - Default Value: `60`\n\n- **ssl**: \n  - Type: `Object`\n  - Description: SSL configuration object. Used to secure the connection to the PostgreSQL server.\n  - Fields:\n    - **ca**: \n      - Type: `String`\n      - Description: Certificate authority certificate for SSL connection.\n      - Value Source: `process.env.SUPABASE_CA_CERTIFICATE`\n      - Fetched using: `getEnv('SUPABASE_CA_CERTIFICATE')`\n    - **rejectUnauthorized** (commented section): \n      - Type: `Boolean`\n      - Description: If set to `false`, it allows connecting to servers without a trusted CA certificate.\n      - Default Value: `true` (standard not to include it unless specified otherwise)\n\n## Environment Variables\n\nThis configuration relies on several environment variables, which need to be set for the application to successfully connect to the PostgreSQL database. The variables are accessed using the `getEnv()` function, which retrieves their values from the environment:\n\n- `DATABASE_HOST`\n- `DATABASE_NAME`\n- `DATABASE_PORT`\n- `DATABASE_USERNAME`\n- `DATABASE_PASSWORD`\n- `SUPABASE_CA_CERTIFICATE`\n\n### Example Usage\n\nEnsure the environment variables are set before running the application:\n\n```bash\nexport DATABASE_HOST=your-db-host\nexport DATABASE_NAME=your-db-name\nexport DATABASE_PORT=5432\nexport DATABASE_USERNAME=your-db-username\nexport DATABASE_PASSWORD=your-db-password\nexport SUPABASE_CA_CERTIFICATE=your-ca-certificate\n```\n\nAfter setting the environment variables, `sql` can be used to interact with the PostgreSQL database:\n\n```javascript\nsql`SELECT * FROM users`.then(users => {\n  console.log(users)\n}).catch(err => {\n  console.error('Database Error:', err)\n});\n```\n\n## Conclusion\n\nThe `sql` assignment creates a configured connection to a PostgreSQL database using the `postgres` client, with settings driven by environment variables for flexibility and security. Proper SSL configuration ensures secure connections, abiding by best practices for sensitive data management."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/git::getCommitHash",
    "label": "getCommitHash",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/git",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
    "summary": "# Function Documentation: `getCommitHash`\n\n## Overview\nThe `getCommitHash` function extracts and returns the commit hash from the data provided by different version control providers. It currently supports GitHub, GitLab, and Bitbucket.\n\n## Function Signature\n\n```typescript\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string\n```\n\n## Parameters\n\n- `provider: 'github' | 'gitlab' | 'bitbucket'`\n  - A string specifying the version control provider. It must be one of `'github'`, `'gitlab'`, or `'bitbucket'`.\n  - Type: `string`\n  - Required: Yes\n\n- `data: any`\n  - The data object from which the commit hash will be extracted. The structure of this object depends on the provider.\n  - Type: `any`\n  - Required: Yes\n\n## Return Value\n\n- **Returns**: `string`\n  - The function returns the commit hash as a string. The specific property of the data object from which the commit hash is extracted depends on the provider:\n    - For `github`, it returns the value of the `sha` property from the first item in the data array.\n    - For `gitlab`, it returns the value of the `id` property from the first item in the data array.\n    - For `bitbucket`, it returns the value of the `hash` property from the first item in the `values` array within data.\n  - If the provider does not match any of the supported providers, the function returns an empty string.\n\n## Usage\n\n### Example 1: GitHub\n\n```javascript\nconst githubData = [{ sha: 'a1b2c3d4e5f6g7h8i9j0' }];\nconst commitHash = getCommitHash('github', githubData);\nconsole.log(commitHash); // Output: 'a1b2c3d4e5f6g7h8i9j0'\n```\n\n### Example 2: GitLab\n\n```javascript\nconst gitlabData = [{ id: '1234567890abcdef' }];\nconst commitHash = getCommitHash('gitlab', gitlabData);\nconsole.log(commitHash); // Output: '1234567890abcdef'\n```\n\n### Example 3: Bitbucket\n\n```javascript\nconst bitbucketData = { values: [{ hash: 'abcdef1234567890' }] };\nconst commitHash = getCommitHash('bitbucket', bitbucketData);\nconsole.log(commitHash); // Output: 'abcdef1234567890'\n```\n\n### Example 4: Unsupported Provider\n\n```javascript\nconst unsupportedData = {};\nconst commitHash = getCommitHash('unsupported', unsupportedData);\nconsole.log(commitHash); // Output: ''\n```\n\n## Notes\n\n- Ensure that the data object structure aligns with the expected structure for the specified provider to prevent runtime errors.\n- The function currently supports only GitHub, GitLab, and Bitbucket. For other providers, the function will return an empty string.\n\n## Implementation Details\n\nThis function uses simple conditional checks (`if`-`else if` statements) to determine how to extract the commit hash based on the provider. Here are the detailed steps it performs:\n1. Check which provider is specified.\n2. Extract the commit hash from the corresponding property of the data object based on the provider.\n3. Return the extracted commit hash.\n4. If the provider does not match any supported ones, return an empty string.\n\nThis simple, yet effective, approach ensures proper commit hash extraction for the supported providers."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/git::MAXSIZE",
    "label": "MAXSIZE",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/git",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "MAXSIZE = 2",
    "summary": "# MAXSIZE Assignment Documentation\n\n```python\nMAXSIZE = 2\n```\n\n## Overview\nThe above assignment is a simple variable declaration in Python. The variable `MAXSIZE` is assigned the integer value `2`.\n\n## Description\nThis assignment sets the value of `MAXSIZE` to `2`. `MAXSIZE` can be used as a constant in the program to represent a threshold, limit, or configuration setting. Typically, constants like this are written in uppercase to distinguish them from other variables.\n\n## Nodes Involved\n- **Assignment Node** (`=`):\n  - Assigns the value on the right-hand side (`2`) to the variable on the left-hand side (`MAXSIZE`).\n\n- **Name Node** (`MAXSIZE`):\n  - Represents the identifier to which a value is assigned. In this context, `MAXSIZE` is the name of the variable being assigned a value.\n\n- **Constant Node** (`2`):\n  - Represents the literal value that is being assigned to the variable. In this context, `2` is the integer value being assigned to `MAXSIZE`.\n\n## Usage\n`MAXSIZE` can be used anywhere in the program to reference the value `2`, ensuring consistency and making it easier to update the value in one place if needed.\n\nExample:\n```python\nif len(items) > MAXSIZE:\n    print(\"Exceeded the maximum size.\")\n```\n\n## Notes\n- The naming convention of using all uppercase letters for `MAXSIZE` indicates that it is intended to be a constant value.\n- It is a common practice to define such constants at the beginning of a program/module or in a separate configuration file.\n\nThis assignment is straightforward but can be crucial in setting limits or configuration parameters that the rest of the program can rely on."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/gitlab/refresh-token::refreshAccessToken",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/gitlab/refresh-token",
    "totalTokens": 237,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "summary": "Certainly! Below is the documentation for the `refreshAccessToken` function.\n\n---\n\n## `refreshAccessToken`\n\n### Description\nThe `refreshAccessToken` function refreshes an access token using a given refresh token by making a request to the GitLab OAuth endpoint. It returns a promise that resolves with the new access token and refresh token, or `null` in case of an error.\n\n### Parameters\n- `refreshToken` (string): The refresh token used to request a new access token and refresh token.\n\n### Returns\n- `Promise<any>`: A promise that resolves to an object containing the new access token and refresh token if successful. If an error occurs, the promise resolves to `null`.\n\n### Usage\n```javascript\nconst newTokens = await refreshAccessToken(existingRefreshToken);\nif (newTokens) {\n  console.log('New access token:', newTokens.newAccessToken);\n  console.log('New refresh token:', newTokens.newRefreshToken);\n} else {\n  console.log('Failed to refresh access token.');\n}\n```\n\n### Example\n```javascript\nasync function example() {\n  const existingRefreshToken = 'your-existing-refresh-token';\n  const tokens = await refreshAccessToken(existingRefreshToken);\n\n  if (tokens) {\n    console.log('New access token:', tokens.newAccessToken);\n    console.log('New refresh token:', tokens.newRefreshToken);\n  } else {\n    console.error('Failed to refresh access token.');\n  }\n}\n\nexample();\n```\n\n### Implementation Details\n1. **API Endpoint:** The function constructs a URL for the GitLab OAuth token endpoint (`https://gitlab.com/oauth/token`) and sets the required query parameters.\n2. **Request Method:** It sends a POST request with the required headers (`Content-Type` and `Accept`).\n3. **Response Handling:**\n   - If the request is successful (`res.ok`), it extracts the `access_token` and `refresh_token` from the JSON response and returns them.\n   - If the request fails, it logs the error details to the console and returns `null`.\n4. **Error Handling:** Any unexpected errors caught during the process are logged to the console, and the function returns `null`.\n\n### Dependencies\n- `fetch`: A function available in modern JavaScript environments (e.g., browsers, Node.js with the `node-fetch` or `isomorphic-fetch` module).\n- `getEnv`: A function presumably defined elsewhere in the codebase to retrieve environment variables (`GITLAB_APP_ID` and `GITLAB_SECRET_ID`).\n\n### Errors\n- Logs error details to the console if the request fails or an unexpected error occurs during the process.\n\n### Environment Variables\nMake sure the following environment variables are properly configured:\n- `GITLAB_APP_ID`: The client ID for the GitLab application.\n- `GITLAB_SECRET_ID`: The client secret for the GitLab application.\n\n---\n\nThis documentation provides a comprehensive overview of the `refreshAccessToken` function, including its use case, parameters, return values, and examples of how to use it.\n"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/utils::ENV_VARS",
    "label": "ENV_VARS",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/utils/utils",
    "totalTokens": 145,
    "inDegree": 1,
    "outDegree": 1,
    "code": "ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "summary": "# ENV_VARS Documentation\n\n## Overview\n\nThe `ENV_VARS` assignment is a configuration object that aggregates various environment variables. These variables are primarily used for connecting to databases, authenticating with Supabase, and integrating with GitLab and Bitbucket services. By sourcing these values from environment variables, the application ensures sensitive information is not hardcoded and can be easily modified based on the deployment environment.\n\n## Structure\n\nThe `ENV_VARS` object is structured as follows:\n\n```javascript\nconst ENV_VARS = {\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\n  DATABASE_HOST: process.env.DATABASE_HOST,\n  DATABASE_PORT: process.env.DATABASE_PORT,\n  DATABASE_NAME: process.env.DATABASE_NAME,\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\n};\n```\n\n## Environment Variables\n\n### Database Configuration\n\n1. **DATABASE_USERNAME**\n   - Description: The username used to connect to the database.\n   - Example: `my_db_user`\n   \n2. **DATABASE_PASSWORD**\n   - Description: The password associated with the `DATABASE_USERNAME`.\n   - Example: `super_secure_password`\n\n3. **DATABASE_HOST**\n   - Description: The hostname or IP address of the database server.\n   - Example: `localhost` or `127.0.0.1`\n\n4. **DATABASE_PORT**\n   - Description: The port number on which the database server is listening.\n   - Example: `5432`\n\n5. **DATABASE_NAME**\n   - Description: The name of the specific database to connect to.\n   - Example: `my_database`\n\n### Supabase Configuration\n\n6. **SUPABASE_CA_CERTIFICATE**\n   - Description: The CA certificate for validating the Supabase connection.\n   - Example: `supabase-ca-cert.pem` (or the actual PEM content)\n\n7. **SUPABASE_JWT**\n   - Description: The JSON Web Token (JWT) for authenticating with Supabase services.\n   - Example: `eyJhbGciOiJIU...`\n\n### GitLab Configuration\n\n8. **GITLAB_APP_ID**\n   - Description: The application ID for authenticating with GitLab APIs.\n   - Example: `1234567890abcdef`\n\n9. **GITLAB_SECRET_ID**\n   - Description: The secret ID associated with the GitLab application.\n   - Example: `ghijk12345lmnop6789`\n\n### Bitbucket Configuration\n\n10. **BITBUCKET_KEY**\n    - Description: The consumer key for Bitbucket API access.\n    - Example: `bitbucket_consumer_key`\n    \n11. **BITBUCKET_SECRET**\n    - Description: The consumer secret corresponding to the Bitbucket key.\n    - Example: `bitbucket_consumer_secret`\n\n## Usage\n\nTo use the `ENV_VARS` configuration object, ensure that all the necessary environment variables are set in your deployment environment. This can typically be done through environment configuration files (`.env`) or through deployment orchestration tools that manage environment variables.\n\nExample of accessing an environment variable in your application:\n\n```javascript\nconst dbUsername = ENV_VARS.DATABASE_USERNAME;\n```\n\n## Notes\n\n1. Ensure that all necessary environment variables are defined in your environment to avoid runtime errors.\n2. For security reasons, avoid hardcoding sensitive information in your source code.\n3. Environment variables add flexibility to the application configuration, making it easier to manage settings across different environments (development, testing, production).\n\n---\n\nThis documentation provides an exhaustive overview of the `ENV_VARS` assignment, ensuring proper configuration and usage in your application context."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml::processFolderContents",
    "label": "processFolderContents",
    "type": "function",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml",
    "totalTokens": 158,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function processFolderContents(folderContents: any, htmlContent: string) {\r\n  const folderPaths = Object.keys(folderContents);\r\n  //console.log(folderPaths);\r\n  // Sort folder paths in descending order to start from the bottom\r\n  folderPaths.sort((a, b) => b.length - a.length);\r\n\r\n  for (const folderPath of folderPaths) {\r\n    htmlContent += `<section>\\n<h1>${folderPath}</h1>\\n`;\r\n\r\n    const nodes = folderContents[folderPath];\r\n    for (const node of nodes) {\r\n      htmlContent += `<article>\\n${node.summary}\\n</article>\\n`;\r\n    }\r\n\r\n    htmlContent += \"</section>\\n\";\r\n  }\r\n  //console.log(htmlContent);\r\n  return htmlContent;\r\n}",
    "summary": "# Function Documentation: `processFolderContents`\n\n## Description\n\nThe `processFolderContents` function processes the contents of a folder structure and generates a structured HTML string representing the contents. It takes an object containing folder paths as keys and nodes as values, and it appends HTML content representing each folder and its corresponding nodes. The folder paths are processed in descending order of their length to ensure that deeper folders are handled first.\n\n## Usage\n\n```javascript\nasync function processFolderContents(folderContents, htmlContent)\n```\n\n### Parameters\n\n- **folderContents** `(Object)`: An object where each key is a folder path and each corresponding value is an array of nodes. Each node should have a `summary` property.\n  \n  Example:\n  ```javascript\n  {\n    \"folder1\": [{ summary: \"Node 1 summary\" }, { summary: \"Node 2 summary\" }],\n    \"folder2/subfolder1\": [{ summary: \"Subfolder node summary\" }]\n  }\n  ```\n\n- **htmlContent** `(string)`: A string containing initial HTML content to which processed folder contents will be appended.\n\n### Returns\n\n- **htmlContent** `(string)`: The resulting HTML string after appending the processed folder contents.\n\n## Function Logic\n\n1. **Extract Folder Paths**: The function starts by extracting folder paths from the `folderContents` object using `Object.keys`.\n\n2. **Sort Folder Paths**: The folder paths are sorted in descending order based on their string length to prioritize processing deeper folders first.\n\n3. **Process Each Folder Path**:\n    - For each folder path, an HTML `<section>` tag is appended to `htmlContent` with the folder name as a heading (`<h1>`).\n    - For each node in the folder, an HTML `<article>` tag is appended to `htmlContent` containing the node's summary.\n\n4. **Return HTML Content**: The processed and appended HTML content is returned.\n\n## Example\n\nGiven the following folder contents:\n\n```javascript\nconst folderContents = {\n  \"folder1\": [{ summary: \"Node 1 summary\" }, { summary: \"Node 2 summary\" }],\n  \"folder2/subfolder1\": [{ summary: \"Subfolder node summary\" }]\n};\n\nlet initialHtmlContent = \"<div>Initial Content</div>\\n\";\n\nprocessFolderContents(folderContents, initialHtmlContent).then(updatedHtmlContent => {\n  console.log(updatedHtmlContent);\n});\n```\n\nThe `processFolderContents` function will output:\n\n```html\n<div>Initial Content</div>\n<section>\n<h1>folder2/subfolder1</h1>\n<article>\nSubfolder node summary\n</article>\n</section>\n<section>\n<h1>folder1</h1>\n<article>\nNode 1 summary\n</article>\n<article>\nNode 2 summary\n</article>\n</section>\n```\n\n## Notes\n\n- This function assumes that each node object within `folderContents` has a `summary` property.\n- If `folderContents` is empty or if no valid nodes are provided, the function will simply return the original `htmlContent`."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml::outputHtmlPath",
    "label": "outputHtmlPath",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml",
    "totalTokens": 10,
    "inDegree": 1,
    "outDegree": 1,
    "code": "outputHtmlPath = \"repository_wiki.html\"",
    "summary": "# Documentation for `outputHtmlPath`\n\n## Overview\n\nThe assignment `outputHtmlPath` is a variable that holds the filepath for the HTML file intended to store or represent the wiki contents of a repository. In this context, the assignment is straightforward, setting the path to a specific string value.\n\n```python\noutputHtmlPath = \"repository_wiki.html\"\n```\n\n## Purpose\n\nThe `outputHtmlPath` variable is used to define the location and name of the HTML file (`repository_wiki.html`). This file can be used to store the output of a wiki page rendered in HTML format, which is typically part of a repository.\n\n## Nodes Used\n\nThis assignment does not directly use any specific nodes (objects, functions, or structures) beyond the assignment operation itself. However, it serves as an essential component for the following nodes (or parts of the program), where its purpose can be outlined in these contexts:\n- **File Writing Operations:** Any code segment responsible for outputting HTML content will likely reference `outputHtmlPath` to determine the output file location.\n- **HTML Generation Functions:** Functions handling the generation or manipulation of HTML content may make use of this path to save or reference the final output.\n- **Configuration and Settings:** This variable serves as a configuration element, allowing easy changes to the output file location by altering the value of `outputHtmlPath`.\n\n## Example Usage\n\nConsider that we have a function `generate_wiki_html()` that generates HTML content for a wiki and writes it to `repository_wiki.html`. Heres how `outputHtmlPath` might be used:\n\n```python\ndef generate_wiki_html():\n    html_content = \"<html><body><h1>Wiki Page</h1></body></html>\"\n    with open(outputHtmlPath, 'w') as file:\n        file.write(html_content)\n\ngenerate_wiki_html()\nprint(f\"Wiki HTML has been generated and saved to {outputHtmlPath}\")\n```\n\nIn this example, `outputHtmlPath` is used to specify where the generated wiki HTML should be saved.\n\n## Conclusion\n\nThe `outputHtmlPath` variable is a key part of defining and managing the location where the HTML representation of a repository wiki will be stored. Its role is primarily to serve as a configurable component in file-related operations, ensuring that HTML content is correctly directed to the desired file, `repository_wiki.html`. By setting the path through this variable, it enhances code readability and maintainability, allowing for straightforward changes to file paths without needing widespread code alterations."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml::folderContentsPath",
    "label": "folderContentsPath",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml",
    "totalTokens": 9,
    "inDegree": 1,
    "outDegree": 1,
    "code": "folderContentsPath = \"folderContents.json\"",
    "summary": "### Documentation for `folderContentsPath` Assignment\n\n**Assignment:** \n```python\nfolderContentsPath = \"folderContents.json\"\n```\n\n#### Description:\nThe variable `folderContentsPath` is assigned the string value `\"folderContents.json\"`. This suggests that the assignment is likely intended to represent the file path for a JSON file named `folderContents.json`.\n\n#### Purpose:\nThe `folderContentsPath` assignment is intended to store the file path of a JSON file that presumably contains the contents of a folder. This path can be used in the code to read from or write to the `folderContents.json` file.\n\n#### Usage:\nIn the context of a program, `folderContentsPath` will typically be used wherever the path to the `folderContents.json` file is required. This could include operations such as:\n\n- Reading the JSON file to load folder contents.\n- Writing or modifying the JSON file to update folder contents.\n- Checking the existence of the JSON file.\n\n#### Example Nodes utilizing `folderContentsPath`:\nThe `folderContentsPath` assignment might interact with a number of different nodes (functions, classes, or methods) in the program. Below are some hypothetical examples of nodes that could utilize this variable:\n\n1. **Function to Read JSON File:**\n    ```python\n    import json\n\n    def read_folder_contents(path):\n        try:\n            with open(path, 'r') as file:\n                contents = json.load(file)\n                return contents\n        except FileNotFoundError:\n            return {}\n    \n    folder_contents = read_folder_contents(folderContentsPath)\n    ```\n\n2. **Function to Write to JSON File:**\n    ```python\n    def write_folder_contents(path, contents):\n        with open(path, 'w') as file:\n            json.dump(contents, file, indent=4)\n    \n    sample_contents = {\"files\": [\"file1.txt\", \"file2.doc\"], \"directories\": [\"folderA\", \"folderB\"]}\n    write_folder_contents(folderContentsPath, sample_contents)\n    ```\n\n3. **Function to Check File Existence:**\n    ```python\n    import os\n\n    def folder_contents_exists(path):\n        return os.path.exists(path)\n    \n    exists = folder_contents_exists(folderContentsPath)\n    ```\n\n#### Conclusion:\nThe `folderContentsPath` variable is an essential part of the application as it centralizes the file path to the `folderContents.json` file, allowing for easy reference and modification in other parts of the code. By using this variable, the code remains flexible and maintainable, enabling easier updates to the file path without the need to change multiple reference points throughout the program."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml::path2",
    "label": "path2",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml",
    "totalTokens": 7,
    "inDegree": 0,
    "outDegree": 1,
    "code": "path2 = require(\"path\")",
    "summary": "## Documentation for `path2` Assignment\n\n### Overview\nThe `path2` assignment is a straightforward module import that leverages Node.js's built-in `path` module. This module provides utilities for working with file and directory paths. In this assignment, the `path` module is loaded into a variable called `path2`.\n\n### Code\n```javascript\npath2 = require(\"path\")\n```\n\n### Functionality\nBy assigning the `path` module to `path2`, you have access to all the utilities provided by the `path` module using the `path2` variable. These utilities include methods for path manipulation such as:\n\n- **path.basename()**\n  - Returns the last portion of a path.\n\n- **path.dirname()**\n  - Returns the directory name of a path.\n\n- **path.extname()**\n  - Returns the extension of the path.\n\n- **path.format()**\n  - Returns a path string from an object.\n\n- **path.isAbsolute()**\n  - Determines whether the path is an absolute path.\n\n- **path.join()**\n  - Joins all given path segments together using the platform-specific separator as a delimiter.\n\n- **path.normalize()**\n  - Normalizes a string path, resolving `..` and `.` segments.\n\n- **path.parse()**\n  - Returns an object whose properties represent significant elements of the path.\n\n- **path.relative()**\n  - Returns the relative path from one given path to another.\n\n- **path.resolve()**\n  - Resolves a sequence of paths or path segments into an absolute path.\n\n- **path.sep**\n  - Provides the platform-specific path segment separator (`\\` on Windows, `/` on POSIX).\n\n### Example Usage\nHere's an example showing how the `path2` variable can be used to join two path segments:\n\n```javascript\nconst path2 = require(\"path\");\n\nconst directory = 'users';\nconst filename = 'file.txt';\n\nconst fullPath = path2.join(directory, filename);\nconsole.log(fullPath);  // Output: 'users/file.txt'\n```\n\n### Node.js Built-in Module\nThe `path` module is a built-in utility in Node.js, which means it does not require any external installation. It is part of the core Node.js API, enabling reliable and efficient path manipulations.\n\n### Conclusion\nThe `path2` assignment imports Node.js's powerful `path` module into your application, providing a wide range of utilities for handling and transforming file paths. Whether you need to parse, format, or resolve paths, the methods available through `path2` can help streamline file system operations in your Node.js projects.\n\n"
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml::fs2",
    "label": "fs2",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/genWikiHtml",
    "totalTokens": 9,
    "inDegree": 1,
    "outDegree": 1,
    "code": "fs2 = require(\"fs\").promises",
    "summary": "# Documentation for `fs2`\n\n## Overview\n`fs2` is an assignment that imports the `promises` API from Node.js' built-in `fs` (file system) module. This API provides promise-based methods for interacting with the file system, which can be used instead of the traditional callback-based methods for more readable and maintainable asynchronous code.\n\n```javascript\nfs2 = require(\"fs\").promises\n```\n\n## Description\nNode.js' `fs` module includes both a callback-based API and a promise-based API for file system operations. The `promises` property of the `fs` module offers promise-based methods, enabling write operations, reading files, and manipulating the filesystem in a way that integrates seamlessly with JavaScripts `async` and `await` syntax.\n\n## Benefits\n- **Readability:** Using Promises, especially with `async`/`await`, makes the code cleaner and easier to understand.\n- **Error Handling:** Promises offer a straightforward way to handle errors with `.catch()`, or using `try` and `catch` within `async` functions.\n- **Modern JavaScript Syntax:** The use of Promises aligns with modern JavaScript standards and best practices.\n\n## Common Methods Available with `fs2`\nThe `promises` API mirrors many of the callback-based methods available on `fs`. Here are some of the commonly used methods you can call on `fs2`:\n\n### `fs2.readFile`\nReads the entire contents of a file.\n```javascript\nconst data = await fs2.readFile('/path/to/file', 'utf8');\n```\n\n### `fs2.writeFile`\nWrites data to a file, replacing the file if it already exists.\n```javascript\nawait fs2.writeFile('/path/to/file', 'Hello, World!', 'utf8');\n```\n\n### `fs2.appendFile`\nAppends data to a file, creating the file if it does not exist.\n```javascript\nawait fs2.appendFile('/path/to/file', 'Appends Data', 'utf8');\n```\n\n### `fs2.mkdir`\nCreates a new directory.\n```javascript\nawait fs2.mkdir('/path/to/new/dir');\n```\n\n### `fs2.rmdir`\nRemoves a directory.\n```javascript\nawait fs2.rmdir('/path/to/dir');\n```\n\n### `fs2.readdir`\nReads the contents of a directory.\n```javascript\nconst files = await fs2.readdir('/path/to/dir');\n```\n\n### `fs2.unlink`\nDeletes a file.\n```javascript\nawait fs2.unlink('/path/to/file');\n```\n\n### `fs2.stat`\nReturns the status of a file (like size, modification times, etc.).\n```javascript\nconst stats = await fs2.stat('/path/to/file');\n```\n\n## Example Usage\nBelow is an example of using `fs2` to read a file, modify its contents, and then write the changes back to the file:\n\n```javascript\nconst fs2 = require('fs').promises;\n\nasync function modifyFile(filePath) {\n    try {\n        // Read the file contents\n        const data = await fs2.readFile(filePath, 'utf8');\n        console.log('Original content:', data);\n        \n        // Modify the file contents\n        const modifiedData = data.toUpperCase();\n        \n        // Write the modified contents back to the file\n        await fs2.writeFile(filePath, modifiedData, 'utf8');\n        console.log('File updated successfully.');\n        \n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\n// Call the function with the path to your file\nmodifyFile('/path/to/your/file.txt');\n```\n\n## Nodes Used\nThe assignment imports the `promises` API from the `fs` module, which is a part of Node.js core modules. No additional nodes are used in the assignment process.\n\n### Relevant Path\n- `fs.promises`\n\n## Conclusion\nUsing `fs2` provides beneficial convenience for handling file system operations in a modern, concise, and easy-to-read manner by leveraging JavaScript Promises. This approach improves code quality by making asynchronous operations more straightforward to manage and maintain."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::contents",
    "label": "contents",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 3,
    "inDegree": 1,
    "outDegree": 1,
    "code": "contents = \"\"",
    "summary": "# Assignment Documentation\n\n## Assignment: `contents`\n```python\ncontents = \"\"\n```\n\n### Description:\nThe variable `contents` is assigned an empty string. This signifies that `contents` currently holds no textual data.\n\n### Nodes Used:\n- **Variable Declaration**: The `contents` variable is being declared and initialized with an empty string. This can be useful for future operations where `contents` might be populated with some data.\n\n### Possible Usage Scenarios:\n1. **Initialization for Future Use**: The `contents` variable might be initially set to an empty string as a placeholder, with the intention to be populated later.\n2. **Indicator of Empty State**: An empty string can indicate that the `contents` variable is in an empty or uninitialized state.\n3. **Avoiding Null Errors**: By initializing `contents` to an empty string, we can avoid null reference errors when manipulating the variable later.\n\n### Example Extension:\nTo give a practical example, here is how `contents` might be used in the future:\n```python\ncontents = \"\"  # Initializing contents as an empty string\n# Later in the code\ncontents = \"Example text data\"  # Populating contents with a string\nprint(contents)  # Output: Example text data\n```\n\nIn this example, `contents` was initially empty and then later assigned some text data, demonstrating its utility as a placeholder.\n\n### Potential Enhancements:\nIf more complex initialization or handling is required, the assignment can be modified as necessary. For instance:\n```python\ncontents = None  # Alternatively initializing as None, if suitable for specific use cases\n```\n\n### Conclusion:\nThe assignment of `contents` to an empty string is a simple yet effective initial declaration, ensuring that the variable is set up for later use."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::nodesFilePath",
    "label": "nodesFilePath",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 34,
    "inDegree": 2,
    "outDegree": 1,
    "code": "nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\"",
    "summary": "### Documentation for `nodesFilePath`\n\n#### Description\nThe variable `nodesFilePath` is a string that specifies the absolute file path to a JSON file named `nodes.json`. This file is expected to contain data relevant to nodes, possibly for use in graph-related operations.\n\n#### Declaration\n```typescript\nnodesFilePath: string = \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\";\n```\n\n#### Usage\nThe `nodesFilePath` is used to reference the location of the `nodes.json` file which stores node-related data. This file path can be utilized whenever the application needs to read from or write to the `nodes.json` file.\n\n#### Examples\n\n1. **Reading Node Data**\n    ```typescript\n    const fs = require('fs');\n\n    fs.readFile(nodesFilePath, 'utf8', (err, data) => {\n        if (err) {\n            console.error('Error reading nodes file:', err);\n            return;\n        }\n        const nodes = JSON.parse(data);\n        console.log('Nodes data:', nodes);\n    });\n    ```\n\n2. **Writing Node Data**\n    ```typescript\n    const fs = require('fs');\n\n    const newNodeData = {\n        id: 1,\n        label: \"Node1\",\n        edges: []\n    };\n\n    fs.writeFile(nodesFilePath, JSON.stringify(newNodeData, null, 2), (err) => {\n        if (err) {\n            console.error('Error writing to nodes file:', err);\n            return;\n        }\n        console.log('Node data written successfully!');\n    });\n    ```\n\n#### File Structure\nThe JSON file located at the `nodesFilePath` is expected to contain structured data representing nodes. Here is an example of how the data might be structured:\n\n```json\n[\n    {\n        \"id\": 1,\n        \"label\": \"Node1\",\n        \"edges\": [2, 3]\n    },\n    {\n        \"id\": 2,\n        \"label\": \"Node2\",\n        \"edges\": [1]\n    },\n    {\n        \"id\": 3,\n        \"label\": \"Node3\",\n        \"edges\": [1]\n    }\n]\n```\nEach node object typically contains:\n- `id`: A unique identifier for the node.\n- `label`: A human-readable label or name for the node.\n- `edges`: An array of node IDs that this node is connected to.\n\n#### Nodes Used\nThe assignment may involve the use of nodes such as:\n- Nodes with unique identifiers, labels, and connections represented by edges.\n- Nodes represented as JSON objects within the `nodes.json` file.\n\n#### Path Information\n- **Absolute Path**: The `nodesFilePath` is an absolute path, meaning it specifies the complete directory structure from the root to the file.\n- **User Specific**: This path is user-specific and may need to be adjusted if the code is executed in a different environment or by a different user.\n\n#### Notes\n- Ensure that the file at `nodesFilePath` is accessible and has the correct permissions for read/write operations.\n- If the path changes or if you are collaborating with others, you'll want to use a relative path or a configurable setting to avoid hardcoding user-specific paths."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::codebasePath",
    "label": "codebasePath",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 34,
    "inDegree": 0,
    "outDegree": 1,
    "code": "codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\src\\\\utils\"",
    "summary": "# Documentation for `codebasePath` Assignment\n\n## Overview\nThe `codebasePath` assignment is a string variable that holds the path to a specific directory within a codebase. This path indicates where certain utility scripts or modules are located in a project's directory structure.\n\n## Assignment Definition\n```plaintext\ncodebasePath = \n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\src\\\\utils\"\n```\n\n## Description\n- **Variable Name**: `codebasePath`\n- **Type**: String\n- **Value**:\n  ```\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\src\\\\utils\"\n  ```\n\n## Path Details\nThe value assigned to `codebasePath` represents an absolute path in a Windows file system. It points to the `utils` directory inside the `src` directory of the `codebase-index-ts` project, which is housed within the `Graphs` folder. The full path is located in the `OneDrive\\Documentos` directory under the user's personal directory (`C:\\\\Users\\\\gmasc`).\n\n### Path Components\n1. **User Directory**: `C:\\\\Users\\\\gmasc`\n   - Specifies the user's profile folder in the Windows operating system.\n\n2. **OneDrive\\Documentos**:\n   - Indicates that the file path is within the user's OneDrive documents folder.\n\n3. **Project Path**:\n   - `CodeGPT`: The main directory, presumably for projects related to CodeGPT.\n   - `Graphs`: A subfolder within `CodeGPT`.\n   - `codebase-index-ts`: The specific project directory.\n   - `src`: Typically signifies the source code directory in a project.\n   - `utils`: A common sub-directory within `src` where utility scripts or modules are stored.\n\n## Utilization\nThe path provided by the `codebasePath` variable can be used in several contexts within the project, such as:\n- Importing utility modules or scripts located in the `utils` directory.\n- Programmatically accessing files or resources within this directory.\n- Defining file paths for configuration purposes.\n\n## Example Usage\nHere's an example of how `codebasePath` could be used in a script:\n```javascript\nconst utilsPath = \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\src\\\\utils\";\nconst someUtil = require(`${utilsPath}\\\\someUtil.js`);\n\n// Use the imported utility function\nsomeUtil.performTask();\n```\n\n## Node Utilization\nThis assignment uses the following nodes:\n- **Literal node**: The entire string literal assigned to the `codebasePath`.\n- **String node**: Represents the type of the assignment value.\n- **File Path node**: Provides the path details in a structured format.\n\n## Conclusion\nThe `codebasePath` assignment is a foundational variable that defines a specific directory path within a project structure. Understanding and utilizing this path is crucial for tasks involving file management, module imports, and program configuration."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::OpenAI",
    "label": "OpenAI",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 8,
    "inDegree": 2,
    "outDegree": 1,
    "code": "OpenAI = require(\"openai\")",
    "summary": "# OpenAI Module Documentation\n\n## Overview\nThe OpenAI module provides a way to interact with OpenAI's API services. By using this module, you can implement various functionalities such as generating text, translating languages, and more.\n\n## Installation\nTo use the OpenAI module, you first need to install it using npm:\n```bash\nnpm install openai\n```\n\n## Importing the Module\nTo import the OpenAI module in your project, require it as follows:\n```javascript\nconst OpenAI = require(\"openai\");\n```\n\n## Configuration\nBefore making any API calls, you will need to configure the API key provided by OpenAI. This typically involves setting up your API client using the key.\n\n```javascript\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,  // Ensure to set your API key here\n});\n```\n\n## Nodes\nThe OpenAI module facilitates various operations through different nodes. Each node pertains to a particular function or capability offered by the API. This documentation will highlight the key nodes available for use:\n\n1. **Completion Node**\n   - **Purpose**: To generate text based on a provided prompt.\n   - **Usage Example**:\n     ```javascript\n     openai.complete({\n       engine: 'davinci-codex',\n       prompt: 'Once upon a time',\n       maxTokens: 150,\n     }).then(response => {\n       console.log(response.data.choices[0].text);\n     }).catch(error => {\n       console.error(error);\n     });\n     ```\n   \n2. **Translation Node**\n   - **Purpose**: To translate text from one language to another.\n   - **Usage Example**:\n     ```javascript\n     openai.translate({\n       engine: 'text-davinci-003',\n       text: 'Hello, how are you?',\n       target_language: 'es',\n     }).then(response => {\n       console.log(response.translated_text);  // Should output: \"Hola, cmo ests?\"\n     }).catch(error => {\n       console.error(error);\n     });\n     ```\n\n3. **Search Node**\n   - **Purpose**: To search for relevant documents or entries based on a query.\n   - **Usage Example**:\n     ```javascript\n     openai.search({\n       engine: 'davinci',\n       documents: ['White House', 'hospital', 'school'],\n       query: 'president',\n     }).then(response => {\n       console.log(response.data);\n     }).catch(error => {\n       console.error(error);\n     });\n     ```\n\n4. **Classification Node**\n   - **Purpose**: To classify text into specified categories.\n   - **Usage Example**:\n     ```javascript\n     openai.classify({\n       engine: 'davinci',\n       examples: [\n         [\"A happy moment\", \"Positive\"],\n         [\"I am sad.\", \"Negative\"],\n         [\"I feel great!\", \"Positive\"]\n       ],\n       query: 'It is a rainy day.',\n       labels: [\"Positive\", \"Negative\", \"Neutral\"]\n     }).then(response => {\n       console.log(response.label);  // Should output one of the labels: \"Positive\", \"Negative\", or \"Neutral\"\n     }).catch(error => {\n       console.error(error);\n     });\n     ```\n\n## Error Handling\nEnsure to implement error handling for robust and reliable applications. The OpenAI module provides error responses which can be captured using `.catch()`:\n\n```javascript\nopenai.someApiFunction(params)\n  .then(response => {\n    // Handle successful response\n  })\n  .catch(error => {\n    console.error('Error:', error.message);\n  });\n```\n\n## Conclusion\nThe OpenAI module is a powerful tool for integrating advanced AI functionalities into your applications. Utilizing various nodes, you can perform text generation, translation, search, and classification, among other capabilities. Make sure to handle errors appropriately to enhance the user experience and application stability.\n\nFor more detailed information and advanced usage, refer to the OpenAI API documentation at [OpenAI API Documentation](https://beta.openai.com/docs/)."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::path",
    "label": "path",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 6,
    "inDegree": 1,
    "outDegree": 1,
    "code": "path = require(\"path\")",
    "summary": "# Path Module Documentation\n\n## Assignment\n```javascript\nconst path = require(\"path\");\n```\n\nThe `path` module is a core Node.js module that provides utilities for working with file and directory paths. It can be used to handle and manipulate filesystem paths effectively, regardless of the operating system.\n\n## Nodes Utilized\n\n### 1. `basename(p, [ext])`\n- **Purpose**: Returns the last portion of a path.\n- **Description**: This method is useful when you need to extract the filename from a full path.\n- **Example Usage**:\n  ```javascript\n  const fileName = path.basename('/foo/bar/baz/asdf/quux.html');\n  console.log(fileName); // Output: 'quux.html'\n  ```\n\n### 2. `dirname(p)`\n- **Purpose**: Returns the directory name of a path.\n- **Description**: This method extracts the directory path from a given file path.\n- **Example Usage**:\n  ```javascript\n  const dirName = path.dirname('/foo/bar/baz/asdf/quux.html');\n  console.log(dirName); // Output: '/foo/bar/baz/asdf'\n  ```\n\n### 3. `extname(p)`\n- **Purpose**: Returns the extension of the path.\n- **Description**: This method extracts the file extension from a given file path.\n- **Example Usage**:\n  ```javascript\n  const extName = path.extname('/foo/bar/baz/asdf/quux.html');\n  console.log(extName); // Output: '.html'\n  ```\n\n### 4. `join([...paths])`\n- **Purpose**: Joins all given path segments together using the platform-specific separator as a delimiter, then normalizes the resulting path.\n- **Description**: This method is useful for constructing a path string from multiple segments.\n- **Example Usage**:\n  ```javascript\n  const fullPath = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');\n  console.log(fullPath); // Output: '/foo/bar/baz/asdf'\n  ```\n\n### 5. `resolve([...paths])`\n- **Purpose**: Resolves a sequence of paths or path segments into an absolute path.\n- **Description**: This method processes paths from right to left, prepending each until an absolute path is created. Non-absolute segments are normalized to an absolute path.\n- **Example Usage**:\n  ```javascript\n  const absPath = path.resolve('/foo/bar', './baz');\n  console.log(absPath); // Output: '/foo/bar/baz'\n  ```\n\n### 6. `normalize(p)`\n- **Purpose**: Normalizes a path, resolving `..` and `.` segments.\n- **Description**: This method ensures the given path string is in a standard format.\n- **Example Usage**:\n  ```javascript\n  const normalizedPath = path.normalize('/foo/bar//baz/asdf/quux/..');\n  console.log(normalizedPath); // Output: '/foo/bar/baz/asdf'\n  ```\n\n## Example Usage in a Project\nBy consolidating the above nodes, we can seamlessly handle filesystem paths in various scenarios within a Node.js project:\n\n```javascript\nconst path = require(\"path\");\n\n// Example: Constructing a path from segments\nconst projectRoot = \"/user/project\";\nconst logsDir = \"logs\";\nconst actualLogDir = path.join(projectRoot, logsDir);\nconsole.log(actualLogDir); // Output: '/user/project/logs'\n\n// Example: Extracting the directory name from a given path\nconst filePath = \"/user/project/logs/app.log\";\nconst directoryName = path.dirname(filePath);\nconsole.log(directoryName); // Output: '/user/project/logs'\n\n// Example: Normalizing a path\nconst misconfiguredPath = \"/user///project/logs/../logs/app.log\";\nconst correctedPath = path.normalize(misconfiguredPath);\nconsole.log(correctedPath); // Output: '/user/project/logs/app.log'\n```\n\nThe `path` module is essential for Node.js applications working with file systems, ensuring consistent behavior across different operating systems."
  },
  {
    "id": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki::fs",
    "label": "fs",
    "type": "assignment",
    "parent": "C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/src/wiki/wiki",
    "totalTokens": 8,
    "inDegree": 1,
    "outDegree": 1,
    "code": "fs = require(\"fs\").promises",
    "summary": "# Documentation for `fs` Assignment\n\n## Overview\n\nThe `fs` assignment is a requirement that brings in the file system (fs) module from Node.js, specifically using the `fs.promises` API which provides promise-based methods for asynchronous file operations. This documentation describes the import and usage nodes associated with this assignment.\n\n## Import Statement\n\nThe assignment uses the following import statement:\n\n```javascript\nconst fs = require(\"fs\").promises;\n```\n\nThis statement imports the `promises` API from the Node.js `fs` (file system) module. By interfacing with `fs.promises`, we can leverage promise-based asynchronous file operations, which makes it easier to handle operations such as reading, writing, and deleting files without resorting to callback patterns. This improves code readability and reduces complexity, especially when dealing with multiple asynchronous tasks.\n\n## Available Methods\n\nThe `fs.promises` API exposes several methods that you can use. Here are some of the most commonly used methods:\n\n### `fs.readFile(path, options)`\n\nReads the content of the file located at `path`.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL | integer): Path to the file.\n  - `options` (object | string): Optional options object or string specifying the encoding and flag.\n\n- **Returns:**\n  - A promise that resolves to the file content.\n\n### `fs.writeFile(file, data, options)`\n\nWrites data to a file, replacing the file if it already exists.\n\n- **Parameters:**\n  - `file` (string | Buffer | URL | integer): Path to the file.\n  - `data` (string | Buffer | TypedArray | DataView): Data to be written to the file.\n  - `options` (object | string): Optional options object or string specifying the encoding and mode.\n  \n- **Returns:**\n  - A promise that resolves once the data has been written.\n\n### `fs.appendFile(path, data, options)`\n\nAppends data to a file, creating the file if it does not exist.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL | integer): Path to the file.\n  - `data` (string | Buffer | TypedArray | DataView): Data to append.\n  - `options` (object | string): Optional options object or string specifying the encoding and mode.\n\n- **Returns:**\n  - A promise that resolves once the data has been appended.\n\n### `fs.mkdir(path, options)`\n\nCreates a directory.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL): Path to the directory.\n  - `options` (object): Optional options object specifying recursive directory creation or mode.\n\n- **Returns:**\n  - A promise that resolves once the directory has been created.\n\n### `fs.readdir(path, options)`\n\nReads the contents of a directory.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL): Path to the directory.\n  - `options` (object): Optional options object specifying encoding and withFileTypes.\n\n- **Returns:**\n  - A promise that resolves to an array of the names of the files in the directory.\n\n### `fs.unlink(path)`\n\nDeletes a file or symbolic link.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL): Path to the file or symbolic link.\n\n- **Returns:**\n  - A promise that resolves once the file or symbolic link has been deleted.\n\n### `fs.stat(path)`\n\nRetrieves the status of a file.\n\n- **Parameters:**\n  - `path` (string | Buffer | URL): Path to the file.\n\n- **Returns:**\n  - A promise that resolves to an `fs.Stats` object that provides file status information.\n\n## Usage Example\n\nHere is a basic example of how to use some of these methods:\n\n```javascript\nconst fs = require(\"fs\").promises;\n\nasync function example() {\n  try {\n    // Create a new directory\n    await fs.mkdir('./exampleDir');\n\n    // Write to a file\n    await fs.writeFile('./exampleDir/exampleFile.txt', 'Hello, world!');\n\n    // Read the file content\n    const data = await fs.readFile('./exampleDir/exampleFile.txt', 'utf-8');\n    console.log(data); // Outputs: Hello, world!\n\n    // Append to the file\n    await fs.appendFile('./exampleDir/exampleFile.txt', ' Appended text.');\n    \n    // Read the updated content\n    const updatedData = await fs.readFile('./exampleDir/exampleFile.txt', 'utf-8');\n    console.log(updatedData); // Outputs: Hello, world! Appended text.\n\n    // Delete the file\n    await fs.unlink('./exampleDir/exampleFile.txt');\n\n    // Remove the directory\n    await fs.rmdir('./exampleDir');\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\nexample();\n```\n\n## Conclusion\n\nThe `fs` assignment, using the `fs.promises` API from Node.js, simplifies the process of working with the file system by using promise-based methods. This improves the readability and maintainability of your code, allowing you to handle asynchronous file operations more effectively."
  }
]