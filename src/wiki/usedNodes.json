[
  {
    "id": "judini-python-main\\examples\\chat_completion::chat_example",
    "language": "python",
    "label": "chat_example",
    "type": "function",
    "parent": "judini-python-main\\examples\\chat_completion",
    "totalTokens": 166,
    "inDegree": 1,
    "outDegree": 1,
    "code": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    CODEGPT_API_KEY = os.getenv(\"CODEGPT_API_KEY\")\n    CODEGPT_ORG_ID = os.getenv(\"CODEGPT_ORG_ID\")\n    CODEGPT_AGENT_ID = os.getenv(\"CODEGPT_AGENT_ID\")\n    # Create an instance of the CodeGPTPlus class\n    codegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=CODEGPT_ORG_ID)\n\n    # Use a loop to interact with the agent and get responses\n    for chunk in codegpt.chat_completion(agent_id=CODEGPT_AGENT_ID, messages=messages, stream=True):\n        print(chunk, end=\"\")  # Print the responses obtained from the agent",
    "importStatements": [],
    "codeNoBody": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    ...",
    "originFile": "judini-python-main\\examples\\chat_completion.py",
    "summary": "The function \"chat_example\" takes a list of messages as input, retrieves the CodeGPT API key, organization ID, and agent ID from environment variables, creates an instance of the CodeGPTPlus class using the API key and organization ID, then iterates through the messages to interact with the agent and obtain responses, printing them out. The function requires imports from \"os\" for environment variables, \"judini\" for the CodeGPTPlus class, and \"dotenv\" to load environment variables from a .env file."
  },
  {
    "id": "judini-python-main\\src\\judini\\codegpt::PLAYGROUND_KEYS_URL",
    "language": "python",
    "label": "PLAYGROUND_KEYS_URL",
    "type": "assignment",
    "parent": "judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
    "importStatements": [],
    "codeNoBody": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
    "originFile": "judini-python-main\\src\\judini\\codegpt.py",
    "summary": "The `PLAYGROUND_KEYS_URL` constant stores the URL 'https://app.codegpt.co/en/apikeys' and is defined in a file that imports `os`, `mimetypes`, `warnings`, `json`, `requests`, `List`, `Dict`, `Literal`, `Optional`, `handle_non_stream`, `handle_stream`, `Agent`, `Document`, and `DocumentMetadata` from the local modules `utils` and `types`."
  },
  {
    "id": "judini-python-main\\src\\judini\\codegpt::base_url",
    "language": "python",
    "label": "base_url",
    "type": "assignment",
    "parent": "judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 16,
    "inDegree": 4,
    "outDegree": 1,
    "code": "base_url = 'https://api-beta.codegpt.co/api/v1'",
    "importStatements": [],
    "codeNoBody": "base_url = 'https://api-beta.codegpt.co/api/v1'",
    "originFile": "judini-python-main\\src\\judini\\codegpt.py",
    "summary": "Defines the base URL for the CodeGPT beta API endpoint, stored in the variable `base_url`, which is set to 'https://api-beta.codegpt.co/api/v1'."
  },
  {
    "id": "judini-python-main\\src\\judini\\types::Document.json_loads",
    "language": "python",
    "label": "Document.json_loads",
    "type": "method",
    "parent": "judini-python-main\\src\\judini\\types::Document",
    "totalTokens": 41,
    "inDegree": 0,
    "outDegree": 1,
    "code": "class Document(BaseModel):\n    ...\n    @field_validator(\"metadata\", mode=\"before\")\ndef json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
    "importStatements": [],
    "codeNoBody": "class Document(BaseModel):\n    ...\n    @field_validator(\"metadata\", mode=\"before\")\ndef json_loads(cls, v):\n            ...",
    "originFile": "judini-python-main\\src\\judini\\types.py",
    "summary": "This method, defined in a class extending BaseModel and using field_validator from pydantic, takes a parameter 'v' and checks if it's a non-empty string; if so, it deserializes the string using json.loads; otherwise, it returns the input parameter 'v'."
  },
  {
    "id": "judini-python-main\\src\\judini\\types::Document",
    "language": "python",
    "label": "Document",
    "type": "class",
    "parent": "judini-python-main\\src\\judini\\types",
    "totalTokens": 179,
    "inDegree": 1,
    "outDegree": 1,
    "code": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
    "importStatements": [],
    "codeNoBody": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        \n        ...",
    "originFile": "judini-python-main\\src\\judini\\types.py",
    "summary": "The \"Document\" class, defined in the file with import statements from pydantic, typing, and json, represents a document with attributes such as ID, user ID, name, file type, metadata, number of tokens, number of chunks, and content. The class includes a field validator method \"json_loads\" to handle the conversion of metadata from a string to a JSON object if needed."
  },
  {
    "id": "judini-python-main\\src\\judini\\types::DocumentMetadata",
    "language": "python",
    "label": "DocumentMetadata",
    "type": "class",
    "parent": "judini-python-main\\src\\judini\\types",
    "totalTokens": 90,
    "inDegree": 0,
    "outDegree": 1,
    "code": "class DocumentMetadata(BaseModel):\n    title: Optional[str] = \"\"\n    \"\"\"The title of the document\"\"\"\n    description: Optional[str] = \"\"\n    \"\"\"The description of the document\"\"\"\n    summary: Optional[str] = \"\"\n    \"\"\"The summary of the document\"\"\"\n    keywords: Optional[str] = \"\"\n    \"\"\"The keywords of the document, separated by commas\"\"\"\n    language: Optional[str] = \"\"\n    \"\"\"The language of the document\"\"\"",
    "importStatements": [],
    "codeNoBody": "class DocumentMetadata(BaseModel):\n    ...",
    "originFile": "judini-python-main\\src\\judini\\types.py",
    "summary": "The \"DocumentMetadata\" class, defined in the file with import statements from \"pydantic\" for BaseModel and Optional, and from \"typing\" for List, includes parameters for title, description, summary, keywords, and language, each representing different metadata aspects of a document, with the option to provide values for each parameter."
  },
  {
    "id": "judini-python-main\\src\\judini\\types::Agent",
    "language": "python",
    "label": "Agent",
    "type": "class",
    "parent": "judini-python-main\\src\\judini\\types",
    "totalTokens": 142,
    "inDegree": 0,
    "outDegree": 1,
    "code": "class Agent(BaseModel):\n    id: str\n    \"\"\"The ID of the agent\"\"\"\n    name: str\n    \"\"\"The name of the agent\"\"\"\n    prompt: str\n    \"\"\"The prompt of the agent\"\"\"\n    model: str\n    \"\"\"The model of the agent\"\"\"\n    agent_documents: Optional[List[str]] = None\n    \"\"\"The list of documents associated with the agent\"\"\"\n    welcome: str\n    \"\"\"The welcome message of the agent\"\"\"\n    pincode: Optional[str] = None\n    \"\"\"The pincode of the agent\"\"\"\n    is_public: bool\n    \"\"\"Whether the agent is public or not\"\"\"\n    agent_type: str\n    \"\"\"The type of the agent\"\"\"",
    "importStatements": [],
    "codeNoBody": "class Agent(BaseModel):\n    ...",
    "originFile": "judini-python-main\\src\\judini\\types.py",
    "summary": "The \"Agent\" class, defined in the file with import statements from pydantic, typing, and json, includes parameters for the ID, name, prompt, model, list of agent documents, welcome message, pincode, public status, and agent type. The parameters are used to store information about an agent, such as its identification, attributes, associated documents, and messaging details."
  },
  {
    "id": "judini-python-main\\src\\judini\\utils::handle_non_stream",
    "language": "python",
    "label": "handle_non_stream",
    "type": "function",
    "parent": "judini-python-main\\src\\judini\\utils",
    "totalTokens": 48,
    "inDegree": 0,
    "outDegree": 1,
    "code": "def handle_non_stream(response: requests.Response) -> str:\n    try:\n        text = response.json()\n        return text\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n    finally:\n        response.close()",
    "importStatements": [],
    "codeNoBody": "def handle_non_stream(response: requests.Response) -> str:\n    ...",
    "originFile": "judini-python-main\\src\\judini\\utils.py",
    "summary": "This function named \"handle_non_stream\" takes a requests.Response object as input and attempts to parse it as JSON. If successful, it returns the parsed JSON data as a string; otherwise, it prints the error message and closes the response object before exiting. The function does not require any import statements beyond the ones provided."
  },
  {
    "id": "judini-python-main\\src\\judini\\utils::handle_stream",
    "language": "python",
    "label": "handle_stream",
    "type": "function",
    "parent": "judini-python-main\\src\\judini\\utils",
    "totalTokens": 68,
    "inDegree": 0,
    "outDegree": 1,
    "code": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    try:\n        for chunk in response.iter_content(chunk_size=64, decode_unicode=True):\n            if chunk:\n                yield chunk\n    except Exception as e:\n        print(f\"Error occurred: {e}\", chunk)\n    finally:\n        response.close()",
    "importStatements": [],
    "codeNoBody": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    ...",
    "originFile": "judini-python-main\\src\\judini\\utils.py",
    "summary": "Uses the `requests` library to handle a streaming response, yielding chunks of data from the response iteratively. The function takes a `response` object of type `requests.Response` and returns a generator that yields chunks of data. If an error occurs during the streaming process, it prints the error message and the chunk causing the error, and finally closes the response."
  },
  {
    "id": "judini-python-main\\streamlit::enable_stream",
    "language": "python",
    "label": "enable_stream",
    "type": "assignment",
    "parent": "judini-python-main\\streamlit",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
    "importStatements": [],
    "codeNoBody": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
    "originFile": "judini-python-main\\streamlit.py",
    "summary": "The `enable_stream` assignment creates a Streamlit sidebar checkbox titled \"Enable Stream\" with a default value of True, utilizing the `streamlit` library for the user interface."
  },
  {
    "id": "judini-python-main\\streamlit::AGENT_ID",
    "language": "python",
    "label": "AGENT_ID",
    "type": "assignment",
    "parent": "judini-python-main\\streamlit",
    "totalTokens": 21,
    "inDegree": 0,
    "outDegree": 1,
    "code": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
    "importStatements": [],
    "codeNoBody": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
    "originFile": "judini-python-main\\streamlit.py",
    "summary": "Assigns the value of the \"Agent ID\" text input from the Streamlit sidebar to the variable AGENT_ID, with the initial value set to the existing \"agent_id\" stored in the session state, using the Streamlit library for the user interface."
  },
  {
    "id": "judini-python-main\\streamlit::CODEGPT_API_KEY",
    "language": "python",
    "label": "CODEGPT_API_KEY",
    "type": "assignment",
    "parent": "judini-python-main\\streamlit",
    "totalTokens": 34,
    "inDegree": 1,
    "outDegree": 1,
    "code": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
    "importStatements": [],
    "codeNoBody": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
    "originFile": "judini-python-main\\streamlit.py",
    "summary": "Assigns the CodeGPT API key inputted by the user in a Streamlit sidebar text input field, with the initial value retrieved from the session state if available. Requires importing `streamlit` for the sidebar functionality."
  }
]