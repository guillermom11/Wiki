{
  "judini-python-main\\judini-python-main\\examples\\chat_completion.py": [
    {
      "id": "judini-python-main\\judini-python-main\\examples\\chat_completion::chat_example",
      "language": "python",
      "label": "chat_example",
      "type": "function",
      "parent": "judini-python-main\\judini-python-main\\examples\\chat_completion",
      "totalTokens": 166,
      "inDegree": 1,
      "outDegree": 1,
      "code": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    CODEGPT_API_KEY = os.getenv(\"CODEGPT_API_KEY\")\n    CODEGPT_ORG_ID = os.getenv(\"CODEGPT_ORG_ID\")\n    CODEGPT_AGENT_ID = os.getenv(\"CODEGPT_AGENT_ID\")\n    # Create an instance of the CodeGPTPlus class\n    codegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=CODEGPT_ORG_ID)\n\n    # Use a loop to interact with the agent and get responses\n    for chunk in codegpt.chat_completion(agent_id=CODEGPT_AGENT_ID, messages=messages, stream=True):\n        print(chunk, end=\"\")  # Print the responses obtained from the agent",
      "importStatements": [],
      "codeNoBody": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    ...",
      "originFile": "judini-python-main\\judini-python-main\\examples\\chat_completion.py",
      "summary": "The \"chat_example\" function takes a list of messages as input, retrieves the CodeGPT API key, organization ID, and agent ID from environment variables, creates an instance of the CodeGPTPlus class using the API key and organization ID, then interacts with the agent using the provided messages to obtain responses, and finally prints the responses obtained from the agent. The function requires the import statements for \"os\", \"CodeGPTPlus\" from \"judini\", and \"load_dotenv\" from \"dotenv\"."
    }
  ],
  "judini-python-main\\judini-python-main\\setup.py": [],
  "judini-python-main\\judini-python-main\\src\\judini\\__init__.py": [],
  "judini-python-main\\judini-python-main\\src\\judini\\codegpt.py": [
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\codegpt::PLAYGROUND_KEYS_URL",
      "language": "python",
      "label": "PLAYGROUND_KEYS_URL",
      "type": "assignment",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\codegpt",
      "totalTokens": 17,
      "inDegree": 0,
      "outDegree": 1,
      "code": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
      "importStatements": [],
      "codeNoBody": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\codegpt.py",
      "summary": "The `PLAYGROUND_KEYS_URL` constant stores the URL 'https://app.codegpt.co/en/apikeys' and is defined in a file that imports modules such as os, mimetypes, warnings, json, requests, List, Dict, Literal, Optional, handle_non_stream, handle_stream, Agent, Document, and DocumentMetadata."
    },
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\codegpt::base_url",
      "language": "python",
      "label": "base_url",
      "type": "assignment",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\codegpt",
      "totalTokens": 16,
      "inDegree": 4,
      "outDegree": 1,
      "code": "base_url = 'https://api-beta.codegpt.co/api/v1'",
      "importStatements": [],
      "codeNoBody": "base_url = 'https://api-beta.codegpt.co/api/v1'",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\codegpt.py",
      "summary": "The assignment \"base_url\" in the file uses the import statements from os, mimetypes, warnings, json, requests, typing, and custom modules utils and types. It defines the base URL 'https://api-beta.codegpt.co/api/v1' for API requests."
    }
  ],
  "judini-python-main\\judini-python-main\\src\\judini\\types.py": [
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\types::Document.json_loads",
      "language": "python",
      "label": "Document.json_loads",
      "type": "method",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\types::Document",
      "totalTokens": 41,
      "inDegree": 0,
      "outDegree": 1,
      "code": "class Document(BaseModel):\n    ...\n    @field_validator(\"metadata\", mode=\"before\")\ndef json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
      "importStatements": [],
      "codeNoBody": "class Document(BaseModel):\n    ...\n    @field_validator(\"metadata\", mode=\"before\")\ndef json_loads(cls, v):\n            ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\types.py",
      "summary": "This method, defined in a class extending `BaseModel` and using the `field_validator` decorator from `pydantic`, takes a parameter `v` and checks if it's a non-empty string; if so, it deserializes the string using `json.loads` and returns the result, otherwise, it returns `v`."
    },
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\types::Document",
      "language": "python",
      "label": "Document",
      "type": "class",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\types",
      "totalTokens": 179,
      "inDegree": 1,
      "outDegree": 1,
      "code": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
      "importStatements": [],
      "codeNoBody": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        \n        ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\types.py",
      "summary": "The \"Document\" class, defined in the file with import statements from pydantic, typing, and json, represents a document with attributes such as ID, user ID, name, file type, metadata, number of tokens, number of chunks, and content. The class includes a field validator method \"json_loads\" to handle the conversion of metadata to JSON format before validation."
    },
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\types::DocumentMetadata",
      "language": "python",
      "label": "DocumentMetadata",
      "type": "class",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\types",
      "totalTokens": 90,
      "inDegree": 0,
      "outDegree": 1,
      "code": "class DocumentMetadata(BaseModel):\n    title: Optional[str] = \"\"\n    \"\"\"The title of the document\"\"\"\n    description: Optional[str] = \"\"\n    \"\"\"The description of the document\"\"\"\n    summary: Optional[str] = \"\"\n    \"\"\"The summary of the document\"\"\"\n    keywords: Optional[str] = \"\"\n    \"\"\"The keywords of the document, separated by commas\"\"\"\n    language: Optional[str] = \"\"\n    \"\"\"The language of the document\"\"\"",
      "importStatements": [],
      "codeNoBody": "class DocumentMetadata(BaseModel):\n    ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\types.py",
      "summary": "The \"DocumentMetadata\" class, defined in the file with import statements from pydantic, typing, and json, includes parameters for title, description, summary, keywords, and language, all optional strings used to store metadata information about a document."
    },
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\types::Agent",
      "language": "python",
      "label": "Agent",
      "type": "class",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\types",
      "totalTokens": 142,
      "inDegree": 0,
      "outDegree": 1,
      "code": "class Agent(BaseModel):\n    id: str\n    \"\"\"The ID of the agent\"\"\"\n    name: str\n    \"\"\"The name of the agent\"\"\"\n    prompt: str\n    \"\"\"The prompt of the agent\"\"\"\n    model: str\n    \"\"\"The model of the agent\"\"\"\n    agent_documents: Optional[List[str]] = None\n    \"\"\"The list of documents associated with the agent\"\"\"\n    welcome: str\n    \"\"\"The welcome message of the agent\"\"\"\n    pincode: Optional[str] = None\n    \"\"\"The pincode of the agent\"\"\"\n    is_public: bool\n    \"\"\"Whether the agent is public or not\"\"\"\n    agent_type: str\n    \"\"\"The type of the agent\"\"\"",
      "importStatements": [],
      "codeNoBody": "class Agent(BaseModel):\n    ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\types.py",
      "summary": "The \"Agent\" class, defined in the file with import statements from pydantic, typing, and json, includes parameters for the ID, name, prompt, model, list of agent documents, welcome message, pincode, public status, and agent type. The parameters are used to store information about an agent, such as its identification, attributes, associated documents, and messaging details."
    }
  ],
  "judini-python-main\\judini-python-main\\src\\judini\\utils.py": [
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\utils::handle_non_stream",
      "language": "python",
      "label": "handle_non_stream",
      "type": "function",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\utils",
      "totalTokens": 48,
      "inDegree": 0,
      "outDegree": 1,
      "code": "def handle_non_stream(response: requests.Response) -> str:\n    try:\n        text = response.json()\n        return text\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n    finally:\n        response.close()",
      "importStatements": [],
      "codeNoBody": "def handle_non_stream(response: requests.Response) -> str:\n    ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\utils.py",
      "summary": "This function named \"handle_non_stream\" takes a requests.Response object as a parameter and attempts to extract and return the JSON content from the response. If an exception occurs during the JSON extraction, it prints the error message. Finally, it ensures the response object is closed. The function does not require any import statements beyond the ones provided."
    },
    {
      "id": "judini-python-main\\judini-python-main\\src\\judini\\utils::handle_stream",
      "language": "python",
      "label": "handle_stream",
      "type": "function",
      "parent": "judini-python-main\\judini-python-main\\src\\judini\\utils",
      "totalTokens": 68,
      "inDegree": 0,
      "outDegree": 1,
      "code": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    try:\n        for chunk in response.iter_content(chunk_size=64, decode_unicode=True):\n            if chunk:\n                yield chunk\n    except Exception as e:\n        print(f\"Error occurred: {e}\", chunk)\n    finally:\n        response.close()",
      "importStatements": [],
      "codeNoBody": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    ...",
      "originFile": "judini-python-main\\judini-python-main\\src\\judini\\utils.py",
      "summary": "Uses the `requests` library to handle a streaming response. The function `handle_stream` takes a `response` object from `requests.Response` and yields chunks of data from the response iteratively with a chunk size of 64 bytes and decodes the content as Unicode. If an error occurs during the process, it prints the error message and the chunk causing the error, then closes the response."
    }
  ],
  "judini-python-main\\judini-python-main\\streamlit.py": [
    {
      "id": "judini-python-main\\judini-python-main\\streamlit::enable_stream",
      "language": "python",
      "label": "enable_stream",
      "type": "assignment",
      "parent": "judini-python-main\\judini-python-main\\streamlit",
      "totalTokens": 13,
      "inDegree": 0,
      "outDegree": 1,
      "code": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
      "importStatements": [],
      "codeNoBody": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
      "originFile": "judini-python-main\\judini-python-main\\streamlit.py",
      "summary": "The `enable_stream` assignment creates a Streamlit sidebar checkbox titled \"Enable Stream\" with a default value of True, utilizing the `streamlit` library for the user interface."
    },
    {
      "id": "judini-python-main\\judini-python-main\\streamlit::AGENT_ID",
      "language": "python",
      "label": "AGENT_ID",
      "type": "assignment",
      "parent": "judini-python-main\\judini-python-main\\streamlit",
      "totalTokens": 21,
      "inDegree": 0,
      "outDegree": 1,
      "code": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
      "importStatements": [],
      "codeNoBody": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
      "originFile": "judini-python-main\\judini-python-main\\streamlit.py",
      "summary": "Assigns the value of the \"Agent ID\" text input in the Streamlit sidebar to the variable AGENT_ID, with the initial value set to the existing \"agent_id\" value in the session state if available. Requires importing \"streamlit\" for the sidebar functionality."
    },
    {
      "id": "judini-python-main\\judini-python-main\\streamlit::CODEGPT_API_KEY",
      "language": "python",
      "label": "CODEGPT_API_KEY",
      "type": "assignment",
      "parent": "judini-python-main\\judini-python-main\\streamlit",
      "totalTokens": 34,
      "inDegree": 1,
      "outDegree": 1,
      "code": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
      "importStatements": [],
      "codeNoBody": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
      "originFile": "judini-python-main\\judini-python-main\\streamlit.py",
      "summary": "Assigns the CodeGPT API key inputted by the user in a Streamlit sidebar text input field, with the initial value retrieved from the session state if available. The assignment requires the 'streamlit' library to be imported."
    }
  ]
}