{
  "options": {
    "type": "directed",
    "multi": true,
    "allowSelfLoops": true
  },
  "attributes": {},
  "nodes": [
    {
      "key": "\\jest.config",
      "attributes": {
        "id": "\\jest.config",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\jest.config.js",
        "type": "file",
        "totalTokens": 53,
        "inDegree": 0,
        "outDegree": 0,
        "code": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };\r\n  ",
        "importStatements": [],
        "codeNoBody": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };",
        "originFile": "\\jest.config.js"
      }
    },
    {
      "key": "\\llamaindex::readJson",
      "attributes": {
        "id": "\\llamaindex::readJson",
        "language": "typescript",
        "label": "readJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\llamaindex",
        "totalTokens": 82,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
        "originFile": "\\llamaindex.ts"
      }
    },
    {
      "key": "\\llamaindex::main",
      "attributes": {
        "id": "\\llamaindex::main",
        "language": "typescript",
        "label": "main",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\llamaindex",
        "totalTokens": 293,
        "inDegree": 2,
        "outDegree": 1,
        "code": "async function main() {\r\n  // Load file\r\n  dotenv.config();\r\n  const path =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\grapNodes-codebase-index-ts-gpt-35-turbo.json\";\r\n  const data = await readJson(path);\r\n  //console.log(data);\r\n  const vectorStore = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n  });\r\n  //console.log(\"HEREEEEE\");\r\n  // Create Document object with file\r\n  const docs = [];\r\n  for (let i = 0; i < data.length; i++) {\r\n    docs.push(\r\n      new Document({ text: data[i].generatedDocumentation, id_: data[i].id })\r\n    );\r\n  }\r\n  //const document = new Document({ text: data, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments(docs, {\r\n    vectorStore,\r\n  });\r\n\r\n  // Query the index (own implementation for CODEGPT)\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  //\r\n  const response = await queryEngine.query({\r\n    query: \"What does the file db.ts do? Why is it important?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}",
        "importStatements": [],
        "codeNoBody": "async function main() {\n//...\n}",
        "originFile": "\\llamaindex.ts"
      }
    },
    {
      "key": "\\llamaindex",
      "attributes": {
        "id": "\\llamaindex",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\llamaindex.ts",
        "type": "file",
        "totalTokens": 418,
        "inDegree": 0,
        "outDegree": 3,
        "code": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport dotenv from \"dotenv\";\r\nasync function main() {\r\n  // Load file\r\n  dotenv.config();\r\n  const path =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\grapNodes-codebase-index-ts-gpt-35-turbo.json\";\r\n  const data = await readJson(path);\r\n  //console.log(data);\r\n  const vectorStore = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n  });\r\n  //console.log(\"HEREEEEE\");\r\n  // Create Document object with file\r\n  const docs = [];\r\n  for (let i = 0; i < data.length; i++) {\r\n    docs.push(\r\n      new Document({ text: data[i].generatedDocumentation, id_: data[i].id })\r\n    );\r\n  }\r\n  //const document = new Document({ text: data, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments(docs, {\r\n    vectorStore,\r\n  });\r\n\r\n  // Query the index (own implementation for CODEGPT)\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  //\r\n  const response = await queryEngine.query({\r\n    query: \"What does the file db.ts do? Why is it important?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}\r\n\r\nmain().catch(console.error);\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n",
        "importStatements": [
          "import fs from \"node:fs/promises\";",
          "import { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";",
          "import dotenv from \"dotenv\";"
        ],
        "codeNoBody": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport dotenv from \"dotenv\";\r\nasync function main() {\n//...\n}\r\nmain().catch(console.error);\r\n\r\nasync function readJson(filePath: string) {\n//...\n}",
        "originFile": "\\llamaindex.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::eigenvector",
      "attributes": {
        "id": "\\src\\communities\\centralities::eigenvector",
        "language": "typescript",
        "label": "eigenvector",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 13,
        "inDegree": 2,
        "outDegree": 1,
        "code": "const eigenvector = eigenvectorCentrality(graph);",
        "importStatements": [],
        "codeNoBody": "const eigenvector = eigenvectorCentrality(graph);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::pageranks",
      "attributes": {
        "id": "\\src\\communities\\centralities::pageranks",
        "language": "typescript",
        "label": "pageranks",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 1,
        "code": "const pageranks = pagerank(graph);",
        "importStatements": [],
        "codeNoBody": "const pageranks = pagerank(graph);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::closeness",
      "attributes": {
        "id": "\\src\\communities\\centralities::closeness",
        "language": "typescript",
        "label": "closeness",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 11,
        "inDegree": 2,
        "outDegree": 1,
        "code": "const closeness = closenessCentrality(graph);",
        "importStatements": [],
        "codeNoBody": "const closeness = closenessCentrality(graph);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::betweenness",
      "attributes": {
        "id": "\\src\\communities\\centralities::betweenness",
        "language": "typescript",
        "label": "betweenness",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 11,
        "inDegree": 2,
        "outDegree": 1,
        "code": "const betweenness = betweennessCentrality(graph);",
        "importStatements": [],
        "codeNoBody": "const betweenness = betweennessCentrality(graph);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::degree",
      "attributes": {
        "id": "\\src\\communities\\centralities::degree",
        "language": "typescript",
        "label": "degree",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 9,
        "inDegree": 2,
        "outDegree": 1,
        "code": "const degree = degreeCentrality(graph);",
        "importStatements": [],
        "codeNoBody": "const degree = degreeCentrality(graph);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::graph",
      "attributes": {
        "id": "\\src\\communities\\centralities::graph",
        "language": "typescript",
        "label": "graph",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 49,
        "inDegree": 6,
        "outDegree": 0,
        "code": "const graph = new Graph();\ngraph.addNode(\"fileA\", { type: \"file\" })\ngraph.addNode(\"methodB\", { type: \"method\" })\ngraph.addEdge(\"fileA\", \"methodB\", { type: \"calls\" })",
        "importStatements": [],
        "codeNoBody": "const graph = new Graph();\ngraph.addNode(\"fileA\", { type: \"file\" })\ngraph.addNode(\"methodB\", { type: \"method\" })\ngraph.addEdge(\"fileA\", \"methodB\", { type: \"calls\" })",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::constructGraphFromJson",
      "attributes": {
        "id": "\\src\\communities\\centralities::constructGraphFromJson",
        "language": "typescript",
        "label": "constructGraphFromJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 122,
        "inDegree": 1,
        "outDegree": 5,
        "code": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::readJson",
      "attributes": {
        "id": "\\src\\communities\\centralities::readJson",
        "language": "typescript",
        "label": "readJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 29,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}",
        "importStatements": [],
        "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::wikiLink",
      "attributes": {
        "id": "\\src\\communities\\centralities::wikiLink",
        "language": "typescript",
        "label": "wikiLink",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 21,
        "inDegree": 3,
        "outDegree": 1,
        "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::wikiNode",
      "attributes": {
        "id": "\\src\\communities\\centralities::wikiNode",
        "language": "typescript",
        "label": "wikiNode",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 90,
        "inDegree": 3,
        "outDegree": 1,
        "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::linksFilePath",
      "attributes": {
        "id": "\\src\\communities\\centralities::linksFilePath",
        "language": "typescript",
        "label": "linksFilePath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 15,
        "inDegree": 2,
        "outDegree": 2,
        "code": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
        "importStatements": [],
        "codeNoBody": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::nodesFilePath",
      "attributes": {
        "id": "\\src\\communities\\centralities::nodesFilePath",
        "language": "typescript",
        "label": "nodesFilePath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 15,
        "inDegree": 2,
        "outDegree": 2,
        "code": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
        "importStatements": [],
        "codeNoBody": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::folder_path",
      "attributes": {
        "id": "\\src\\communities\\centralities::folder_path",
        "language": "typescript",
        "label": "folder_path",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 10,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const folder_path = `../../test_files/`;",
        "importStatements": [],
        "codeNoBody": "const folder_path = `../../test_files/`;",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities::projectId",
      "attributes": {
        "id": "\\src\\communities\\centralities::projectId",
        "language": "typescript",
        "label": "projectId",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities",
        "totalTokens": 9,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const projectId = \"judini-python-main\";",
        "importStatements": [],
        "codeNoBody": "const projectId = \"judini-python-main\";",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\centralities",
      "attributes": {
        "id": "\\src\\communities\\centralities",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\centralities.ts",
        "type": "file",
        "totalTokens": 665,
        "inDegree": 0,
        "outDegree": 19,
        "code": "const { Graph } = require(\"graphology\");\r\nconst fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst {\r\n  degreeCentrality,\r\n  betweennessCentrality,\r\n  closenessCentrality,\r\n  eigenvectorCentrality,\r\n} = require(\"graphology-metrics/centrality\");\r\nconst { pagerank } = require(\"graphology-pagerank\");\r\nconst { hits } = require(\"graphology-hits\");\r\n\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}\r\n\r\n// Create the graph\r\nconst graph = new Graph();\r\n\r\n// Add nodes and edges\r\ngraph.addNode(\"fileA\", { type: \"file\" });\r\ngraph.addNode(\"methodB\", { type: \"method\" });\r\ngraph.addEdge(\"fileA\", \"methodB\", { type: \"calls\" });\r\n\r\n// Add more nodes and edges as needed...\r\n\r\n// Calculate centralities\r\nconst degree = degreeCentrality(graph);\r\nconst betweenness = betweennessCentrality(graph);\r\nconst closeness = closenessCentrality(graph);\r\nconst pageranks = pagerank(graph);\r\nconst { hubs, authorities } = hits(graph);\r\nconst eigenvector = eigenvectorCentrality(graph);\r\n\r\n// Print or use the centrality measures\r\nconsole.log(\"Degree Centrality:\", degree);\r\nconsole.log(\"Betweenness Centrality:\", betweenness);\r\nconsole.log(\"Closeness Centrality:\", closeness);\r\nconsole.log(\"PageRank:\", pageranks);\r\nconsole.log(\"Hubs:\", hubs);\r\nconsole.log(\"Authorities:\", authorities);\r\nconsole.log(\"Eigenvector Centrality:\", eigenvector);\r\n",
        "importStatements": [
          "const { Graph } = require(\"graphology\");",
          "const fs = require(\"fs\").promises;",
          "import { AllowedTypes } from \"../model/consts\";",
          "const {\r\n  degreeCentrality,\r\n  betweennessCentrality,\r\n  closenessCentrality,\r\n  eigenvectorCentrality,\r\n} = require(\"graphology-metrics/centrality\");",
          "const { pagerank } = require(\"graphology-pagerank\");",
          "const { hits } = require(\"graphology-hits\");"
        ],
        "codeNoBody": "const { Graph } = require(\"graphology\");\r\nconst fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst {\r\n  degreeCentrality,\r\n  betweennessCentrality,\r\n  closenessCentrality,\r\n  eigenvectorCentrality,\r\n} = require(\"graphology-metrics/centrality\");\r\nconst { pagerank } = require(\"graphology-pagerank\");\r\nconst { hits } = require(\"graphology-hits\");\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}\r\n\r\n// Create the graph\r\nconst graph = new Graph();\r\n\r\n// Add nodes and edges\r\ngraph.addNode(\"fileA\", { type: \"file\" });\r\ngraph.addNode(\"methodB\", { type: \"method\" });\r\ngraph.addEdge(\"fileA\", \"methodB\", { type: \"calls\" });\r\n\r\n// Add more nodes and edges as needed...\r\n\r\n// Calculate centralities\r\nconst degree = degreeCentrality(graph);\r\nconst betweenness = betweennessCentrality(graph);\r\nconst closeness = closenessCentrality(graph);\r\nconst pageranks = pagerank(graph);\r\nconst { hubs, authorities } = hits(graph);\r\nconst eigenvector = eigenvectorCentrality(graph);\r\n\r\n// Print or use the centrality measures\r\nconsole.log(\"Degree Centrality:\", degree);\r\nconsole.log(\"Betweenness Centrality:\", betweenness);\r\nconsole.log(\"Closeness Centrality:\", closeness);\r\nconsole.log(\"PageRank:\", pageranks);\r\nconsole.log(\"Hubs:\", hubs);\r\nconsole.log(\"Authorities:\", authorities);\r\nconsole.log(\"Eigenvector Centrality:\", eigenvector);",
        "originFile": "\\src\\communities\\centralities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::cmap",
      "attributes": {
        "id": "\\src\\communities\\communities::cmap",
        "language": "python",
        "label": "cmap",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 11,
        "inDegree": 1,
        "outDegree": 0,
        "code": "cmap = plt.get_cmap('viridis')",
        "importStatements": [],
        "codeNoBody": "cmap = plt.get_cmap('viridis')",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::pos",
      "attributes": {
        "id": "\\src\\communities\\communities::pos",
        "language": "python",
        "label": "pos",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 7,
        "inDegree": 1,
        "outDegree": 0,
        "code": "pos = nx.spring_layout(G)",
        "importStatements": [],
        "codeNoBody": "pos = nx.spring_layout(G)",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::partition",
      "attributes": {
        "id": "\\src\\communities\\communities::partition",
        "language": "python",
        "label": "partition",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 10,
        "inDegree": 1,
        "outDegree": 0,
        "code": "partition = community_louvain.best_partition(G)",
        "importStatements": [],
        "codeNoBody": "partition = community_louvain.best_partition(G)",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::G",
      "attributes": {
        "id": "\\src\\communities\\communities::G",
        "language": "python",
        "label": "G",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 10,
        "inDegree": 1,
        "outDegree": 0,
        "code": "G = construct_graph_from_json(nodes, links)",
        "importStatements": [],
        "codeNoBody": "G = construct_graph_from_json(nodes, links)",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::links",
      "attributes": {
        "id": "\\src\\communities\\communities::links",
        "language": "python",
        "label": "links",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 7,
        "inDegree": 1,
        "outDegree": 0,
        "code": "links = read_json(links_path)",
        "importStatements": [],
        "codeNoBody": "links = read_json(links_path)",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::nodes",
      "attributes": {
        "id": "\\src\\communities\\communities::nodes",
        "language": "python",
        "label": "nodes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 7,
        "inDegree": 1,
        "outDegree": 0,
        "code": "nodes = read_json(nodes_path)",
        "importStatements": [],
        "codeNoBody": "nodes = read_json(nodes_path)",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::construct_graph_from_json",
      "attributes": {
        "id": "\\src\\communities\\communities::construct_graph_from_json",
        "language": "python",
        "label": "construct_graph_from_json",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 56,
        "inDegree": 1,
        "outDegree": 0,
        "code": "def construct_graph_from_json(nodes, links):\r\n    G = nx.Graph()\r\n    for node in nodes:\r\n        G.add_node(node['id'], **node)\r\n    for link in links:\r\n        G.add_edge(link['source'], link['target'], **link)\r\n    return G",
        "importStatements": [],
        "codeNoBody": "def construct_graph_from_json(nodes, links):\r\n    ...",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::save_json",
      "attributes": {
        "id": "\\src\\communities\\communities::save_json",
        "language": "python",
        "label": "save_json",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 31,
        "inDegree": 1,
        "outDegree": 0,
        "code": "def save_json(data, file_path):\r\n    with open(file_path, 'w') as file:\r\n        json.dump(data, file, indent=4)",
        "importStatements": [],
        "codeNoBody": "def save_json(data, file_path):\r\n    ...",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::read_json",
      "attributes": {
        "id": "\\src\\communities\\communities::read_json",
        "language": "python",
        "label": "read_json",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 24,
        "inDegree": 1,
        "outDegree": 0,
        "code": "def read_json(file_path):\r\n    with open(file_path, 'r') as file:\r\n        return json.load(file)",
        "importStatements": [],
        "codeNoBody": "def read_json(file_path):\r\n    ...",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::graph_to_csv",
      "attributes": {
        "id": "\\src\\communities\\communities::graph_to_csv",
        "language": "python",
        "label": "graph_to_csv",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 72,
        "inDegree": 1,
        "outDegree": 0,
        "code": "def graph_to_csv(name='codebase'):\r\n\r\n    nodes = pd.read_json(\"nodesCommunities.json\")\r\n    nodes['full_name'] = nodes['id']\r\n    edges = pd.read_json(links_path)\r\n\r\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\r\n    edges.to_csv(f'edges_{name}.csv', index=False)",
        "importStatements": [],
        "codeNoBody": "def graph_to_csv(name='codebase'):\r\n    ...",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::links_path",
      "attributes": {
        "id": "\\src\\communities\\communities::links_path",
        "language": "python",
        "label": "links_path",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 13,
        "inDegree": 1,
        "outDegree": 0,
        "code": "links_path = f\"{folder_path}/{projectId}/links.json\"",
        "importStatements": [],
        "codeNoBody": "links_path = f\"{folder_path}/{projectId}/links.json\"",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::nodes_path",
      "attributes": {
        "id": "\\src\\communities\\communities::nodes_path",
        "language": "python",
        "label": "nodes_path",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 13,
        "inDegree": 1,
        "outDegree": 0,
        "code": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
        "importStatements": [],
        "codeNoBody": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
        "originFile": "\\src\\communities\\communities.py"
      }
    },
    {
      "key": "\\src\\communities\\communities::folder_path",
      "attributes": {
        "id": "\\src\\communities\\communities::folder_path",
        "language": "typescript",
        "label": "folder_path",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 10,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const folder_path = `../../test_files/`;",
        "importStatements": [],
        "codeNoBody": "const folder_path = `../../test_files/`;",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::projectId",
      "attributes": {
        "id": "\\src\\communities\\communities::projectId",
        "language": "typescript",
        "label": "projectId",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 9,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const projectId = \"judini-python-main\";",
        "importStatements": [],
        "codeNoBody": "const projectId = \"judini-python-main\";",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities",
      "attributes": {
        "id": "\\src\\communities\\communities",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
        "type": "file",
        "totalTokens": 663,
        "inDegree": 0,
        "outDegree": 12,
        "code": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\n\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();\r\n",
        "importStatements": [
          "const fs = require(\"fs\").promises;",
          "import { AllowedTypes } from \"../model/consts\";",
          "const { Graph } = require(\"graphology\");",
          "const louvain = require(\"graphology-communities-louvain\");",
          "import ForceSupervisor from \"graphology-layout-force/worker\";",
          "const sigma = require(\"sigma\");",
          "import { v4 as uuid } from \"uuid\";",
          "const express = require(\"express\");",
          "const path = require(\"path\");"
        ],
        "codeNoBody": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::constructGraphFromJson",
      "attributes": {
        "id": "\\src\\communities\\communities::constructGraphFromJson",
        "language": "typescript",
        "label": "constructGraphFromJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 122,
        "inDegree": 2,
        "outDegree": 5,
        "code": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::readJson",
      "attributes": {
        "id": "\\src\\communities\\communities::readJson",
        "language": "typescript",
        "label": "readJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 29,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}",
        "importStatements": [],
        "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::wikiLink",
      "attributes": {
        "id": "\\src\\communities\\communities::wikiLink",
        "language": "typescript",
        "label": "wikiLink",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 21,
        "inDegree": 3,
        "outDegree": 1,
        "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::wikiNode",
      "attributes": {
        "id": "\\src\\communities\\communities::wikiNode",
        "language": "typescript",
        "label": "wikiNode",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 90,
        "inDegree": 4,
        "outDegree": 1,
        "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::linksFilePath",
      "attributes": {
        "id": "\\src\\communities\\communities::linksFilePath",
        "language": "typescript",
        "label": "linksFilePath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 15,
        "inDegree": 3,
        "outDegree": 2,
        "code": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
        "importStatements": [],
        "codeNoBody": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\communities\\communities::nodesFilePath",
      "attributes": {
        "id": "\\src\\communities\\communities::nodesFilePath",
        "language": "typescript",
        "label": "nodesFilePath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities",
        "totalTokens": 15,
        "inDegree": 3,
        "outDegree": 2,
        "code": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
        "importStatements": [],
        "codeNoBody": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
        "originFile": "\\src\\communities\\communities.ts"
      }
    },
    {
      "key": "\\src\\index::const",
      "attributes": {
        "id": "\\src\\index::const",
        "language": "typescript",
        "label": "const",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index",
        "totalTokens": 7,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const app = new Hono();",
        "importStatements": [],
        "codeNoBody": "const app = new Hono();",
        "originFile": "\\src\\index.ts"
      }
    },
    {
      "key": "\\src\\index",
      "attributes": {
        "id": "\\src\\index",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index.ts",
        "type": "file",
        "totalTokens": 555,
        "inDegree": 0,
        "outDegree": 2,
        "code": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\n\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});\r\n",
        "importStatements": [
          "import { serve } from \"@hono/node-server\";",
          "import { Hono } from \"hono\";",
          "import { cors } from \"hono/cors\";",
          "import { prettyJSON } from \"hono/pretty-json\";",
          "import { createGraph } from \"./routes/create_graph\";",
          "import { createGraphTest } from \"./routes/create_graph-test\";",
          "import { graphs } from \"./routes/graphs\";",
          "import { Codebase } from \"./model/codebase\";",
          "import { writeFile } from \"node:fs/promises\";"
        ],
        "codeNoBody": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});",
        "originFile": "\\src\\index.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
      "attributes": {
        "id": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
        "language": "typescript",
        "label": "CallsCapturer.getCallsFromNode",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
        "totalTokens": 760,
        "inDegree": 1,
        "outDegree": 3,
        "code": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }",
        "importStatements": [],
        "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n    //...\n    }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallsCapturer.captureCalls",
      "attributes": {
        "id": "\\src\\model\\calls::CallsCapturer.captureCalls",
        "language": "typescript",
        "label": "CallsCapturer.captureCalls",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
        "totalTokens": 469,
        "inDegree": 2,
        "outDegree": 2,
        "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }",
        "importStatements": [],
        "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n    //...\n    }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallsCapturer.captureAssignments",
      "attributes": {
        "id": "\\src\\model\\calls::CallsCapturer.captureAssignments",
        "language": "typescript",
        "label": "CallsCapturer.captureAssignments",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
        "totalTokens": 425,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }",
        "importStatements": [],
        "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n    //...\n    }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallsCapturer.constructor",
      "attributes": {
        "id": "\\src\\model\\calls::CallsCapturer.constructor",
        "language": "typescript",
        "label": "CallsCapturer.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallsCapturer",
        "totalTokens": 159,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }",
        "importStatements": [],
        "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\n    //...\n    }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "id": "\\src\\model\\calls::CallsCapturer",
        "language": "typescript",
        "label": "CallsCapturer",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
        "totalTokens": 1849,
        "inDegree": 6,
        "outDegree": 7,
        "code": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
        "importStatements": [],
        "codeNoBody": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n        //...\n    }\r\n}",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallIdentifier.constructor",
      "attributes": {
        "id": "\\src\\model\\calls::CallIdentifier.constructor",
        "language": "typescript",
        "label": "CallIdentifier.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls::CallIdentifier",
        "totalTokens": 26,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }",
        "importStatements": [],
        "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\n    //...\n    }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "id": "\\src\\model\\calls::CallIdentifier",
        "language": "typescript",
        "label": "CallIdentifier",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
        "totalTokens": 45,
        "inDegree": 6,
        "outDegree": 2,
        "code": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
        "importStatements": [],
        "codeNoBody": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "id": "\\src\\model\\calls::VariableAssignment",
        "language": "typescript",
        "label": "VariableAssignment",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls",
        "totalTokens": 36,
        "inDegree": 5,
        "outDegree": 1,
        "code": "class VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}",
        "importStatements": [],
        "codeNoBody": "class VariableAssignment {\n//...\n}",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\calls",
      "attributes": {
        "id": "\\src\\model\\calls",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
        "type": "file",
        "totalTokens": 1967,
        "inDegree": 0,
        "outDegree": 6,
        "code": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\n\r\nclass VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}\r\n\r\nclass CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}\r\n\r\nexport class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
        "importStatements": [
          "import { cleanAndSplitContent, captureQuery } from \"./utils\"",
          "import { Node, ImportStatement} from \"./codebase\"",
          "import { itselfClassMap } from \"./consts\""
        ],
        "codeNoBody": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\nclass VariableAssignment {\n//...\n}\r\n\r\nclass CallIdentifier {\n//...\n}\r\n\r\nexport class CallsCapturer {\n       //...\n       }",
        "originFile": "\\src\\model\\calls.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "language": "typescript",
        "label": "Codebase.resolveHeaderC",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 181,
        "inDegree": 2,
        "outDegree": 4,
        "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "language": "typescript",
        "label": "Codebase.resolveImportStatementsNodes",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 395,
        "inDegree": 2,
        "outDegree": 3,
        "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
        "language": "typescript",
        "label": "Codebase.resolvePythonInitImportStatements",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 167,
        "inDegree": 2,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.getLinks",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.getLinks",
        "language": "typescript",
        "label": "Codebase.getLinks",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 186,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[] {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.simplify",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.simplify",
        "language": "typescript",
        "label": "Codebase.simplify",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 33,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.getCalls",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.getCalls",
        "language": "typescript",
        "label": "Codebase.getCalls",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 356,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.parseFolder",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.parseFolder",
        "language": "typescript",
        "label": "Codebase.parseFolder",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 231,
        "inDegree": 1,
        "outDegree": 7,
        "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "language": "typescript",
        "label": "Codebase.resolveSpaces",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 317,
        "inDegree": 2,
        "outDegree": 3,
        "code": "class Codebase\n    ...\n    resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    resolveSpaces() {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "language": "typescript",
        "label": "Codebase.generateNodesFromFilePath",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 374,
        "inDegree": 2,
        "outDegree": 6,
        "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
        "language": "typescript",
        "label": "Codebase.addNodeToSpaceMap",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 39,
        "inDegree": 2,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.addNodeMap",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.addNodeMap",
        "language": "typescript",
        "label": "Codebase.addNodeMap",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 32,
        "inDegree": 2,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.getNode",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.getNode",
        "language": "typescript",
        "label": "Codebase.getNode",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 18,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.addNode",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.addNode",
        "language": "typescript",
        "label": "Codebase.addNode",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 19,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Codebase\n    ...\n    addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase.constructor",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase.constructor",
        "language": "typescript",
        "label": "Codebase.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Codebase",
        "totalTokens": 17,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "id": "\\src\\model\\codebase::Codebase",
        "language": "typescript",
        "label": "Codebase",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 2450,
        "inDegree": 17,
        "outDegree": 17,
        "code": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\n      //...\n  }\r\n  getNode(id: string): Node | undefined {\n      //...\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\n      //...\n  }\r\n  addNodeToSpaceMap(node: Node) {\n      //...\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n      //...\n  }\r\n\r\n  resolveSpaces() {\n      //...\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\n      //...\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n\r\n  getLinks(): Link[] {\n      //...\n  }\r\n\r\n  resolvePythonInitImportStatements() {\n      //...\n  }\r\n\r\n  resolveImportStatementsNodes() {\n      //...\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\n      //...\n  }\r\n}",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.simplify",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.simplify",
        "language": "typescript",
        "label": "Node.simplify",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 302,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Node\n    ...\n    simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = [], rootFolderPath?: string) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.getChildrenDefinitions",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.getChildrenDefinitions",
        "language": "typescript",
        "label": "Node.getChildrenDefinitions",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 1502,
        "inDegree": 2,
        "outDegree": 2,
        "code": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
        "language": "typescript",
        "label": "Node.resolveImportStatementsPath",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 329,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.parseExportClauses",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.parseExportClauses",
        "language": "typescript",
        "label": "Node.parseExportClauses",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 692,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.generateImports",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.generateImports",
        "language": "typescript",
        "label": "Node.generateImports",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 391,
        "inDegree": 2,
        "outDegree": 3,
        "code": "class Node\n    ...\n    generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    generateImports() {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.getCodeWithoutBody",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.getCodeWithoutBody",
        "language": "typescript",
        "label": "Node.getCodeWithoutBody",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 855,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.addNodeRelationship",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.addNodeRelationship",
        "language": "typescript",
        "label": "Node.addNodeRelationship",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 225,
        "inDegree": 1,
        "outDegree": 3,
        "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.isWithin",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.isWithin",
        "language": "typescript",
        "label": "Node.isWithin",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 37,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.addImportStatement",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.addImportStatement",
        "language": "typescript",
        "label": "Node.addImportStatement",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 20,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.addCall",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.addCall",
        "language": "typescript",
        "label": "Node.addCall",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 46,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.removeChild",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.removeChild",
        "language": "typescript",
        "label": "Node.removeChild",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 48,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class Node\n    ...\n    removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    removeChild(child: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.addChild",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.addChild",
        "language": "typescript",
        "label": "Node.addChild",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 45,
        "inDegree": 4,
        "outDegree": 1,
        "code": "class Node\n    ...\n    addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    addChild(child: Node) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.getAllChildren",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.getAllChildren",
        "language": "typescript",
        "label": "Node.getAllChildren",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 74,
        "inDegree": 2,
        "outDegree": 1,
        "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.getChild",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.getChild",
        "language": "typescript",
        "label": "Node.getChild",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 89,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node.constructor",
      "attributes": {
        "id": "\\src\\model\\codebase::Node.constructor",
        "language": "typescript",
        "label": "Node.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::Node",
        "totalTokens": 52,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }",
        "importStatements": [],
        "codeNoBody": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Node",
      "attributes": {
        "id": "\\src\\model\\codebase::Node",
        "language": "typescript",
        "label": "Node",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 4932,
        "inDegree": 30,
        "outDegree": 18,
        "code": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\n      //...\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n      //...\n  }\r\n\r\n  addChild(child: Node) {\n      //...\n  }\r\n\r\n  removeChild(child: Node) {\n      //...\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\n      //...\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\n      //...\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\n      //...\n  }\r\n\r\n  addNodeRelationship(node: Node) {\n      //...\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n      //...\n  }\r\n\r\n  generateImports() {\n      //...\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n      //...\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n      //...\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\n      //...\n  }\r\n}",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::NodeCallTuple",
      "attributes": {
        "id": "\\src\\model\\codebase::NodeCallTuple",
        "language": "typescript",
        "label": "NodeCallTuple",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 21,
        "inDegree": 3,
        "outDegree": 2,
        "code": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r",
        "importStatements": [],
        "codeNoBody": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::Link",
      "attributes": {
        "id": "\\src\\model\\codebase::Link",
        "language": "typescript",
        "label": "Link",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 24,
        "inDegree": 5,
        "outDegree": 1,
        "code": "interface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}",
        "importStatements": [],
        "codeNoBody": "interface Link {\n//...\n}",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::ImportStatement.constructor",
      "attributes": {
        "id": "\\src\\model\\codebase::ImportStatement.constructor",
        "language": "typescript",
        "label": "ImportStatement.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportStatement",
        "totalTokens": 72,
        "inDegree": 1,
        "outDegree": 2,
        "code": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }",
        "importStatements": [],
        "codeNoBody": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "id": "\\src\\model\\codebase::ImportStatement",
        "language": "typescript",
        "label": "ImportStatement",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 105,
        "inDegree": 8,
        "outDegree": 3,
        "code": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::ImportName.constructor",
      "attributes": {
        "id": "\\src\\model\\codebase::ImportName.constructor",
        "language": "typescript",
        "label": "ImportName.constructor",
        "type": "method",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase::ImportName",
        "totalTokens": 26,
        "inDegree": 1,
        "outDegree": 1,
        "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }",
        "importStatements": [],
        "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\n  //...\n  }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "id": "\\src\\model\\codebase::ImportName",
        "language": "typescript",
        "label": "ImportName",
        "type": "class",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 58,
        "inDegree": 8,
        "outDegree": 3,
        "code": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase::const",
      "attributes": {
        "id": "\\src\\model\\codebase::const",
        "language": "typescript",
        "label": "const",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase",
        "totalTokens": 15,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const enc = encoding_for_model('gpt-4-turbo')",
        "importStatements": [],
        "codeNoBody": "const enc = encoding_for_model('gpt-4-turbo')",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\codebase",
      "attributes": {
        "id": "\\src\\model\\codebase",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
        "type": "file",
        "totalTokens": 7721,
        "inDegree": 0,
        "outDegree": 12,
        "code": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\n\r\nexport class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}\r\nexport class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}\r\n\r\ninterface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}\r\n\r\nexport class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }\r\n}\r\n",
        "importStatements": [
          "import fs from 'node:fs/promises'",
          "import { Point } from 'tree-sitter'",
          "import { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'",
          "import {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'",
          "import { CallsCapturer } from './calls'",
          "import path from 'path'",
          "import { encoding_for_model } from 'tiktoken'"
        ],
        "codeNoBody": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\nexport class ImportName {\n       //...\n       }\r\nexport class ImportStatement {\n       //...\n       }\r\n\r\ninterface Link {\n//...\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\n       //...\n       }\r\n\r\nexport class Codebase {\n       //...\n       }",
        "originFile": "\\src\\model\\codebase.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::treeSitterCommentTypes",
      "attributes": {
        "id": "\\src\\model\\consts::treeSitterCommentTypes",
        "language": "typescript",
        "label": "treeSitterCommentTypes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 19,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
        "importStatements": [],
        "codeNoBody": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::indexSuffixesMap",
      "attributes": {
        "id": "\\src\\model\\consts::indexSuffixesMap",
        "language": "typescript",
        "label": "indexSuffixesMap",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 73,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
        "importStatements": [],
        "codeNoBody": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::itselfClassMap",
      "attributes": {
        "id": "\\src\\model\\consts::itselfClassMap",
        "language": "typescript",
        "label": "itselfClassMap",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 58,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
        "importStatements": [],
        "codeNoBody": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::newClassMethodsMap",
      "attributes": {
        "id": "\\src\\model\\consts::newClassMethodsMap",
        "language": "typescript",
        "label": "newClassMethodsMap",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 69,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
        "importStatements": [],
        "codeNoBody": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::languageExtensionMap",
      "attributes": {
        "id": "\\src\\model\\consts::languageExtensionMap",
        "language": "typescript",
        "label": "languageExtensionMap",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 86,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
        "importStatements": [],
        "codeNoBody": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::languages",
      "attributes": {
        "id": "\\src\\model\\consts::languages",
        "language": "typescript",
        "label": "languages",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 28,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
        "importStatements": [],
        "codeNoBody": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::excludedExtensions",
      "attributes": {
        "id": "\\src\\model\\consts::excludedExtensions",
        "language": "typescript",
        "label": "excludedExtensions",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 39,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
        "importStatements": [],
        "codeNoBody": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::excludedFolders",
      "attributes": {
        "id": "\\src\\model\\consts::excludedFolders",
        "language": "typescript",
        "label": "excludedFolders",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 57,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]",
        "importStatements": [],
        "codeNoBody": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::AllowedTypesArray",
      "attributes": {
        "id": "\\src\\model\\consts::AllowedTypesArray",
        "language": "typescript",
        "label": "AllowedTypesArray",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 72,
        "inDegree": 1,
        "outDegree": 1,
        "code": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
        "importStatements": [],
        "codeNoBody": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts::AllowedTypes",
      "attributes": {
        "id": "\\src\\model\\consts::AllowedTypes",
        "language": "typescript",
        "label": "AllowedTypes",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts",
        "totalTokens": 79,
        "inDegree": 3,
        "outDegree": 1,
        "code": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
        "importStatements": [],
        "codeNoBody": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\consts",
      "attributes": {
        "id": "\\src\\model\\consts",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
        "type": "file",
        "totalTokens": 737,
        "inDegree": 0,
        "outDegree": 10,
        "code": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']\r\n",
        "importStatements": [
          "const JavaScript = require('tree-sitter-javascript')",
          "const Python = require('tree-sitter-python')",
          "const TypeScript = require('tree-sitter-typescript').typescript",
          "const TSX = require('tree-sitter-typescript').tsx",
          "const Java = require('tree-sitter-java')",
          "const C = require('tree-sitter-c')",
          "const PHP = require('tree-sitter-php').php"
        ],
        "codeNoBody": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
        "originFile": "\\src\\model\\consts.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::getCalledNode",
      "attributes": {
        "id": "\\src\\model\\utils::getCalledNode",
        "language": "typescript",
        "label": "getCalledNode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 87,
        "inDegree": 1,
        "outDegree": 0,
        "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
        "importStatements": [],
        "codeNoBody": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::cleanAndSplitContent",
      "attributes": {
        "id": "\\src\\model\\utils::cleanAndSplitContent",
        "language": "typescript",
        "label": "cleanAndSplitContent",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 128,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
        "importStatements": [],
        "codeNoBody": "const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::firstConsecutiveDots",
      "attributes": {
        "id": "\\src\\model\\utils::firstConsecutiveDots",
        "language": "typescript",
        "label": "firstConsecutiveDots",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 38,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
        "importStatements": [],
        "codeNoBody": "function firstConsecutiveDots(s: string): number {\n//...\n}",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::renameSource",
      "attributes": {
        "id": "\\src\\model\\utils::renameSource",
        "language": "typescript",
        "label": "renameSource",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 378,
        "inDegree": 1,
        "outDegree": 1,
        "code": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}",
        "importStatements": [],
        "codeNoBody": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::cleanDefCaptures",
      "attributes": {
        "id": "\\src\\model\\utils::cleanDefCaptures",
        "language": "typescript",
        "label": "cleanDefCaptures",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 162,
        "inDegree": 1,
        "outDegree": 0,
        "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
        "importStatements": [],
        "codeNoBody": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::captureQuery",
      "attributes": {
        "id": "\\src\\model\\utils::captureQuery",
        "language": "typescript",
        "label": "captureQuery",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 320,
        "inDegree": 1,
        "outDegree": 1,
        "code": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}",
        "importStatements": [],
        "codeNoBody": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::getRequiredDefinitions",
      "attributes": {
        "id": "\\src\\model\\utils::getRequiredDefinitions",
        "language": "typescript",
        "label": "getRequiredDefinitions",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 238,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
        "importStatements": [],
        "codeNoBody": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::getTotalSize",
      "attributes": {
        "id": "\\src\\model\\utils::getTotalSize",
        "language": "typescript",
        "label": "getTotalSize",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 87,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils::getAllFiles",
      "attributes": {
        "id": "\\src\\model\\utils::getAllFiles",
        "language": "typescript",
        "label": "getAllFiles",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils",
        "totalTokens": 243,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\model\\utils",
      "attributes": {
        "id": "\\src\\model\\utils",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
        "type": "file",
        "totalTokens": 2107,
        "inDegree": 0,
        "outDegree": 9,
        "code": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}\r\n\r\nfunction firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}\r\n",
        "importStatements": [
          "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";",
          "import { treeSitterQueries, languageQueries } from \"../queries\";",
          "import { glob } from \"glob\";",
          "import fs from \"node:fs/promises\";",
          "import path from \"path\";",
          "import Parser from \"tree-sitter\";",
          "import { Node, ImportStatement } from \"./codebase\";"
        ],
        "codeNoBody": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }\r\n\r\nfunction firstConsecutiveDots(s: string): number {\n//...\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
        "originFile": "\\src\\model\\utils.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::cQueries",
      "attributes": {
        "id": "\\src\\queries\\c::cQueries",
        "language": "typescript",
        "label": "cQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 55,
        "inDegree": 1,
        "outDegree": 4,
        "code": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "importStatements": [],
        "codeNoBody": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\c::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 65,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::calls",
      "attributes": {
        "id": "\\src\\queries\\c::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 30,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
        "importStatements": [],
        "codeNoBody": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\c::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 73,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\c::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 129,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c::signments",
      "attributes": {
        "id": "\\src\\queries\\c::signments",
        "language": "typescript",
        "label": "signments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c",
        "totalTokens": 47,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\c",
      "attributes": {
        "id": "\\src\\queries\\c",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
        "type": "file",
        "totalTokens": 660,
        "inDegree": 0,
        "outDegree": 6,
        "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    ` \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "importStatements": [
          "import { treeSitterQueries } from './index';"
        ],
        "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => {\n//...\n} \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\c.ts"
      }
    },
    {
      "key": "\\src\\queries\\index::treeSitterQueries",
      "attributes": {
        "id": "\\src\\queries\\index::treeSitterQueries",
        "language": "typescript",
        "label": "treeSitterQueries",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index",
        "totalTokens": 174,
        "inDegree": 2,
        "outDegree": 1,
        "code": "interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
        "importStatements": [],
        "codeNoBody": "interface treeSitterQueries {\n       //...\n       }",
        "originFile": "\\src\\queries\\index.ts"
      }
    },
    {
      "key": "\\src\\queries\\index::languageQueries",
      "attributes": {
        "id": "\\src\\queries\\index::languageQueries",
        "language": "typescript",
        "label": "languageQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index",
        "totalTokens": 44,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
        "importStatements": [],
        "codeNoBody": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
        "originFile": "\\src\\queries\\index.ts"
      }
    },
    {
      "key": "\\src\\queries\\index",
      "attributes": {
        "id": "\\src\\queries\\index",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index.ts",
        "type": "file",
        "totalTokens": 273,
        "inDegree": 0,
        "outDegree": 2,
        "code": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\n\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
        "importStatements": [
          "import { jsQueries } from \"./javascript\"",
          "import { tsQueries } from \"./typescript\"",
          "import { pyQueries } from \"./python\"",
          "import { javaQueries } from \"./java\"",
          "import { cQueries } from \"./c\"",
          "import { phpQueries } from \"./php\""
        ],
        "codeNoBody": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\n       //...\n       }",
        "originFile": "\\src\\queries\\index.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::javaQueries",
      "attributes": {
        "id": "\\src\\queries\\java::javaQueries",
        "language": "typescript",
        "label": "javaQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 54,
        "inDegree": 1,
        "outDegree": 5,
        "code": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "importStatements": [],
        "codeNoBody": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\java::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 51,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::calls",
      "attributes": {
        "id": "\\src\\queries\\java::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 30,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
        "importStatements": [],
        "codeNoBody": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\java::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 12,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = (name: string) => ``",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::spaceDeclaration",
      "attributes": {
        "id": "\\src\\queries\\java::spaceDeclaration",
        "language": "typescript",
        "label": "spaceDeclaration",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 14,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
        "importStatements": [],
        "codeNoBody": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\java::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 53,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java::signments",
      "attributes": {
        "id": "\\src\\queries\\java::signments",
        "language": "typescript",
        "label": "signments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java",
        "totalTokens": 4,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const assignments = ``",
        "importStatements": [],
        "codeNoBody": "const assignments = ``",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\java",
      "attributes": {
        "id": "\\src\\queries\\java",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
        "type": "file",
        "totalTokens": 481,
        "inDegree": 0,
        "outDegree": 7,
        "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = ``\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "importStatements": [
          "import { treeSitterQueries } from './index';"
        ],
        "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = {\n//...\n}\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "originFile": "\\src\\queries\\java.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::jsQueries",
      "attributes": {
        "id": "\\src\\queries\\javascript::jsQueries",
        "language": "typescript",
        "label": "jsQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 54,
        "inDegree": 1,
        "outDegree": 5,
        "code": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
        "importStatements": [],
        "codeNoBody": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\javascript::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 290,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::calls",
      "attributes": {
        "id": "\\src\\queries\\javascript::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 196,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;",
        "importStatements": [],
        "codeNoBody": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\javascript::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 73,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n};",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::exportClauses",
      "attributes": {
        "id": "\\src\\queries\\javascript::exportClauses",
        "language": "typescript",
        "label": "exportClauses",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 56,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
        "importStatements": [],
        "codeNoBody": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::arrowFunctionConstructor",
      "attributes": {
        "id": "\\src\\queries\\javascript::arrowFunctionConstructor",
        "language": "typescript",
        "label": "arrowFunctionConstructor",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 23,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
        "importStatements": [],
        "codeNoBody": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\javascript::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript",
        "totalTokens": 95,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\javascript",
      "attributes": {
        "id": "\\src\\queries\\javascript",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
        "type": "file",
        "totalTokens": 1482,
        "inDegree": 0,
        "outDegree": 8,
        "code": "// Tree-sitter definition + call queries for JavaScript\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};\r\n",
        "importStatements": [
          "import { treeSitterQueries } from \"./index\";"
        ],
        "codeNoBody": "// Tree-sitter definition + call queries for JavaScript\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n};\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
        "originFile": "\\src\\queries\\javascript.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::phpQueries",
      "attributes": {
        "id": "\\src\\queries\\php::phpQueries",
        "language": "typescript",
        "label": "phpQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 54,
        "inDegree": 1,
        "outDegree": 5,
        "code": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "importStatements": [],
        "codeNoBody": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\php::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 95,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::calls",
      "attributes": {
        "id": "\\src\\queries\\php::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 49,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
        "importStatements": [],
        "codeNoBody": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\php::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 58,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::spaceDeclaration",
      "attributes": {
        "id": "\\src\\queries\\php::spaceDeclaration",
        "language": "typescript",
        "label": "spaceDeclaration",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 18,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
        "importStatements": [],
        "codeNoBody": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\php::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 82,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php::signments",
      "attributes": {
        "id": "\\src\\queries\\php::signments",
        "language": "typescript",
        "label": "signments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php",
        "totalTokens": 38,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\php",
      "attributes": {
        "id": "\\src\\queries\\php",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
        "type": "file",
        "totalTokens": 863,
        "inDegree": 0,
        "outDegree": 7,
        "code": "// Tree-sitter definition + call queries for PHP\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "importStatements": [
          "import { treeSitterQueries } from './index';"
        ],
        "codeNoBody": "// Tree-sitter definition + call queries for PHP\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
        "originFile": "\\src\\queries\\php.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::pyQueries",
      "attributes": {
        "id": "\\src\\queries\\python::pyQueries",
        "language": "typescript",
        "label": "pyQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 56,
        "inDegree": 1,
        "outDegree": 4,
        "code": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
        "importStatements": [],
        "codeNoBody": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\python::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 65,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::calls",
      "attributes": {
        "id": "\\src\\queries\\python::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 318,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
        "importStatements": [],
        "codeNoBody": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\python::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 138,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\python::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 81,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python::signments",
      "attributes": {
        "id": "\\src\\queries\\python::signments",
        "language": "typescript",
        "label": "signments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python",
        "totalTokens": 32,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\python",
      "attributes": {
        "id": "\\src\\queries\\python",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
        "type": "file",
        "totalTokens": 1098,
        "inDegree": 0,
        "outDegree": 6,
        "code": "// Tree-sitter definition queries for Python\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}\r\n",
        "importStatements": [
          "import { treeSitterQueries } from './index';"
        ],
        "codeNoBody": "// Tree-sitter definition queries for Python\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\python.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::tsQueries",
      "attributes": {
        "id": "\\src\\queries\\typescript::tsQueries",
        "language": "typescript",
        "label": "tsQueries",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 49,
        "inDegree": 1,
        "outDegree": 5,
        "code": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "importStatements": [],
        "codeNoBody": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::anyAssignments",
      "attributes": {
        "id": "\\src\\queries\\typescript::anyAssignments",
        "language": "typescript",
        "label": "anyAssignments",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 52,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
        "importStatements": [],
        "codeNoBody": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::calls",
      "attributes": {
        "id": "\\src\\queries\\typescript::calls",
        "language": "typescript",
        "label": "calls",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 38,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
        "importStatements": [],
        "codeNoBody": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::extraAssignmentCode",
      "attributes": {
        "id": "\\src\\queries\\typescript::extraAssignmentCode",
        "language": "typescript",
        "label": "extraAssignmentCode",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 10,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
        "importStatements": [],
        "codeNoBody": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::exportClauses",
      "attributes": {
        "id": "\\src\\queries\\typescript::exportClauses",
        "language": "typescript",
        "label": "exportClauses",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 10,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const exportClauses = jsQueries.exportClauses",
        "importStatements": [],
        "codeNoBody": "const exportClauses = jsQueries.exportClauses",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript::definitionTemplate",
      "attributes": {
        "id": "\\src\\queries\\typescript::definitionTemplate",
        "language": "typescript",
        "label": "definitionTemplate",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript",
        "totalTokens": 127,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
        "importStatements": [],
        "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\queries\\typescript",
      "attributes": {
        "id": "\\src\\queries\\typescript",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
        "type": "file",
        "totalTokens": 598,
        "inDegree": 0,
        "outDegree": 6,
        "code": "// Tree-sitter definition queries for Typescript\r\n\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "importStatements": [
          "import { jsQueries } from './javascript';",
          "import { treeSitterQueries } from './index';"
        ],
        "codeNoBody": "// Tree-sitter definition queries for Typescript\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
        "originFile": "\\src\\queries\\typescript.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph-test::repoRequestValidator",
      "attributes": {
        "id": "\\src\\routes\\create_graph-test::repoRequestValidator",
        "language": "typescript",
        "label": "repoRequestValidator",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test",
        "totalTokens": 43,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
        "importStatements": [],
        "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
        "originFile": "\\src\\routes\\create_graph-test.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph-test::createGraphTest",
      "attributes": {
        "id": "\\src\\routes\\create_graph-test::createGraphTest",
        "language": "typescript",
        "label": "createGraphTest",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test",
        "totalTokens": 582,
        "inDegree": 1,
        "outDegree": 1,
        "code": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
        "importStatements": [],
        "codeNoBody": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
        "originFile": "\\src\\routes\\create_graph-test.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph-test",
      "attributes": {
        "id": "\\src\\routes\\create_graph-test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test.ts",
        "type": "file",
        "totalTokens": 396,
        "inDegree": 0,
        "outDegree": 3,
        "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
        "importStatements": [
          "import { Hono } from 'hono'",
          "import { z } from 'zod'",
          "import { zValidator } from '@hono/zod-validator'",
          "import { downloadAndExtractRepo, getCommitRepo } from '../utils/git'",
          "import { Codebase } from '../model/codebase'"
        ],
        "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
        "originFile": "\\src\\routes\\create_graph-test.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph::processGraphCreation",
      "attributes": {
        "id": "\\src\\routes\\create_graph::processGraphCreation",
        "language": "typescript",
        "label": "processGraphCreation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
        "totalTokens": 1020,
        "inDegree": 3,
        "outDegree": 0,
        "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label,\r\n            origin_file,\r\n            import_statements\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label},\r\n            ${node.originFile},\r\n            ${node.importStatements.join('\\n')}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    \r\n    if (generateDocBool) {\r\n\r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n \r\n\r\n\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\n//...\n}",
        "originFile": "\\src\\routes\\create_graph.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph::repoRequestValidator",
      "attributes": {
        "id": "\\src\\routes\\create_graph::repoRequestValidator",
        "language": "typescript",
        "label": "repoRequestValidator",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
        "totalTokens": 85,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)",
        "importStatements": [],
        "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)",
        "originFile": "\\src\\routes\\create_graph.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph::secret",
      "attributes": {
        "id": "\\src\\routes\\create_graph::secret",
        "language": "typescript",
        "label": "secret",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
        "totalTokens": 12,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const secret = getEnv('SUPABASE_JWT')",
        "importStatements": [],
        "codeNoBody": "const secret = getEnv('SUPABASE_JWT')",
        "originFile": "\\src\\routes\\create_graph.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph::createGraph",
      "attributes": {
        "id": "\\src\\routes\\create_graph::createGraph",
        "language": "typescript",
        "label": "createGraph",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph",
        "totalTokens": 1929,
        "inDegree": 1,
        "outDegree": 3,
        "code": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
        "importStatements": [],
        "codeNoBody": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
        "originFile": "\\src\\routes\\create_graph.ts"
      }
    },
    {
      "key": "\\src\\routes\\create_graph",
      "attributes": {
        "id": "\\src\\routes\\create_graph",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
        "type": "file",
        "totalTokens": 2203,
        "inDegree": 0,
        "outDegree": 7,
        "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label,\r\n            origin_file,\r\n            import_statements\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label},\r\n            ${node.originFile},\r\n            ${node.importStatements.join('\\n')}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    \r\n    if (generateDocBool) {\r\n\r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n \r\n\r\n\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { createGraph }\r\n",
        "importStatements": [
          "import { Hono } from 'hono'",
          "import { z } from 'zod'",
          "import { zValidator } from '@hono/zod-validator'",
          "import { GraphLink, GraphNode, sql } from '../utils/db'",
          "import { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
          "import { Codebase } from '../model/codebase'",
          "import { jwtVerify } from 'jose'",
          "import { getEnv } from '../utils/utils'",
          "import { GitServiceType } from '../utils/git'",
          "import { generateAndUpdateDocumentation } from '../wiki/wiki'"
        ],
        "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst secret = getEnv('SUPABASE_JWT')\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\n//...\n}\r\n\r\nexport { createGraph }",
        "originFile": "\\src\\routes\\create_graph.ts"
      }
    },
    {
      "key": "\\src\\routes\\graphs::updateGraph",
      "attributes": {
        "id": "\\src\\routes\\graphs::updateGraph",
        "language": "typescript",
        "label": "updateGraph",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
        "totalTokens": 957,
        "inDegree": 3,
        "outDegree": 1,
        "code": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label,\r\n          origin_file,\r\n          import_statements\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName},\r\n          ${node.label},\r\n          ${node.originFile},\r\n          ${node.importStatements.join('\\n')}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    if(generateDocBool) {\r\n      \r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\n//...\n}",
        "originFile": "\\src\\routes\\graphs.ts"
      }
    },
    {
      "key": "\\src\\routes\\graphs::UpdateGraph",
      "attributes": {
        "id": "\\src\\routes\\graphs::UpdateGraph",
        "language": "typescript",
        "label": "UpdateGraph",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
        "totalTokens": 62,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n  generateDocBool: boolean\r\n}",
        "importStatements": [],
        "codeNoBody": "interface UpdateGraph {\n//...\n}",
        "originFile": "\\src\\routes\\graphs.ts"
      }
    },
    {
      "key": "\\src\\routes\\graphs::graphs",
      "attributes": {
        "id": "\\src\\routes\\graphs::graphs",
        "language": "typescript",
        "label": "graphs",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs",
        "totalTokens": 2166,
        "inDegree": 1,
        "outDegree": 1,
        "code": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
        "importStatements": [],
        "codeNoBody": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
        "originFile": "\\src\\routes\\graphs.ts"
      }
    },
    {
      "key": "\\src\\routes\\graphs",
      "attributes": {
        "id": "\\src\\routes\\graphs",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
        "type": "file",
        "totalTokens": 2222,
        "inDegree": 0,
        "outDegree": 5,
        "code": "import { Hono } from 'hono'\r\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\n\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n  generateDocBool: boolean\r\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label,\r\n          origin_file,\r\n          import_statements\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName},\r\n          ${node.label},\r\n          ${node.originFile},\r\n          ${node.importStatements.join('\\n')}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    if(generateDocBool) {\r\n      \r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { graphs }\r\n",
        "importStatements": [
          "import { Hono } from 'hono'",
          "import { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'",
          "import { getEnv } from '../utils/utils'",
          "import { jwtVerify } from 'jose'",
          "import { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
          "import { Codebase } from '../model/codebase'",
          "import { v4 as uuidv4 } from 'uuid'",
          "import { generateAndUpdateDocumentation } from '../wiki/wiki'"
        ],
        "codeNoBody": "import { Hono } from 'hono'\r\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\n//...\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\n//...\n}\r\n\r\nexport { graphs }",
        "originFile": "\\src\\routes\\graphs.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::similarToDescription",
      "attributes": {
        "id": "\\src\\tools\\function_tools::similarToDescription",
        "language": "typescript",
        "label": "similarToDescription",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 91,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
        "importStatements": [],
        "codeNoBody": "export const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
        "language": "typescript",
        "label": "getCodebyNodeIdDescription",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 112,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}",
        "importStatements": [],
        "codeNoBody": "export const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getCodeDescription",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getCodeDescription",
        "language": "typescript",
        "label": "getCodeDescription",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 84,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
        "importStatements": [],
        "codeNoBody": "export const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::similarToTool",
      "attributes": {
        "id": "\\src\\tools\\function_tools::similarToTool",
        "language": "typescript",
        "label": "similarToTool",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "totalTokens": 35,
        "inDegree": 2,
        "outDegree": 1,
        "code": "function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }",
        "importStatements": [],
        "codeNoBody": "function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\n  //...\n  }",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
        "language": "typescript",
        "label": "getCodenbyNodeIdTool",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "totalTokens": 25,
        "inDegree": 2,
        "outDegree": 1,
        "code": "function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }",
        "importStatements": [],
        "codeNoBody": "function getCodenbyNodeIdTool(nodeId: string) {\n  //...\n  }",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getCodeTool",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getCodeTool",
        "language": "typescript",
        "label": "getCodeTool",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "totalTokens": 20,
        "inDegree": 2,
        "outDegree": 1,
        "code": "function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }",
        "importStatements": [],
        "codeNoBody": "function getCodeTool(nodeName: string) {\n  //...\n  }",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "language": "typescript",
        "label": "getUserToolsAndPrompt",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 552,
        "inDegree": 1,
        "outDegree": 11,
        "code": "async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getCode",
        "language": "typescript",
        "label": "getCode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 752,
        "inDegree": 5,
        "outDegree": 3,
        "code": "async function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\r\n  if (!nodesSeen) {\r\n    nodesSeen = {}\r\n  }\r\n\r\n  let node: GraphNode | undefined\r\n  if (nodeId) {\r\n    node = nodes.find((node) => node.id === nodeId)\r\n    if (node) {\r\n      nodeName = node.label\r\n    }\r\n  } else if (nodeName) {\r\n    node = nodes.find((node) => node.label === nodeName) ||\r\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\r\n  }\r\n\r\n  let toReturn = ''\r\n  if (maxTokens < 0) {\r\n    return toReturn\r\n  }\r\n\r\n  if (Object.keys(nodesSeen).length > 0) {\r\n    toReturn += '\\n\\n-------\\n\\n'\r\n  }\r\n\r\n  if (node) {\r\n    nodesSeen[node.id] = true\r\n    const language = node.language\r\n    toReturn += `From ${node.full_name}:\\n`\r\n    if (node.documentation) {\r\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\r\n    }\r\n    if (node.total_tokens > maxTokens || node.type === 'file') {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\r\n    } else {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\r\n    }\r\n\r\n    if (maxDeepLevel > 0) {\r\n      maxDeepLevel -= 1\r\n      const calls = links.filter((link) =>\r\n        link.node_source_id === node!.id && link.label === 'calls'\r\n      )\r\n      for (const call of calls) {\r\n        if (nodesSeen[call.node_target_id]) {\r\n          continue\r\n        }\r\n        nodesSeen[call.node_target_id] = true\r\n        const callNode = await getCode(\r\n          nodes,\r\n          links,\r\n          undefined,\r\n          call.node_target_id,\r\n          maxTokens - node.total_tokens,\r\n          nodesSeen,\r\n          maxDeepLevel,\r\n        )\r\n        toReturn += callNode\r\n      }\r\n    }\r\n  } else {\r\n    toReturn = `There is no node named ${nodeName}.\\n`\r\n    if (nodeName) {\r\n      const res = similarTo(nodeName, nodes)\r\n      return {\r\n        ...res,\r\n        content: toReturn + res.content,\r\n        targetNodes: [],\r\n        sourceNodes: [],\r\n      }\r\n    }\r\n  }\r\n\r\n  let targetNodes: GraphNode[] = []\r\n  let sourceNodes: GraphNode[] = []\r\n\r\n  if (node) {\r\n    const targetLinks = links.filter((link) => {\r\n      return link.node_source_id === node.id\r\n    }) ?? []\r\n\r\n    const sourceLinks = links.filter((link) => {\r\n      return link.node_target_id === node.id\r\n    }) ?? []\r\n\r\n    sourceNodes = nodes.filter((node) => {\r\n      return sourceLinks.some((link) => link.node_source_id === node.id)\r\n    }) ?? []\r\n\r\n    targetNodes = nodes.filter((node) => {\r\n      return targetLinks.some((link) => link.node_target_id === node.id)\r\n    }) ?? []\r\n  }\r\n\r\n  return {\r\n    content: toReturn,\r\n    match: nodeName,\r\n    topFiles: [],\r\n    topClasses: [],\r\n    topFunctions: [],\r\n    topMethods: [],\r\n    topInterfaces: [],\r\n    topAssignments: [],\r\n    targetNodes,\r\n    sourceNodes,\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::nodeSeen",
      "attributes": {
        "id": "\\src\\tools\\function_tools::nodeSeen",
        "language": "typescript",
        "label": "nodeSeen",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 13,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface nodeSeen {\r\n  [key: string]: boolean\r\n}",
        "importStatements": [],
        "codeNoBody": "interface nodeSeen {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::similarTo",
      "attributes": {
        "id": "\\src\\tools\\function_tools::similarTo",
        "language": "typescript",
        "label": "similarTo",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 781,
        "inDegree": 4,
        "outDegree": 1,
        "code": "function similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\r\n  const similarNodes = []\r\n  let topFiles: string[] = []\r\n  let topClasses: string[] = []\r\n  let topFunctions: string[] = []\r\n  let topMethods: string[] = []\r\n  let topInterfaces: string[] = []\r\n  let topAssignments: string[] = []\r\n  let similars: string[] = []\r\n\r\n  if (type === 'all') {\r\n    topFiles = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'file'),\r\n      n,\r\n    )\r\n\r\n    topClasses = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'class'),\r\n      n,\r\n    )\r\n    topFunctions = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'function'),\r\n      n,\r\n    )\r\n    topMethods = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'method'),\r\n      n,\r\n    )\r\n    topInterfaces = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'interface'),\r\n      n,\r\n    )\r\n    topAssignments = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'assignment'),\r\n      n,\r\n    )\r\n\r\n    if (topFiles.length > 0) {\r\n      similarNodes.push(` - Files: ${topFiles}`)\r\n    }\r\n    if (topClasses.length > 0) {\r\n      similarNodes.push(` - Classes: ${topClasses}`)\r\n    }\r\n    if (topFunctions.length > 0) {\r\n      similarNodes.push(` - Functions: ${topFunctions}`)\r\n    }\r\n    if (topMethods.length > 0) {\r\n      similarNodes.push(` - Methods: ${topMethods}`)\r\n    }\r\n    if (topInterfaces.length > 0) {\r\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\r\n    }\r\n    if (topAssignments.length > 0) {\r\n      similarNodes.push(` - Assignments: ${topAssignments}`)\r\n    }\r\n  } else {\r\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\r\n    if (similars.length > 0) {\r\n      similarNodes.push(\r\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\r\n      )\r\n    }\r\n  }\r\n\r\n  if (similarNodes.length === 0) {\r\n    return {\r\n      content: `No similar node IDs found for ${name}.`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  } else {\r\n    return {\r\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "function similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::topNSimilar",
      "attributes": {
        "id": "\\src\\tools\\function_tools::topNSimilar",
        "language": "typescript",
        "label": "topNSimilar",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 121,
        "inDegree": 2,
        "outDegree": 1,
        "code": "function topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\r\n  const similarities: Similarity[] = nodes.map((n) => ({\r\n    id: n.full_name,\r\n    score: distance(targetName, n.label),\r\n  }))\r\n\r\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\r\n\r\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\r\n    .map((item) => item.id)\r\n}",
        "importStatements": [],
        "codeNoBody": "function topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getGraphLinksById",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getGraphLinksById",
        "language": "typescript",
        "label": "getGraphLinksById",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 169,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id,\r\n        l.node_target_id,\r\n        l.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::getGraphNodesById",
      "attributes": {
        "id": "\\src\\tools\\function_tools::getGraphNodesById",
        "language": "typescript",
        "label": "getGraphNodesById",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 197,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name,\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body,\r\n        n.total_tokens,\r\n        n.in_degree,\r\n        n.out_degree,\r\n        n.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::Similarity",
      "attributes": {
        "id": "\\src\\tools\\function_tools::Similarity",
        "language": "typescript",
        "label": "Similarity",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 15,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface Similarity {\r\n  id: string\r\n  score: number\r\n}",
        "importStatements": [],
        "codeNoBody": "interface Similarity {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools::calculateLanguagePercentages",
      "attributes": {
        "id": "\\src\\tools\\function_tools::calculateLanguagePercentages",
        "language": "typescript",
        "label": "calculateLanguagePercentages",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools",
        "totalTokens": 162,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function calculateLanguagePercentages(languages: string[]) {\r\n  const total = languages.length\r\n  const counts: Record<string, number> = {}\r\n\r\n  languages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1\r\n  })\r\n\r\n  const percentages: Record<string, string> = {}\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\r\n    parseFloat(b[1]) - parseFloat(a[1])\r\n  )\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\r\n\r\n  return sortedPercentages\r\n}",
        "importStatements": [],
        "codeNoBody": "function calculateLanguagePercentages(languages: string[]) {\n//...\n}",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\tools\\function_tools",
      "attributes": {
        "id": "\\src\\tools\\function_tools",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
        "type": "file",
        "totalTokens": 3749,
        "inDegree": 0,
        "outDegree": 14,
        "code": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\r\nimport { sql } from '@/lib/db/index.ts'\r\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\r\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\r\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\r\n\r\nfunction calculateLanguagePercentages(languages: string[]) {\r\n  const total = languages.length\r\n  const counts: Record<string, number> = {}\r\n\r\n  languages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1\r\n  })\r\n\r\n  const percentages: Record<string, string> = {}\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\r\n    parseFloat(b[1]) - parseFloat(a[1])\r\n  )\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\r\n\r\n  return sortedPercentages\r\n}\r\n\r\ninterface Similarity {\r\n  id: string\r\n  score: number\r\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name,\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body,\r\n        n.total_tokens,\r\n        n.in_degree,\r\n        n.out_degree,\r\n        n.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id,\r\n        l.node_target_id,\r\n        l.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nfunction topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\r\n  const similarities: Similarity[] = nodes.map((n) => ({\r\n    id: n.full_name,\r\n    score: distance(targetName, n.label),\r\n  }))\r\n\r\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\r\n\r\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\r\n    .map((item) => item.id)\r\n}\r\n\r\n/**\r\n * Finds the most similar nodes to the given name based on their type.\r\n *\r\n * @param {string} name - The name to compare against.\r\n * @param {GraphNode[]} nodes - The array of nodes to search.\r\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\r\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\r\n */\r\nfunction similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\r\n  const similarNodes = []\r\n  let topFiles: string[] = []\r\n  let topClasses: string[] = []\r\n  let topFunctions: string[] = []\r\n  let topMethods: string[] = []\r\n  let topInterfaces: string[] = []\r\n  let topAssignments: string[] = []\r\n  let similars: string[] = []\r\n\r\n  if (type === 'all') {\r\n    topFiles = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'file'),\r\n      n,\r\n    )\r\n\r\n    topClasses = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'class'),\r\n      n,\r\n    )\r\n    topFunctions = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'function'),\r\n      n,\r\n    )\r\n    topMethods = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'method'),\r\n      n,\r\n    )\r\n    topInterfaces = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'interface'),\r\n      n,\r\n    )\r\n    topAssignments = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'assignment'),\r\n      n,\r\n    )\r\n\r\n    if (topFiles.length > 0) {\r\n      similarNodes.push(` - Files: ${topFiles}`)\r\n    }\r\n    if (topClasses.length > 0) {\r\n      similarNodes.push(` - Classes: ${topClasses}`)\r\n    }\r\n    if (topFunctions.length > 0) {\r\n      similarNodes.push(` - Functions: ${topFunctions}`)\r\n    }\r\n    if (topMethods.length > 0) {\r\n      similarNodes.push(` - Methods: ${topMethods}`)\r\n    }\r\n    if (topInterfaces.length > 0) {\r\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\r\n    }\r\n    if (topAssignments.length > 0) {\r\n      similarNodes.push(` - Assignments: ${topAssignments}`)\r\n    }\r\n  } else {\r\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\r\n    if (similars.length > 0) {\r\n      similarNodes.push(\r\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\r\n      )\r\n    }\r\n  }\r\n\r\n  if (similarNodes.length === 0) {\r\n    return {\r\n      content: `No similar node IDs found for ${name}.`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  } else {\r\n    return {\r\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  }\r\n}\r\n\r\ninterface nodeSeen {\r\n  [key: string]: boolean\r\n}\r\n\r\nasync function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\r\n  if (!nodesSeen) {\r\n    nodesSeen = {}\r\n  }\r\n\r\n  let node: GraphNode | undefined\r\n  if (nodeId) {\r\n    node = nodes.find((node) => node.id === nodeId)\r\n    if (node) {\r\n      nodeName = node.label\r\n    }\r\n  } else if (nodeName) {\r\n    node = nodes.find((node) => node.label === nodeName) ||\r\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\r\n  }\r\n\r\n  let toReturn = ''\r\n  if (maxTokens < 0) {\r\n    return toReturn\r\n  }\r\n\r\n  if (Object.keys(nodesSeen).length > 0) {\r\n    toReturn += '\\n\\n-------\\n\\n'\r\n  }\r\n\r\n  if (node) {\r\n    nodesSeen[node.id] = true\r\n    const language = node.language\r\n    toReturn += `From ${node.full_name}:\\n`\r\n    if (node.documentation) {\r\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\r\n    }\r\n    if (node.total_tokens > maxTokens || node.type === 'file') {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\r\n    } else {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\r\n    }\r\n\r\n    if (maxDeepLevel > 0) {\r\n      maxDeepLevel -= 1\r\n      const calls = links.filter((link) =>\r\n        link.node_source_id === node!.id && link.label === 'calls'\r\n      )\r\n      for (const call of calls) {\r\n        if (nodesSeen[call.node_target_id]) {\r\n          continue\r\n        }\r\n        nodesSeen[call.node_target_id] = true\r\n        const callNode = await getCode(\r\n          nodes,\r\n          links,\r\n          undefined,\r\n          call.node_target_id,\r\n          maxTokens - node.total_tokens,\r\n          nodesSeen,\r\n          maxDeepLevel,\r\n        )\r\n        toReturn += callNode\r\n      }\r\n    }\r\n  } else {\r\n    toReturn = `There is no node named ${nodeName}.\\n`\r\n    if (nodeName) {\r\n      const res = similarTo(nodeName, nodes)\r\n      return {\r\n        ...res,\r\n        content: toReturn + res.content,\r\n        targetNodes: [],\r\n        sourceNodes: [],\r\n      }\r\n    }\r\n  }\r\n\r\n  let targetNodes: GraphNode[] = []\r\n  let sourceNodes: GraphNode[] = []\r\n\r\n  if (node) {\r\n    const targetLinks = links.filter((link) => {\r\n      return link.node_source_id === node.id\r\n    }) ?? []\r\n\r\n    const sourceLinks = links.filter((link) => {\r\n      return link.node_target_id === node.id\r\n    }) ?? []\r\n\r\n    sourceNodes = nodes.filter((node) => {\r\n      return sourceLinks.some((link) => link.node_source_id === node.id)\r\n    }) ?? []\r\n\r\n    targetNodes = nodes.filter((node) => {\r\n      return targetLinks.some((link) => link.node_target_id === node.id)\r\n    }) ?? []\r\n  }\r\n\r\n  return {\r\n    content: toReturn,\r\n    match: nodeName,\r\n    topFiles: [],\r\n    topClasses: [],\r\n    topFunctions: [],\r\n    topMethods: [],\r\n    topInterfaces: [],\r\n    topAssignments: [],\r\n    targetNodes,\r\n    sourceNodes,\r\n  }\r\n}\r\n\r\nexport async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}\r\n\r\nexport const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}\r\n\r\nexport const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\r\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\r\n\r\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\r\n// const links = await getGraphLinksById({ userOrgId, graphId })\r\n\r\n// console.log(await getCode(nodes, links, 'langchain_utils'))\r\n\r\n// // console.log(similarTo('Props', nodes, 'all'))\r\n// const nodesPerType = nodes.reduce((acc, node) => {\r\n//   if (!acc[node.type]) {\r\n//     acc[node.type] = []\r\n//   }\r\n//   acc[node.type].push(node)\r\n//   return acc\r\n// }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\r\n\r\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\r\n// console.log(allLanguagesString)\r\n\r\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\r\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\r\n//     ).slice(0, 5).map((n) => n.full_name)\r\n//   return acc\r\n// }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\r\n// }).join('\\n')\r\n\r\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n// These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n// console.log(prompt)\r\n",
        "importStatements": [
          "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'",
          "import { sql } from '@/lib/db/index.ts'",
          "import { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'",
          "import { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'",
          "import { CONFIGURATION } from '@/lib/ai/consts.ts'"
        ],
        "codeNoBody": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\r\nimport { sql } from '@/lib/db/index.ts'\r\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\r\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\r\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\r\nfunction calculateLanguagePercentages(languages: string[]) {\n//...\n}\r\n\r\ninterface Similarity {\n//...\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }\r\n\r\nfunction topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\n//...\n}\r\n\r\n/**\r\n * Finds the most similar nodes to the given name based on their type.\r\n *\r\n * @param {string} name - The name to compare against.\r\n * @param {GraphNode[]} nodes - The array of nodes to search.\r\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\r\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\r\n */\r\nfunction similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\n//...\n}\r\n\r\ninterface nodeSeen {\n//...\n}\r\n\r\nasync function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\n//...\n}\r\n\r\nexport async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\n       //...\n       }\r\n\r\nexport const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}\r\n\r\nexport const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\r\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\r\n\r\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\r\n// const links = await getGraphLinksById({ userOrgId, graphId })\r\n\r\n// console.log(await getCode(nodes, links, 'langchain_utils'))\r\n\r\n// // console.log(similarTo('Props', nodes, 'all'))\r\n// const nodesPerType = nodes.reduce((acc, node) => {\r\n//   if (!acc[node.type]) {\r\n//     acc[node.type] = []\r\n//   }\r\n//   acc[node.type].push(node)\r\n//   return acc\r\n// }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\r\n\r\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\r\n// console.log(allLanguagesString)\r\n\r\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\r\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\r\n//     ).slice(0, 5).map((n) => n.full_name)\r\n//   return acc\r\n// }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\r\n// }).join('\\n')\r\n\r\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n// These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n// console.log(prompt)",
        "originFile": "\\src\\tools\\function_tools.ts"
      }
    },
    {
      "key": "\\src\\utils\\ai::getOpenAIChatCompletion",
      "attributes": {
        "id": "\\src\\utils\\ai::getOpenAIChatCompletion",
        "language": "typescript",
        "label": "getOpenAIChatCompletion",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai",
        "totalTokens": 143,
        "inDegree": 1,
        "outDegree": 2,
        "code": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\n       //...\n       }",
        "originFile": "\\src\\utils\\ai.ts"
      }
    },
    {
      "key": "\\src\\utils\\ai::chatResponse",
      "attributes": {
        "id": "\\src\\utils\\ai::chatResponse",
        "language": "typescript",
        "label": "chatResponse",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai",
        "totalTokens": 15,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}",
        "importStatements": [],
        "codeNoBody": "interface chatResponse {\n//...\n}",
        "originFile": "\\src\\utils\\ai.ts"
      }
    },
    {
      "key": "\\src\\utils\\ai::chatCompletionMessages",
      "attributes": {
        "id": "\\src\\utils\\ai::chatCompletionMessages",
        "language": "typescript",
        "label": "chatCompletionMessages",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai",
        "totalTokens": 16,
        "inDegree": 4,
        "outDegree": 1,
        "code": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
        "importStatements": [],
        "codeNoBody": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
        "originFile": "\\src\\utils\\ai.ts"
      }
    },
    {
      "key": "\\src\\utils\\ai",
      "attributes": {
        "id": "\\src\\utils\\ai",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
        "type": "file",
        "totalTokens": 185,
        "inDegree": 0,
        "outDegree": 5,
        "code": "import OpenAI from 'openai';\r\n\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
        "importStatements": [
          "import OpenAI from 'openai';"
        ],
        "codeNoBody": "import OpenAI from 'openai';\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\n//...\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\n       //...\n       }",
        "originFile": "\\src\\utils\\ai.ts"
      }
    },
    {
      "key": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
      "attributes": {
        "id": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
        "language": "typescript",
        "label": "refreshAccessToken",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token",
        "totalTokens": 245,
        "inDegree": 1,
        "outDegree": 0,
        "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
        "originFile": "\\src\\utils\\bitbucket\\refresh-token.ts"
      }
    },
    {
      "key": "\\src\\utils\\bitbucket\\refresh-token",
      "attributes": {
        "id": "\\src\\utils\\bitbucket\\refresh-token",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts",
        "type": "file",
        "totalTokens": 255,
        "inDegree": 0,
        "outDegree": 1,
        "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
        "importStatements": [
          "import { getEnv } from \"../utils\""
        ],
        "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
        "originFile": "\\src\\utils\\bitbucket\\refresh-token.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::getGraphFolderById",
      "attributes": {
        "id": "\\src\\utils\\db::getGraphFolderById",
        "language": "typescript",
        "label": "getGraphFolderById",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 163,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\r\n  try {\r\n    const rows = await sql<GraphFolder[]>`\r\n      SELECT\r\n        f.id,\r\n        f.name,\r\n        f.wiki\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN graph_folders f\r\n        ON f.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph folder by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::getGraphLinksById",
      "attributes": {
        "id": "\\src\\utils\\db::getGraphLinksById",
        "language": "typescript",
        "label": "getGraphLinksById",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 177,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::getGraphNodesById",
      "attributes": {
        "id": "\\src\\utils\\db::getGraphNodesById",
        "language": "typescript",
        "label": "getGraphNodesById",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 246,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS \"fullName\",\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS \"codeNoBody\",\r\n        n.total_tokens AS \"totalTokens\",\r\n        n.in_degree AS \"inDegree\",\r\n        n.out_degree AS \"outDegree\",\r\n        n.label,\r\n        n.origin_file AS \"originFile\",\r\n        n.generated_documentation AS \"generatedDocumentation\",\r\n        n.import_statements AS \"importStatements\"\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::GraphFolder",
      "attributes": {
        "id": "\\src\\utils\\db::GraphFolder",
        "language": "typescript",
        "label": "GraphFolder",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 20,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface GraphFolder {\r\n  id: string\r\n  name: string\r\n  wiki: string\r\n}",
        "importStatements": [],
        "codeNoBody": "interface GraphFolder {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::GraphLink",
      "attributes": {
        "id": "\\src\\utils\\db::GraphLink",
        "language": "typescript",
        "label": "GraphLink",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 30,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}",
        "importStatements": [],
        "codeNoBody": "interface GraphLink {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::GraphNode",
      "attributes": {
        "id": "\\src\\utils\\db::GraphNode",
        "language": "typescript",
        "label": "GraphNode",
        "type": "interface",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 84,
        "inDegree": 4,
        "outDegree": 1,
        "code": "interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}",
        "importStatements": [],
        "codeNoBody": "interface GraphNode {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db::sql",
      "attributes": {
        "id": "\\src\\utils\\db::sql",
        "language": "typescript",
        "label": "sql",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db",
        "totalTokens": 108,
        "inDegree": 1,
        "outDegree": 0,
        "code": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
        "importStatements": [],
        "codeNoBody": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\db",
      "attributes": {
        "id": "\\src\\utils\\db",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
        "type": "file",
        "totalTokens": 861,
        "inDegree": 0,
        "outDegree": 10,
        "code": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\n\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}\r\n\r\nexport interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}\r\n\r\nexport interface GraphFolder {\r\n  id: string\r\n  name: string\r\n  wiki: string\r\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS \"fullName\",\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS \"codeNoBody\",\r\n        n.total_tokens AS \"totalTokens\",\r\n        n.in_degree AS \"inDegree\",\r\n        n.out_degree AS \"outDegree\",\r\n        n.label,\r\n        n.origin_file AS \"originFile\",\r\n        n.generated_documentation AS \"generatedDocumentation\",\r\n        n.import_statements AS \"importStatements\"\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\r\n  try {\r\n    const rows = await sql<GraphFolder[]>`\r\n      SELECT\r\n        f.id,\r\n        f.name,\r\n        f.wiki\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN graph_folders f\r\n        ON f.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph folder by id', error)\r\n    return []\r\n  }\r\n}",
        "importStatements": [
          "import { AllowedTypes } from '../model/consts'",
          "import { getEnv } from './utils'",
          "import postgres from 'postgres'"
        ],
        "codeNoBody": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\n       //...\n       }\r\n\r\nexport interface GraphLink {\n       //...\n       }\r\n\r\nexport interface GraphFolder {\n       //...\n       }\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }\r\n\r\nexport async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\n       //...\n       }",
        "originFile": "\\src\\utils\\db.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::getAccessToken",
      "attributes": {
        "id": "\\src\\utils\\git::getAccessToken",
        "language": "typescript",
        "label": "getAccessToken",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 217,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::getCommitHash",
      "attributes": {
        "id": "\\src\\utils\\git::getCommitHash",
        "language": "typescript",
        "label": "getCommitHash",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 89,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
        "importStatements": [],
        "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::getCommitRepo",
      "attributes": {
        "id": "\\src\\utils\\git::getCommitRepo",
        "language": "typescript",
        "label": "getCommitRepo",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 616,
        "inDegree": 1,
        "outDegree": 2,
        "code": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::downloadAndExtractRepo",
      "attributes": {
        "id": "\\src\\utils\\git::downloadAndExtractRepo",
        "language": "typescript",
        "label": "downloadAndExtractRepo",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 569,
        "inDegree": 1,
        "outDegree": 2,
        "code": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::MAXSIZE",
      "attributes": {
        "id": "\\src\\utils\\git::MAXSIZE",
        "language": "typescript",
        "label": "MAXSIZE",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 9,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const MAXSIZE = 2 // MB\r",
        "importStatements": [],
        "codeNoBody": "const MAXSIZE = 2 // MB",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "id": "\\src\\utils\\git::GitServiceType",
        "language": "typescript",
        "label": "GitServiceType",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git",
        "totalTokens": 18,
        "inDegree": 6,
        "outDegree": 1,
        "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
        "importStatements": [],
        "codeNoBody": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\git",
      "attributes": {
        "id": "\\src\\utils\\git",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
        "type": "file",
        "totalTokens": 1609,
        "inDegree": 0,
        "outDegree": 7,
        "code": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\n\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}\r\n",
        "importStatements": [
          "import axios from 'axios'",
          "import fs from 'node:fs/promises'",
          "import AdmZip from 'adm-zip'",
          "import path from 'node:path'",
          "import { sql } from './db'",
          "import { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'",
          "import { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'",
          "import { getTotalSize } from '../model/utils'"
        ],
        "codeNoBody": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
        "originFile": "\\src\\utils\\git.ts"
      }
    },
    {
      "key": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
      "attributes": {
        "id": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
        "language": "typescript",
        "label": "refreshAccessToken",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token",
        "totalTokens": 237,
        "inDegree": 1,
        "outDegree": 0,
        "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
        "originFile": "\\src\\utils\\gitlab\\refresh-token.ts"
      }
    },
    {
      "key": "\\src\\utils\\gitlab\\refresh-token",
      "attributes": {
        "id": "\\src\\utils\\gitlab\\refresh-token",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts",
        "type": "file",
        "totalTokens": 247,
        "inDegree": 0,
        "outDegree": 1,
        "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
        "importStatements": [
          "import { getEnv } from \"../utils\""
        ],
        "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
        "originFile": "\\src\\utils\\gitlab\\refresh-token.ts"
      }
    },
    {
      "key": "\\src\\utils\\utils::getEnv",
      "attributes": {
        "id": "\\src\\utils\\utils::getEnv",
        "language": "typescript",
        "label": "getEnv",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils",
        "totalTokens": 50,
        "inDegree": 1,
        "outDegree": 1,
        "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
        "importStatements": [],
        "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
        "originFile": "\\src\\utils\\utils.ts"
      }
    },
    {
      "key": "\\src\\utils\\utils::ENV_VARS",
      "attributes": {
        "id": "\\src\\utils\\utils::ENV_VARS",
        "language": "typescript",
        "label": "ENV_VARS",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils",
        "totalTokens": 147,
        "inDegree": 2,
        "outDegree": 0,
        "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
        "importStatements": [],
        "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
        "originFile": "\\src\\utils\\utils.ts"
      }
    },
    {
      "key": "\\src\\utils\\utils",
      "attributes": {
        "id": "\\src\\utils\\utils",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils.ts",
        "type": "file",
        "totalTokens": 199,
        "inDegree": 0,
        "outDegree": 2,
        "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
        "importStatements": [],
        "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
        "originFile": "\\src\\utils\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\test-wiki",
      "attributes": {
        "id": "\\src\\wiki\\test-wiki",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\test-wiki.ts",
        "type": "file",
        "totalTokens": 591,
        "inDegree": 0,
        "outDegree": 0,
        "code": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();\r\n",
        "importStatements": [
          "import { fstat } from \"fs\";",
          "import { Codebase } from \"../model/codebase\";",
          "import { GraphLink, GraphNode } from \"../utils/db\";",
          "import { generateDocumentation } from \"./wiki\";",
          "import { v4 as uuidv4 } from \"uuid\";",
          "import fs from \"fs/promises\";"
        ],
        "codeNoBody": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();",
        "originFile": "\\src\\wiki\\test-wiki.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::documentFolders",
      "attributes": {
        "id": "\\src\\wiki\\utils::documentFolders",
        "language": "typescript",
        "label": "documentFolders",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 1566,
        "inDegree": 1,
        "outDegree": 4,
        "code": "async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const nodesPerType = getNodesPerType(nodes);\r\n  const allLanguages = calculateLanguagePercentages(nodesPerType);\r\n  const allLanguagesString = Object.entries(allLanguages)\r\n    .map(([name, pct]) => `${name} (${pct})`)\r\n    .join(\", \");\r\n\r\n  console.log(\"Generating documentation for each folder ..\");\r\n  const fileNodes = nodes.filter((n) => n.type === \"file\");\r\n  const folderNames = fileNodes.map((n) =>\r\n    n.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\")\r\n  );\r\n  const uniqueFolderNames = [...new Set(folderNames)];\r\n\r\n  // sort by level (number of '/')\r\n  uniqueFolderNames.sort(\r\n    (a, b) => b.split(\"\\\\\").length - a.split(\"\\\\\").length || b.length - a.length\r\n  );\r\n  const documentedFolders: { [key: string]: string } = {};\r\n  uniqueFolderNames.forEach(\r\n    (foldername) => (documentedFolders[foldername] = \"\")\r\n  );\r\n  //console.log(\"Documented Folders:\", documentedFolders);\r\n  for (const folderName of uniqueFolderNames) {\r\n    const filteredNodes =\r\n      folderName.length > 0\r\n        ? nodes.filter((n) => n.originFile?.startsWith(folderName))\r\n        : nodes;\r\n    //console.log(\"Folder:\", folderName);\r\n    //console.log(\"Nodes:\", filteredNodes);\r\n    const codeNoBodyFolder = filteredNodes.map((n) => n.codeNoBody).join(\"\\n\");\r\n    const fileNodesPerType = getNodesPerType(filteredNodes);\r\n    const mostUsedNodesPerType = getMostUsedNodesPerType(fileNodesPerType);\r\n    const mostUsedNodesPerTypeString = Object.keys(mostUsedNodesPerType)\r\n      .map((type) => {\r\n        return mostUsedNodesPerType[type as AllowedTypes].join(\"\\n\\n\");\r\n      })\r\n      .join(\"\\n\");\r\n    let systemPrompt = `You are a helpful code expert and wikipedia editor who is writing a publication for repository ${repoName}, which uses the following languages: ${allLanguagesString}.`;\r\n    systemPrompt += `\\nThese are the most common elements from the repository:\\n${mostUsedNodesPerTypeString}\\n\\n`;\r\n    systemPrompt += `The user will pass you information about files and subfolders of the repo, and you have to generate a final wiki.`;\r\n\r\n    if (folderName.length === 0) {\r\n      systemPrompt += ` The wiki must describe the main features of the repo and its final purpose, i.e.:\\n\r\n        1. **Introduction**: Brief description of the project, its purpose, and main functionalities.\r\n        2. **Getting Started**: List of software, libraries, and tools needed. Step-by-step instructions on how to install and set up the project.\r\n        3. **Project Structure**: Description of the main directories and their purposes. Explanation of important files and their roles.\r\n        4. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\`\r\n        5. (optional) **Configuration** : Explanation of default configuration settings.\r\n        6. (optional) **Glossary**:  Definitions of key terms and concepts used in the project.`;\r\n    } else {\r\n      systemPrompt += ` The wiki must describe the main features of the folder and its final purpose, i.e.:\\n\r\n            1. **Introduction**: Brief description of the folder, its purpose, and main functionalities.\r\n            2. **Directory structure**:  Explanation of important files/directories and their roles.\r\n            3. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\``;\r\n    }\r\n\r\n    const fileNodesInFolder = fileNodes.filter(\r\n      (n) =>\r\n        n.fullName.startsWith(folderName) &&\r\n        n.fullName.split(\"\\\\\").length ==\r\n          (folderName ? folderName.split(\"\\\\\").length + 1 : 1)\r\n    );\r\n    const subfoldersDocumentations = Object.fromEntries(\r\n      Object.entries(documentedFolders).filter(([key]) => {\r\n        return key.startsWith(folderName) && key != folderName; // && key.split('/').length == folderName.split('/').length + 1 && key != folderName\r\n      })\r\n    );\r\n\r\n    const folderContext =\r\n      folderName.length > 0\r\n        ? `folder \"${folderName}\"`\r\n        : `repository ${repoName}`;\r\n    let userPrompt = `Generate a publication for the ${folderContext}. The following information corresponds to the documentation of the subfolders of the folder we want to document. Use them to generate a better response. Here they are:\\n\\n`;\r\n\r\n    for (const [subfolder, subfolderDoc] of Object.entries(\r\n      subfoldersDocumentations\r\n    )) {\r\n      if (subfolderDoc) {\r\n        userPrompt += `Subfolder ${subfolder} information:\\n${subfolderDoc}`;\r\n        userPrompt += `\\n------------------------------------------------\\n\\n`;\r\n      }\r\n    }\r\n\r\n    for (const fileNode of fileNodesInFolder) {\r\n      userPrompt += `Documentation for file ${fileNode.label}:\\n${\r\n        fileNode.generatedDocumentation ?? \"\"\r\n      }\\n`;\r\n      // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n      // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n\r\n      // if (callLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Uses:\\n`\r\n      //     callLinks.forEach(l => {\r\n      //         const calledNode = nodes.find(n => n.id === l.target)\r\n      //         if (calledNode) {\r\n      //             userPrompt += `   - ${calledNode.type} ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // }\r\n\r\n      // if (defineLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n      //     defineLinks.forEach(l => {\r\n      //         const definedNode = nodes.find(n => n.id === l.target)\r\n      //         if (definedNode) {\r\n      //             userPrompt += `   - ${definedNode.type} ${definedNode.label}${\": \" + definedNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n      // }\r\n    }\r\n\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (folderName.length === 0) {\r\n      console.log(systemPrompt);\r\n      console.log(userPrompt);\r\n    }\r\n\r\n    const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n    totalTokens += tokens ?? 0;\r\n    documentedFolders[folderName] = response;\r\n  }\r\n\r\n  console.log(`${repoName} - Total tokens used:`, totalTokens);\r\n  return documentedFolders;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::documentNodesByLevels",
      "attributes": {
        "id": "\\src\\wiki\\utils::documentNodesByLevels",
        "language": "typescript",
        "label": "documentNodesByLevels",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 214,
        "inDegree": 1,
        "outDegree": 3,
        "code": "async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  console.log(\"Generating documentation for each node ..\");\r\n  const levels = Object.keys(nodeIdsByLevels);\r\n  levels.sort((a, b) => parseInt(b) - parseInt(a));\r\n\r\n  for (const l of levels) {\r\n    const level = parseInt(l); // Convert the key back to a number if needed\r\n    const nodeIds = nodeIdsByLevels[level];\r\n    const promises = nodeIds.map((nodeId) => {\r\n      const node = nodes.find((n) => n.id === nodeId);\r\n      if (node && node.generatedDocumentation?.length === 0) {\r\n        return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n      }\r\n    });\r\n    await Promise.all(promises);\r\n  }\r\n  console.log(`${repoName} - Used tokens for node documentation:`, totalTokens);\r\n}",
        "importStatements": [],
        "codeNoBody": "async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::generateNodeDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\utils::generateNodeDocumentation",
        "language": "typescript",
        "label": "generateNodeDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 279,
        "inDegree": 2,
        "outDegree": 2,
        "code": "async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const { systemPrompt, userPrompt } = generateNodePrompts(\r\n    node,\r\n    nodes,\r\n    graph,\r\n    repoName\r\n  );\r\n\r\n  try {\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (\r\n      [\"class\", \"function\", \"method\"].includes(node.type) ||\r\n      node.code.split(\"\\n\").length >= 2\r\n    ) {\r\n      const { response, tokens } = await getOpenAIChatCompletion(\r\n        messages,\r\n        node.type === \"file\" ? \"gpt-4o\" : model\r\n      );\r\n      totalTokens += tokens ?? 0;\r\n      node.generatedDocumentation = response;\r\n    } else {\r\n      node.generatedDocumentation = `Code: ${node.code}`;\r\n    }\r\n    // console.log(`#### ${node.label} ####`)\r\n    // console.log({ systemPrompt, userPrompt } )\r\n    // console.log({ response, tokens })\r\n  } catch (error: any) {\r\n    console.error(\r\n      `Error generating documentation for ${node.label}: ${error.message}`\r\n    );\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::generateNodePrompts",
      "attributes": {
        "id": "\\src\\wiki\\utils::generateNodePrompts",
        "language": "typescript",
        "label": "generateNodePrompts",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 828,
        "inDegree": 2,
        "outDegree": 2,
        "code": "function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\r\n  const originFileNode = findFileParentNode(nodes, node);\r\n\r\n  let systemPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code and being concise but precise and accurate.`;\r\n  } else {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write summaries for files from the repository ${repoName}. The user will pass you a reduced version of the file content and you must explain the main features and purpose of the file. Be concise but accurate and precise.`;\r\n  }\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does or accomplishes.`;\r\n  }\r\n\r\n  if (node.type !== \"file\")\r\n    systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  const parentFileString = originFileNode\r\n    ? `from file \"${originFileNode.label}\" `\r\n    : \"\";\r\n\r\n  let userPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mentioning the principal features of the code:`;\r\n  } else {\r\n    const folder = node.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\");\r\n    userPrompt = `Write a brief documentation for the file \"${node.label}\" from folder \"${folder}\", explaining the main features and purpose of the file:`;\r\n  }\r\n\r\n  const code = [\r\n    \"method\",\r\n    \"function\",\r\n    \"interface\",\r\n    \"assignment\",\r\n    \"type\",\r\n    \"enum\",\r\n    \"struct\",\r\n    \"union\",\r\n  ].includes(node.type)\r\n    ? node.code\r\n    : node.codeNoBody;\r\n\r\n  if (\r\n    originFileNode &&\r\n    graph[node.id].length > 0 &&\r\n    originFileNode.importStatements\r\n  ) {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n    systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`;\r\n  } else {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n  }\r\n\r\n  const linkedNodes = graph[node.id].map((linkedNodeId) =>\r\n    nodes.find((node) => node.id === linkedNodeId)\r\n  );\r\n\r\n  if (\r\n    graph[node.id].length > 0 &&\r\n    linkedNodes.some((n) => n?.generatedDocumentation)\r\n  ) {\r\n    userPrompt += `Use the following information to generate a better description of what ${node.label} does:`;\r\n    systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`;\r\n\r\n    graph[node.id].forEach((linkedNodeId) => {\r\n      const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n      if (linkedNode && linkedNode.generatedDocumentation) {\r\n        userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n      }\r\n    });\r\n  }\r\n\r\n  userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`;\r\n  if (node.type === \"file\") {\r\n    userPrompt += \" Remember also to explain the purpose of the file.\";\r\n  }\r\n  return { systemPrompt, userPrompt };\r\n}",
        "importStatements": [],
        "codeNoBody": "function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::bfsLevels",
      "attributes": {
        "id": "\\src\\wiki\\utils::bfsLevels",
        "language": "typescript",
        "label": "bfsLevels",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 495,
        "inDegree": 1,
        "outDegree": 1,
        "code": "function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\r\n  const results: { [key: number]: string[] } = {};\r\n  const levels: { [key: string]: number } = {};\r\n  const inDegree: { [key: string]: number } = {};\r\n\r\n  // Initialize in-degree for each node\r\n  for (const node of nodes) {\r\n    inDegree[node.id] = 0;\r\n  }\r\n\r\n  // Calculate in-degree for each node\r\n  for (const [source, targets] of Object.entries(graph)) {\r\n    for (const target of targets) {\r\n      inDegree[target] = (inDegree[target] || 0) + 1;\r\n    }\r\n  }\r\n\r\n  // Find start nodes (nodes with in-degree 0)\r\n  const queue = nodes\r\n    .filter((node) => inDegree[node.id] === 0)\r\n    .map((node) => node.id);\r\n\r\n  // Perform topological sort and assign levels\r\n  let currentLevel = 0;\r\n  while (queue.length > 0) {\r\n    const levelSize = queue.length;\r\n    for (let i = 0; i < levelSize; i++) {\r\n      const nodeId = queue.shift()!;\r\n      levels[nodeId] = currentLevel;\r\n\r\n      if (!results[currentLevel]) {\r\n        results[currentLevel] = [];\r\n      }\r\n\r\n      results[currentLevel].push(nodeId);\r\n\r\n      for (const neighbor of graph[nodeId] || []) {\r\n        inDegree[neighbor]--;\r\n        if (inDegree[neighbor] === 0) {\r\n          queue.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    currentLevel++;\r\n  }\r\n\r\n  // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n  for (const node of nodes) {\r\n    if (levels[node.id] === undefined) {\r\n      const dependencyLevels = (graph[node.id] || [])\r\n        .map((dep) => levels[dep] || 0)\r\n        .filter((level) => level !== undefined);\r\n      const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n      levels[node.id] = maxDependencyLevel + 1;\r\n\r\n      if (!results[levels[node.id]]) {\r\n        results[levels[node.id]] = [];\r\n      }\r\n      results[levels[node.id]].push(node.id);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}",
        "importStatements": [],
        "codeNoBody": "function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::buildGraphs",
      "attributes": {
        "id": "\\src\\wiki\\utils::buildGraphs",
        "language": "typescript",
        "label": "buildGraphs",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 152,
        "inDegree": 1,
        "outDegree": 1,
        "code": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n  //all nodes appear on links?\r\n  const graph: Graph = {};\r\n  nodes.forEach((node) => {\r\n    graph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (link.source === link.target) continue;\r\n\r\n    // each link save the id node\r\n    const sourceNode = nodes.find((node) => node.id === link.source);\r\n    const targetNode = nodes.find((node) => node.id === link.target);\r\n    // only save the links between nodes and not files\r\n    if (sourceNode && targetNode) {\r\n      graph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { graph };\r\n}",
        "importStatements": [],
        "codeNoBody": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::findFileParentNode",
      "attributes": {
        "id": "\\src\\wiki\\utils::findFileParentNode",
        "language": "typescript",
        "label": "findFileParentNode",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 139,
        "inDegree": 3,
        "outDegree": 1,
        "code": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n  let parentName = \"\";\r\n  if (node.originFile) {\r\n    parentName = node.originFile?.split(\".\").slice(0, -1).join(\".\");\r\n  } else {\r\n    parentName = node.fullName.includes(\"::\")\r\n      ? node.fullName.split(\"::\")[0]\r\n      : \"\";\r\n  }\r\n  const parent = nodes.find((node) => node.fullName === parentName);\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent && parent.type !== \"file\") {\r\n    return findFileParentNode(nodes, parent);\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::getMostUsedNodesPerType",
      "attributes": {
        "id": "\\src\\wiki\\utils::getMostUsedNodesPerType",
        "language": "typescript",
        "label": "getMostUsedNodesPerType",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 261,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    if (discardMethods && type === \"method\") {\r\n      return acc;\r\n    }\r\n\r\n    if (\r\n      ![\"file\", \"namespace\", \"package\", \"mod\", \"assignment\", \"header\"].includes(\r\n        type\r\n      )\r\n    )\r\n      acc[type as AllowedTypes] = nodesPerType[type as AllowedTypes]\r\n        .filter((n) => n.outDegree > 0)\r\n        .sort((a, b) => b.outDegree + b.inDegree - (a.outDegree + a.inDegree))\r\n        .slice(0, 5)\r\n        .map(\r\n          (n) =>\r\n            `### From ${n.originFile}:\\n\\`\\`\\`${n.language}\\n${n.codeNoBody}\\n\\`\\`\\``\r\n        );\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, (string | number)[]>);\r\n\r\n  return mostUsedNodesPerType;\r\n}",
        "importStatements": [],
        "codeNoBody": "function getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\n//...\n}",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::getNodesPerType",
      "attributes": {
        "id": "\\src\\wiki\\utils::getNodesPerType",
        "language": "typescript",
        "label": "getNodesPerType",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 75,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function getNodesPerType(nodes: GraphNode[]) {\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = [];\r\n    }\r\n    acc[node.type].push(node);\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, GraphNode[]>);\r\n\r\n  return nodesPerType;\r\n}",
        "importStatements": [],
        "codeNoBody": "function getNodesPerType(nodes: GraphNode[]) {\n//...\n}",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::calculateLanguagePercentages",
      "attributes": {
        "id": "\\src\\wiki\\utils::calculateLanguagePercentages",
        "language": "typescript",
        "label": "calculateLanguagePercentages",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 197,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\r\n  const allLanguages = nodesPerType[\"file\"].map((n) => n.language);\r\n  const total = allLanguages.length;\r\n  const counts: Record<string, number> = {};\r\n\r\n  allLanguages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1;\r\n  });\r\n\r\n  const percentages: Record<string, string> = {};\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = ((count / total) * 100).toFixed(2) + \"%\";\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort(\r\n    (a, b) => parseFloat(b[1]) - parseFloat(a[1])\r\n  );\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray);\r\n  return sortedPercentages;\r\n}",
        "importStatements": [],
        "codeNoBody": "function calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\n//...\n}",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "id": "\\src\\wiki\\utils::Graph",
        "language": "typescript",
        "label": "Graph",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 12,
        "inDegree": 8,
        "outDegree": 1,
        "code": "type Graph = { [key: string]: string[] };",
        "importStatements": [],
        "codeNoBody": "type Graph = { [key: string]: string[] };",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils::totalTokens",
      "attributes": {
        "id": "\\src\\wiki\\utils::totalTokens",
        "language": "typescript",
        "label": "totalTokens",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils",
        "totalTokens": 7,
        "inDegree": 3,
        "outDegree": 0,
        "code": "let totalTokens = 0;",
        "importStatements": [],
        "codeNoBody": "let totalTokens = 0;",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\utils",
      "attributes": {
        "id": "\\src\\wiki\\utils",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
        "type": "file",
        "totalTokens": 4274,
        "inDegree": 0,
        "outDegree": 13,
        "code": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\nimport { AllowedTypes } from \"../model/consts\";\r\n\r\nlet totalTokens = 0;\r\n\r\ntype Graph = { [key: string]: string[] };\r\n\r\nfunction calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\r\n  const allLanguages = nodesPerType[\"file\"].map((n) => n.language);\r\n  const total = allLanguages.length;\r\n  const counts: Record<string, number> = {};\r\n\r\n  allLanguages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1;\r\n  });\r\n\r\n  const percentages: Record<string, string> = {};\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = ((count / total) * 100).toFixed(2) + \"%\";\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort(\r\n    (a, b) => parseFloat(b[1]) - parseFloat(a[1])\r\n  );\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray);\r\n  return sortedPercentages;\r\n}\r\n\r\nfunction getNodesPerType(nodes: GraphNode[]) {\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = [];\r\n    }\r\n    acc[node.type].push(node);\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, GraphNode[]>);\r\n\r\n  return nodesPerType;\r\n}\r\n\r\nfunction getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    if (discardMethods && type === \"method\") {\r\n      return acc;\r\n    }\r\n\r\n    if (\r\n      ![\"file\", \"namespace\", \"package\", \"mod\", \"assignment\", \"header\"].includes(\r\n        type\r\n      )\r\n    )\r\n      acc[type as AllowedTypes] = nodesPerType[type as AllowedTypes]\r\n        .filter((n) => n.outDegree > 0)\r\n        .sort((a, b) => b.outDegree + b.inDegree - (a.outDegree + a.inDegree))\r\n        .slice(0, 5)\r\n        .map(\r\n          (n) =>\r\n            `### From ${n.originFile}:\\n\\`\\`\\`${n.language}\\n${n.codeNoBody}\\n\\`\\`\\``\r\n        );\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, (string | number)[]>);\r\n\r\n  return mostUsedNodesPerType;\r\n}\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n  let parentName = \"\";\r\n  if (node.originFile) {\r\n    parentName = node.originFile?.split(\".\").slice(0, -1).join(\".\");\r\n  } else {\r\n    parentName = node.fullName.includes(\"::\")\r\n      ? node.fullName.split(\"::\")[0]\r\n      : \"\";\r\n  }\r\n  const parent = nodes.find((node) => node.fullName === parentName);\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent && parent.type !== \"file\") {\r\n    return findFileParentNode(nodes, parent);\r\n  }\r\n}\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n  //all nodes appear on links?\r\n  const graph: Graph = {};\r\n  nodes.forEach((node) => {\r\n    graph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (link.source === link.target) continue;\r\n\r\n    // each link save the id node\r\n    const sourceNode = nodes.find((node) => node.id === link.source);\r\n    const targetNode = nodes.find((node) => node.id === link.target);\r\n    // only save the links between nodes and not files\r\n    if (sourceNode && targetNode) {\r\n      graph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { graph };\r\n}\r\n\r\nexport function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\r\n  const results: { [key: number]: string[] } = {};\r\n  const levels: { [key: string]: number } = {};\r\n  const inDegree: { [key: string]: number } = {};\r\n\r\n  // Initialize in-degree for each node\r\n  for (const node of nodes) {\r\n    inDegree[node.id] = 0;\r\n  }\r\n\r\n  // Calculate in-degree for each node\r\n  for (const [source, targets] of Object.entries(graph)) {\r\n    for (const target of targets) {\r\n      inDegree[target] = (inDegree[target] || 0) + 1;\r\n    }\r\n  }\r\n\r\n  // Find start nodes (nodes with in-degree 0)\r\n  const queue = nodes\r\n    .filter((node) => inDegree[node.id] === 0)\r\n    .map((node) => node.id);\r\n\r\n  // Perform topological sort and assign levels\r\n  let currentLevel = 0;\r\n  while (queue.length > 0) {\r\n    const levelSize = queue.length;\r\n    for (let i = 0; i < levelSize; i++) {\r\n      const nodeId = queue.shift()!;\r\n      levels[nodeId] = currentLevel;\r\n\r\n      if (!results[currentLevel]) {\r\n        results[currentLevel] = [];\r\n      }\r\n\r\n      results[currentLevel].push(nodeId);\r\n\r\n      for (const neighbor of graph[nodeId] || []) {\r\n        inDegree[neighbor]--;\r\n        if (inDegree[neighbor] === 0) {\r\n          queue.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    currentLevel++;\r\n  }\r\n\r\n  // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n  for (const node of nodes) {\r\n    if (levels[node.id] === undefined) {\r\n      const dependencyLevels = (graph[node.id] || [])\r\n        .map((dep) => levels[dep] || 0)\r\n        .filter((level) => level !== undefined);\r\n      const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n      levels[node.id] = maxDependencyLevel + 1;\r\n\r\n      if (!results[levels[node.id]]) {\r\n        results[levels[node.id]] = [];\r\n      }\r\n      results[levels[node.id]].push(node.id);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\r\n  const originFileNode = findFileParentNode(nodes, node);\r\n\r\n  let systemPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code and being concise but precise and accurate.`;\r\n  } else {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write summaries for files from the repository ${repoName}. The user will pass you a reduced version of the file content and you must explain the main features and purpose of the file. Be concise but accurate and precise.`;\r\n  }\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does or accomplishes.`;\r\n  }\r\n\r\n  if (node.type !== \"file\")\r\n    systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  const parentFileString = originFileNode\r\n    ? `from file \"${originFileNode.label}\" `\r\n    : \"\";\r\n\r\n  let userPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mentioning the principal features of the code:`;\r\n  } else {\r\n    const folder = node.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\");\r\n    userPrompt = `Write a brief documentation for the file \"${node.label}\" from folder \"${folder}\", explaining the main features and purpose of the file:`;\r\n  }\r\n\r\n  const code = [\r\n    \"method\",\r\n    \"function\",\r\n    \"interface\",\r\n    \"assignment\",\r\n    \"type\",\r\n    \"enum\",\r\n    \"struct\",\r\n    \"union\",\r\n  ].includes(node.type)\r\n    ? node.code\r\n    : node.codeNoBody;\r\n\r\n  if (\r\n    originFileNode &&\r\n    graph[node.id].length > 0 &&\r\n    originFileNode.importStatements\r\n  ) {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n    systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`;\r\n  } else {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n  }\r\n\r\n  const linkedNodes = graph[node.id].map((linkedNodeId) =>\r\n    nodes.find((node) => node.id === linkedNodeId)\r\n  );\r\n\r\n  if (\r\n    graph[node.id].length > 0 &&\r\n    linkedNodes.some((n) => n?.generatedDocumentation)\r\n  ) {\r\n    userPrompt += `Use the following information to generate a better description of what ${node.label} does:`;\r\n    systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`;\r\n\r\n    graph[node.id].forEach((linkedNodeId) => {\r\n      const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n      if (linkedNode && linkedNode.generatedDocumentation) {\r\n        userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n      }\r\n    });\r\n  }\r\n\r\n  userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`;\r\n  if (node.type === \"file\") {\r\n    userPrompt += \" Remember also to explain the purpose of the file.\";\r\n  }\r\n  return { systemPrompt, userPrompt };\r\n}\r\n\r\nexport async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const { systemPrompt, userPrompt } = generateNodePrompts(\r\n    node,\r\n    nodes,\r\n    graph,\r\n    repoName\r\n  );\r\n\r\n  try {\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (\r\n      [\"class\", \"function\", \"method\"].includes(node.type) ||\r\n      node.code.split(\"\\n\").length >= 2\r\n    ) {\r\n      const { response, tokens } = await getOpenAIChatCompletion(\r\n        messages,\r\n        node.type === \"file\" ? \"gpt-4o\" : model\r\n      );\r\n      totalTokens += tokens ?? 0;\r\n      node.generatedDocumentation = response;\r\n    } else {\r\n      node.generatedDocumentation = `Code: ${node.code}`;\r\n    }\r\n    // console.log(`#### ${node.label} ####`)\r\n    // console.log({ systemPrompt, userPrompt } )\r\n    // console.log({ response, tokens })\r\n  } catch (error: any) {\r\n    console.error(\r\n      `Error generating documentation for ${node.label}: ${error.message}`\r\n    );\r\n  }\r\n}\r\n\r\nexport async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  console.log(\"Generating documentation for each node ..\");\r\n  const levels = Object.keys(nodeIdsByLevels);\r\n  levels.sort((a, b) => parseInt(b) - parseInt(a));\r\n\r\n  for (const l of levels) {\r\n    const level = parseInt(l); // Convert the key back to a number if needed\r\n    const nodeIds = nodeIdsByLevels[level];\r\n    const promises = nodeIds.map((nodeId) => {\r\n      const node = nodes.find((n) => n.id === nodeId);\r\n      if (node && node.generatedDocumentation?.length === 0) {\r\n        return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n      }\r\n    });\r\n    await Promise.all(promises);\r\n  }\r\n  console.log(`${repoName} - Used tokens for node documentation:`, totalTokens);\r\n}\r\n\r\nexport async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const nodesPerType = getNodesPerType(nodes);\r\n  const allLanguages = calculateLanguagePercentages(nodesPerType);\r\n  const allLanguagesString = Object.entries(allLanguages)\r\n    .map(([name, pct]) => `${name} (${pct})`)\r\n    .join(\", \");\r\n\r\n  console.log(\"Generating documentation for each folder ..\");\r\n  const fileNodes = nodes.filter((n) => n.type === \"file\");\r\n  const folderNames = fileNodes.map((n) =>\r\n    n.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\")\r\n  );\r\n  const uniqueFolderNames = [...new Set(folderNames)];\r\n\r\n  // sort by level (number of '/')\r\n  uniqueFolderNames.sort(\r\n    (a, b) => b.split(\"\\\\\").length - a.split(\"\\\\\").length || b.length - a.length\r\n  );\r\n  const documentedFolders: { [key: string]: string } = {};\r\n  uniqueFolderNames.forEach(\r\n    (foldername) => (documentedFolders[foldername] = \"\")\r\n  );\r\n  //console.log(\"Documented Folders:\", documentedFolders);\r\n  for (const folderName of uniqueFolderNames) {\r\n    const filteredNodes =\r\n      folderName.length > 0\r\n        ? nodes.filter((n) => n.originFile?.startsWith(folderName))\r\n        : nodes;\r\n    //console.log(\"Folder:\", folderName);\r\n    //console.log(\"Nodes:\", filteredNodes);\r\n    const codeNoBodyFolder = filteredNodes.map((n) => n.codeNoBody).join(\"\\n\");\r\n    const fileNodesPerType = getNodesPerType(filteredNodes);\r\n    const mostUsedNodesPerType = getMostUsedNodesPerType(fileNodesPerType);\r\n    const mostUsedNodesPerTypeString = Object.keys(mostUsedNodesPerType)\r\n      .map((type) => {\r\n        return mostUsedNodesPerType[type as AllowedTypes].join(\"\\n\\n\");\r\n      })\r\n      .join(\"\\n\");\r\n    let systemPrompt = `You are a helpful code expert and wikipedia editor who is writing a publication for repository ${repoName}, which uses the following languages: ${allLanguagesString}.`;\r\n    systemPrompt += `\\nThese are the most common elements from the repository:\\n${mostUsedNodesPerTypeString}\\n\\n`;\r\n    systemPrompt += `The user will pass you information about files and subfolders of the repo, and you have to generate a final wiki.`;\r\n\r\n    if (folderName.length === 0) {\r\n      systemPrompt += ` The wiki must describe the main features of the repo and its final purpose, i.e.:\\n\r\n        1. **Introduction**: Brief description of the project, its purpose, and main functionalities.\r\n        2. **Getting Started**: List of software, libraries, and tools needed. Step-by-step instructions on how to install and set up the project.\r\n        3. **Project Structure**: Description of the main directories and their purposes. Explanation of important files and their roles.\r\n        4. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\`\r\n        5. (optional) **Configuration** : Explanation of default configuration settings.\r\n        6. (optional) **Glossary**:  Definitions of key terms and concepts used in the project.`;\r\n    } else {\r\n      systemPrompt += ` The wiki must describe the main features of the folder and its final purpose, i.e.:\\n\r\n            1. **Introduction**: Brief description of the folder, its purpose, and main functionalities.\r\n            2. **Directory structure**:  Explanation of important files/directories and their roles.\r\n            3. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\``;\r\n    }\r\n\r\n    const fileNodesInFolder = fileNodes.filter(\r\n      (n) =>\r\n        n.fullName.startsWith(folderName) &&\r\n        n.fullName.split(\"\\\\\").length ==\r\n          (folderName ? folderName.split(\"\\\\\").length + 1 : 1)\r\n    );\r\n    const subfoldersDocumentations = Object.fromEntries(\r\n      Object.entries(documentedFolders).filter(([key]) => {\r\n        return key.startsWith(folderName) && key != folderName; // && key.split('/').length == folderName.split('/').length + 1 && key != folderName\r\n      })\r\n    );\r\n\r\n    const folderContext =\r\n      folderName.length > 0\r\n        ? `folder \"${folderName}\"`\r\n        : `repository ${repoName}`;\r\n    let userPrompt = `Generate a publication for the ${folderContext}. The following information corresponds to the documentation of the subfolders of the folder we want to document. Use them to generate a better response. Here they are:\\n\\n`;\r\n\r\n    for (const [subfolder, subfolderDoc] of Object.entries(\r\n      subfoldersDocumentations\r\n    )) {\r\n      if (subfolderDoc) {\r\n        userPrompt += `Subfolder ${subfolder} information:\\n${subfolderDoc}`;\r\n        userPrompt += `\\n------------------------------------------------\\n\\n`;\r\n      }\r\n    }\r\n\r\n    for (const fileNode of fileNodesInFolder) {\r\n      userPrompt += `Documentation for file ${fileNode.label}:\\n${\r\n        fileNode.generatedDocumentation ?? \"\"\r\n      }\\n`;\r\n      // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n      // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n\r\n      // if (callLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Uses:\\n`\r\n      //     callLinks.forEach(l => {\r\n      //         const calledNode = nodes.find(n => n.id === l.target)\r\n      //         if (calledNode) {\r\n      //             userPrompt += `   - ${calledNode.type} ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // }\r\n\r\n      // if (defineLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n      //     defineLinks.forEach(l => {\r\n      //         const definedNode = nodes.find(n => n.id === l.target)\r\n      //         if (definedNode) {\r\n      //             userPrompt += `   - ${definedNode.type} ${definedNode.label}${\": \" + definedNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n      // }\r\n    }\r\n\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (folderName.length === 0) {\r\n      console.log(systemPrompt);\r\n      console.log(userPrompt);\r\n    }\r\n\r\n    const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n    totalTokens += tokens ?? 0;\r\n    documentedFolders[folderName] = response;\r\n  }\r\n\r\n  console.log(`${repoName} - Total tokens used:`, totalTokens);\r\n  return documentedFolders;\r\n}\r\n",
        "importStatements": [
          "import { GraphLink, GraphNode } from \"../utils/db\";",
          "import { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";",
          "import { AllowedTypes } from \"../model/consts\";"
        ],
        "codeNoBody": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\nimport { AllowedTypes } from \"../model/consts\";\r\nlet totalTokens = 0;\r\n\r\ntype Graph = { [key: string]: string[] };\r\n\r\nfunction calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\n//...\n}\r\n\r\nfunction getNodesPerType(nodes: GraphNode[]) {\n//...\n}\r\n\r\nfunction getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\n//...\n}\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }\r\n\r\nexport function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\n       //...\n       }\r\n\r\nexport function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\n       //...\n       }\r\n\r\nexport async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }\r\n\r\nexport async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }\r\n\r\nexport async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
        "originFile": "\\src\\wiki\\utils.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
        "language": "typescript",
        "label": "generateAndUpdateDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki",
        "totalTokens": 265,
        "inDegree": 1,
        "outDegree": 1,
        "code": "async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\r\n\r\n  const documentedFolders = await generateDocumentation(graphNodes, graphLinks, repoName, model)\r\n\r\n  const insertFolderPromises = Object.entries(documentedFolders).map(([name, wiki]) => {\r\n\r\n    if (graphFolders?.find(folder => folder.name === name)) {\r\n      // update\r\n      return sql`\r\n        UPDATE graph_folders\r\n        SET wiki = ${wiki}\r\n        WHERE name = ${name}\r\n      `\r\n    } else {\r\n      return sql`\r\n        INSERT INTO graph_folders (\r\n          repo_id,\r\n          name,\r\n          wiki\r\n        ) VALUES (\r\n          ${repoId},\r\n          ${name},\r\n          ${wiki}\r\n        )\r\n      `\r\n    }\r\n  })\r\n\r\n  const updateNodeDocsPromises = graphNodes.map(node => {\r\n    if (node.generatedDocumentation) {\r\n      return sql`\r\n        UPDATE nodes\r\n        SET generated_documentation = ${node.generatedDocumentation}\r\n        WHERE id = ${node.id}\r\n      `\r\n    }\r\n  })\r\n\r\n  await Promise.all([...insertFolderPromises, ...updateNodeDocsPromises])\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\n       //...\n       }",
        "originFile": "\\src\\wiki\\wiki.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wiki::generateDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\wiki::generateDocumentation",
        "language": "typescript",
        "label": "generateDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki",
        "totalTokens": 106,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\n       //...\n       }",
        "originFile": "\\src\\wiki\\wiki.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wiki",
      "attributes": {
        "id": "\\src\\wiki\\wiki",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki.ts",
        "type": "file",
        "totalTokens": 419,
        "inDegree": 0,
        "outDegree": 2,
        "code": "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\nimport { sql } from \"../utils/db\";\r\n\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}\r\n\r\nexport async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\r\n\r\n  const documentedFolders = await generateDocumentation(graphNodes, graphLinks, repoName, model)\r\n\r\n  const insertFolderPromises = Object.entries(documentedFolders).map(([name, wiki]) => {\r\n\r\n    if (graphFolders?.find(folder => folder.name === name)) {\r\n      // update\r\n      return sql`\r\n        UPDATE graph_folders\r\n        SET wiki = ${wiki}\r\n        WHERE name = ${name}\r\n      `\r\n    } else {\r\n      return sql`\r\n        INSERT INTO graph_folders (\r\n          repo_id,\r\n          name,\r\n          wiki\r\n        ) VALUES (\r\n          ${repoId},\r\n          ${name},\r\n          ${wiki}\r\n        )\r\n      `\r\n    }\r\n  })\r\n\r\n  const updateNodeDocsPromises = graphNodes.map(node => {\r\n    if (node.generatedDocumentation) {\r\n      return sql`\r\n        UPDATE nodes\r\n        SET generated_documentation = ${node.generatedDocumentation}\r\n        WHERE id = ${node.id}\r\n      `\r\n    }\r\n  })\r\n\r\n  await Promise.all([...insertFolderPromises, ...updateNodeDocsPromises])\r\n}",
        "importStatements": [
          "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";",
          "import { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";",
          "import { sql } from \"../utils/db\";"
        ],
        "codeNoBody": "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\nimport { sql } from \"../utils/db\";\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\n       //...\n       }\r\n\r\nexport async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\n       //...\n       }",
        "originFile": "\\src\\wiki\\wiki.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::buildWiki",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::buildWiki",
        "language": "typescript",
        "label": "buildWiki",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 539,
        "inDegree": 2,
        "outDegree": 2,
        "code": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "language": "typescript",
        "label": "generateFolderDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 532,
        "inDegree": 2,
        "outDegree": 5,
        "code": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::documentFolders",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::documentFolders",
        "language": "typescript",
        "label": "documentFolders",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 293,
        "inDegree": 2,
        "outDegree": 2,
        "code": "async function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function documentFolders(filesDocumentation: any) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "language": "typescript",
        "label": "generateFileDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 655,
        "inDegree": 2,
        "outDegree": 6,
        "code": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
        "language": "typescript",
        "label": "classifyAndDocumentFiles",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 303,
        "inDegree": 2,
        "outDegree": 2,
        "code": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "language": "typescript",
        "label": "generateNodeDocumentation",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 656,
        "inDegree": 2,
        "outDegree": 7,
        "code": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::bfs",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::bfs",
        "language": "typescript",
        "label": "bfs",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 364,
        "inDegree": 2,
        "outDegree": 2,
        "code": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::findStartNodes",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::findStartNodes",
        "language": "typescript",
        "label": "findStartNodes",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 48,
        "inDegree": 2,
        "outDegree": 0,
        "code": "function findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}",
        "importStatements": [],
        "codeNoBody": "function findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::buildGraphs",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::buildGraphs",
        "language": "typescript",
        "label": "buildGraphs",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 229,
        "inDegree": 2,
        "outDegree": 2,
        "code": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}",
        "importStatements": [],
        "codeNoBody": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::readJson",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::readJson",
        "language": "typescript",
        "label": "readJson",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 83,
        "inDegree": 2,
        "outDegree": 0,
        "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
        "importStatements": [],
        "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::findFileParent",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::findFileParent",
        "language": "typescript",
        "label": "findFileParent",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 93,
        "inDegree": 3,
        "outDegree": 2,
        "code": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}",
        "importStatements": [],
        "codeNoBody": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::tokenizer",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::tokenizer",
        "language": "typescript",
        "label": "tokenizer",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 86,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};",
        "importStatements": [],
        "codeNoBody": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "language": "typescript",
        "label": "timeElapsedInSecconds",
        "type": "function",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 76,
        "inDegree": 5,
        "outDegree": 0,
        "code": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};",
        "importStatements": [],
        "codeNoBody": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::totalTokensUsed",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::totalTokensUsed",
        "language": "typescript",
        "label": "totalTokensUsed",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "let totalTokensUsed = 0;",
        "importStatements": [],
        "codeNoBody": "let totalTokensUsed = 0;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::linksPath",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::linksPath",
        "language": "typescript",
        "label": "linksPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 15,
        "inDegree": 2,
        "outDegree": 2,
        "code": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
        "importStatements": [],
        "codeNoBody": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::nodesPath",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::nodesPath",
        "language": "typescript",
        "label": "nodesPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 15,
        "inDegree": 2,
        "outDegree": 2,
        "code": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
        "importStatements": [],
        "codeNoBody": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::folder_path",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::folder_path",
        "language": "typescript",
        "label": "folder_path",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 10,
        "inDegree": 3,
        "outDegree": 0,
        "code": "const folder_path = `../../test_files/`;",
        "importStatements": [],
        "codeNoBody": "const folder_path = `../../test_files/`;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::projectId",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::projectId",
        "language": "typescript",
        "label": "projectId",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 9,
        "inDegree": 4,
        "outDegree": 0,
        "code": "const projectId = \"judini-python-main\";",
        "importStatements": [],
        "codeNoBody": "const projectId = \"judini-python-main\";",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::onlyLogs",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::onlyLogs",
        "language": "typescript",
        "label": "onlyLogs",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 6,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const onlyLogs = false;",
        "importStatements": [],
        "codeNoBody": "const onlyLogs = false;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::response_format",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::response_format",
        "language": "typescript",
        "label": "response_format",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 12,
        "inDegree": 1,
        "outDegree": 0,
        "code": "const response_format = { type: \"json_object\" };",
        "importStatements": [],
        "codeNoBody": "const response_format = { type: \"json_object\" };",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::max_tokens",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::max_tokens",
        "language": "typescript",
        "label": "max_tokens",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 8,
        "inDegree": 4,
        "outDegree": 0,
        "code": "const max_tokens = 1024;",
        "importStatements": [],
        "codeNoBody": "const max_tokens = 1024;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::temperature",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::temperature",
        "language": "typescript",
        "label": "temperature",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 6,
        "inDegree": 4,
        "outDegree": 0,
        "code": "const temperature = 0;",
        "importStatements": [],
        "codeNoBody": "const temperature = 0;",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::model",
        "language": "typescript",
        "label": "model",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 14,
        "inDegree": 5,
        "outDegree": 0,
        "code": "const model = \"gpt-3.5-turbo\";",
        "importStatements": [],
        "codeNoBody": "const model = \"gpt-3.5-turbo\";",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::client2",
        "language": "typescript",
        "label": "client2",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 48,
        "inDegree": 5,
        "outDegree": 0,
        "code": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
        "importStatements": [],
        "codeNoBody": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::wikiLink",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::wikiLink",
        "language": "typescript",
        "label": "wikiLink",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 21,
        "inDegree": 4,
        "outDegree": 1,
        "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille::wikiNode",
        "language": "typescript",
        "label": "wikiNode",
        "type": "type",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille",
        "totalTokens": 90,
        "inDegree": 9,
        "outDegree": 1,
        "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "importStatements": [],
        "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\src\\wiki\\wikiGuille",
      "attributes": {
        "id": "\\src\\wiki\\wikiGuille",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
        "type": "file",
        "totalTokens": 4997,
        "inDegree": 0,
        "outDegree": 39,
        "code": "import { AllowedTypes } from \"../model/consts\";\r\n\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}\r\n",
        "importStatements": [
          "import { AllowedTypes } from \"../model/consts\";",
          "const fs2 = require(\"fs\").promises;",
          "const path2 = require(\"path\");",
          "const OpenAI2 = require(\"openai\");",
          "const { Tiktoken } = require(\"tiktoken/lite\");",
          "const cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");"
        ],
        "codeNoBody": "import { AllowedTypes } from \"../model/consts\";\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}\r\n\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\n//...\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
        "originFile": "\\src\\wiki\\wikiGuille.ts"
      }
    },
    {
      "key": "\\tests\\c.test::nodeAttributes",
      "attributes": {
        "id": "\\tests\\c.test::nodeAttributes",
        "language": "typescript",
        "label": "nodeAttributes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test",
        "totalTokens": 40,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "importStatements": [],
        "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "originFile": "\\tests\\c.test.ts"
      }
    },
    {
      "key": "\\tests\\c.test::rootFolderPath",
      "attributes": {
        "id": "\\tests\\c.test::rootFolderPath",
        "language": "typescript",
        "label": "rootFolderPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const rootFolderPath = '/my/path'",
        "importStatements": [],
        "codeNoBody": "const rootFolderPath = '/my/path'",
        "originFile": "\\tests\\c.test.ts"
      }
    },
    {
      "key": "\\tests\\c.test",
      "attributes": {
        "id": "\\tests\\c.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test.ts",
        "type": "file",
        "totalTokens": 2362,
        "inDegree": 0,
        "outDegree": 4,
        "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});\r\n",
        "importStatements": [
          "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
        ],
        "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});",
        "originFile": "\\tests\\c.test.ts"
      }
    },
    {
      "key": "\\tests\\java.test::nodeAttributes",
      "attributes": {
        "id": "\\tests\\java.test::nodeAttributes",
        "language": "typescript",
        "label": "nodeAttributes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test",
        "totalTokens": 40,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "importStatements": [],
        "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "originFile": "\\tests\\java.test.ts"
      }
    },
    {
      "key": "\\tests\\java.test::rootFolderPath",
      "attributes": {
        "id": "\\tests\\java.test::rootFolderPath",
        "language": "typescript",
        "label": "rootFolderPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const rootFolderPath = '/my/path'",
        "importStatements": [],
        "codeNoBody": "const rootFolderPath = '/my/path'",
        "originFile": "\\tests\\java.test.ts"
      }
    },
    {
      "key": "\\tests\\java.test",
      "attributes": {
        "id": "\\tests\\java.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test.ts",
        "type": "file",
        "totalTokens": 2014,
        "inDegree": 0,
        "outDegree": 4,
        "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});\r\n",
        "importStatements": [
          "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
        ],
        "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});",
        "originFile": "\\tests\\java.test.ts"
      }
    },
    {
      "key": "\\tests\\javascript.test::nodeAttributes",
      "attributes": {
        "id": "\\tests\\javascript.test::nodeAttributes",
        "language": "typescript",
        "label": "nodeAttributes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test",
        "totalTokens": 40,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "importStatements": [],
        "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "originFile": "\\tests\\javascript.test.ts"
      }
    },
    {
      "key": "\\tests\\javascript.test::rootFolderPath",
      "attributes": {
        "id": "\\tests\\javascript.test::rootFolderPath",
        "language": "typescript",
        "label": "rootFolderPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const rootFolderPath = '/my/path'",
        "importStatements": [],
        "codeNoBody": "const rootFolderPath = '/my/path'",
        "originFile": "\\tests\\javascript.test.ts"
      }
    },
    {
      "key": "\\tests\\javascript.test",
      "attributes": {
        "id": "\\tests\\javascript.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test.ts",
        "type": "file",
        "totalTokens": 2809,
        "inDegree": 0,
        "outDegree": 4,
        "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
        "importStatements": [
          "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
        ],
        "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
        "originFile": "\\tests\\javascript.test.ts"
      }
    },
    {
      "key": "\\tests\\php.test::nodeAttributes",
      "attributes": {
        "id": "\\tests\\php.test::nodeAttributes",
        "language": "typescript",
        "label": "nodeAttributes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test",
        "totalTokens": 40,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "importStatements": [],
        "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "originFile": "\\tests\\php.test.ts"
      }
    },
    {
      "key": "\\tests\\php.test::rootFolderPath",
      "attributes": {
        "id": "\\tests\\php.test::rootFolderPath",
        "language": "typescript",
        "label": "rootFolderPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const rootFolderPath = '/my/path'",
        "importStatements": [],
        "codeNoBody": "const rootFolderPath = '/my/path'",
        "originFile": "\\tests\\php.test.ts"
      }
    },
    {
      "key": "\\tests\\php.test",
      "attributes": {
        "id": "\\tests\\php.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test.ts",
        "type": "file",
        "totalTokens": 3125,
        "inDegree": 0,
        "outDegree": 4,
        "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});\r\n",
        "importStatements": [
          "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
        ],
        "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});",
        "originFile": "\\tests\\php.test.ts"
      }
    },
    {
      "key": "\\tests\\python.test::nodeAttributes",
      "attributes": {
        "id": "\\tests\\python.test::nodeAttributes",
        "language": "typescript",
        "label": "nodeAttributes",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test",
        "totalTokens": 40,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "importStatements": [],
        "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
        "originFile": "\\tests\\python.test.ts"
      }
    },
    {
      "key": "\\tests\\python.test::rootFolderPath",
      "attributes": {
        "id": "\\tests\\python.test::rootFolderPath",
        "language": "typescript",
        "label": "rootFolderPath",
        "type": "assignment",
        "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test",
        "totalTokens": 8,
        "inDegree": 2,
        "outDegree": 0,
        "code": "const rootFolderPath = '/my/path'",
        "importStatements": [],
        "codeNoBody": "const rootFolderPath = '/my/path'",
        "originFile": "\\tests\\python.test.ts"
      }
    },
    {
      "key": "\\tests\\python.test",
      "attributes": {
        "id": "\\tests\\python.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test.ts",
        "type": "file",
        "totalTokens": 2547,
        "inDegree": 0,
        "outDegree": 4,
        "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})\r\n",
        "importStatements": [
          "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
        ],
        "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})",
        "originFile": "\\tests\\python.test.ts"
      }
    },
    {
      "key": "\\tests\\utils.test",
      "attributes": {
        "id": "\\tests\\utils.test",
        "language": "typescript",
        "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\utils.test.ts",
        "type": "file",
        "totalTokens": 4001,
        "inDegree": 0,
        "outDegree": 0,
        "code": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    // test('generateNodePrompts', async () => {\r\n    //     const links: GraphLink[] = [\r\n    //         { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n    //         { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n    //         { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n    //         { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n    //         { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n    //         { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n    //         { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n    //     ];\r\n    //     const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n    //     const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n    //     // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n    //     // console.log(systemPrompt)\r\n    //     // console.log(userPrompt)\r\n    //     // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n    //     await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n    //     wikiutils.documentFolders(nodes, links, repoName)\r\n    //     // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    // }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })\r\n",
        "importStatements": [
          "import * as utils from '../src/model/utils'",
          "import { GraphLink, GraphNode } from '../src/utils/db'",
          "import * as wikiutils from '../src/wiki/utils'"
        ],
        "codeNoBody": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    // test('generateNodePrompts', async () => {\r\n    //     const links: GraphLink[] = [\r\n    //         { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n    //         { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n    //         { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n    //         { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n    //         { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n    //         { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n    //         { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n    //     ];\r\n    //     const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n    //     const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n    //     // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n    //     // console.log(systemPrompt)\r\n    //     // console.log(userPrompt)\r\n    //     // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n    //     await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n    //     wikiutils.documentFolders(nodes, links, repoName)\r\n    //     // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    // }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })",
        "originFile": "\\tests\\utils.test.ts"
      }
    }
  ],
  "edges": [
    {
      "key": "geid_71_0",
      "source": "\\llamaindex",
      "target": "\\llamaindex::readJson",
      "attributes": {
        "source": "\\llamaindex",
        "target": "\\llamaindex::readJson",
        "label": "defines",
        "line": 44
      }
    },
    {
      "key": "geid_71_1",
      "source": "\\llamaindex",
      "target": "\\llamaindex::main",
      "attributes": {
        "source": "\\llamaindex",
        "target": "\\llamaindex::main",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_2",
      "source": "\\llamaindex::main",
      "target": "\\llamaindex::readJson",
      "attributes": {
        "source": "\\llamaindex::main",
        "target": "\\llamaindex::readJson",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_3",
      "source": "\\llamaindex",
      "target": "\\llamaindex::main",
      "attributes": {
        "source": "\\llamaindex",
        "target": "\\llamaindex::main",
        "label": "calls",
        "line": 42
      }
    },
    {
      "key": "geid_71_4",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::eigenvector",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::eigenvector",
        "label": "defines",
        "line": 87
      }
    },
    {
      "key": "geid_71_5",
      "source": "\\src\\communities\\centralities::eigenvector",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities::eigenvector",
        "target": "\\src\\communities\\centralities::graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_6",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::pageranks",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::pageranks",
        "label": "defines",
        "line": 85
      }
    },
    {
      "key": "geid_71_7",
      "source": "\\src\\communities\\centralities::pageranks",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities::pageranks",
        "target": "\\src\\communities\\centralities::graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_8",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::closeness",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::closeness",
        "label": "defines",
        "line": 84
      }
    },
    {
      "key": "geid_71_9",
      "source": "\\src\\communities\\centralities::closeness",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities::closeness",
        "target": "\\src\\communities\\centralities::graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_10",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::betweenness",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::betweenness",
        "label": "defines",
        "line": 83
      }
    },
    {
      "key": "geid_71_11",
      "source": "\\src\\communities\\centralities::betweenness",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities::betweenness",
        "target": "\\src\\communities\\centralities::graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_12",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::degree",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::degree",
        "label": "defines",
        "line": 82
      }
    },
    {
      "key": "geid_71_13",
      "source": "\\src\\communities\\centralities::degree",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities::degree",
        "target": "\\src\\communities\\centralities::graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_14",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::graph",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::graph",
        "label": "defines",
        "line": 72
      }
    },
    {
      "key": "geid_71_15",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::constructGraphFromJson",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::constructGraphFromJson",
        "label": "defines",
        "line": 47
      }
    },
    {
      "key": "geid_71_16",
      "source": "\\src\\communities\\centralities::constructGraphFromJson",
      "target": "\\src\\communities\\centralities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\centralities::constructGraphFromJson",
        "target": "\\src\\communities\\centralities::wikiNode",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_17",
      "source": "\\src\\communities\\centralities::constructGraphFromJson",
      "target": "\\src\\communities\\centralities::readJson",
      "attributes": {
        "source": "\\src\\communities\\centralities::constructGraphFromJson",
        "target": "\\src\\communities\\centralities::readJson",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_18",
      "source": "\\src\\communities\\centralities::constructGraphFromJson",
      "target": "\\src\\communities\\centralities::nodesFilePath",
      "attributes": {
        "source": "\\src\\communities\\centralities::constructGraphFromJson",
        "target": "\\src\\communities\\centralities::nodesFilePath",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_19",
      "source": "\\src\\communities\\centralities::constructGraphFromJson",
      "target": "\\src\\communities\\centralities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\centralities::constructGraphFromJson",
        "target": "\\src\\communities\\centralities::wikiLink",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_20",
      "source": "\\src\\communities\\centralities::constructGraphFromJson",
      "target": "\\src\\communities\\centralities::linksFilePath",
      "attributes": {
        "source": "\\src\\communities\\centralities::constructGraphFromJson",
        "target": "\\src\\communities\\centralities::linksFilePath",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_21",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::readJson",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::readJson",
        "label": "defines",
        "line": 41
      }
    },
    {
      "key": "geid_71_22",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::wikiLink",
        "label": "defines",
        "line": 35
      }
    },
    {
      "key": "geid_71_23",
      "source": "\\src\\communities\\centralities::wikiLink",
      "target": "\\src\\communities\\centralities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\centralities::wikiLink",
        "target": "\\src\\communities\\centralities::wikiLink",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_24",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::wikiNode",
        "label": "defines",
        "line": 19
      }
    },
    {
      "key": "geid_71_25",
      "source": "\\src\\communities\\centralities::wikiNode",
      "target": "\\src\\communities\\centralities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\centralities::wikiNode",
        "target": "\\src\\communities\\centralities::wikiNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_26",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::linksFilePath",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::linksFilePath",
        "label": "defines",
        "line": 16
      }
    },
    {
      "key": "geid_71_27",
      "source": "\\src\\communities\\centralities::linksFilePath",
      "target": "\\src\\communities\\centralities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\centralities::linksFilePath",
        "target": "\\src\\communities\\centralities::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_28",
      "source": "\\src\\communities\\centralities::linksFilePath",
      "target": "\\src\\communities\\centralities::projectId",
      "attributes": {
        "source": "\\src\\communities\\centralities::linksFilePath",
        "target": "\\src\\communities\\centralities::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_29",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::nodesFilePath",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::nodesFilePath",
        "label": "defines",
        "line": 15
      }
    },
    {
      "key": "geid_71_30",
      "source": "\\src\\communities\\centralities::nodesFilePath",
      "target": "\\src\\communities\\centralities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\centralities::nodesFilePath",
        "target": "\\src\\communities\\centralities::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_31",
      "source": "\\src\\communities\\centralities::nodesFilePath",
      "target": "\\src\\communities\\centralities::projectId",
      "attributes": {
        "source": "\\src\\communities\\centralities::nodesFilePath",
        "target": "\\src\\communities\\centralities::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_32",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::folder_path",
        "label": "defines",
        "line": 14
      }
    },
    {
      "key": "geid_71_33",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::projectId",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::projectId",
        "label": "defines",
        "line": 13
      }
    },
    {
      "key": "geid_71_34",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::degree",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::degree",
        "label": "calls",
        "line": 108
      }
    },
    {
      "key": "geid_71_35",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::betweenness",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::betweenness",
        "label": "calls",
        "line": 109
      }
    },
    {
      "key": "geid_71_36",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::closeness",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::closeness",
        "label": "calls",
        "line": 110
      }
    },
    {
      "key": "geid_71_37",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::pageranks",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::pageranks",
        "label": "calls",
        "line": 111
      }
    },
    {
      "key": "geid_71_38",
      "source": "\\src\\communities\\centralities",
      "target": "\\src\\communities\\centralities::eigenvector",
      "attributes": {
        "source": "\\src\\communities\\centralities",
        "target": "\\src\\communities\\centralities::eigenvector",
        "label": "calls",
        "line": 114
      }
    },
    {
      "key": "geid_71_39",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::cmap",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::cmap",
        "label": "defines",
        "line": 52
      }
    },
    {
      "key": "geid_71_40",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::pos",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::pos",
        "label": "defines",
        "line": 51
      }
    },
    {
      "key": "geid_71_41",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::partition",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::partition",
        "label": "defines",
        "line": 44
      }
    },
    {
      "key": "geid_71_42",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::G",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::G",
        "label": "defines",
        "line": 41
      }
    },
    {
      "key": "geid_71_43",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::links",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::links",
        "label": "defines",
        "line": 37
      }
    },
    {
      "key": "geid_71_44",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::nodes",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::nodes",
        "label": "defines",
        "line": 36
      }
    },
    {
      "key": "geid_71_45",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::construct_graph_from_json",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::construct_graph_from_json",
        "label": "defines",
        "line": 27
      }
    },
    {
      "key": "geid_71_46",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::save_json",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::save_json",
        "label": "defines",
        "line": 23
      }
    },
    {
      "key": "geid_71_47",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::read_json",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::read_json",
        "label": "defines",
        "line": 20
      }
    },
    {
      "key": "geid_71_48",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::graph_to_csv",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::graph_to_csv",
        "label": "defines",
        "line": 11
      }
    },
    {
      "key": "geid_71_49",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::links_path",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::links_path",
        "label": "defines",
        "line": 9
      }
    },
    {
      "key": "geid_71_50",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::nodes_path",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::nodes_path",
        "label": "defines",
        "line": 8
      }
    },
    {
      "key": "geid_71_51",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::folder_path",
        "label": "defines",
        "line": 12
      }
    },
    {
      "key": "geid_71_52",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::projectId",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::projectId",
        "label": "defines",
        "line": 11
      }
    },
    {
      "key": "geid_71_53",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::wikiNode",
        "label": "calls",
        "line": 77
      }
    },
    {
      "key": "geid_71_54",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::constructGraphFromJson",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::constructGraphFromJson",
        "label": "calls",
        "line": 78
      }
    },
    {
      "key": "geid_71_55",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::nodesFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::nodesFilePath",
        "label": "calls",
        "line": 78
      }
    },
    {
      "key": "geid_71_56",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::linksFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::linksFilePath",
        "label": "calls",
        "line": 78
      }
    },
    {
      "key": "geid_71_57",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::constructGraphFromJson",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::constructGraphFromJson",
        "label": "defines",
        "line": 45
      }
    },
    {
      "key": "geid_71_58",
      "source": "\\src\\communities\\communities::constructGraphFromJson",
      "target": "\\src\\communities\\communities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\communities::constructGraphFromJson",
        "target": "\\src\\communities\\communities::wikiNode",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_59",
      "source": "\\src\\communities\\communities::constructGraphFromJson",
      "target": "\\src\\communities\\communities::readJson",
      "attributes": {
        "source": "\\src\\communities\\communities::constructGraphFromJson",
        "target": "\\src\\communities\\communities::readJson",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_60",
      "source": "\\src\\communities\\communities::constructGraphFromJson",
      "target": "\\src\\communities\\communities::nodesFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities::constructGraphFromJson",
        "target": "\\src\\communities\\communities::nodesFilePath",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_61",
      "source": "\\src\\communities\\communities::constructGraphFromJson",
      "target": "\\src\\communities\\communities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\communities::constructGraphFromJson",
        "target": "\\src\\communities\\communities::wikiLink",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_62",
      "source": "\\src\\communities\\communities::constructGraphFromJson",
      "target": "\\src\\communities\\communities::linksFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities::constructGraphFromJson",
        "target": "\\src\\communities\\communities::linksFilePath",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_63",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::readJson",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::readJson",
        "label": "defines",
        "line": 39
      }
    },
    {
      "key": "geid_71_64",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::wikiLink",
        "label": "defines",
        "line": 33
      }
    },
    {
      "key": "geid_71_65",
      "source": "\\src\\communities\\communities::wikiLink",
      "target": "\\src\\communities\\communities::wikiLink",
      "attributes": {
        "source": "\\src\\communities\\communities::wikiLink",
        "target": "\\src\\communities\\communities::wikiLink",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_66",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::wikiNode",
        "label": "defines",
        "line": 17
      }
    },
    {
      "key": "geid_71_67",
      "source": "\\src\\communities\\communities::wikiNode",
      "target": "\\src\\communities\\communities::wikiNode",
      "attributes": {
        "source": "\\src\\communities\\communities::wikiNode",
        "target": "\\src\\communities\\communities::wikiNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_68",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::linksFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::linksFilePath",
        "label": "defines",
        "line": 14
      }
    },
    {
      "key": "geid_71_69",
      "source": "\\src\\communities\\communities::linksFilePath",
      "target": "\\src\\communities\\communities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\communities::linksFilePath",
        "target": "\\src\\communities\\communities::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_70",
      "source": "\\src\\communities\\communities::linksFilePath",
      "target": "\\src\\communities\\communities::projectId",
      "attributes": {
        "source": "\\src\\communities\\communities::linksFilePath",
        "target": "\\src\\communities\\communities::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_71",
      "source": "\\src\\communities\\communities",
      "target": "\\src\\communities\\communities::nodesFilePath",
      "attributes": {
        "source": "\\src\\communities\\communities",
        "target": "\\src\\communities\\communities::nodesFilePath",
        "label": "defines",
        "line": 13
      }
    },
    {
      "key": "geid_71_72",
      "source": "\\src\\communities\\communities::nodesFilePath",
      "target": "\\src\\communities\\communities::folder_path",
      "attributes": {
        "source": "\\src\\communities\\communities::nodesFilePath",
        "target": "\\src\\communities\\communities::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_73",
      "source": "\\src\\communities\\communities::nodesFilePath",
      "target": "\\src\\communities\\communities::projectId",
      "attributes": {
        "source": "\\src\\communities\\communities::nodesFilePath",
        "target": "\\src\\communities\\communities::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_74",
      "source": "\\src\\index",
      "target": "\\src\\index::const",
      "attributes": {
        "source": "\\src\\index",
        "target": "\\src\\index::const",
        "label": "defines",
        "line": 11
      }
    },
    {
      "key": "geid_71_75",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
        "label": "defines",
        "line": 133
      }
    },
    {
      "key": "geid_71_76",
      "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_77",
      "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
      "target": "\\src\\model\\calls::CallsCapturer.captureAssignments",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
        "target": "\\src\\model\\calls::CallsCapturer.captureAssignments",
        "label": "calls",
        "line": 42
      }
    },
    {
      "key": "geid_71_78",
      "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
      "target": "\\src\\model\\calls::CallsCapturer.captureCalls",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
        "target": "\\src\\model\\calls::CallsCapturer.captureCalls",
        "label": "calls",
        "line": 64
      }
    },
    {
      "key": "geid_71_79",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallsCapturer.captureCalls",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallsCapturer.captureCalls",
        "label": "defines",
        "line": 91
      }
    },
    {
      "key": "geid_71_80",
      "source": "\\src\\model\\calls::CallsCapturer.captureCalls",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.captureCalls",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_81",
      "source": "\\src\\model\\calls::CallsCapturer.captureCalls",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.captureCalls",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "calls",
        "line": 29
      }
    },
    {
      "key": "geid_71_82",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallsCapturer.captureAssignments",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallsCapturer.captureAssignments",
        "label": "defines",
        "line": 46
      }
    },
    {
      "key": "geid_71_83",
      "source": "\\src\\model\\calls::CallsCapturer.captureAssignments",
      "target": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.captureAssignments",
        "target": "\\src\\model\\calls::VariableAssignment",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_84",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallsCapturer.constructor",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallsCapturer.constructor",
        "label": "defines",
        "line": 27
      }
    },
    {
      "key": "geid_71_85",
      "source": "\\src\\model\\calls::CallsCapturer.constructor",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer.constructor",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_86",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "defines",
        "line": 22
      }
    },
    {
      "key": "geid_71_87",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_88",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::VariableAssignment",
        "label": "calls",
        "line": 25
      }
    },
    {
      "key": "geid_71_89",
      "source": "\\src\\model\\calls::CallsCapturer",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls::CallsCapturer",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "calls",
        "line": 70
      }
    },
    {
      "key": "geid_71_90",
      "source": "\\src\\model\\calls::CallIdentifier",
      "target": "\\src\\model\\calls::CallIdentifier.constructor",
      "attributes": {
        "source": "\\src\\model\\calls::CallIdentifier",
        "target": "\\src\\model\\calls::CallIdentifier.constructor",
        "label": "defines",
        "line": 16
      }
    },
    {
      "key": "geid_71_91",
      "source": "\\src\\model\\calls::CallIdentifier.constructor",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls::CallIdentifier.constructor",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_92",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "defines",
        "line": 12
      }
    },
    {
      "key": "geid_71_93",
      "source": "\\src\\model\\calls::CallIdentifier",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls::CallIdentifier",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_94",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::VariableAssignment",
        "label": "defines",
        "line": 5
      }
    },
    {
      "key": "geid_71_95",
      "source": "\\src\\model\\calls::VariableAssignment",
      "target": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "source": "\\src\\model\\calls::VariableAssignment",
        "target": "\\src\\model\\calls::VariableAssignment",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_96",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::VariableAssignment",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::VariableAssignment",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_97",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::CallIdentifier",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::CallIdentifier",
        "label": "calls",
        "line": 12
      }
    },
    {
      "key": "geid_71_98",
      "source": "\\src\\model\\calls",
      "target": "\\src\\model\\calls::CallsCapturer",
      "attributes": {
        "source": "\\src\\model\\calls",
        "target": "\\src\\model\\calls::CallsCapturer",
        "label": "calls",
        "line": 22
      }
    },
    {
      "key": "geid_71_99",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "label": "defines",
        "line": 884
      }
    },
    {
      "key": "geid_71_100",
      "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_101",
      "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "target": "\\src\\model\\codebase::Node.getAllChildren",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "target": "\\src\\model\\codebase::Node.getAllChildren",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_102",
      "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_103",
      "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "target": "\\src\\model\\codebase::Node.removeChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "target": "\\src\\model\\codebase::Node.removeChild",
        "label": "calls",
        "line": 10
      }
    },
    {
      "key": "geid_71_104",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "label": "defines",
        "line": 839
      }
    },
    {
      "key": "geid_71_105",
      "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_106",
      "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 14
      }
    },
    {
      "key": "geid_71_107",
      "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "target": "\\src\\model\\codebase::Codebase.resolveHeaderC",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "target": "\\src\\model\\codebase::Codebase.resolveHeaderC",
        "label": "calls",
        "line": 22
      }
    },
    {
      "key": "geid_71_108",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
        "label": "defines",
        "line": 822
      }
    },
    {
      "key": "geid_71_109",
      "source": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_110",
      "source": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_111",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.getLinks",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.getLinks",
        "label": "defines",
        "line": 800
      }
    },
    {
      "key": "geid_71_112",
      "source": "\\src\\model\\codebase::Codebase.getLinks",
      "target": "\\src\\model\\codebase::Link",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getLinks",
        "target": "\\src\\model\\codebase::Link",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_113",
      "source": "\\src\\model\\codebase::Codebase.getLinks",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getLinks",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_114",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.simplify",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.simplify",
        "label": "defines",
        "line": 796
      }
    },
    {
      "key": "geid_71_115",
      "source": "\\src\\model\\codebase::Codebase.simplify",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.simplify",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_116",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.getCalls",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.getCalls",
        "label": "defines",
        "line": 761
      }
    },
    {
      "key": "geid_71_117",
      "source": "\\src\\model\\codebase::Codebase.getCalls",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getCalls",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_118",
      "source": "\\src\\model\\codebase::Codebase.getCalls",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getCalls",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 19
      }
    },
    {
      "key": "geid_71_119",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.parseFolder",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.parseFolder",
        "label": "defines",
        "line": 734
      }
    },
    {
      "key": "geid_71_120",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_121",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_122",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_123",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase.addNodeMap",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase.addNodeMap",
        "label": "calls",
        "line": 10
      }
    },
    {
      "key": "geid_71_124",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
        "label": "calls",
        "line": 22
      }
    },
    {
      "key": "geid_71_125",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "label": "calls",
        "line": 23
      }
    },
    {
      "key": "geid_71_126",
      "source": "\\src\\model\\codebase::Codebase.parseFolder",
      "target": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.parseFolder",
        "target": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
        "label": "calls",
        "line": 24
      }
    },
    {
      "key": "geid_71_127",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "label": "defines",
        "line": 700
      }
    },
    {
      "key": "geid_71_128",
      "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_129",
      "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_130",
      "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
      "target": "\\src\\model\\codebase::Node.addChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.resolveSpaces",
        "target": "\\src\\model\\codebase::Node.addChild",
        "label": "calls",
        "line": 16
      }
    },
    {
      "key": "geid_71_131",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "label": "defines",
        "line": 653
      }
    },
    {
      "key": "geid_71_132",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_133",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Node.getChildrenDefinitions",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Node.getChildrenDefinitions",
        "label": "calls",
        "line": 33
      }
    },
    {
      "key": "geid_71_134",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Node.generateImports",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Node.generateImports",
        "label": "calls",
        "line": 34
      }
    },
    {
      "key": "geid_71_135",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Node.parseExportClauses",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Node.parseExportClauses",
        "label": "calls",
        "line": 35
      }
    },
    {
      "key": "geid_71_136",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 35
      }
    },
    {
      "key": "geid_71_137",
      "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
      "target": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
        "target": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
        "label": "calls",
        "line": 42
      }
    },
    {
      "key": "geid_71_138",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
        "label": "defines",
        "line": 648
      }
    },
    {
      "key": "geid_71_139",
      "source": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_140",
      "source": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_141",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.addNodeMap",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.addNodeMap",
        "label": "defines",
        "line": 645
      }
    },
    {
      "key": "geid_71_142",
      "source": "\\src\\model\\codebase::Codebase.addNodeMap",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNodeMap",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_143",
      "source": "\\src\\model\\codebase::Codebase.addNodeMap",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNodeMap",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_144",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.getNode",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.getNode",
        "label": "defines",
        "line": 642
      }
    },
    {
      "key": "geid_71_145",
      "source": "\\src\\model\\codebase::Codebase.getNode",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getNode",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_146",
      "source": "\\src\\model\\codebase::Codebase.getNode",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.getNode",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_147",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.addNode",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.addNode",
        "label": "defines",
        "line": 639
      }
    },
    {
      "key": "geid_71_148",
      "source": "\\src\\model\\codebase::Codebase.addNode",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNode",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_149",
      "source": "\\src\\model\\codebase::Codebase.addNode",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.addNode",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_150",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase.constructor",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase.constructor",
        "label": "defines",
        "line": 636
      }
    },
    {
      "key": "geid_71_151",
      "source": "\\src\\model\\codebase::Codebase.constructor",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase.constructor",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_152",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "defines",
        "line": 629
      }
    },
    {
      "key": "geid_71_153",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_154",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_155",
      "source": "\\src\\model\\codebase::Codebase",
      "target": "\\src\\model\\codebase::Link",
      "attributes": {
        "source": "\\src\\model\\codebase::Codebase",
        "target": "\\src\\model\\codebase::Link",
        "label": "calls",
        "line": 172
      }
    },
    {
      "key": "geid_71_156",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.simplify",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.simplify",
        "label": "defines",
        "line": 592
      }
    },
    {
      "key": "geid_71_157",
      "source": "\\src\\model\\codebase::Node.simplify",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.simplify",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_158",
      "source": "\\src\\model\\codebase::Node.simplify",
      "target": "\\src\\model\\codebase::Node.getCodeWithoutBody",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.simplify",
        "target": "\\src\\model\\codebase::Node.getCodeWithoutBody",
        "label": "calls",
        "line": 15
      }
    },
    {
      "key": "geid_71_159",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.getChildrenDefinitions",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.getChildrenDefinitions",
        "label": "defines",
        "line": 426
      }
    },
    {
      "key": "geid_71_160",
      "source": "\\src\\model\\codebase::Node.getChildrenDefinitions",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.getChildrenDefinitions",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_161",
      "source": "\\src\\model\\codebase::Node.getChildrenDefinitions",
      "target": "\\src\\model\\codebase::Node.addChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.getChildrenDefinitions",
        "target": "\\src\\model\\codebase::Node.addChild",
        "label": "calls",
        "line": 156
      }
    },
    {
      "key": "geid_71_162",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
        "label": "defines",
        "line": 387
      }
    },
    {
      "key": "geid_71_163",
      "source": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_164",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.parseExportClauses",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.parseExportClauses",
        "label": "defines",
        "line": 312
      }
    },
    {
      "key": "geid_71_165",
      "source": "\\src\\model\\codebase::Node.parseExportClauses",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.parseExportClauses",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_166",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.generateImports",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.generateImports",
        "label": "defines",
        "line": 261
      }
    },
    {
      "key": "geid_71_167",
      "source": "\\src\\model\\codebase::Node.generateImports",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.generateImports",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_168",
      "source": "\\src\\model\\codebase::Node.generateImports",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.generateImports",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 10
      }
    },
    {
      "key": "geid_71_169",
      "source": "\\src\\model\\codebase::Node.generateImports",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.generateImports",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 24
      }
    },
    {
      "key": "geid_71_170",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.getCodeWithoutBody",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.getCodeWithoutBody",
        "label": "defines",
        "line": 173
      }
    },
    {
      "key": "geid_71_171",
      "source": "\\src\\model\\codebase::Node.getCodeWithoutBody",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.getCodeWithoutBody",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_172",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.addNodeRelationship",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.addNodeRelationship",
        "label": "defines",
        "line": 148
      }
    },
    {
      "key": "geid_71_173",
      "source": "\\src\\model\\codebase::Node.addNodeRelationship",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addNodeRelationship",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_174",
      "source": "\\src\\model\\codebase::Node.addNodeRelationship",
      "target": "\\src\\model\\codebase::Node.isWithin",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addNodeRelationship",
        "target": "\\src\\model\\codebase::Node.isWithin",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_175",
      "source": "\\src\\model\\codebase::Node.addNodeRelationship",
      "target": "\\src\\model\\codebase::Node.addChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addNodeRelationship",
        "target": "\\src\\model\\codebase::Node.addChild",
        "label": "calls",
        "line": 22
      }
    },
    {
      "key": "geid_71_176",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.isWithin",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.isWithin",
        "label": "defines",
        "line": 141
      }
    },
    {
      "key": "geid_71_177",
      "source": "\\src\\model\\codebase::Node.isWithin",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.isWithin",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_178",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.addImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.addImportStatement",
        "label": "defines",
        "line": 136
      }
    },
    {
      "key": "geid_71_179",
      "source": "\\src\\model\\codebase::Node.addImportStatement",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addImportStatement",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_180",
      "source": "\\src\\model\\codebase::Node.addImportStatement",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addImportStatement",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_181",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.addCall",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.addCall",
        "label": "defines",
        "line": 129
      }
    },
    {
      "key": "geid_71_182",
      "source": "\\src\\model\\codebase::Node.addCall",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addCall",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_183",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.removeChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.removeChild",
        "label": "defines",
        "line": 120
      }
    },
    {
      "key": "geid_71_184",
      "source": "\\src\\model\\codebase::Node.removeChild",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.removeChild",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_185",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.addChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.addChild",
        "label": "defines",
        "line": 112
      }
    },
    {
      "key": "geid_71_186",
      "source": "\\src\\model\\codebase::Node.addChild",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.addChild",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_187",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.getAllChildren",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.getAllChildren",
        "label": "defines",
        "line": 101
      }
    },
    {
      "key": "geid_71_188",
      "source": "\\src\\model\\codebase::Node.getAllChildren",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.getAllChildren",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_189",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.getChild",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.getChild",
        "label": "defines",
        "line": 88
      }
    },
    {
      "key": "geid_71_190",
      "source": "\\src\\model\\codebase::Node.getChild",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.getChild",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_191",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node.constructor",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node.constructor",
        "label": "defines",
        "line": 81
      }
    },
    {
      "key": "geid_71_192",
      "source": "\\src\\model\\codebase::Node.constructor",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node.constructor",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_193",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Node",
        "label": "defines",
        "line": 59
      }
    },
    {
      "key": "geid_71_194",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_195",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_196",
      "source": "\\src\\model\\codebase::Node",
      "target": "\\src\\model\\codebase::NodeCallTuple",
      "attributes": {
        "source": "\\src\\model\\codebase::Node",
        "target": "\\src\\model\\codebase::NodeCallTuple",
        "label": "calls",
        "line": 15
      }
    },
    {
      "key": "geid_71_197",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::NodeCallTuple",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::NodeCallTuple",
        "label": "defines",
        "line": 57
      }
    },
    {
      "key": "geid_71_198",
      "source": "\\src\\model\\codebase::NodeCallTuple",
      "target": "\\src\\model\\codebase::NodeCallTuple",
      "attributes": {
        "source": "\\src\\model\\codebase::NodeCallTuple",
        "target": "\\src\\model\\codebase::NodeCallTuple",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_199",
      "source": "\\src\\model\\codebase::NodeCallTuple",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::NodeCallTuple",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_200",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Link",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Link",
        "label": "defines",
        "line": 50
      }
    },
    {
      "key": "geid_71_201",
      "source": "\\src\\model\\codebase::Link",
      "target": "\\src\\model\\codebase::Link",
      "attributes": {
        "source": "\\src\\model\\codebase::Link",
        "target": "\\src\\model\\codebase::Link",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_202",
      "source": "\\src\\model\\codebase::ImportStatement",
      "target": "\\src\\model\\codebase::ImportStatement.constructor",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportStatement",
        "target": "\\src\\model\\codebase::ImportStatement.constructor",
        "label": "defines",
        "line": 35
      }
    },
    {
      "key": "geid_71_203",
      "source": "\\src\\model\\codebase::ImportStatement.constructor",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportStatement.constructor",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_204",
      "source": "\\src\\model\\codebase::ImportStatement.constructor",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportStatement.constructor",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_205",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "defines",
        "line": 28
      }
    },
    {
      "key": "geid_71_206",
      "source": "\\src\\model\\codebase::ImportStatement",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportStatement",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_207",
      "source": "\\src\\model\\codebase::ImportStatement",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportStatement",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_208",
      "source": "\\src\\model\\codebase::ImportName",
      "target": "\\src\\model\\codebase::ImportName.constructor",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportName",
        "target": "\\src\\model\\codebase::ImportName.constructor",
        "label": "defines",
        "line": 23
      }
    },
    {
      "key": "geid_71_209",
      "source": "\\src\\model\\codebase::ImportName.constructor",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportName.constructor",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_210",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "defines",
        "line": 17
      }
    },
    {
      "key": "geid_71_211",
      "source": "\\src\\model\\codebase::ImportName",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportName",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_212",
      "source": "\\src\\model\\codebase::ImportName",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase::ImportName",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_213",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::const",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::const",
        "label": "defines",
        "line": 15
      }
    },
    {
      "key": "geid_71_214",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::ImportName",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::ImportName",
        "label": "calls",
        "line": 19
      }
    },
    {
      "key": "geid_71_215",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::ImportStatement",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::ImportStatement",
        "label": "calls",
        "line": 30
      }
    },
    {
      "key": "geid_71_216",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Link",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Link",
        "label": "calls",
        "line": 52
      }
    },
    {
      "key": "geid_71_217",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Node",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Node",
        "label": "calls",
        "line": 63
      }
    },
    {
      "key": "geid_71_218",
      "source": "\\src\\model\\codebase",
      "target": "\\src\\model\\codebase::Codebase",
      "attributes": {
        "source": "\\src\\model\\codebase",
        "target": "\\src\\model\\codebase::Codebase",
        "label": "calls",
        "line": 633
      }
    },
    {
      "key": "geid_71_219",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::treeSitterCommentTypes",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::treeSitterCommentTypes",
        "label": "defines",
        "line": 126
      }
    },
    {
      "key": "geid_71_220",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::indexSuffixesMap",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::indexSuffixesMap",
        "label": "defines",
        "line": 116
      }
    },
    {
      "key": "geid_71_221",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::itselfClassMap",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::itselfClassMap",
        "label": "defines",
        "line": 106
      }
    },
    {
      "key": "geid_71_222",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::newClassMethodsMap",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::newClassMethodsMap",
        "label": "defines",
        "line": 96
      }
    },
    {
      "key": "geid_71_223",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::languageExtensionMap",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::languageExtensionMap",
        "label": "defines",
        "line": 82
      }
    },
    {
      "key": "geid_71_224",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::languages",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::languages",
        "label": "defines",
        "line": 72
      }
    },
    {
      "key": "geid_71_225",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::excludedExtensions",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::excludedExtensions",
        "label": "defines",
        "line": 63
      }
    },
    {
      "key": "geid_71_226",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::excludedFolders",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::excludedFolders",
        "label": "defines",
        "line": 50
      }
    },
    {
      "key": "geid_71_227",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::AllowedTypesArray",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::AllowedTypesArray",
        "label": "defines",
        "line": 32
      }
    },
    {
      "key": "geid_71_228",
      "source": "\\src\\model\\consts::AllowedTypesArray",
      "target": "\\src\\model\\consts::AllowedTypes",
      "attributes": {
        "source": "\\src\\model\\consts::AllowedTypesArray",
        "target": "\\src\\model\\consts::AllowedTypes",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_229",
      "source": "\\src\\model\\consts",
      "target": "\\src\\model\\consts::AllowedTypes",
      "attributes": {
        "source": "\\src\\model\\consts",
        "target": "\\src\\model\\consts::AllowedTypes",
        "label": "defines",
        "line": 15
      }
    },
    {
      "key": "geid_71_230",
      "source": "\\src\\model\\consts::AllowedTypes",
      "target": "\\src\\model\\consts::AllowedTypes",
      "attributes": {
        "source": "\\src\\model\\consts::AllowedTypes",
        "target": "\\src\\model\\consts::AllowedTypes",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_231",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::getCalledNode",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::getCalledNode",
        "label": "defines",
        "line": 263
      }
    },
    {
      "key": "geid_71_232",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::cleanAndSplitContent",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::cleanAndSplitContent",
        "label": "defines",
        "line": 249
      }
    },
    {
      "key": "geid_71_233",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::firstConsecutiveDots",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::firstConsecutiveDots",
        "label": "defines",
        "line": 244
      }
    },
    {
      "key": "geid_71_234",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::renameSource",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::renameSource",
        "label": "defines",
        "line": 200
      }
    },
    {
      "key": "geid_71_235",
      "source": "\\src\\model\\utils::renameSource",
      "target": "\\src\\model\\utils::firstConsecutiveDots",
      "attributes": {
        "source": "\\src\\model\\utils::renameSource",
        "target": "\\src\\model\\utils::firstConsecutiveDots",
        "label": "calls",
        "line": 27
      }
    },
    {
      "key": "geid_71_236",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::cleanDefCaptures",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::cleanDefCaptures",
        "label": "defines",
        "line": 168
      }
    },
    {
      "key": "geid_71_237",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::captureQuery",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::captureQuery",
        "label": "defines",
        "line": 126
      }
    },
    {
      "key": "geid_71_238",
      "source": "\\src\\model\\utils::captureQuery",
      "target": "\\src\\model\\utils::getRequiredDefinitions",
      "attributes": {
        "source": "\\src\\model\\utils::captureQuery",
        "target": "\\src\\model\\utils::getRequiredDefinitions",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_239",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::getRequiredDefinitions",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::getRequiredDefinitions",
        "label": "defines",
        "line": 76
      }
    },
    {
      "key": "geid_71_240",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::getTotalSize",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::getTotalSize",
        "label": "defines",
        "line": 59
      }
    },
    {
      "key": "geid_71_241",
      "source": "\\src\\model\\utils::getTotalSize",
      "target": "\\src\\model\\utils::getAllFiles",
      "attributes": {
        "source": "\\src\\model\\utils::getTotalSize",
        "target": "\\src\\model\\utils::getAllFiles",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_242",
      "source": "\\src\\model\\utils",
      "target": "\\src\\model\\utils::getAllFiles",
      "attributes": {
        "source": "\\src\\model\\utils",
        "target": "\\src\\model\\utils::getAllFiles",
        "label": "defines",
        "line": 21
      }
    },
    {
      "key": "geid_71_243",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::cQueries",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::cQueries",
        "label": "defines",
        "line": 111
      }
    },
    {
      "key": "geid_71_244",
      "source": "\\src\\queries\\c::cQueries",
      "target": "\\src\\queries\\c::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\c::cQueries",
        "target": "\\src\\queries\\c::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_245",
      "source": "\\src\\queries\\c::cQueries",
      "target": "\\src\\queries\\c::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\c::cQueries",
        "target": "\\src\\queries\\c::extraAssignmentCode",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_246",
      "source": "\\src\\queries\\c::cQueries",
      "target": "\\src\\queries\\c::calls",
      "attributes": {
        "source": "\\src\\queries\\c::cQueries",
        "target": "\\src\\queries\\c::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_247",
      "source": "\\src\\queries\\c::cQueries",
      "target": "\\src\\queries\\c::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\c::cQueries",
        "target": "\\src\\queries\\c::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_248",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::anyAssignments",
        "label": "defines",
        "line": 98
      }
    },
    {
      "key": "geid_71_249",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::calls",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::calls",
        "label": "defines",
        "line": 89
      }
    },
    {
      "key": "geid_71_250",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::extraAssignmentCode",
        "label": "defines",
        "line": 76
      }
    },
    {
      "key": "geid_71_251",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::definitionTemplate",
        "label": "defines",
        "line": 41
      }
    },
    {
      "key": "geid_71_252",
      "source": "\\src\\queries\\c",
      "target": "\\src\\queries\\c::signments",
      "attributes": {
        "source": "\\src\\queries\\c",
        "target": "\\src\\queries\\c::signments",
        "label": "defines",
        "line": 26
      }
    },
    {
      "key": "geid_71_253",
      "source": "\\src\\queries\\index",
      "target": "\\src\\queries\\index::treeSitterQueries",
      "attributes": {
        "source": "\\src\\queries\\index",
        "target": "\\src\\queries\\index::treeSitterQueries",
        "label": "defines",
        "line": 18
      }
    },
    {
      "key": "geid_71_254",
      "source": "\\src\\queries\\index::treeSitterQueries",
      "target": "\\src\\queries\\index::treeSitterQueries",
      "attributes": {
        "source": "\\src\\queries\\index::treeSitterQueries",
        "target": "\\src\\queries\\index::treeSitterQueries",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_255",
      "source": "\\src\\queries\\index",
      "target": "\\src\\queries\\index::languageQueries",
      "attributes": {
        "source": "\\src\\queries\\index",
        "target": "\\src\\queries\\index::languageQueries",
        "label": "defines",
        "line": 8
      }
    },
    {
      "key": "geid_71_256",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::javaQueries",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::javaQueries",
        "label": "defines",
        "line": 87
      }
    },
    {
      "key": "geid_71_257",
      "source": "\\src\\queries\\java::javaQueries",
      "target": "\\src\\queries\\java::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\java::javaQueries",
        "target": "\\src\\queries\\java::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_258",
      "source": "\\src\\queries\\java::javaQueries",
      "target": "\\src\\queries\\java::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\java::javaQueries",
        "target": "\\src\\queries\\java::extraAssignmentCode",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_259",
      "source": "\\src\\queries\\java::javaQueries",
      "target": "\\src\\queries\\java::calls",
      "attributes": {
        "source": "\\src\\queries\\java::javaQueries",
        "target": "\\src\\queries\\java::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_260",
      "source": "\\src\\queries\\java::javaQueries",
      "target": "\\src\\queries\\java::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\java::javaQueries",
        "target": "\\src\\queries\\java::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_261",
      "source": "\\src\\queries\\java::javaQueries",
      "target": "\\src\\queries\\java::spaceDeclaration",
      "attributes": {
        "source": "\\src\\queries\\java::javaQueries",
        "target": "\\src\\queries\\java::spaceDeclaration",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_262",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::anyAssignments",
        "label": "defines",
        "line": 77
      }
    },
    {
      "key": "geid_71_263",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::calls",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::calls",
        "label": "defines",
        "line": 67
      }
    },
    {
      "key": "geid_71_264",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::extraAssignmentCode",
        "label": "defines",
        "line": 64
      }
    },
    {
      "key": "geid_71_265",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::spaceDeclaration",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::spaceDeclaration",
        "label": "defines",
        "line": 57
      }
    },
    {
      "key": "geid_71_266",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::definitionTemplate",
        "label": "defines",
        "line": 36
      }
    },
    {
      "key": "geid_71_267",
      "source": "\\src\\queries\\java",
      "target": "\\src\\queries\\java::signments",
      "attributes": {
        "source": "\\src\\queries\\java",
        "target": "\\src\\queries\\java::signments",
        "label": "defines",
        "line": 30
      }
    },
    {
      "key": "geid_71_268",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::jsQueries",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::jsQueries",
        "label": "defines",
        "line": 259
      }
    },
    {
      "key": "geid_71_269",
      "source": "\\src\\queries\\javascript::jsQueries",
      "target": "\\src\\queries\\javascript::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\javascript::jsQueries",
        "target": "\\src\\queries\\javascript::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_270",
      "source": "\\src\\queries\\javascript::jsQueries",
      "target": "\\src\\queries\\javascript::exportClauses",
      "attributes": {
        "source": "\\src\\queries\\javascript::jsQueries",
        "target": "\\src\\queries\\javascript::exportClauses",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_271",
      "source": "\\src\\queries\\javascript::jsQueries",
      "target": "\\src\\queries\\javascript::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\javascript::jsQueries",
        "target": "\\src\\queries\\javascript::extraAssignmentCode",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_272",
      "source": "\\src\\queries\\javascript::jsQueries",
      "target": "\\src\\queries\\javascript::calls",
      "attributes": {
        "source": "\\src\\queries\\javascript::jsQueries",
        "target": "\\src\\queries\\javascript::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_273",
      "source": "\\src\\queries\\javascript::jsQueries",
      "target": "\\src\\queries\\javascript::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\javascript::jsQueries",
        "target": "\\src\\queries\\javascript::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_274",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::anyAssignments",
        "label": "defines",
        "line": 206
      }
    },
    {
      "key": "geid_71_275",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::calls",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::calls",
        "label": "defines",
        "line": 166
      }
    },
    {
      "key": "geid_71_276",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::extraAssignmentCode",
        "label": "defines",
        "line": 153
      }
    },
    {
      "key": "geid_71_277",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::exportClauses",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::exportClauses",
        "label": "defines",
        "line": 134
      }
    },
    {
      "key": "geid_71_278",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::arrowFunctionConstructor",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::arrowFunctionConstructor",
        "label": "defines",
        "line": 111
      }
    },
    {
      "key": "geid_71_279",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::definitionTemplate",
        "label": "defines",
        "line": 92
      }
    },
    {
      "key": "geid_71_280",
      "source": "\\src\\queries\\javascript",
      "target": "\\src\\queries\\javascript::arrowFunctionConstructor",
      "attributes": {
        "source": "\\src\\queries\\javascript",
        "target": "\\src\\queries\\javascript::arrowFunctionConstructor",
        "label": "calls",
        "line": 124
      }
    },
    {
      "key": "geid_71_281",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::phpQueries",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::phpQueries",
        "label": "defines",
        "line": 134
      }
    },
    {
      "key": "geid_71_282",
      "source": "\\src\\queries\\php::phpQueries",
      "target": "\\src\\queries\\php::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\php::phpQueries",
        "target": "\\src\\queries\\php::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_283",
      "source": "\\src\\queries\\php::phpQueries",
      "target": "\\src\\queries\\php::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\php::phpQueries",
        "target": "\\src\\queries\\php::extraAssignmentCode",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_284",
      "source": "\\src\\queries\\php::phpQueries",
      "target": "\\src\\queries\\php::calls",
      "attributes": {
        "source": "\\src\\queries\\php::phpQueries",
        "target": "\\src\\queries\\php::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_285",
      "source": "\\src\\queries\\php::phpQueries",
      "target": "\\src\\queries\\php::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\php::phpQueries",
        "target": "\\src\\queries\\php::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_286",
      "source": "\\src\\queries\\php::phpQueries",
      "target": "\\src\\queries\\php::spaceDeclaration",
      "attributes": {
        "source": "\\src\\queries\\php::phpQueries",
        "target": "\\src\\queries\\php::spaceDeclaration",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_287",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::anyAssignments",
        "label": "defines",
        "line": 117
      }
    },
    {
      "key": "geid_71_288",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::calls",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::calls",
        "label": "defines",
        "line": 104
      }
    },
    {
      "key": "geid_71_289",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::extraAssignmentCode",
        "label": "defines",
        "line": 93
      }
    },
    {
      "key": "geid_71_290",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::spaceDeclaration",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::spaceDeclaration",
        "label": "defines",
        "line": 82
      }
    },
    {
      "key": "geid_71_291",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::definitionTemplate",
        "label": "defines",
        "line": 58
      }
    },
    {
      "key": "geid_71_292",
      "source": "\\src\\queries\\php",
      "target": "\\src\\queries\\php::signments",
      "attributes": {
        "source": "\\src\\queries\\php",
        "target": "\\src\\queries\\php::signments",
        "label": "defines",
        "line": 44
      }
    },
    {
      "key": "geid_71_293",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::pyQueries",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::pyQueries",
        "label": "defines",
        "line": 183
      }
    },
    {
      "key": "geid_71_294",
      "source": "\\src\\queries\\python::pyQueries",
      "target": "\\src\\queries\\python::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\python::pyQueries",
        "target": "\\src\\queries\\python::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_295",
      "source": "\\src\\queries\\python::pyQueries",
      "target": "\\src\\queries\\python::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\python::pyQueries",
        "target": "\\src\\queries\\python::extraAssignmentCode",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_296",
      "source": "\\src\\queries\\python::pyQueries",
      "target": "\\src\\queries\\python::calls",
      "attributes": {
        "source": "\\src\\queries\\python::pyQueries",
        "target": "\\src\\queries\\python::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_297",
      "source": "\\src\\queries\\python::pyQueries",
      "target": "\\src\\queries\\python::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\python::pyQueries",
        "target": "\\src\\queries\\python::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_298",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::anyAssignments",
        "label": "defines",
        "line": 168
      }
    },
    {
      "key": "geid_71_299",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::calls",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::calls",
        "label": "defines",
        "line": 108
      }
    },
    {
      "key": "geid_71_300",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::extraAssignmentCode",
        "label": "defines",
        "line": 84
      }
    },
    {
      "key": "geid_71_301",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::definitionTemplate",
        "label": "defines",
        "line": 61
      }
    },
    {
      "key": "geid_71_302",
      "source": "\\src\\queries\\python",
      "target": "\\src\\queries\\python::signments",
      "attributes": {
        "source": "\\src\\queries\\python",
        "target": "\\src\\queries\\python::signments",
        "label": "defines",
        "line": 49
      }
    },
    {
      "key": "geid_71_303",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::tsQueries",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::tsQueries",
        "label": "defines",
        "line": 109
      }
    },
    {
      "key": "geid_71_304",
      "source": "\\src\\queries\\typescript::tsQueries",
      "target": "\\src\\queries\\typescript::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\typescript::tsQueries",
        "target": "\\src\\queries\\typescript::definitionTemplate",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_305",
      "source": "\\src\\queries\\typescript::tsQueries",
      "target": "\\src\\queries\\typescript::exportClauses",
      "attributes": {
        "source": "\\src\\queries\\typescript::tsQueries",
        "target": "\\src\\queries\\typescript::exportClauses",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_306",
      "source": "\\src\\queries\\typescript::tsQueries",
      "target": "\\src\\queries\\typescript::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\typescript::tsQueries",
        "target": "\\src\\queries\\typescript::extraAssignmentCode",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_307",
      "source": "\\src\\queries\\typescript::tsQueries",
      "target": "\\src\\queries\\typescript::calls",
      "attributes": {
        "source": "\\src\\queries\\typescript::tsQueries",
        "target": "\\src\\queries\\typescript::calls",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_308",
      "source": "\\src\\queries\\typescript::tsQueries",
      "target": "\\src\\queries\\typescript::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\typescript::tsQueries",
        "target": "\\src\\queries\\typescript::anyAssignments",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_309",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::anyAssignments",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::anyAssignments",
        "label": "defines",
        "line": 99
      }
    },
    {
      "key": "geid_71_310",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::calls",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::calls",
        "label": "defines",
        "line": 89
      }
    },
    {
      "key": "geid_71_311",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::extraAssignmentCode",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::extraAssignmentCode",
        "label": "defines",
        "line": 86
      }
    },
    {
      "key": "geid_71_312",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::exportClauses",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::exportClauses",
        "label": "defines",
        "line": 81
      }
    },
    {
      "key": "geid_71_313",
      "source": "\\src\\queries\\typescript",
      "target": "\\src\\queries\\typescript::definitionTemplate",
      "attributes": {
        "source": "\\src\\queries\\typescript",
        "target": "\\src\\queries\\typescript::definitionTemplate",
        "label": "defines",
        "line": 25
      }
    },
    {
      "key": "geid_71_314",
      "source": "\\src\\routes\\create_graph-test",
      "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph-test",
        "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
        "label": "defines",
        "line": 7
      }
    },
    {
      "key": "geid_71_315",
      "source": "\\src\\routes\\create_graph-test",
      "target": "\\src\\routes\\create_graph-test::createGraphTest",
      "attributes": {
        "source": "\\src\\routes\\create_graph-test",
        "target": "\\src\\routes\\create_graph-test::createGraphTest",
        "label": "defines",
        "line": 17
      }
    },
    {
      "key": "geid_71_316",
      "source": "\\src\\routes\\create_graph-test::createGraphTest",
      "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph-test::createGraphTest",
        "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_317",
      "source": "\\src\\routes\\create_graph-test",
      "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph-test",
        "target": "\\src\\routes\\create_graph-test::repoRequestValidator",
        "label": "calls",
        "line": 19
      }
    },
    {
      "key": "geid_71_318",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::processGraphCreation",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::processGraphCreation",
        "label": "defines",
        "line": 182
      }
    },
    {
      "key": "geid_71_319",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::repoRequestValidator",
        "label": "defines",
        "line": 13
      }
    },
    {
      "key": "geid_71_320",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::secret",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::secret",
        "label": "defines",
        "line": 11
      }
    },
    {
      "key": "geid_71_321",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::createGraph",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::createGraph",
        "label": "defines",
        "line": 26
      }
    },
    {
      "key": "geid_71_322",
      "source": "\\src\\routes\\create_graph::createGraph",
      "target": "\\src\\routes\\create_graph::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph::createGraph",
        "target": "\\src\\routes\\create_graph::repoRequestValidator",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_323",
      "source": "\\src\\routes\\create_graph::createGraph",
      "target": "\\src\\routes\\create_graph::secret",
      "attributes": {
        "source": "\\src\\routes\\create_graph::createGraph",
        "target": "\\src\\routes\\create_graph::secret",
        "label": "calls",
        "line": 25
      }
    },
    {
      "key": "geid_71_324",
      "source": "\\src\\routes\\create_graph::createGraph",
      "target": "\\src\\routes\\create_graph::processGraphCreation",
      "attributes": {
        "source": "\\src\\routes\\create_graph::createGraph",
        "target": "\\src\\routes\\create_graph::processGraphCreation",
        "label": "calls",
        "line": 138
      }
    },
    {
      "key": "geid_71_325",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::repoRequestValidator",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::repoRequestValidator",
        "label": "calls",
        "line": 30
      }
    },
    {
      "key": "geid_71_326",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::secret",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::secret",
        "label": "calls",
        "line": 53
      }
    },
    {
      "key": "geid_71_327",
      "source": "\\src\\routes\\create_graph",
      "target": "\\src\\routes\\create_graph::processGraphCreation",
      "attributes": {
        "source": "\\src\\routes\\create_graph",
        "target": "\\src\\routes\\create_graph::processGraphCreation",
        "label": "calls",
        "line": 166
      }
    },
    {
      "key": "geid_71_328",
      "source": "\\src\\routes\\graphs",
      "target": "\\src\\routes\\graphs::updateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs",
        "target": "\\src\\routes\\graphs::updateGraph",
        "label": "defines",
        "line": 207
      }
    },
    {
      "key": "geid_71_329",
      "source": "\\src\\routes\\graphs::updateGraph",
      "target": "\\src\\routes\\graphs::UpdateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs::updateGraph",
        "target": "\\src\\routes\\graphs::UpdateGraph",
        "label": "calls",
        "line": 11
      }
    },
    {
      "key": "geid_71_330",
      "source": "\\src\\routes\\graphs",
      "target": "\\src\\routes\\graphs::UpdateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs",
        "target": "\\src\\routes\\graphs::UpdateGraph",
        "label": "defines",
        "line": 195
      }
    },
    {
      "key": "geid_71_331",
      "source": "\\src\\routes\\graphs::UpdateGraph",
      "target": "\\src\\routes\\graphs::UpdateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs::UpdateGraph",
        "target": "\\src\\routes\\graphs::UpdateGraph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_332",
      "source": "\\src\\routes\\graphs",
      "target": "\\src\\routes\\graphs::graphs",
      "attributes": {
        "source": "\\src\\routes\\graphs",
        "target": "\\src\\routes\\graphs::graphs",
        "label": "defines",
        "line": 10
      }
    },
    {
      "key": "geid_71_333",
      "source": "\\src\\routes\\graphs::graphs",
      "target": "\\src\\routes\\graphs::updateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs::graphs",
        "target": "\\src\\routes\\graphs::updateGraph",
        "label": "calls",
        "line": 166
      }
    },
    {
      "key": "geid_71_334",
      "source": "\\src\\routes\\graphs",
      "target": "\\src\\routes\\graphs::updateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs",
        "target": "\\src\\routes\\graphs::updateGraph",
        "label": "calls",
        "line": 176
      }
    },
    {
      "key": "geid_71_335",
      "source": "\\src\\routes\\graphs",
      "target": "\\src\\routes\\graphs::UpdateGraph",
      "attributes": {
        "source": "\\src\\routes\\graphs",
        "target": "\\src\\routes\\graphs::UpdateGraph",
        "label": "calls",
        "line": 195
      }
    },
    {
      "key": "geid_71_336",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::similarToDescription",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::similarToDescription",
        "label": "defines",
        "line": 441
      }
    },
    {
      "key": "geid_71_337",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
        "label": "defines",
        "line": 424
      }
    },
    {
      "key": "geid_71_338",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getCodeDescription",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getCodeDescription",
        "label": "defines",
        "line": 409
      }
    },
    {
      "key": "geid_71_339",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::similarToTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::similarToTool",
        "label": "defines",
        "line": 399
      }
    },
    {
      "key": "geid_71_340",
      "source": "\\src\\tools\\function_tools::similarToTool",
      "target": "\\src\\tools\\function_tools::similarTo",
      "attributes": {
        "source": "\\src\\tools\\function_tools::similarToTool",
        "target": "\\src\\tools\\function_tools::similarTo",
        "label": "calls",
        "line": 5
      }
    },
    {
      "key": "geid_71_341",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
        "label": "defines",
        "line": 395
      }
    },
    {
      "key": "geid_71_342",
      "source": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
      "target": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
        "target": "\\src\\tools\\function_tools::getCode",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_343",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getCodeTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getCodeTool",
        "label": "defines",
        "line": 391
      }
    },
    {
      "key": "geid_71_344",
      "source": "\\src\\tools\\function_tools::getCodeTool",
      "target": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getCodeTool",
        "target": "\\src\\tools\\function_tools::getCode",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_345",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "label": "defines",
        "line": 349
      }
    },
    {
      "key": "geid_71_346",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getGraphNodesById",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getGraphNodesById",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_347",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getGraphLinksById",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getGraphLinksById",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_348",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::calculateLanguagePercentages",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::calculateLanguagePercentages",
        "label": "calls",
        "line": 26
      }
    },
    {
      "key": "geid_71_349",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getCode",
        "label": "calls",
        "line": 44
      }
    },
    {
      "key": "geid_71_350",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::similarTo",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::similarTo",
        "label": "calls",
        "line": 55
      }
    },
    {
      "key": "geid_71_351",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getCodeTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getCodeTool",
        "label": "calls",
        "line": 58
      }
    },
    {
      "key": "geid_71_352",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::similarToTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::similarToTool",
        "label": "calls",
        "line": 58
      }
    },
    {
      "key": "geid_71_353",
      "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
      "target": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
        "target": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
        "label": "calls",
        "line": 58
      }
    },
    {
      "key": "geid_71_354",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getCode",
        "label": "defines",
        "line": 232
      }
    },
    {
      "key": "geid_71_355",
      "source": "\\src\\tools\\function_tools::getCode",
      "target": "\\src\\tools\\function_tools::nodeSeen",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getCode",
        "target": "\\src\\tools\\function_tools::nodeSeen",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_356",
      "source": "\\src\\tools\\function_tools::getCode",
      "target": "\\src\\tools\\function_tools::getCode",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getCode",
        "target": "\\src\\tools\\function_tools::getCode",
        "label": "calls",
        "line": 58
      }
    },
    {
      "key": "geid_71_357",
      "source": "\\src\\tools\\function_tools::getCode",
      "target": "\\src\\tools\\function_tools::similarTo",
      "attributes": {
        "source": "\\src\\tools\\function_tools::getCode",
        "target": "\\src\\tools\\function_tools::similarTo",
        "label": "calls",
        "line": 73
      }
    },
    {
      "key": "geid_71_358",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::nodeSeen",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::nodeSeen",
        "label": "defines",
        "line": 228
      }
    },
    {
      "key": "geid_71_359",
      "source": "\\src\\tools\\function_tools::nodeSeen",
      "target": "\\src\\tools\\function_tools::nodeSeen",
      "attributes": {
        "source": "\\src\\tools\\function_tools::nodeSeen",
        "target": "\\src\\tools\\function_tools::nodeSeen",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_360",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::similarTo",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::similarTo",
        "label": "defines",
        "line": 126
      }
    },
    {
      "key": "geid_71_361",
      "source": "\\src\\tools\\function_tools::similarTo",
      "target": "\\src\\tools\\function_tools::topNSimilar",
      "attributes": {
        "source": "\\src\\tools\\function_tools::similarTo",
        "target": "\\src\\tools\\function_tools::topNSimilar",
        "label": "calls",
        "line": 17
      }
    },
    {
      "key": "geid_71_362",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::topNSimilar",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::topNSimilar",
        "label": "defines",
        "line": 102
      }
    },
    {
      "key": "geid_71_363",
      "source": "\\src\\tools\\function_tools::topNSimilar",
      "target": "\\src\\tools\\function_tools::Similarity",
      "attributes": {
        "source": "\\src\\tools\\function_tools::topNSimilar",
        "target": "\\src\\tools\\function_tools::Similarity",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_364",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getGraphLinksById",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getGraphLinksById",
        "label": "defines",
        "line": 71
      }
    },
    {
      "key": "geid_71_365",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::getGraphNodesById",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::getGraphNodesById",
        "label": "defines",
        "line": 33
      }
    },
    {
      "key": "geid_71_366",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::Similarity",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::Similarity",
        "label": "defines",
        "line": 28
      }
    },
    {
      "key": "geid_71_367",
      "source": "\\src\\tools\\function_tools::Similarity",
      "target": "\\src\\tools\\function_tools::Similarity",
      "attributes": {
        "source": "\\src\\tools\\function_tools::Similarity",
        "target": "\\src\\tools\\function_tools::Similarity",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_368",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::calculateLanguagePercentages",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::calculateLanguagePercentages",
        "label": "defines",
        "line": 7
      }
    },
    {
      "key": "geid_71_369",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::Similarity",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::Similarity",
        "label": "calls",
        "line": 28
      }
    },
    {
      "key": "geid_71_370",
      "source": "\\src\\tools\\function_tools",
      "target": "\\src\\tools\\function_tools::nodeSeen",
      "attributes": {
        "source": "\\src\\tools\\function_tools",
        "target": "\\src\\tools\\function_tools::nodeSeen",
        "label": "calls",
        "line": 228
      }
    },
    {
      "key": "geid_71_371",
      "source": "\\src\\utils\\ai",
      "target": "\\src\\utils\\ai::getOpenAIChatCompletion",
      "attributes": {
        "source": "\\src\\utils\\ai",
        "target": "\\src\\utils\\ai::getOpenAIChatCompletion",
        "label": "defines",
        "line": 12
      }
    },
    {
      "key": "geid_71_372",
      "source": "\\src\\utils\\ai::getOpenAIChatCompletion",
      "target": "\\src\\utils\\ai::chatCompletionMessages",
      "attributes": {
        "source": "\\src\\utils\\ai::getOpenAIChatCompletion",
        "target": "\\src\\utils\\ai::chatCompletionMessages",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_373",
      "source": "\\src\\utils\\ai::getOpenAIChatCompletion",
      "target": "\\src\\utils\\ai::chatResponse",
      "attributes": {
        "source": "\\src\\utils\\ai::getOpenAIChatCompletion",
        "target": "\\src\\utils\\ai::chatResponse",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_374",
      "source": "\\src\\utils\\ai",
      "target": "\\src\\utils\\ai::chatResponse",
      "attributes": {
        "source": "\\src\\utils\\ai",
        "target": "\\src\\utils\\ai::chatResponse",
        "label": "defines",
        "line": 7
      }
    },
    {
      "key": "geid_71_375",
      "source": "\\src\\utils\\ai::chatResponse",
      "target": "\\src\\utils\\ai::chatResponse",
      "attributes": {
        "source": "\\src\\utils\\ai::chatResponse",
        "target": "\\src\\utils\\ai::chatResponse",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_376",
      "source": "\\src\\utils\\ai",
      "target": "\\src\\utils\\ai::chatCompletionMessages",
      "attributes": {
        "source": "\\src\\utils\\ai",
        "target": "\\src\\utils\\ai::chatCompletionMessages",
        "label": "defines",
        "line": 3
      }
    },
    {
      "key": "geid_71_377",
      "source": "\\src\\utils\\ai::chatCompletionMessages",
      "target": "\\src\\utils\\ai::chatCompletionMessages",
      "attributes": {
        "source": "\\src\\utils\\ai::chatCompletionMessages",
        "target": "\\src\\utils\\ai::chatCompletionMessages",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_378",
      "source": "\\src\\utils\\ai",
      "target": "\\src\\utils\\ai::chatResponse",
      "attributes": {
        "source": "\\src\\utils\\ai",
        "target": "\\src\\utils\\ai::chatResponse",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_379",
      "source": "\\src\\utils\\ai",
      "target": "\\src\\utils\\ai::chatCompletionMessages",
      "attributes": {
        "source": "\\src\\utils\\ai",
        "target": "\\src\\utils\\ai::chatCompletionMessages",
        "label": "calls",
        "line": 14
      }
    },
    {
      "key": "geid_71_380",
      "source": "\\src\\utils\\bitbucket\\refresh-token",
      "target": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
      "attributes": {
        "source": "\\src\\utils\\bitbucket\\refresh-token",
        "target": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
        "label": "defines",
        "line": 3
      }
    },
    {
      "key": "geid_71_381",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::getGraphFolderById",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::getGraphFolderById",
        "label": "defines",
        "line": 127
      }
    },
    {
      "key": "geid_71_382",
      "source": "\\src\\utils\\db::getGraphFolderById",
      "target": "\\src\\utils\\db::GraphFolder",
      "attributes": {
        "source": "\\src\\utils\\db::getGraphFolderById",
        "target": "\\src\\utils\\db::GraphFolder",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_383",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::getGraphLinksById",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::getGraphLinksById",
        "label": "defines",
        "line": 95
      }
    },
    {
      "key": "geid_71_384",
      "source": "\\src\\utils\\db::getGraphLinksById",
      "target": "\\src\\utils\\db::GraphLink",
      "attributes": {
        "source": "\\src\\utils\\db::getGraphLinksById",
        "target": "\\src\\utils\\db::GraphLink",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_385",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::getGraphNodesById",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::getGraphNodesById",
        "label": "defines",
        "line": 54
      }
    },
    {
      "key": "geid_71_386",
      "source": "\\src\\utils\\db::getGraphNodesById",
      "target": "\\src\\utils\\db::GraphNode",
      "attributes": {
        "source": "\\src\\utils\\db::getGraphNodesById",
        "target": "\\src\\utils\\db::GraphNode",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_387",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphFolder",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphFolder",
        "label": "defines",
        "line": 48
      }
    },
    {
      "key": "geid_71_388",
      "source": "\\src\\utils\\db::GraphFolder",
      "target": "\\src\\utils\\db::GraphFolder",
      "attributes": {
        "source": "\\src\\utils\\db::GraphFolder",
        "target": "\\src\\utils\\db::GraphFolder",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_389",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphLink",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphLink",
        "label": "defines",
        "line": 40
      }
    },
    {
      "key": "geid_71_390",
      "source": "\\src\\utils\\db::GraphLink",
      "target": "\\src\\utils\\db::GraphLink",
      "attributes": {
        "source": "\\src\\utils\\db::GraphLink",
        "target": "\\src\\utils\\db::GraphLink",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_391",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphNode",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphNode",
        "label": "defines",
        "line": 23
      }
    },
    {
      "key": "geid_71_392",
      "source": "\\src\\utils\\db::GraphNode",
      "target": "\\src\\utils\\db::GraphNode",
      "attributes": {
        "source": "\\src\\utils\\db::GraphNode",
        "target": "\\src\\utils\\db::GraphNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_393",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::sql",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::sql",
        "label": "defines",
        "line": 5
      }
    },
    {
      "key": "geid_71_394",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphLink",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphLink",
        "label": "calls",
        "line": 40
      }
    },
    {
      "key": "geid_71_395",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphFolder",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphFolder",
        "label": "calls",
        "line": 48
      }
    },
    {
      "key": "geid_71_396",
      "source": "\\src\\utils\\db",
      "target": "\\src\\utils\\db::GraphNode",
      "attributes": {
        "source": "\\src\\utils\\db",
        "target": "\\src\\utils\\db::GraphNode",
        "label": "calls",
        "line": 60
      }
    },
    {
      "key": "geid_71_397",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::getAccessToken",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::getAccessToken",
        "label": "defines",
        "line": 205
      }
    },
    {
      "key": "geid_71_398",
      "source": "\\src\\utils\\git::getAccessToken",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git::getAccessToken",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_399",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::getCommitHash",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::getCommitHash",
        "label": "defines",
        "line": 193
      }
    },
    {
      "key": "geid_71_400",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::getCommitRepo",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::getCommitRepo",
        "label": "defines",
        "line": 98
      }
    },
    {
      "key": "geid_71_401",
      "source": "\\src\\utils\\git::getCommitRepo",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git::getCommitRepo",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_402",
      "source": "\\src\\utils\\git::getCommitRepo",
      "target": "\\src\\utils\\git::getCommitHash",
      "attributes": {
        "source": "\\src\\utils\\git::getCommitRepo",
        "target": "\\src\\utils\\git::getCommitHash",
        "label": "calls",
        "line": 88
      }
    },
    {
      "key": "geid_71_403",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::downloadAndExtractRepo",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::downloadAndExtractRepo",
        "label": "defines",
        "line": 14
      }
    },
    {
      "key": "geid_71_404",
      "source": "\\src\\utils\\git::downloadAndExtractRepo",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git::downloadAndExtractRepo",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_405",
      "source": "\\src\\utils\\git::downloadAndExtractRepo",
      "target": "\\src\\utils\\git::MAXSIZE",
      "attributes": {
        "source": "\\src\\utils\\git::downloadAndExtractRepo",
        "target": "\\src\\utils\\git::MAXSIZE",
        "label": "calls",
        "line": 75
      }
    },
    {
      "key": "geid_71_406",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::MAXSIZE",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::MAXSIZE",
        "label": "defines",
        "line": 12
      }
    },
    {
      "key": "geid_71_407",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "defines",
        "line": 10
      }
    },
    {
      "key": "geid_71_408",
      "source": "\\src\\utils\\git::GitServiceType",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git::GitServiceType",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_409",
      "source": "\\src\\utils\\git",
      "target": "\\src\\utils\\git::GitServiceType",
      "attributes": {
        "source": "\\src\\utils\\git",
        "target": "\\src\\utils\\git::GitServiceType",
        "label": "calls",
        "line": 19
      }
    },
    {
      "key": "geid_71_410",
      "source": "\\src\\utils\\gitlab\\refresh-token",
      "target": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
      "attributes": {
        "source": "\\src\\utils\\gitlab\\refresh-token",
        "target": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
        "label": "defines",
        "line": 3
      }
    },
    {
      "key": "geid_71_411",
      "source": "\\src\\utils\\utils",
      "target": "\\src\\utils\\utils::getEnv",
      "attributes": {
        "source": "\\src\\utils\\utils",
        "target": "\\src\\utils\\utils::getEnv",
        "label": "defines",
        "line": 16
      }
    },
    {
      "key": "geid_71_412",
      "source": "\\src\\utils\\utils::getEnv",
      "target": "\\src\\utils\\utils::ENV_VARS",
      "attributes": {
        "source": "\\src\\utils\\utils::getEnv",
        "target": "\\src\\utils\\utils::ENV_VARS",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_413",
      "source": "\\src\\utils\\utils",
      "target": "\\src\\utils\\utils::ENV_VARS",
      "attributes": {
        "source": "\\src\\utils\\utils",
        "target": "\\src\\utils\\utils::ENV_VARS",
        "label": "defines",
        "line": 1
      }
    },
    {
      "key": "geid_71_414",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::documentFolders",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::documentFolders",
        "label": "defines",
        "line": 332
      }
    },
    {
      "key": "geid_71_415",
      "source": "\\src\\wiki\\utils::documentFolders",
      "target": "\\src\\wiki\\utils::getNodesPerType",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentFolders",
        "target": "\\src\\wiki\\utils::getNodesPerType",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_416",
      "source": "\\src\\wiki\\utils::documentFolders",
      "target": "\\src\\wiki\\utils::calculateLanguagePercentages",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentFolders",
        "target": "\\src\\wiki\\utils::calculateLanguagePercentages",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_417",
      "source": "\\src\\wiki\\utils::documentFolders",
      "target": "\\src\\wiki\\utils::getMostUsedNodesPerType",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentFolders",
        "target": "\\src\\wiki\\utils::getMostUsedNodesPerType",
        "label": "calls",
        "line": 38
      }
    },
    {
      "key": "geid_71_418",
      "source": "\\src\\wiki\\utils::documentFolders",
      "target": "\\src\\wiki\\utils::totalTokens",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentFolders",
        "target": "\\src\\wiki\\utils::totalTokens",
        "label": "calls",
        "line": 134
      }
    },
    {
      "key": "geid_71_419",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::documentNodesByLevels",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::documentNodesByLevels",
        "label": "defines",
        "line": 307
      }
    },
    {
      "key": "geid_71_420",
      "source": "\\src\\wiki\\utils::documentNodesByLevels",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentNodesByLevels",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_421",
      "source": "\\src\\wiki\\utils::documentNodesByLevels",
      "target": "\\src\\wiki\\utils::generateNodeDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentNodesByLevels",
        "target": "\\src\\wiki\\utils::generateNodeDocumentation",
        "label": "calls",
        "line": 18
      }
    },
    {
      "key": "geid_71_422",
      "source": "\\src\\wiki\\utils::documentNodesByLevels",
      "target": "\\src\\wiki\\utils::totalTokens",
      "attributes": {
        "source": "\\src\\wiki\\utils::documentNodesByLevels",
        "target": "\\src\\wiki\\utils::totalTokens",
        "label": "calls",
        "line": 23
      }
    },
    {
      "key": "geid_71_423",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::generateNodeDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::generateNodeDocumentation",
        "label": "defines",
        "line": 264
      }
    },
    {
      "key": "geid_71_424",
      "source": "\\src\\wiki\\utils::generateNodeDocumentation",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::generateNodeDocumentation",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_425",
      "source": "\\src\\wiki\\utils::generateNodeDocumentation",
      "target": "\\src\\wiki\\utils::generateNodePrompts",
      "attributes": {
        "source": "\\src\\wiki\\utils::generateNodeDocumentation",
        "target": "\\src\\wiki\\utils::generateNodePrompts",
        "label": "calls",
        "line": 8
      }
    },
    {
      "key": "geid_71_426",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::generateNodePrompts",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::generateNodePrompts",
        "label": "defines",
        "line": 180
      }
    },
    {
      "key": "geid_71_427",
      "source": "\\src\\wiki\\utils::generateNodePrompts",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::generateNodePrompts",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 4
      }
    },
    {
      "key": "geid_71_428",
      "source": "\\src\\wiki\\utils::generateNodePrompts",
      "target": "\\src\\wiki\\utils::findFileParentNode",
      "attributes": {
        "source": "\\src\\wiki\\utils::generateNodePrompts",
        "target": "\\src\\wiki\\utils::findFileParentNode",
        "label": "calls",
        "line": 7
      }
    },
    {
      "key": "geid_71_429",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::bfsLevels",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::bfsLevels",
        "label": "defines",
        "line": 112
      }
    },
    {
      "key": "geid_71_430",
      "source": "\\src\\wiki\\utils::bfsLevels",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::bfsLevels",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_431",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::buildGraphs",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::buildGraphs",
        "label": "defines",
        "line": 90
      }
    },
    {
      "key": "geid_71_432",
      "source": "\\src\\wiki\\utils::buildGraphs",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::buildGraphs",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_433",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::findFileParentNode",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::findFileParentNode",
        "label": "defines",
        "line": 73
      }
    },
    {
      "key": "geid_71_434",
      "source": "\\src\\wiki\\utils::findFileParentNode",
      "target": "\\src\\wiki\\utils::findFileParentNode",
      "attributes": {
        "source": "\\src\\wiki\\utils::findFileParentNode",
        "target": "\\src\\wiki\\utils::findFileParentNode",
        "label": "calls",
        "line": 14
      }
    },
    {
      "key": "geid_71_435",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::getMostUsedNodesPerType",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::getMostUsedNodesPerType",
        "label": "defines",
        "line": 44
      }
    },
    {
      "key": "geid_71_436",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::getNodesPerType",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::getNodesPerType",
        "label": "defines",
        "line": 32
      }
    },
    {
      "key": "geid_71_437",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::calculateLanguagePercentages",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::calculateLanguagePercentages",
        "label": "defines",
        "line": 9
      }
    },
    {
      "key": "geid_71_438",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "defines",
        "line": 7
      }
    },
    {
      "key": "geid_71_439",
      "source": "\\src\\wiki\\utils::Graph",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils::Graph",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_440",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::totalTokens",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::totalTokens",
        "label": "defines",
        "line": 5
      }
    },
    {
      "key": "geid_71_441",
      "source": "\\src\\wiki\\utils",
      "target": "\\src\\wiki\\utils::Graph",
      "attributes": {
        "source": "\\src\\wiki\\utils",
        "target": "\\src\\wiki\\utils::Graph",
        "label": "calls",
        "line": 118
      }
    },
    {
      "key": "geid_71_442",
      "source": "\\src\\wiki\\wiki",
      "target": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wiki",
        "target": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
        "label": "defines",
        "line": 16
      }
    },
    {
      "key": "geid_71_443",
      "source": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
      "target": "\\src\\wiki\\wiki::generateDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
        "target": "\\src\\wiki\\wiki::generateDocumentation",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_444",
      "source": "\\src\\wiki\\wiki",
      "target": "\\src\\wiki\\wiki::generateDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wiki",
        "target": "\\src\\wiki\\wiki::generateDocumentation",
        "label": "defines",
        "line": 5
      }
    },
    {
      "key": "geid_71_445",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::buildWiki",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::buildWiki",
        "label": "defines",
        "line": 601
      }
    },
    {
      "key": "geid_71_446",
      "source": "\\src\\wiki\\wikiGuille::buildWiki",
      "target": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::buildWiki",
        "target": "\\src\\wiki\\wikiGuille::client2",
        "label": "calls",
        "line": 32
      }
    },
    {
      "key": "geid_71_447",
      "source": "\\src\\wiki\\wikiGuille::buildWiki",
      "target": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::buildWiki",
        "target": "\\src\\wiki\\wikiGuille::model",
        "label": "calls",
        "line": 43
      }
    },
    {
      "key": "geid_71_448",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "label": "defines",
        "line": 522
      }
    },
    {
      "key": "geid_71_449",
      "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "target": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "target": "\\src\\wiki\\wikiGuille::client2",
        "label": "calls",
        "line": 25
      }
    },
    {
      "key": "geid_71_450",
      "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "target": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "target": "\\src\\wiki\\wikiGuille::model",
        "label": "calls",
        "line": 36
      }
    },
    {
      "key": "geid_71_451",
      "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "target": "\\src\\wiki\\wikiGuille::temperature",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "target": "\\src\\wiki\\wikiGuille::temperature",
        "label": "calls",
        "line": 37
      }
    },
    {
      "key": "geid_71_452",
      "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "target": "\\src\\wiki\\wikiGuille::max_tokens",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "target": "\\src\\wiki\\wikiGuille::max_tokens",
        "label": "calls",
        "line": 38
      }
    },
    {
      "key": "geid_71_453",
      "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "label": "calls",
        "line": 52
      }
    },
    {
      "key": "geid_71_454",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::documentFolders",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::documentFolders",
        "label": "defines",
        "line": 484
      }
    },
    {
      "key": "geid_71_455",
      "source": "\\src\\wiki\\wikiGuille::documentFolders",
      "target": "\\src\\wiki\\wikiGuille::projectId",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::documentFolders",
        "target": "\\src\\wiki\\wikiGuille::projectId",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_456",
      "source": "\\src\\wiki\\wikiGuille::documentFolders",
      "target": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::documentFolders",
        "target": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
        "label": "calls",
        "line": 31
      }
    },
    {
      "key": "geid_71_457",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "label": "defines",
        "line": 397
      }
    },
    {
      "key": "geid_71_458",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_459",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::client2",
        "label": "calls",
        "line": 33
      }
    },
    {
      "key": "geid_71_460",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::model",
        "label": "calls",
        "line": 44
      }
    },
    {
      "key": "geid_71_461",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::temperature",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::temperature",
        "label": "calls",
        "line": 45
      }
    },
    {
      "key": "geid_71_462",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::max_tokens",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::max_tokens",
        "label": "calls",
        "line": 46
      }
    },
    {
      "key": "geid_71_463",
      "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "label": "calls",
        "line": 60
      }
    },
    {
      "key": "geid_71_464",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
        "label": "defines",
        "line": 363
      }
    },
    {
      "key": "geid_71_465",
      "source": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 3
      }
    },
    {
      "key": "geid_71_466",
      "source": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
      "target": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
        "target": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
        "label": "calls",
        "line": 23
      }
    },
    {
      "key": "geid_71_467",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "label": "defines",
        "line": 255
      }
    },
    {
      "key": "geid_71_468",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_469",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::findFileParent",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::findFileParent",
        "label": "calls",
        "line": 9
      }
    },
    {
      "key": "geid_71_470",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::client2",
        "label": "calls",
        "line": 53
      }
    },
    {
      "key": "geid_71_471",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::model",
        "label": "calls",
        "line": 64
      }
    },
    {
      "key": "geid_71_472",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::temperature",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::temperature",
        "label": "calls",
        "line": 65
      }
    },
    {
      "key": "geid_71_473",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::max_tokens",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::max_tokens",
        "label": "calls",
        "line": 66
      }
    },
    {
      "key": "geid_71_474",
      "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "label": "calls",
        "line": 75
      }
    },
    {
      "key": "geid_71_475",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::bfs",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::bfs",
        "label": "defines",
        "line": 204
      }
    },
    {
      "key": "geid_71_476",
      "source": "\\src\\wiki\\wikiGuille::bfs",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::bfs",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 2
      }
    },
    {
      "key": "geid_71_477",
      "source": "\\src\\wiki\\wikiGuille::bfs",
      "target": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::bfs",
        "target": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
        "label": "calls",
        "line": 30
      }
    },
    {
      "key": "geid_71_478",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::findStartNodes",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::findStartNodes",
        "label": "defines",
        "line": 200
      }
    },
    {
      "key": "geid_71_479",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::buildGraphs",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::buildGraphs",
        "label": "defines",
        "line": 172
      }
    },
    {
      "key": "geid_71_480",
      "source": "\\src\\wiki\\wikiGuille::buildGraphs",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::buildGraphs",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_481",
      "source": "\\src\\wiki\\wikiGuille::buildGraphs",
      "target": "\\src\\wiki\\wikiGuille::wikiLink",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::buildGraphs",
        "target": "\\src\\wiki\\wikiGuille::wikiLink",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_482",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::readJson",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::readJson",
        "label": "defines",
        "line": 158
      }
    },
    {
      "key": "geid_71_483",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::findFileParent",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::findFileParent",
        "label": "defines",
        "line": 147
      }
    },
    {
      "key": "geid_71_484",
      "source": "\\src\\wiki\\wikiGuille::findFileParent",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::findFileParent",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_485",
      "source": "\\src\\wiki\\wikiGuille::findFileParent",
      "target": "\\src\\wiki\\wikiGuille::findFileParent",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::findFileParent",
        "target": "\\src\\wiki\\wikiGuille::findFileParent",
        "label": "calls",
        "line": 6
      }
    },
    {
      "key": "geid_71_486",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::tokenizer",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::tokenizer",
        "label": "defines",
        "line": 80
      }
    },
    {
      "key": "geid_71_487",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "label": "defines",
        "line": 66
      }
    },
    {
      "key": "geid_71_488",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::totalTokensUsed",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::totalTokensUsed",
        "label": "defines",
        "line": 63
      }
    },
    {
      "key": "geid_71_489",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::linksPath",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::linksPath",
        "label": "defines",
        "line": 61
      }
    },
    {
      "key": "geid_71_490",
      "source": "\\src\\wiki\\wikiGuille::linksPath",
      "target": "\\src\\wiki\\wikiGuille::folder_path",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::linksPath",
        "target": "\\src\\wiki\\wikiGuille::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_491",
      "source": "\\src\\wiki\\wikiGuille::linksPath",
      "target": "\\src\\wiki\\wikiGuille::projectId",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::linksPath",
        "target": "\\src\\wiki\\wikiGuille::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_492",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::nodesPath",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::nodesPath",
        "label": "defines",
        "line": 60
      }
    },
    {
      "key": "geid_71_493",
      "source": "\\src\\wiki\\wikiGuille::nodesPath",
      "target": "\\src\\wiki\\wikiGuille::folder_path",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::nodesPath",
        "target": "\\src\\wiki\\wikiGuille::folder_path",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_494",
      "source": "\\src\\wiki\\wikiGuille::nodesPath",
      "target": "\\src\\wiki\\wikiGuille::projectId",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::nodesPath",
        "target": "\\src\\wiki\\wikiGuille::projectId",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_495",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::folder_path",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::folder_path",
        "label": "defines",
        "line": 58
      }
    },
    {
      "key": "geid_71_496",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::projectId",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::projectId",
        "label": "defines",
        "line": 57
      }
    },
    {
      "key": "geid_71_497",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::onlyLogs",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::onlyLogs",
        "label": "defines",
        "line": 52
      }
    },
    {
      "key": "geid_71_498",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::response_format",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::response_format",
        "label": "defines",
        "line": 50
      }
    },
    {
      "key": "geid_71_499",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::max_tokens",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::max_tokens",
        "label": "defines",
        "line": 49
      }
    },
    {
      "key": "geid_71_500",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::temperature",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::temperature",
        "label": "defines",
        "line": 48
      }
    },
    {
      "key": "geid_71_501",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::model",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::model",
        "label": "defines",
        "line": 47
      }
    },
    {
      "key": "geid_71_502",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::client2",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::client2",
        "label": "defines",
        "line": 40
      }
    },
    {
      "key": "geid_71_503",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::wikiLink",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::wikiLink",
        "label": "defines",
        "line": 34
      }
    },
    {
      "key": "geid_71_504",
      "source": "\\src\\wiki\\wikiGuille::wikiLink",
      "target": "\\src\\wiki\\wikiGuille::wikiLink",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::wikiLink",
        "target": "\\src\\wiki\\wikiGuille::wikiLink",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_505",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "defines",
        "line": 17
      }
    },
    {
      "key": "geid_71_506",
      "source": "\\src\\wiki\\wikiGuille::wikiNode",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille::wikiNode",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 1
      }
    },
    {
      "key": "geid_71_507",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::wikiNode",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::wikiNode",
        "label": "calls",
        "line": 119
      }
    },
    {
      "key": "geid_71_508",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::readJson",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::readJson",
        "label": "calls",
        "line": 119
      }
    },
    {
      "key": "geid_71_509",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::nodesPath",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::nodesPath",
        "label": "calls",
        "line": 119
      }
    },
    {
      "key": "geid_71_510",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::wikiLink",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::wikiLink",
        "label": "calls",
        "line": 123
      }
    },
    {
      "key": "geid_71_511",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::linksPath",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::linksPath",
        "label": "calls",
        "line": 123
      }
    },
    {
      "key": "geid_71_512",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::buildGraphs",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::buildGraphs",
        "label": "calls",
        "line": 124
      }
    },
    {
      "key": "geid_71_513",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::findStartNodes",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::findStartNodes",
        "label": "calls",
        "line": 129
      }
    },
    {
      "key": "geid_71_514",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::bfs",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::bfs",
        "label": "calls",
        "line": 134
      }
    },
    {
      "key": "geid_71_515",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
        "label": "calls",
        "line": 144
      }
    },
    {
      "key": "geid_71_516",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::documentFolders",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::documentFolders",
        "label": "calls",
        "line": 154
      }
    },
    {
      "key": "geid_71_517",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::buildWiki",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::buildWiki",
        "label": "calls",
        "line": 160
      }
    },
    {
      "key": "geid_71_518",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::totalTokensUsed",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::totalTokensUsed",
        "label": "calls",
        "line": 162
      }
    },
    {
      "key": "geid_71_519",
      "source": "\\src\\wiki\\wikiGuille",
      "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
      "attributes": {
        "source": "\\src\\wiki\\wikiGuille",
        "target": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
        "label": "calls",
        "line": 164
      }
    },
    {
      "key": "geid_71_520",
      "source": "\\tests\\c.test",
      "target": "\\tests\\c.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\c.test",
        "target": "\\tests\\c.test::nodeAttributes",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_521",
      "source": "\\tests\\c.test",
      "target": "\\tests\\c.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\c.test",
        "target": "\\tests\\c.test::rootFolderPath",
        "label": "defines",
        "line": 2
      }
    },
    {
      "key": "geid_71_522",
      "source": "\\tests\\c.test",
      "target": "\\tests\\c.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\c.test",
        "target": "\\tests\\c.test::rootFolderPath",
        "label": "calls",
        "line": 17
      }
    },
    {
      "key": "geid_71_523",
      "source": "\\tests\\c.test",
      "target": "\\tests\\c.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\c.test",
        "target": "\\tests\\c.test::nodeAttributes",
        "label": "calls",
        "line": 83
      }
    },
    {
      "key": "geid_71_524",
      "source": "\\tests\\java.test",
      "target": "\\tests\\java.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\java.test",
        "target": "\\tests\\java.test::nodeAttributes",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_525",
      "source": "\\tests\\java.test",
      "target": "\\tests\\java.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\java.test",
        "target": "\\tests\\java.test::rootFolderPath",
        "label": "defines",
        "line": 2
      }
    },
    {
      "key": "geid_71_526",
      "source": "\\tests\\java.test",
      "target": "\\tests\\java.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\java.test",
        "target": "\\tests\\java.test::rootFolderPath",
        "label": "calls",
        "line": 17
      }
    },
    {
      "key": "geid_71_527",
      "source": "\\tests\\java.test",
      "target": "\\tests\\java.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\java.test",
        "target": "\\tests\\java.test::nodeAttributes",
        "label": "calls",
        "line": 67
      }
    },
    {
      "key": "geid_71_528",
      "source": "\\tests\\javascript.test",
      "target": "\\tests\\javascript.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\javascript.test",
        "target": "\\tests\\javascript.test::nodeAttributes",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_529",
      "source": "\\tests\\javascript.test",
      "target": "\\tests\\javascript.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\javascript.test",
        "target": "\\tests\\javascript.test::rootFolderPath",
        "label": "defines",
        "line": 2
      }
    },
    {
      "key": "geid_71_530",
      "source": "\\tests\\javascript.test",
      "target": "\\tests\\javascript.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\javascript.test",
        "target": "\\tests\\javascript.test::rootFolderPath",
        "label": "calls",
        "line": 19
      }
    },
    {
      "key": "geid_71_531",
      "source": "\\tests\\javascript.test",
      "target": "\\tests\\javascript.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\javascript.test",
        "target": "\\tests\\javascript.test::nodeAttributes",
        "label": "calls",
        "line": 56
      }
    },
    {
      "key": "geid_71_532",
      "source": "\\tests\\php.test",
      "target": "\\tests\\php.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\php.test",
        "target": "\\tests\\php.test::nodeAttributes",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_533",
      "source": "\\tests\\php.test",
      "target": "\\tests\\php.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\php.test",
        "target": "\\tests\\php.test::rootFolderPath",
        "label": "defines",
        "line": 2
      }
    },
    {
      "key": "geid_71_534",
      "source": "\\tests\\php.test",
      "target": "\\tests\\php.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\php.test",
        "target": "\\tests\\php.test::rootFolderPath",
        "label": "calls",
        "line": 20
      }
    },
    {
      "key": "geid_71_535",
      "source": "\\tests\\php.test",
      "target": "\\tests\\php.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\php.test",
        "target": "\\tests\\php.test::nodeAttributes",
        "label": "calls",
        "line": 82
      }
    },
    {
      "key": "geid_71_536",
      "source": "\\tests\\python.test",
      "target": "\\tests\\python.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\python.test",
        "target": "\\tests\\python.test::nodeAttributes",
        "label": "defines",
        "line": 4
      }
    },
    {
      "key": "geid_71_537",
      "source": "\\tests\\python.test",
      "target": "\\tests\\python.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\python.test",
        "target": "\\tests\\python.test::rootFolderPath",
        "label": "defines",
        "line": 2
      }
    },
    {
      "key": "geid_71_538",
      "source": "\\tests\\python.test",
      "target": "\\tests\\python.test::rootFolderPath",
      "attributes": {
        "source": "\\tests\\python.test",
        "target": "\\tests\\python.test::rootFolderPath",
        "label": "calls",
        "line": 17
      }
    },
    {
      "key": "geid_71_539",
      "source": "\\tests\\python.test",
      "target": "\\tests\\python.test::nodeAttributes",
      "attributes": {
        "source": "\\tests\\python.test",
        "target": "\\tests\\python.test::nodeAttributes",
        "label": "calls",
        "line": 45
      }
    }
  ]
}