[
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/graph_to_csv::graph_to_csv",
    "language": "python",
    "label": "graph_to_csv",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/graph_to_csv",
    "totalTokens": 71,
    "inDegree": 1,
    "outDegree": 1,
    "code": "def graph_to_csv(name='codebase'):\n\n    nodes = pd.read_json('nodes.json')\n    nodes['full_name'] = nodes['id']\n    edges = pd.read_json('links.json')\n\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\n    edges.to_csv(f'edges_{name}.csv', index=False)",
    "importStatements": [],
    "codeNoBody": "def graph_to_csv(name='codebase'):\n    ..."
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/graph_to_csv",
    "language": "python",
    "label": "graph_to_csv.py",
    "type": "file",
    "totalTokens": 111,
    "inDegree": 1,
    "outDegree": 1,
    "code": "import sys\nimport pandas as pd\n\ndef graph_to_csv(name='codebase'):\n\n    nodes = pd.read_json('nodes.json')\n    nodes['full_name'] = nodes['id']\n    edges = pd.read_json('links.json')\n\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\n    edges.to_csv(f'edges_{name}.csv', index=False)\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        name = sys.argv[1]\n\n    graph_to_csv(name)",
    "importStatements": [
      "import sys",
      "import pandas as pd"
    ],
    "codeNoBody": "import sys\nimport pandas as pd\ndef graph_to_csv(name='codebase'):\n\n    ...\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        name = sys.argv[1]\n\n    graph_to_csv(name)"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/jest.config",
    "language": "typescript",
    "label": "jest.config.js",
    "type": "file",
    "totalTokens": 45,
    "inDegree": 0,
    "outDegree": 0,
    "code": "module.exports = {\n    preset: 'ts-jest',\n    testEnvironment: 'node',\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  };\n  ",
    "importStatements": [],
    "codeNoBody": "module.exports = {\n    preset: 'ts-jest',\n    testEnvironment: 'node',\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  };{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/index::port",
    "language": "typescript",
    "label": "port",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/index",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "port = 8001",
    "importStatements": [],
    "codeNoBody": "port ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/index::app",
    "language": "typescript",
    "label": "app",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/index",
    "totalTokens": 329,
    "inDegree": 0,
    "outDegree": 10,
    "code": "app = new Hono()\napp.use('*', prettyJSON())\napp.use('/v1/*', cors())\napp.get('/', async (c) => {\n  console.time('codebase')\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\n  const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts'\n  const codebase = new Codebase(codebasePath) //\n  console.log(`Parsing ${codebasePath}`)\n  const fileNodesMap = await codebase.parseFolder()\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`)\n  console.log('Getting Calls')\n  codebase.getCalls(fileNodesMap, false)\n  console.timeEnd('codebase')\n  const codebaseSimplified = codebase.simplify(['id', 'label', 'type', 'parent', 'totalTokens', 'inDegree', 'outDegree', 'importStatements', 'code', 'codeNoBody']) //.filter(c => !['file'].includes(c.type))\n  const links = codebase.getLinks()\n\n  // console.log(codebaseSimplified)\n  fs.writeFileSync('nodes.json', JSON.stringify(codebaseSimplified, null, 2));\n  fs.writeFileSync('links.json', JSON.stringify(links, null, 2));\n  return c.text(JSON.stringify(codebaseSimplified, null, 2))\n  \n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\n})\napp.route('/v1/repo', createGraph)\napp.route('/v1/graphs', graphs)\napp.route('v1/repo-test', createGraphTest)",
    "importStatements": [],
    "codeNoBody": "app = \napp.use('*', prettyJSON())\napp.use('/v1/*', cors())\napp.get('/', async (c) => {\n  console.time('codebase')\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\n  const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts'\n  const codebase = new Codebase(codebasePath) //\n  console.log(`Parsing ${codebasePath}`)\n  const fileNodesMap = await codebase.parseFolder()\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`)\n  console.log('Getting Calls')\n  codebase.getCalls(fileNodesMap, false)\n  console.timeEnd('codebase')\n  const codebaseSimplified = codebase.simplify(['id', 'label', 'type', 'parent', 'totalTokens', 'inDegree', 'outDegree', 'importStatements', 'code', 'codeNoBody']) //.filter(c => !['file'].includes(c.type))\n  const links = codebase.getLinks()\n  // console.log(codebaseSimplified)\n  fs.writeFileSync('nodes.json', JSON.stringify(codebaseSimplified, null, 2));\n  fs.writeFileSync('links.json', JSON.stringify(links, null, 2));\n  return c.text(JSON.stringify(codebaseSimplified, null, 2))\n  \n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\n})\napp.route('/v1/repo', createGraph)\napp.route('/v1/graphs', graphs)\napp.route('v1/repo-test', createGraphTest){\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/index::fs",
    "language": "typescript",
    "label": "fs",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/index",
    "totalTokens": 6,
    "inDegree": 2,
    "outDegree": 1,
    "code": "fs = require('fs')",
    "importStatements": [],
    "codeNoBody": "fs ={\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/index",
    "language": "typescript",
    "label": "index.ts",
    "type": "file",
    "totalTokens": 468,
    "inDegree": 3,
    "outDegree": 9,
    "code": "import { serve } from '@hono/node-server'\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { prettyJSON } from 'hono/pretty-json'\nimport { createGraph } from './routes/create_graph'\nimport { createGraphTest } from './routes/create_graph-test'\nimport { graphs } from './routes/graphs'\nvar fs = require('fs');\nimport { Codebase } from './model/codebase'\nimport path from 'node:path'\n\n\n// const\nconst app = new Hono()\n\napp.use('*', prettyJSON())\napp.use('/v1/*', cors())\n\napp.get('/', async (c) => {\n  console.time('codebase')\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\n  const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts'\n  const codebase = new Codebase(codebasePath) //\n  console.log(`Parsing ${codebasePath}`)\n  const fileNodesMap = await codebase.parseFolder()\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`)\n  console.log('Getting Calls')\n  codebase.getCalls(fileNodesMap, false)\n  console.timeEnd('codebase')\n  const codebaseSimplified = codebase.simplify(['id', 'label', 'type', 'parent', 'totalTokens', 'inDegree', 'outDegree', 'importStatements', 'code', 'codeNoBody']) //.filter(c => !['file'].includes(c.type))\n  const links = codebase.getLinks()\n\n  // console.log(codebaseSimplified)\n  fs.writeFileSync('nodes.json', JSON.stringify(codebaseSimplified, null, 2));\n  fs.writeFileSync('links.json', JSON.stringify(links, null, 2));\n  return c.text(JSON.stringify(codebaseSimplified, null, 2))\n  \n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\n})\n\napp.route('/v1/repo', createGraph)\napp.route('/v1/graphs', graphs)\napp.route('v1/repo-test', createGraphTest)\n\nconst port = 8001\nconsole.log(`Server is running on port ${port}`)\n\nserve({\n  fetch: app.fetch,\n  port\n})\n",
    "importStatements": [
      "import { serve } from '@hono/node-server'",
      "import { Hono } from 'hono'",
      "import { cors } from 'hono/cors'",
      "import { prettyJSON } from 'hono/pretty-json'",
      "import { createGraph } from './routes/create_graph'",
      "import { createGraphTest } from './routes/create_graph-test'",
      "import { graphs } from './routes/graphs'",
      "import { Codebase } from './model/codebase'",
      "import path from 'node:path'"
    ],
    "codeNoBody": "import { serve } from '@hono/node-server'\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { prettyJSON } from 'hono/pretty-json'\nimport { createGraph } from './routes/create_graph'\nimport { createGraphTest } from './routes/create_graph-test'\nimport { graphs } from './routes/graphs'\nvar fs = require('fs');\nimport { Codebase } from './model/codebase'\nimport path from 'node:path'\n// const\nconst app = new Hono()\n\napp.use('*', prettyJSON())\napp.use('/v1/*', cors())\n\napp.get('/', async (c) => {\n  console.time('codebase')\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\n  const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts'\n  const codebase = new Codebase(codebasePath) //\n  console.log(`Parsing ${codebasePath}`)\n  const fileNodesMap = await codebase.parseFolder()\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`)\n  console.log('Getting Calls')\n  codebase.getCalls(fileNodesMap, false)\n  console.timeEnd('codebase')\n  const codebaseSimplified = codebase.simplify(['id', 'label', 'type', 'parent', 'totalTokens', 'inDegree', 'outDegree', 'importStatements', 'code', 'codeNoBody']) //.filter(c => !['file'].includes(c.type))\n  const links = codebase.getLinks()\n\n  // console.log(codebaseSimplified)\n  fs.writeFileSync('nodes.json', JSON.stringify(codebaseSimplified, null, 2));\n  fs.writeFileSync('links.json', JSON.stringify(links, null, 2));\n  return c.text(JSON.stringify(codebaseSimplified, null, 2))\n  \n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\n})\n\napp.route('/v1/repo', createGraph)\napp.route('/v1/graphs', graphs)\napp.route('v1/repo-test', createGraphTest)\n\nconst port = 8001\nconsole.log(`Server is running on port ${port}`)\n\nserve({\n  fetch: app.fetch,\n  port\n})"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer.getCallsFromNode",
    "language": "typescript",
    "label": "CallsCapturer.getCallsFromNode",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer",
    "totalTokens": 624,
    "inDegree": 1,
    "outDegree": 7,
    "code": "class CallsCapturer\n    ...\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\n        // console.log(`///${node.name}///`)\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody() : node.code\n        const nameAliasReplacements: { [key: string]: string }  = {}\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\n            if (i.names.length === 0) nameAliasReplacements[i.moduleAlias] = i.module\n            for (const importName of i.names) nameAliasReplacements[importName.alias] = `${importName.name}`\n        })\n        // Replace itself calls by the parent if its a method\n        if (node.type === 'method') {\n            const itself = itselfClassMap[node.language]\n            const parentName = node.parent?.name || itself\n            nameAliasReplacements[itself] = parentName\n            // this solves a bug\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\n        }\n\n        // 1. Replace import names with aliases\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\n            const leftPattern = new RegExp(`\\\\b${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            code = code.replace(leftPattern, v);\n        });\n\n        // 2. Get Assignments\n        const varReplacements = this.captureAssignments(code, node.language)\n        const codeLines = code.split('\\n')\n        const lenCodeLines = codeLines.length\n\n        // 3. Replace variable Assignments\n        varReplacements.forEach(v  =>  {\n            const startLine = v.startLine\n            const endLine  = v.endLine\n            const leftPattern = new RegExp(`(?<!\\\\.)\\\\b${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            let i = 0\n            try {\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\n                    codeLines[i] = codeLines[i].replace(leftPattern, v.right)\n                }\n            } catch (error: any) {\n                if (this.verbose) {\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\n                }\n            }\n\n        })\n        code = codeLines.join('\\n')\n        const capturedCalls = this.captureCalls(code, node)\n        const results: {[key: string]: number[]} = {}\n        capturedCalls.forEach(c  =>  {\n\n            if (!Object.keys(results).includes(c.nodeId)) {\n                results[c.nodeId] = []\n            } \n            results[c.nodeId].push(c.line)\n        })\n        return results\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]}{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer.captureCalls",
    "language": "typescript",
    "label": "CallsCapturer.captureCalls",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer",
    "totalTokens": 406,
    "inDegree": 1,
    "outDegree": 6,
    "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\n        const results: CallIdentifier[]  = []\n        const nodesSeen: Set<string> = new Set()\n\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            const endLine =  c.node.endPosition.row\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            if (nodesSeen.has(nodeIdenfier)) return\n            nodesSeen.add(nodeIdenfier)\n            // console.log(c.name, content)\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\n                for ( const c of cleanAndSplitContent(content)) {\n                    let callName = c.replace(/\\?/g, '')\n                    const calledNode = this.nodesMap[callName]\n                    if (calledNode) {\n                        results.push(new CallIdentifier(calledNode.id, startLine))\n                    }\n                    if (callName.includes('.')) {\n                        const callNameSplit = callName.split('.')\n                        for ( let i = 2; i < callNameSplit.length; i++) {\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\n                            if (calledNode) {\n                                results.push(new CallIdentifier(calledNode.id, startLine))\n                            }\n                            \n                        }\n                    }\n                    \n                }\n            }\n        })\n        return results\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer.captureAssignments",
    "language": "typescript",
    "label": "CallsCapturer.captureAssignments",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer",
    "totalTokens": 424,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        const captures = captureQuery(language, 'assignments', code)\n        const results: { [key: string]: VariableAssignment[] } = {}\n        let varAssignment = new VariableAssignment()\n        let varAssignmentIdentifier = ''\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            switch (c.name) {\n                case 'assignment':\n                    varAssignment = new VariableAssignment()\n                    varAssignment.startLine = startLine\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\n                    break\n                case 'left':\n                    varAssignmentIdentifier = content\n                    varAssignment.left = varAssignmentIdentifier\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\n                        results[content].slice(-1)[0].endLine = startLine - 1\n                    }\n                    break\n                case 'right':\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\n                    // Remove parentheses and their contents\n                    content = content.replace(/\\(.*?\\)/gs, '');\n                    // Replace newlines and double spaces\n                    \n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\n                    // Check for any quotation marks, brackets, or braces\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\n                        break\n                    }\n                    varAssignment.right = content\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \n                    results[varAssignmentIdentifier].push(varAssignment)\n                    break\n            }\n        })\n        const resultsArray: VariableAssignment[] = []\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\n        // sort resultsArray by startLine in reverse\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\n        return resultsArray\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[]{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer.constructor",
    "language": "typescript",
    "label": "CallsCapturer.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer",
    "totalTokens": 115,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\n        this.fileNode = fileNode\n        this.verbose = verbose\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\n        fileNode.importStatements.forEach( i => {\n            i.names.forEach(n => {\n                if (n.node) {\n                    this.nodesMap[n.alias] = n.node\n                }\n            })\n        })\n        // console.log(`/////${fileNode.id}`)\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallsCapturer",
    "language": "typescript",
    "label": "CallsCapturer",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls",
    "totalTokens": 1605,
    "inDegree": 10,
    "outDegree": 5,
    "code": "class CallsCapturer {\n    fileNode: Node\n    verbose: boolean = true\n    nodesMap: {[key: string]: Node} = {}\n\n    constructor(fileNode: Node, verbose: boolean = false) {\n        this.fileNode = fileNode\n        this.verbose = verbose\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\n        fileNode.importStatements.forEach( i => {\n            i.names.forEach(n => {\n                if (n.node) {\n                    this.nodesMap[n.alias] = n.node\n                }\n            })\n        })\n        // console.log(`/////${fileNode.id}`)\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\n    }\n\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        const captures = captureQuery(language, 'assignments', code)\n        const results: { [key: string]: VariableAssignment[] } = {}\n        let varAssignment = new VariableAssignment()\n        let varAssignmentIdentifier = ''\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            switch (c.name) {\n                case 'assignment':\n                    varAssignment = new VariableAssignment()\n                    varAssignment.startLine = startLine\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\n                    break\n                case 'left':\n                    varAssignmentIdentifier = content\n                    varAssignment.left = varAssignmentIdentifier\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\n                        results[content].slice(-1)[0].endLine = startLine - 1\n                    }\n                    break\n                case 'right':\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\n                    // Remove parentheses and their contents\n                    content = content.replace(/\\(.*?\\)/gs, '');\n                    // Replace newlines and double spaces\n                    \n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\n                    // Check for any quotation marks, brackets, or braces\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\n                        break\n                    }\n                    varAssignment.right = content\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \n                    results[varAssignmentIdentifier].push(varAssignment)\n                    break\n            }\n        })\n        const resultsArray: VariableAssignment[] = []\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\n        // sort resultsArray by startLine in reverse\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\n        return resultsArray\n    }\n\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\n        const results: CallIdentifier[]  = []\n        const nodesSeen: Set<string> = new Set()\n\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            const endLine =  c.node.endPosition.row\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            if (nodesSeen.has(nodeIdenfier)) return\n            nodesSeen.add(nodeIdenfier)\n            // console.log(c.name, content)\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\n                for ( const c of cleanAndSplitContent(content)) {\n                    let callName = c.replace(/\\?/g, '')\n                    const calledNode = this.nodesMap[callName]\n                    if (calledNode) {\n                        results.push(new CallIdentifier(calledNode.id, startLine))\n                    }\n                    if (callName.includes('.')) {\n                        const callNameSplit = callName.split('.')\n                        for ( let i = 2; i < callNameSplit.length; i++) {\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\n                            if (calledNode) {\n                                results.push(new CallIdentifier(calledNode.id, startLine))\n                            }\n                            \n                        }\n                    }\n                    \n                }\n            }\n        })\n        return results\n    }\n\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\n        // console.log(`///${node.name}///`)\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody() : node.code\n        const nameAliasReplacements: { [key: string]: string }  = {}\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\n            if (i.names.length === 0) nameAliasReplacements[i.moduleAlias] = i.module\n            for (const importName of i.names) nameAliasReplacements[importName.alias] = `${importName.name}`\n        })\n        // Replace itself calls by the parent if its a method\n        if (node.type === 'method') {\n            const itself = itselfClassMap[node.language]\n            const parentName = node.parent?.name || itself\n            nameAliasReplacements[itself] = parentName\n            // this solves a bug\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\n        }\n\n        // 1. Replace import names with aliases\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\n            const leftPattern = new RegExp(`\\\\b${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            code = code.replace(leftPattern, v);\n        });\n\n        // 2. Get Assignments\n        const varReplacements = this.captureAssignments(code, node.language)\n        const codeLines = code.split('\\n')\n        const lenCodeLines = codeLines.length\n\n        // 3. Replace variable Assignments\n        varReplacements.forEach(v  =>  {\n            const startLine = v.startLine\n            const endLine  = v.endLine\n            const leftPattern = new RegExp(`(?<!\\\\.)\\\\b${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            let i = 0\n            try {\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\n                    codeLines[i] = codeLines[i].replace(leftPattern, v.right)\n                }\n            } catch (error: any) {\n                if (this.verbose) {\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\n                }\n            }\n\n        })\n        code = codeLines.join('\\n')\n        const capturedCalls = this.captureCalls(code, node)\n        const results: {[key: string]: number[]} = {}\n        capturedCalls.forEach(c  =>  {\n\n            if (!Object.keys(results).includes(c.nodeId)) {\n                results[c.nodeId] = []\n            } \n            results[c.nodeId].push(c.line)\n        })\n        return results\n    }\n}",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer {\n    fileNode: Node\n    verbose: boolean = true\n    nodesMap: {[key: string]: Node} = {}\n    constructor(fileNode: Node, verbose: boolean = false) {\n        this.fileNode = fileNode\n        this.verbose = verbose\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\n        fileNode.importStatements.forEach( i => {\n            i.names.forEach(n => {\n                if (n.node) {\n                    this.nodesMap[n.alias] = n.node\n                }\n            })\n        })\n        // console.log(`/////${fileNode.id}`)\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\n    }\n\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\n\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\n\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\n        //...\n    }\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallIdentifier.constructor",
    "language": "typescript",
    "label": "CallIdentifier.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallIdentifier",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\n        this.nodeId = nodeId\n        this.line = line\n    }",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::CallIdentifier",
    "language": "typescript",
    "label": "CallIdentifier",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls",
    "totalTokens": 45,
    "inDegree": 6,
    "outDegree": 2,
    "code": "class CallIdentifier {\n    nodeId: string\n    line: number = 0\n\n    constructor(nodeId: string, line: number) {\n        this.nodeId = nodeId\n        this.line = line\n    }\n}",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier {\n    nodeId: string\n    line: number = 0\n    constructor(nodeId: string, line: number) {\n        this.nodeId = nodeId\n        this.line = line\n    }\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls::VariableAssignment",
    "language": "typescript",
    "label": "VariableAssignment",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls",
    "totalTokens": 36,
    "inDegree": 4,
    "outDegree": 2,
    "code": "class VariableAssignment {\n    left: string = ''\n    right: string = ''\n    startLine: number = 0\n    endLine: number = 99999\n}",
    "importStatements": [],
    "codeNoBody": "class VariableAssignment{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/calls",
    "language": "typescript",
    "label": "calls.ts",
    "type": "file",
    "totalTokens": 1723,
    "inDegree": 3,
    "outDegree": 3,
    "code": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\nimport { Node, ImportStatement} from \"./codebase\"\nimport { itselfClassMap } from \"./consts\"\n\nclass VariableAssignment {\n    left: string = ''\n    right: string = ''\n    startLine: number = 0\n    endLine: number = 99999\n}\n\nclass CallIdentifier {\n    nodeId: string\n    line: number = 0\n\n    constructor(nodeId: string, line: number) {\n        this.nodeId = nodeId\n        this.line = line\n    }\n}\n\nexport class CallsCapturer {\n    fileNode: Node\n    verbose: boolean = true\n    nodesMap: {[key: string]: Node} = {}\n\n    constructor(fileNode: Node, verbose: boolean = false) {\n        this.fileNode = fileNode\n        this.verbose = verbose\n        fileNode.getAllChildren().forEach( c => this.nodesMap[c.alias] = c )\n        fileNode.importStatements.forEach( i => {\n            i.names.forEach(n => {\n                if (n.node) {\n                    this.nodesMap[n.alias] = n.node\n                }\n            })\n        })\n        // console.log(`/////${fileNode.id}`)\n        // Object.keys(this.nodesMap).forEach(k => console.log(k))\n    }\n\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        const captures = captureQuery(language, 'assignments', code)\n        const results: { [key: string]: VariableAssignment[] } = {}\n        let varAssignment = new VariableAssignment()\n        let varAssignmentIdentifier = ''\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            switch (c.name) {\n                case 'assignment':\n                    varAssignment = new VariableAssignment()\n                    varAssignment.startLine = startLine\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\n                    break\n                case 'left':\n                    varAssignmentIdentifier = content\n                    varAssignment.left = varAssignmentIdentifier\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\n                        results[content].slice(-1)[0].endLine = startLine - 1\n                    }\n                    break\n                case 'right':\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\n                    // Remove parentheses and their contents\n                    content = content.replace(/\\(.*?\\)/gs, '');\n                    // Replace newlines and double spaces\n                    \n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\n                    // Check for any quotation marks, brackets, or braces\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\n                        break\n                    }\n                    varAssignment.right = content\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \n                    results[varAssignmentIdentifier].push(varAssignment)\n                    break\n            }\n        })\n        const resultsArray: VariableAssignment[] = []\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\n        // sort resultsArray by startLine in reverse\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\n        return resultsArray\n    }\n\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\n        const results: CallIdentifier[]  = []\n        const nodesSeen: Set<string> = new Set()\n\n        captures.forEach(c => {\n            let content = c.node.text\n            const startLine = c.node.startPosition.row\n            const endLine =  c.node.endPosition.row\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\n            if (nodesSeen.has(nodeIdenfier)) return\n            nodesSeen.add(nodeIdenfier)\n            // console.log(c.name, content)\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\n                for ( const c of cleanAndSplitContent(content)) {\n                    let callName = c.replace(/\\?/g, '')\n                    const calledNode = this.nodesMap[callName]\n                    if (calledNode) {\n                        results.push(new CallIdentifier(calledNode.id, startLine))\n                    }\n                    if (callName.includes('.')) {\n                        const callNameSplit = callName.split('.')\n                        for ( let i = 2; i < callNameSplit.length; i++) {\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\n                            if (calledNode) {\n                                results.push(new CallIdentifier(calledNode.id, startLine))\n                            }\n                            \n                        }\n                    }\n                    \n                }\n            }\n        })\n        return results\n    }\n\n    getCallsFromNode(fileId: string, node: Node) : {[key: string]: number[]} {\n        // console.log(`///${node.name}///`)\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody() : node.code\n        const nameAliasReplacements: { [key: string]: string }  = {}\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\n            if (i.names.length === 0) nameAliasReplacements[i.moduleAlias] = i.module\n            for (const importName of i.names) nameAliasReplacements[importName.alias] = `${importName.name}`\n        })\n        // Replace itself calls by the parent if its a method\n        if (node.type === 'method') {\n            const itself = itselfClassMap[node.language]\n            const parentName = node.parent?.name || itself\n            nameAliasReplacements[itself] = parentName\n            // this solves a bug\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\n        }\n\n        // 1. Replace import names with aliases\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\n            const leftPattern = new RegExp(`\\\\b${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            code = code.replace(leftPattern, v);\n        });\n\n        // 2. Get Assignments\n        const varReplacements = this.captureAssignments(code, node.language)\n        const codeLines = code.split('\\n')\n        const lenCodeLines = codeLines.length\n\n        // 3. Replace variable Assignments\n        varReplacements.forEach(v  =>  {\n            const startLine = v.startLine\n            const endLine  = v.endLine\n            const leftPattern = new RegExp(`(?<!\\\\.)\\\\b${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\n            let i = 0\n            try {\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\n                    codeLines[i] = codeLines[i].replace(leftPattern, v.right)\n                }\n            } catch (error: any) {\n                if (this.verbose) {\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\n                }\n            }\n\n        })\n        code = codeLines.join('\\n')\n        const capturedCalls = this.captureCalls(code, node)\n        const results: {[key: string]: number[]} = {}\n        capturedCalls.forEach(c  =>  {\n\n            if (!Object.keys(results).includes(c.nodeId)) {\n                results[c.nodeId] = []\n            } \n            results[c.nodeId].push(c.line)\n        })\n        return results\n    }\n}",
    "importStatements": [
      "import { cleanAndSplitContent, captureQuery } from \"./utils\"",
      "import { Node, ImportStatement} from \"./codebase\"",
      "import { itselfClassMap } from \"./consts\""
    ],
    "codeNoBody": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\nimport { Node, ImportStatement} from \"./codebase\"\nimport { itselfClassMap } from \"./consts\"\nclass VariableAssignment {\n//...\n}\n\nclass CallIdentifier {\n//...\n}\n\nexport class CallsCapturer {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.resolveHeaderC",
    "language": "typescript",
    "label": "Codebase.resolveHeaderC",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 140,
    "inDegree": 1,
    "outDegree": 6,
    "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n        if ( headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\n        const childIds = headerNode.getAllChildren().map(c => c.id)\n        childIds.forEach(id => {\n            const nodeRef = fileNode.getAllChildren().find(c => c.id === id.replace('::header', ''))\n            if (nodeRef) {\n                delete this.nodesMap[id]\n                headerNode.removeChild(headerNode.children[id])\n                headerNode.addChild(nodeRef)\n                headerNode.children[nodeRef.id] = nodeRef\n                headerNode.inDegree++\n            }\n        })\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.resolveImportStatementsNodes",
    "language": "typescript",
    "label": "Codebase.resolveImportStatementsNodes",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 292,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (!['file', 'header'].includes(n.type) ) return\n            n.importStatements.forEach(i => {\n                i.names.forEach(n => {\n                    n.node = this.nodesMap[`${i.path}::${n.name}`]\n                })\n                const namesIds = i.names.map(n => n.node?.id || '')\n                namesIds.forEach(id => {\n                    this.nodesMap[id]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                })\n                if (['c', 'cpp'].includes(n.language)) {\n                    const headerNode = this.nodesMap[i.path]\n                    if (headerNode) {\n                        this.resolveHeaderC(n, headerNode)\n                    }\n                }  \n                // cases like import *, #define \"file\", etc.\n                if (i.names.length === 0) {\n                    this.nodesMap[i.path]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                }\n                \n            })\n        })\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes(){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.resolvePythonInitImportStatements",
    "language": "typescript",
    "label": "Codebase.resolvePythonInitImportStatements",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 161,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\n        // THIS IS A TEMPORARY FIX\n        // In many cases, the __init__.py file just contains the import statements for the other files\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (n.type !== 'file' || n.language !== 'python') return\n            let newImportStatements: ImportStatement[] = [...n.importStatements]\n            n.importStatements.forEach(i => {\n                if (i.path.endsWith('__init__')) {\n                    newImportStatements = newImportStatements.filter(s => s.path != i.path)\n                    newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\n                }\n            })\n            n.importStatements = newImportStatements\n        })\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements(){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.getLinks",
    "language": "typescript",
    "label": "Codebase.getLinks",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 142,
    "inDegree": 6,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getLinks(): Link[] {\n        const links: Link[] = []\n        const nodes = Object.values(this.nodesMap)\n        for (const n of nodes){\n            if (n.parent) {\n                // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\n                const label = 'defines'\n                links.push({source: n.parent.id, target: n.id, label, line: null})\n            }\n            if (n.calls.length > 0) n.calls.forEach(c => links.push({source: n.id, target: c.node.id, label: 'calls', line: c.lines[0]}))\n        }\n        return links\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[]{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.simplify",
    "language": "typescript",
    "label": "Codebase.simplify",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 28,
    "inDegree": 6,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\n        return Object.values(this.nodesMap).map( n => n.simplify(attributes))\n\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.getCalls",
    "language": "typescript",
    "label": "Codebase.getCalls",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 313,
    "inDegree": 6,
    "outDegree": 5,
    "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: {[id: string]: Node}, verbose: boolean = false) {\n        Object.keys(fileNodesMap).forEach(fileId => {\n            const fileNode = fileNodesMap[fileId]\n            if (Object.values(fileNode.children).length === 0) {\n                if (verbose) console.log(`File ${fileId} has no children`)\n                return\n            }\n\n            const callsCapturer = new CallsCapturer(fileNode, verbose)\n            const nodes: Node[] = [fileNode , ...fileNode.getAllChildren()]\n            nodes.forEach((n: Node) => {\n                const callNodeIds = callsCapturer.getCallsFromNode(fileId, n)\n                // const importFromFailed: Set<string> = new Set()\n                // console.log( `### ${n.id}`)\n                // console.log(n.code)\n                // console.log(calls)\n                Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\n                    // if (importFromFailed.has(c.importFrom)) return\n                    const calledNode = this.nodesMap[nodeId]\n                    if (calledNode) {\n                        n.addCall(calledNode, lines) // first line\n                        // console.log(`Added call from ${n.id} to ${calledNode.id}`)\n                    } else {\n                        if (verbose) console.log(`Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`)\n                        // importFromFailed.add(c.importFrom)\n                    }\n                })\n            })\n        })\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: {[id: string]: Node}, verbose: boolean = false){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.parseFolder",
    "language": "typescript",
    "label": "Codebase.parseFolder",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 222,
    "inDegree": 6,
    "outDegree": 8,
    "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{[id: string]: Node}> {\n        if (!this.rootFolderPath) return {}\n        const fileNodesMap: {[id: string]: Node} = {}\n        const allFiles = await getAllFiles(this.rootFolderPath)\n        for (const filePath of allFiles) { // can't be forEach\n            let id = filePath.split('.').slice(0, -1).join('.')\n            try {\n                const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\n                this.addNodeMap(nodesMap)\n                id = isHeader ? `${id}::header` : id\n                const fileNode = nodesMap[id]\n                fileNodesMap[id] = fileNode\n                fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\n            } catch (error: any) {\n                console.log(`Cannot parse file Id ${id}`)\n                console.log(error.message)\n                throw error\n            }\n        }\n        // python special case\n        this.resolvePythonInitImportStatements()\n        this.resolveImportStatementsNodes()\n        return fileNodesMap \n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{[id: string]: Node}>{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.generateNodesFromFilePath",
    "language": "typescript",
    "label": "Codebase.generateNodesFromFilePath",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 309,
    "inDegree": 1,
    "outDegree": 8,
    "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(filePath: string): Promise<{nodesMap: {[id: string]: Node}, isHeader: boolean}> {\n        const fileExtension  = filePath.split('.').pop()\n        if (!fileExtension) return {nodesMap : {}, isHeader: false}\n        const data = await fs.readFile(filePath)\n        const dataString = Buffer.from(data).toString()\n        // Nodes are created using id, code, type, language. The id does not include the extension\n        const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\n        \n        let fileNode\n        let isHeader = false\n        // Special case: .h files (headers)\n        if (fileExtension === 'h') {\n            fileNode = new Node(`${filePathNoExtension}::header`, dataString, 'header', languageExtensionMap[fileExtension])\n            isHeader = true\n        } else {\n            fileNode = new Node(filePathNoExtension, dataString, 'file', languageExtensionMap[fileExtension])\n        }\n        fileNode.name = filePath\n        fileNode.alias = filePath.split('/').pop() || ''\n        const nodesMap = fileNode.getChildrenDefinitions()\n        fileNode.generateImports()\n        fileNode.parseExportClauses(this.nodesMap)\n        nodesMap[fileNode.id] = fileNode\n\n        // get tokens\n        Object.values(nodesMap).forEach(n => n.totalTokens = enc.encode(n.code, 'all', []).length)\n\n        return {nodesMap, isHeader}\n    }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(filePath: string): Promise<{nodesMap: {[id: string]: Node}, isHeader: boolean}>{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.addNodeMap",
    "language": "typescript",
    "label": "Codebase.addNodeMap",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 29,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: {[id: string]: Node}) { this.nodesMap  = {...this.nodesMap, ...nodeMap} }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: {[id: string]: Node}){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.getNode",
    "language": "typescript",
    "label": "Codebase.getNode",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined { return this.nodesMap[id];  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.addNode",
    "language": "typescript",
    "label": "Codebase.addNode",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNode(node: Node) { this.nodesMap[node.id] = node; }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase.constructor",
    "language": "typescript",
    "label": "Codebase.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "totalTokens": 16,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string)  { this.rootFolderPath  = rootFolderPath }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Codebase",
    "language": "typescript",
    "label": "Codebase",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 1736,
    "inDegree": 32,
    "outDegree": 4,
    "code": "class Codebase {\n     // NOTE: rootFolderPath should be an absolute path\n    rootFolderPath: string = ''\n    nodesMap: { [id: string]: Node } = {}\n\n    constructor(rootFolderPath: string)  { this.rootFolderPath  = rootFolderPath }\n    addNode(node: Node) { this.nodesMap[node.id] = node; }\n    getNode(id: string): Node | undefined { return this.nodesMap[id];  }\n    addNodeMap(nodeMap: {[id: string]: Node}) { this.nodesMap  = {...this.nodesMap, ...nodeMap} }\n\n    async generateNodesFromFilePath(filePath: string): Promise<{nodesMap: {[id: string]: Node}, isHeader: boolean}> {\n        const fileExtension  = filePath.split('.').pop()\n        if (!fileExtension) return {nodesMap : {}, isHeader: false}\n        const data = await fs.readFile(filePath)\n        const dataString = Buffer.from(data).toString()\n        // Nodes are created using id, code, type, language. The id does not include the extension\n        const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\n        \n        let fileNode\n        let isHeader = false\n        // Special case: .h files (headers)\n        if (fileExtension === 'h') {\n            fileNode = new Node(`${filePathNoExtension}::header`, dataString, 'header', languageExtensionMap[fileExtension])\n            isHeader = true\n        } else {\n            fileNode = new Node(filePathNoExtension, dataString, 'file', languageExtensionMap[fileExtension])\n        }\n        fileNode.name = filePath\n        fileNode.alias = filePath.split('/').pop() || ''\n        const nodesMap = fileNode.getChildrenDefinitions()\n        fileNode.generateImports()\n        fileNode.parseExportClauses(this.nodesMap)\n        nodesMap[fileNode.id] = fileNode\n\n        // get tokens\n        Object.values(nodesMap).forEach(n => n.totalTokens = enc.encode(n.code, 'all', []).length)\n\n        return {nodesMap, isHeader}\n    }\n    \n\n    async parseFolder(): Promise<{[id: string]: Node}> {\n        if (!this.rootFolderPath) return {}\n        const fileNodesMap: {[id: string]: Node} = {}\n        const allFiles = await getAllFiles(this.rootFolderPath)\n        for (const filePath of allFiles) { // can't be forEach\n            let id = filePath.split('.').slice(0, -1).join('.')\n            try {\n                const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\n                this.addNodeMap(nodesMap)\n                id = isHeader ? `${id}::header` : id\n                const fileNode = nodesMap[id]\n                fileNodesMap[id] = fileNode\n                fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\n            } catch (error: any) {\n                console.log(`Cannot parse file Id ${id}`)\n                console.log(error.message)\n                throw error\n            }\n        }\n        // python special case\n        this.resolvePythonInitImportStatements()\n        this.resolveImportStatementsNodes()\n        return fileNodesMap \n    }\n\n    getCalls(fileNodesMap: {[id: string]: Node}, verbose: boolean = false) {\n        Object.keys(fileNodesMap).forEach(fileId => {\n            const fileNode = fileNodesMap[fileId]\n            if (Object.values(fileNode.children).length === 0) {\n                if (verbose) console.log(`File ${fileId} has no children`)\n                return\n            }\n\n            const callsCapturer = new CallsCapturer(fileNode, verbose)\n            const nodes: Node[] = [fileNode , ...fileNode.getAllChildren()]\n            nodes.forEach((n: Node) => {\n                const callNodeIds = callsCapturer.getCallsFromNode(fileId, n)\n                // const importFromFailed: Set<string> = new Set()\n                // console.log( `### ${n.id}`)\n                // console.log(n.code)\n                // console.log(calls)\n                Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\n                    // if (importFromFailed.has(c.importFrom)) return\n                    const calledNode = this.nodesMap[nodeId]\n                    if (calledNode) {\n                        n.addCall(calledNode, lines) // first line\n                        // console.log(`Added call from ${n.id} to ${calledNode.id}`)\n                    } else {\n                        if (verbose) console.log(`Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`)\n                        // importFromFailed.add(c.importFrom)\n                    }\n                })\n            })\n        })\n    }\n\n    simplify(attributes: string[] = []) {\n        return Object.values(this.nodesMap).map( n => n.simplify(attributes))\n\n    }\n\n    getLinks(): Link[] {\n        const links: Link[] = []\n        const nodes = Object.values(this.nodesMap)\n        for (const n of nodes){\n            if (n.parent) {\n                // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\n                const label = 'defines'\n                links.push({source: n.parent.id, target: n.id, label, line: null})\n            }\n            if (n.calls.length > 0) n.calls.forEach(c => links.push({source: n.id, target: c.node.id, label: 'calls', line: c.lines[0]}))\n        }\n        return links\n    }\n\n    resolvePythonInitImportStatements() {\n        // THIS IS A TEMPORARY FIX\n        // In many cases, the __init__.py file just contains the import statements for the other files\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (n.type !== 'file' || n.language !== 'python') return\n            let newImportStatements: ImportStatement[] = [...n.importStatements]\n            n.importStatements.forEach(i => {\n                if (i.path.endsWith('__init__')) {\n                    newImportStatements = newImportStatements.filter(s => s.path != i.path)\n                    newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\n                }\n            })\n            n.importStatements = newImportStatements\n        })\n    }\n\n    resolveImportStatementsNodes() {\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (!['file', 'header'].includes(n.type) ) return\n            n.importStatements.forEach(i => {\n                i.names.forEach(n => {\n                    n.node = this.nodesMap[`${i.path}::${n.name}`]\n                })\n                const namesIds = i.names.map(n => n.node?.id || '')\n                namesIds.forEach(id => {\n                    this.nodesMap[id]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                })\n                if (['c', 'cpp'].includes(n.language)) {\n                    const headerNode = this.nodesMap[i.path]\n                    if (headerNode) {\n                        this.resolveHeaderC(n, headerNode)\n                    }\n                }  \n                // cases like import *, #define \"file\", etc.\n                if (i.names.length === 0) {\n                    this.nodesMap[i.path]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                }\n                \n            })\n        })\n    }\n\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n        if ( headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\n        const childIds = headerNode.getAllChildren().map(c => c.id)\n        childIds.forEach(id => {\n            const nodeRef = fileNode.getAllChildren().find(c => c.id === id.replace('::header', ''))\n            if (nodeRef) {\n                delete this.nodesMap[id]\n                headerNode.removeChild(headerNode.children[id])\n                headerNode.addChild(nodeRef)\n                headerNode.children[nodeRef.id] = nodeRef\n                headerNode.inDegree++\n            }\n        })\n    }\n\n}",
    "importStatements": [],
    "codeNoBody": "class Codebase {\n     // NOTE: rootFolderPath should be an absolute path\n    rootFolderPath: string = ''\n    nodesMap: { [id: string]: Node } = {}\n    constructor(rootFolderPath: string)  { this.rootFolderPath  = rootFolderPath }\n    addNode(node: Node) {\n        //...\n    }\n    getNode(id: string): Node | undefined {\n        //...\n    }\n    addNodeMap(nodeMap: {[id: string]: Node}) {\n        //...\n    }\n\n    async generateNodesFromFilePath(filePath: string): Promise<{nodesMap: {[id: string]: Node}, isHeader: boolean}> {\n        //...\n    }\n    \n\n    async parseFolder(): Promise<{[id: string]: Node}> {\n        //...\n    }\n\n    getCalls(fileNodesMap: {[id: string]: Node}, verbose: boolean = false) {\n        //...\n    }\n\n    simplify(attributes: string[] = []) {\n        //...\n    }\n\n    getLinks(): Link[] {\n        //...\n    }\n\n    resolvePythonInitImportStatements() {\n        //...\n    }\n\n    resolveImportStatementsNodes() {\n        //...\n    }\n\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n        //...\n    }\n\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.simplify",
    "language": "typescript",
    "label": "Node.simplify",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 260,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    simplify(attributes: string[] = []) {\n        const allAttributes: { [key: string]: any } = {\n            id: this.id,\n            type: this.type,\n            name: this.name,\n            label: this.alias,\n            language: this.language,\n            exportable: this.exportable,\n            totalTokens: this.totalTokens,\n            documentation: this.documentation,\n            code: this.parent && ['class', 'interface'].includes(this.parent?.type)  ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}` : this.code,\n            codeNoBody: this.getCodeWithoutBody(),\n            importStatements: this.importStatements.map(i => i.code),\n            parent: this.parent?.id,\n            children: Object.keys(this.children),\n            calls: this.calls.map(c => c.node.id),\n            inDegree: this.inDegree,\n            outDegree: this.outDegree\n        };\n    \n        if (attributes.length === 0) {\n            return allAttributes;\n        }\n    \n        return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\n            if (allAttributes.hasOwnProperty(attr)) {\n                acc[attr] = allAttributes[attr];\n            }\n            return acc;\n        }, {});\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = []){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.getChildrenDefinitions",
    "language": "typescript",
    "label": "Node.getChildrenDefinitions",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 1279,
    "inDegree": 1,
    "outDegree": 8,
    "code": "class Node\n    ...\n    getChildrenDefinitions(): {[id: string]: Node}{\n        if (!['file', 'header'].includes(this.type)) return {}\n        const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\n        const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let exportable = ['python', 'php'].includes(this.language) ? true : false\n        let childrenNodes: Node[] = []\n    \n        captures.forEach((c)  => {\n            if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\n                const newNode  = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\n    \n                newNode.startPosition  = c.node.startPosition\n                newNode.endPosition  = c.node.endPosition\n                newNode.exportable = exportable\n                \n                // In many languages the documentation is the prev sibling\n                let prevTreeSitterNode = c.node.previousNamedSibling\n                if (prevTreeSitterNode) { \n                    // if the previous node is a comment and it's in the previous line\n                    if (treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\n                    prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                        newNode.documentation  = prevTreeSitterNode.text\n                    }\n    \n                }\n                childrenNodes.push(newNode)\n\n                // In python the decorator is the prev sibling\n                if (this.language === 'python') {\n                    prevTreeSitterNode = c.node.previousSibling\n                    if (prevTreeSitterNode) { \n                        if (['decorator'].includes(prevTreeSitterNode.type) &&\n                        prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                            // include the decorator\n                            newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\n                        }\n                    }\n                }\n            }\n        })\n    \n        childrenNodes.forEach(n => {\n            // if (unnecessaryNodeTypes.includes(n.type)) return\n            let code = n.code\n            if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\n                if (n.type === 'method' ) {\n                    // Fix bug with methods\n                    code = `function ${n.code}`\n                    n.type = 'function'\n                } else if (n.type === 'assignment') code = `const ${n.code}`\n            } else if (['java'].includes(this.language)) {\n                if (n.type == 'function') {\n                    const firstLine = code.split('(')[0]\n                    const firstLineSplit = firstLine.split(' ')\n                    // if has no return type, add void between modifier and name\n                    if (firstLineSplit.length !== 3) {\n                        code = code.replace(firstLine, `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`)\n                    }\n                }\n            }\n            \n            let captures = captureQuery(this.language, 'definitionTemplate', code)\n            // console.log(`/////${n.type}, ${n.language}/////`)\n            // console.log(`${code}`)\n            // console.log('--------------')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures.forEach((c)  =>  {\n                switch (c.name) {\n                    case 'modifier': // java, php only\n                        if (['php', 'java'].includes(n.language) && c.node.text.includes('public')) n.exportable = true\n                        break\n                    case 'name':\n                        n.name = c.node.text\n                        n.id = `${n.id}::${n.name}`\n                        break\n                    case 'alias':\n                        n.alias  = c.node.text\n                        break\n                    case 'documentation':\n                        n.documentation = c.node.text\n                        if (n.language === 'python') {\n                            n.code = n.code.replace(n.documentation, '')\n                            n.body = n.body.replace(n.documentation, '')\n                        }\n                        break\n                    case 'body':\n                        n.body  = c.node.text\n                        break\n                }\n            })\n            if (!n.alias) n.alias = n.name\n    \n            if (n.type === 'assignment') {\n                const assignmentCaptures = captureQuery(this.language, 'extraAssignmentCode', this.code, n.name)\n                // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n                assignmentCaptures.forEach((c)  =>  {\n                    if (c.name === 'code') n.code += '\\n' + c.node.text\n                })\n            }\n        })\n    \n        // must have a name\n        childrenNodes = childrenNodes.filter(c => c.name)\n    \n        childrenNodes.forEach((n, i) => {\n            for (let j = i+1; j < childrenNodes.length; j++) {\n                n.addNodeRelationship(childrenNodes[j])\n                childrenNodes[j].addNodeRelationship(n)\n            }\n            if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\n        })\n    \n        // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\n        const nodesMap = childrenNodes.reduce<{[id: string]: Node}>((map, n)  =>  {\n            if (!unnecessaryNodeTypes.includes(n.type)) map[n.id]  = n\n            return map\n        }, {})\n        return nodesMap\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): {[id: string]: Node}{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.resolveImportStatementsPath",
    "language": "typescript",
    "label": "Node.resolveImportStatementsPath",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 285,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n        if (this.type !== 'file') return\n        const suffix = indexSuffixesMap[this.language];\n        const fileSet = new Set(allFiles.map(p => p.split('.').slice(0, -1).join('.')));\n        \n        this.importStatements.forEach((importStatement) => {\n            const possiblePaths = [\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}`)),\n                path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\n                path.resolve(`${rootFolderPath}/${importStatement.path}`),\n                path.resolve(`${importStatement.path}${suffix}`),\n                path.resolve(importStatement.path)\n            ];\n    \n            for (const possiblePath of possiblePaths) {\n                if (fileSet.has(possiblePath)) {\n                    importStatement.path = possiblePath\n                    break;\n                }\n            }\n    \n            if (importStatement.path.startsWith('@/')) {\n                importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2));\n            }\n        });\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.parseExportClauses",
    "language": "typescript",
    "label": "Node.parseExportClauses",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 547,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Node\n    ...\n    parseExportClauses(nodesMap: {[id: string]: Node} = {}) {\n        // only js, ts have the \"export { ... }\" clause\n        if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\n        const captures = captureQuery(this.language, 'exportClauses', this.code) \n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let name = ''\n        let alias = ''\n        let moduleName = this.id\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'module':\n                    moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'name':\n                    name = c.node.text\n                    // the name is imported\n                    const importedName = this.importStatements.filter(i => i.names.map(n => n.alias).includes(name))[0]\n                    if (importedName) moduleName = importedName.path\n                    const node = this.children[`${this.id}::${name}`] || nodesMap[`${moduleName}::${name}`]\n                    if (node) {\n                        node.exportable = true\n                        node.alias = alias? alias : name\n                        // if the export clause includes an alias, then we have to update the id\n                        // since this is used to resolve imports and get calls \n                        node.id = `${this.id}::${node.alias}`\n\n                        // the node is exported from the same file \n                        if (moduleName === this.id) {\n                            delete this.children[`${this.id}::${name}`]\n                            this.children[node.id] = node\n                            const childrenNodes = Object.values(node.children)\n                            childrenNodes.forEach(n => {\n                                n.alias = n.name.replace(name, alias)\n                                delete node.children[n.id]\n                                n.id = `${this.id}::${n.alias}`\n                                node.children[n.id] = n\n                            })\n                        \n                        // it's using export { ... } from 'file'\n                        }\n                        // } else {\n                        //     node.exportable = true\n                        //     node.alias = alias? alias : name\n                        //     // add the node to the file node\n                        //     node.id = `${this.id}::${node.alias}`\n                        //     this.children[node.id] = node\n                        // }\n\n                    } \n                    // else {\n                    //     console.log(`Export clause ${name} not found in ${this.id}`)\n                    // }\n            }\n        })\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    parseExportClauses(nodesMap: {[id: string]: Node} = {}){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.generateImports",
    "language": "typescript",
    "label": "Node.generateImports",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 382,
    "inDegree": 1,
    "outDegree": 6,
    "code": "class Node\n    ...\n    generateImports() {\n        if (this.type !== 'file') return\n        const captures = captureQuery(this.language, 'importStatements', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\n        const importStatements: ImportStatement[] = []\n        let newImportStatement = new ImportStatement()\n        let alias: string\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'module':\n                    newImportStatement.module = c.node.text\n                    break\n                case 'name':\n                    const name = c.node.text\n                    if (!alias) alias = name\n                    const newImportName = new ImportName(name, alias)\n                    newImportStatement.names.push(newImportName)\n                    alias = ''\n                    break\n                // case 'submodule':\n                //     break\n                // case 'wildcard':\n                //     break\n                case 'import_statement':\n                    if (alias && newImportStatement.names.length === 0) {\n                        newImportStatement.moduleAlias = alias\n                        alias = ''\n                    } else {\n                        newImportStatement.moduleAlias = newImportStatement.module\n                    }\n                    \n                    newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\n                    newImportStatement.code = c.node.text\n                    // newImportStatement.startPosition = c.node.startPosition\n                    // newImportStatement.endPosition = c.node.endPosition\n                    importStatements.push(newImportStatement)\n                    newImportStatement = new ImportStatement()\n                    break;\n            }\n        })\n        this.importStatements = importStatements.reverse()\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    generateImports(){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.getCodeWithoutBody",
    "language": "typescript",
    "label": "Node.getCodeWithoutBody",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 490,
    "inDegree": 2,
    "outDegree": 3,
    "code": "class Node\n    ...\n    getCodeWithoutBody() {\n        let code = this.code\n\n        if (this.body || this.type === 'file') {\n            if (Object.keys(this.children).length > 0) {\n                // const extension = this.id.split('::')[0].split('.').pop() || '';\n                const classMethodInit = this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\n                Object.values(this.children).forEach(n  => {\n                    if (classMethodInit && this.type === 'class') {\n                        // do not remove init methods\n                        if (n.name?.endsWith(classMethodInit)) return\n\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `\\n${spaces}    ...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}    //...\\n${spaces}}`)\n                            }\n                        }\n                    } else if (this.type === 'file' && !['assignment', 'type', 'enum'].includes(n.type)) {\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `${spaces}...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}//...\\n${spaces}}`)\n                            }\n\n                        }\n                    }\n                })\n\n            } else {\n                const spaces = ' '.repeat(this.startPosition.column)\n                if (this.language === 'python') {\n                    code = code.replace(this.body, '').trim() + `\\n${spaces}    ...`\n                } else {\n                    code = code.replace(this.body, '').trim() + `{\\n${spaces}    //...\\n${spaces}}`\n                }\n\n                \n            }\n        }\n        code = code.trim().replace(/\\n\\s*\\n/, '\\n')\n        if (this.parent && ['class', 'interface'].includes(this.parent?.type))\n            code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\n        return code\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.addNodeRelationship",
    "language": "typescript",
    "label": "Node.addNodeRelationship",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 221,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\n        // if (node.type === this.type && node.name === this.name) return\n        if (this.isWithin(node) && !this.parent) {\n            if (node.type === 'export') { // in js, ts the export clause is parent\n                this.exportable = true\n                if (!this.documentation) this.documentation = node.documentation\n                return\n            }\n            if (this.type === 'export') return // export are not added as nodes\n\n            // const parentCode = node.code.replace(node.body, '')\n            // this.code = `${parentCode}\\n${this.code}`\n            \n            // Case for py, js and ts\n            if (['class', 'interface'].includes(node.type) && this.type === 'function') {\n                this.type = 'method'\n                this.name = `${node.name}.${this.name}`\n                this.alias = this.name // methods has no alias\n            }\n            this.id = `${this.id.split('::')[0]}::${this.name}`\n            node.addChild(this)\n        }\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.isWithin",
    "language": "typescript",
    "label": "Node.isWithin",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 32,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\n        return this.startPosition.row >= node.startPosition.row && this.endPosition.row <= node.endPosition.row\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.addImportStatement",
    "language": "typescript",
    "label": "Node.addImportStatement",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\n        this.importStatements.push(importStatement)\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.addCall",
    "language": "typescript",
    "label": "Node.addCall",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 40,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []){\n        // this -> node\n        this.calls.push({node, lines})\n        node.inDegree++\n        this.outDegree++\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.removeChild",
    "language": "typescript",
    "label": "Node.removeChild",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 49,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    removeChild(child: Node)  {\n        if (Object.keys(this.children).includes(child.id)) {\n            // child.parent = undefined\n            delete this.children[child.id]\n            this.inDegree--\n            child.outDegree--\n        }\n     }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    removeChild(child: Node){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.addChild",
    "language": "typescript",
    "label": "Node.addChild",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 39,
    "inDegree": 3,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addChild(child: Node) {\n        // child -> this\n        this.children[child.id] = child\n        child.parent = this\n        this.inDegree++\n        child.outDegree++\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addChild(child: Node){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.getAllChildren",
    "language": "typescript",
    "label": "Node.getAllChildren",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 74,
    "inDegree": 2,
    "outDegree": 3,
    "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n        // get childrens recursively\n        const children: Node[] = []\n        if (parentTypes && !parentTypes.includes(this.type)) return []\n        for (const child of Object.values(this.children)) {\n            children.push(child)\n            children.push(...child.getAllChildren())\n        }\n        return children\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[]{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.getChild",
    "language": "typescript",
    "label": "Node.getChild",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\n        // recursive search over children, only if is a file\n        if (this.children[childId]) {\n            return this.children[childId]\n        } else if ( this.type === 'file') {\n            for (const child of Object.values(this.children)) {\n                const result = child.getChild(childId)\n                if (result) return result\n            }\n        }\n        return\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined{\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node.constructor",
    "language": "typescript",
    "label": "Node.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "totalTokens": 56,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n        this.id  = id\n        this.code  = code || ''\n        this.type  = type || 'function'\n        this.language  = language || 'js'\n    }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Node",
    "language": "typescript",
    "label": "Node",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 4066,
    "inDegree": 48,
    "outDegree": 5,
    "code": "class Node {\n    id: string = '' // id is like /home/user/repo/file.extension::nodeName\n    type: AllowedTypes = 'function'\n    name: string = ''\n    alias: string = ''\n    language: string = ''\n    importStatements: ImportStatement[] = [] // only for files\n    totalTokens: number = 0\n    documentation: string = ''\n    code: string = ''\n    body: string = ''\n    exportable: boolean = false\n    parent?: Node\n    children: {[key: string]: Node} = {}\n    calls: NodeCallTuple[] = []\n    startPosition: Point = {row: 0, column: 0}\n    endPosition: Point = {row: 99999, column: 0}\n    inDegree: number = 0\n    outDegree: number = 0\n\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n        this.id  = id\n        this.code  = code || ''\n        this.type  = type || 'function'\n        this.language  = language || 'js'\n    }\n\n    getChild(childId: string): Node | undefined {\n        // recursive search over children, only if is a file\n        if (this.children[childId]) {\n            return this.children[childId]\n        } else if ( this.type === 'file') {\n            for (const child of Object.values(this.children)) {\n                const result = child.getChild(childId)\n                if (result) return result\n            }\n        }\n        return\n    }\n\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n        // get childrens recursively\n        const children: Node[] = []\n        if (parentTypes && !parentTypes.includes(this.type)) return []\n        for (const child of Object.values(this.children)) {\n            children.push(child)\n            children.push(...child.getAllChildren())\n        }\n        return children\n    }\n\n    addChild(child: Node) {\n        // child -> this\n        this.children[child.id] = child\n        child.parent = this\n        this.inDegree++\n        child.outDegree++\n    }\n\n    removeChild(child: Node)  {\n        if (Object.keys(this.children).includes(child.id)) {\n            // child.parent = undefined\n            delete this.children[child.id]\n            this.inDegree--\n            child.outDegree--\n        }\n     }\n\n    addCall(node: Node, lines: number[] = []){\n        // this -> node\n        this.calls.push({node, lines})\n        node.inDegree++\n        this.outDegree++\n    }\n\n    addImportStatement(importStatement: ImportStatement) {\n        this.importStatements.push(importStatement)\n    }\n\n    // Checks if this node is within another node\n    isWithin(node: Node): boolean {\n        return this.startPosition.row >= node.startPosition.row && this.endPosition.row <= node.endPosition.row\n    }\n\n    addNodeRelationship(node: Node) {\n        // if (node.type === this.type && node.name === this.name) return\n        if (this.isWithin(node) && !this.parent) {\n            if (node.type === 'export') { // in js, ts the export clause is parent\n                this.exportable = true\n                if (!this.documentation) this.documentation = node.documentation\n                return\n            }\n            if (this.type === 'export') return // export are not added as nodes\n\n            // const parentCode = node.code.replace(node.body, '')\n            // this.code = `${parentCode}\\n${this.code}`\n            \n            // Case for py, js and ts\n            if (['class', 'interface'].includes(node.type) && this.type === 'function') {\n                this.type = 'method'\n                this.name = `${node.name}.${this.name}`\n                this.alias = this.name // methods has no alias\n            }\n            this.id = `${this.id.split('::')[0]}::${this.name}`\n            node.addChild(this)\n        }\n    }\n\n    getCodeWithoutBody() {\n        let code = this.code\n\n        if (this.body || this.type === 'file') {\n            if (Object.keys(this.children).length > 0) {\n                // const extension = this.id.split('::')[0].split('.').pop() || '';\n                const classMethodInit = this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\n                Object.values(this.children).forEach(n  => {\n                    if (classMethodInit && this.type === 'class') {\n                        // do not remove init methods\n                        if (n.name?.endsWith(classMethodInit)) return\n\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `\\n${spaces}    ...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}    //...\\n${spaces}}`)\n                            }\n                        }\n                    } else if (this.type === 'file' && !['assignment', 'type', 'enum'].includes(n.type)) {\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `${spaces}...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}//...\\n${spaces}}`)\n                            }\n\n                        }\n                    }\n                })\n\n            } else {\n                const spaces = ' '.repeat(this.startPosition.column)\n                if (this.language === 'python') {\n                    code = code.replace(this.body, '').trim() + `\\n${spaces}    ...`\n                } else {\n                    code = code.replace(this.body, '').trim() + `{\\n${spaces}    //...\\n${spaces}}`\n                }\n\n                \n            }\n        }\n        code = code.trim().replace(/\\n\\s*\\n/, '\\n')\n        if (this.parent && ['class', 'interface'].includes(this.parent?.type))\n            code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\n        return code\n    }\n\n    generateImports() {\n        if (this.type !== 'file') return\n        const captures = captureQuery(this.language, 'importStatements', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\n        const importStatements: ImportStatement[] = []\n        let newImportStatement = new ImportStatement()\n        let alias: string\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'module':\n                    newImportStatement.module = c.node.text\n                    break\n                case 'name':\n                    const name = c.node.text\n                    if (!alias) alias = name\n                    const newImportName = new ImportName(name, alias)\n                    newImportStatement.names.push(newImportName)\n                    alias = ''\n                    break\n                // case 'submodule':\n                //     break\n                // case 'wildcard':\n                //     break\n                case 'import_statement':\n                    if (alias && newImportStatement.names.length === 0) {\n                        newImportStatement.moduleAlias = alias\n                        alias = ''\n                    } else {\n                        newImportStatement.moduleAlias = newImportStatement.module\n                    }\n                    \n                    newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\n                    newImportStatement.code = c.node.text\n                    // newImportStatement.startPosition = c.node.startPosition\n                    // newImportStatement.endPosition = c.node.endPosition\n                    importStatements.push(newImportStatement)\n                    newImportStatement = new ImportStatement()\n                    break;\n            }\n        })\n        this.importStatements = importStatements.reverse()\n    }\n\n    parseExportClauses(nodesMap: {[id: string]: Node} = {}) {\n        // only js, ts have the \"export { ... }\" clause\n        if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\n        const captures = captureQuery(this.language, 'exportClauses', this.code) \n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let name = ''\n        let alias = ''\n        let moduleName = this.id\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'module':\n                    moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'name':\n                    name = c.node.text\n                    // the name is imported\n                    const importedName = this.importStatements.filter(i => i.names.map(n => n.alias).includes(name))[0]\n                    if (importedName) moduleName = importedName.path\n                    const node = this.children[`${this.id}::${name}`] || nodesMap[`${moduleName}::${name}`]\n                    if (node) {\n                        node.exportable = true\n                        node.alias = alias? alias : name\n                        // if the export clause includes an alias, then we have to update the id\n                        // since this is used to resolve imports and get calls \n                        node.id = `${this.id}::${node.alias}`\n\n                        // the node is exported from the same file \n                        if (moduleName === this.id) {\n                            delete this.children[`${this.id}::${name}`]\n                            this.children[node.id] = node\n                            const childrenNodes = Object.values(node.children)\n                            childrenNodes.forEach(n => {\n                                n.alias = n.name.replace(name, alias)\n                                delete node.children[n.id]\n                                n.id = `${this.id}::${n.alias}`\n                                node.children[n.id] = n\n                            })\n                        \n                        // it's using export { ... } from 'file'\n                        }\n                        // } else {\n                        //     node.exportable = true\n                        //     node.alias = alias? alias : name\n                        //     // add the node to the file node\n                        //     node.id = `${this.id}::${node.alias}`\n                        //     this.children[node.id] = node\n                        // }\n\n                    } \n                    // else {\n                    //     console.log(`Export clause ${name} not found in ${this.id}`)\n                    // }\n            }\n        })\n    }\n\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n        if (this.type !== 'file') return\n        const suffix = indexSuffixesMap[this.language];\n        const fileSet = new Set(allFiles.map(p => p.split('.').slice(0, -1).join('.')));\n        \n        this.importStatements.forEach((importStatement) => {\n            const possiblePaths = [\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}`)),\n                path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\n                path.resolve(`${rootFolderPath}/${importStatement.path}`),\n                path.resolve(`${importStatement.path}${suffix}`),\n                path.resolve(importStatement.path)\n            ];\n    \n            for (const possiblePath of possiblePaths) {\n                if (fileSet.has(possiblePath)) {\n                    importStatement.path = possiblePath\n                    break;\n                }\n            }\n    \n            if (importStatement.path.startsWith('@/')) {\n                importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2));\n            }\n        });\n    }\n\n    getChildrenDefinitions(): {[id: string]: Node}{\n        if (!['file', 'header'].includes(this.type)) return {}\n        const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\n        const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let exportable = ['python', 'php'].includes(this.language) ? true : false\n        let childrenNodes: Node[] = []\n    \n        captures.forEach((c)  => {\n            if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\n                const newNode  = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\n    \n                newNode.startPosition  = c.node.startPosition\n                newNode.endPosition  = c.node.endPosition\n                newNode.exportable = exportable\n                \n                // In many languages the documentation is the prev sibling\n                let prevTreeSitterNode = c.node.previousNamedSibling\n                if (prevTreeSitterNode) { \n                    // if the previous node is a comment and it's in the previous line\n                    if (treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\n                    prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                        newNode.documentation  = prevTreeSitterNode.text\n                    }\n    \n                }\n                childrenNodes.push(newNode)\n\n                // In python the decorator is the prev sibling\n                if (this.language === 'python') {\n                    prevTreeSitterNode = c.node.previousSibling\n                    if (prevTreeSitterNode) { \n                        if (['decorator'].includes(prevTreeSitterNode.type) &&\n                        prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                            // include the decorator\n                            newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\n                        }\n                    }\n                }\n            }\n        })\n    \n        childrenNodes.forEach(n => {\n            // if (unnecessaryNodeTypes.includes(n.type)) return\n            let code = n.code\n            if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\n                if (n.type === 'method' ) {\n                    // Fix bug with methods\n                    code = `function ${n.code}`\n                    n.type = 'function'\n                } else if (n.type === 'assignment') code = `const ${n.code}`\n            } else if (['java'].includes(this.language)) {\n                if (n.type == 'function') {\n                    const firstLine = code.split('(')[0]\n                    const firstLineSplit = firstLine.split(' ')\n                    // if has no return type, add void between modifier and name\n                    if (firstLineSplit.length !== 3) {\n                        code = code.replace(firstLine, `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`)\n                    }\n                }\n            }\n            \n            let captures = captureQuery(this.language, 'definitionTemplate', code)\n            // console.log(`/////${n.type}, ${n.language}/////`)\n            // console.log(`${code}`)\n            // console.log('--------------')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures.forEach((c)  =>  {\n                switch (c.name) {\n                    case 'modifier': // java, php only\n                        if (['php', 'java'].includes(n.language) && c.node.text.includes('public')) n.exportable = true\n                        break\n                    case 'name':\n                        n.name = c.node.text\n                        n.id = `${n.id}::${n.name}`\n                        break\n                    case 'alias':\n                        n.alias  = c.node.text\n                        break\n                    case 'documentation':\n                        n.documentation = c.node.text\n                        if (n.language === 'python') {\n                            n.code = n.code.replace(n.documentation, '')\n                            n.body = n.body.replace(n.documentation, '')\n                        }\n                        break\n                    case 'body':\n                        n.body  = c.node.text\n                        break\n                }\n            })\n            if (!n.alias) n.alias = n.name\n    \n            if (n.type === 'assignment') {\n                const assignmentCaptures = captureQuery(this.language, 'extraAssignmentCode', this.code, n.name)\n                // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n                assignmentCaptures.forEach((c)  =>  {\n                    if (c.name === 'code') n.code += '\\n' + c.node.text\n                })\n            }\n        })\n    \n        // must have a name\n        childrenNodes = childrenNodes.filter(c => c.name)\n    \n        childrenNodes.forEach((n, i) => {\n            for (let j = i+1; j < childrenNodes.length; j++) {\n                n.addNodeRelationship(childrenNodes[j])\n                childrenNodes[j].addNodeRelationship(n)\n            }\n            if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\n        })\n    \n        // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\n        const nodesMap = childrenNodes.reduce<{[id: string]: Node}>((map, n)  =>  {\n            if (!unnecessaryNodeTypes.includes(n.type)) map[n.id]  = n\n            return map\n        }, {})\n        return nodesMap\n    }\n\n    simplify(attributes: string[] = []) {\n        const allAttributes: { [key: string]: any } = {\n            id: this.id,\n            type: this.type,\n            name: this.name,\n            label: this.alias,\n            language: this.language,\n            exportable: this.exportable,\n            totalTokens: this.totalTokens,\n            documentation: this.documentation,\n            code: this.parent && ['class', 'interface'].includes(this.parent?.type)  ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}` : this.code,\n            codeNoBody: this.getCodeWithoutBody(),\n            importStatements: this.importStatements.map(i => i.code),\n            parent: this.parent?.id,\n            children: Object.keys(this.children),\n            calls: this.calls.map(c => c.node.id),\n            inDegree: this.inDegree,\n            outDegree: this.outDegree\n        };\n    \n        if (attributes.length === 0) {\n            return allAttributes;\n        }\n    \n        return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\n            if (allAttributes.hasOwnProperty(attr)) {\n                acc[attr] = allAttributes[attr];\n            }\n            return acc;\n        }, {});\n    }\n}",
    "importStatements": [],
    "codeNoBody": "class Node {\n    id: string = '' // id is like /home/user/repo/file.extension::nodeName\n    type: AllowedTypes = 'function'\n    name: string = ''\n    alias: string = ''\n    language: string = ''\n    importStatements: ImportStatement[] = [] // only for files\n    totalTokens: number = 0\n    documentation: string = ''\n    code: string = ''\n    body: string = ''\n    exportable: boolean = false\n    parent?: Node\n    children: {[key: string]: Node} = {}\n    calls: NodeCallTuple[] = []\n    startPosition: Point = {row: 0, column: 0}\n    endPosition: Point = {row: 99999, column: 0}\n    inDegree: number = 0\n    outDegree: number = 0\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n        this.id  = id\n        this.code  = code || ''\n        this.type  = type || 'function'\n        this.language  = language || 'js'\n    }\n\n    getChild(childId: string): Node | undefined {\n        //...\n    }\n\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n        //...\n    }\n\n    addChild(child: Node) {\n        //...\n    }\n\n    removeChild(child: Node)  {\n        //...\n    }\n\n    addCall(node: Node, lines: number[] = []){\n        //...\n    }\n\n    addImportStatement(importStatement: ImportStatement) {\n        //...\n    }\n\n    // Checks if this node is within another node\n    isWithin(node: Node): boolean {\n        //...\n    }\n\n    addNodeRelationship(node: Node) {\n        //...\n    }\n\n    getCodeWithoutBody() {\n        //...\n    }\n\n    generateImports() {\n        //...\n    }\n\n    parseExportClauses(nodesMap: {[id: string]: Node} = {}) {\n        //...\n    }\n\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n        //...\n    }\n\n    getChildrenDefinitions(): {[id: string]: Node}{\n        //...\n    }\n\n    simplify(attributes: string[] = []) {\n        //...\n    }\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::NodeCallTuple",
    "language": "typescript",
    "label": "NodeCallTuple",
    "type": "type",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 19,
    "inDegree": 3,
    "outDegree": 3,
    "code": "type NodeCallTuple = {node: Node, lines: number[]} // nodeId, first line",
    "importStatements": [],
    "codeNoBody": "type NodeCallTuple =  // nodeId, first line{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::Link",
    "language": "typescript",
    "label": "Link",
    "type": "interface",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 25,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Link {\n    source: string\n    target: string\n    label: string\n    line?: number|null\n}",
    "importStatements": [],
    "codeNoBody": "interface Link{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportStatement.constructor",
    "language": "typescript",
    "label": "ImportStatement.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportStatement",
    "totalTokens": 64,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class ImportStatement\n    ...\n    constructor(module: string = '', names: ImportName[] = [], path: string = '', moduleAlias?: string, code?: string) {\n        this.module = module\n        this.names = names\n        this.moduleAlias = moduleAlias || module\n        this.path = path\n        this.code = code\n    }",
    "importStatements": [],
    "codeNoBody": "class ImportStatement\n    ...\n    constructor(module: string = '', names: ImportName[] = [], path: string = '', moduleAlias?: string, code?: string){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportStatement",
    "language": "typescript",
    "label": "ImportStatement",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 97,
    "inDegree": 10,
    "outDegree": 3,
    "code": "class ImportStatement {\n    module: string\n    names: ImportName[]\n    moduleAlias: string\n    path: string\n    code?: string\n\n    constructor(module: string = '', names: ImportName[] = [], path: string = '', moduleAlias?: string, code?: string) {\n        this.module = module\n        this.names = names\n        this.moduleAlias = moduleAlias || module\n        this.path = path\n        this.code = code\n    }\n}",
    "importStatements": [],
    "codeNoBody": "class ImportStatement {\n    module: string\n    names: ImportName[]\n    moduleAlias: string\n    path: string\n    code?: string\n    constructor(module: string = '', names: ImportName[] = [], path: string = '', moduleAlias?: string, code?: string) {\n        this.module = module\n        this.names = names\n        this.moduleAlias = moduleAlias || module\n        this.path = path\n        this.code = code\n    }\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportName.constructor",
    "language": "typescript",
    "label": "ImportName.constructor",
    "type": "method",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportName",
    "totalTokens": 27,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\n        this.name = name\n        this.alias  = alias || name\n    }",
    "importStatements": [],
    "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string){\n        //...\n    }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::ImportName",
    "language": "typescript",
    "label": "ImportName",
    "type": "class",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 59,
    "inDegree": 8,
    "outDegree": 3,
    "code": "class ImportName {\n    name: string = ''\n    alias: string = ''\n    node?: Node\n    // subpath: string = ''\n    \n    constructor(name: string, alias?: string) {\n        this.name = name\n        this.alias  = alias || name\n    }\n}",
    "importStatements": [],
    "codeNoBody": "class ImportName {\n    name: string = ''\n    alias: string = ''\n    node?: Node\n    // subpath: string = ''\n    constructor(name: string, alias?: string) {\n        this.name = name\n        this.alias  = alias || name\n    }\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase::enc",
    "language": "typescript",
    "label": "enc",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "enc = encoding_for_model(\"gpt-4-turbo\")",
    "importStatements": [],
    "codeNoBody": "enc ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/codebase",
    "language": "typescript",
    "label": "codebase.ts",
    "type": "file",
    "totalTokens": 6141,
    "inDegree": 7,
    "outDegree": 6,
    "code": "import fs from 'node:fs/promises';\nimport { Point } from 'tree-sitter'\nimport {\n    captureQuery,\n    getAllFiles,\n    renameSource,\n    getCalledNode,\n    cleanDefCaptures\n} from \"./utils\"\nimport {\n    languageExtensionMap,\n    AllowedTypes,\n    newClassMethodsMap,\n    indexSuffixesMap,\n    AllowedTypesArray,\n    treeSitterCommentTypes\n} from \"./consts\"\nimport { CallsCapturer } from './calls';\nimport path from 'path'\nimport {  encoding_for_model } from \"tiktoken\";\nconst enc = encoding_for_model(\"gpt-4-turbo\");\n\nexport class ImportName {\n    name: string = ''\n    alias: string = ''\n    node?: Node\n    // subpath: string = ''\n    \n    constructor(name: string, alias?: string) {\n        this.name = name\n        this.alias  = alias || name\n    }\n}\nexport class ImportStatement {\n    module: string\n    names: ImportName[]\n    moduleAlias: string\n    path: string\n    code?: string\n\n    constructor(module: string = '', names: ImportName[] = [], path: string = '', moduleAlias?: string, code?: string) {\n        this.module = module\n        this.names = names\n        this.moduleAlias = moduleAlias || module\n        this.path = path\n        this.code = code\n    }\n}\n\ninterface Link {\n    source: string\n    target: string\n    label: string\n    line?: number|null\n}\n\ntype NodeCallTuple = {node: Node, lines: number[]} // nodeId, first line\n\nexport class Node {\n    id: string = '' // id is like /home/user/repo/file.extension::nodeName\n    type: AllowedTypes = 'function'\n    name: string = ''\n    alias: string = ''\n    language: string = ''\n    importStatements: ImportStatement[] = [] // only for files\n    totalTokens: number = 0\n    documentation: string = ''\n    code: string = ''\n    body: string = ''\n    exportable: boolean = false\n    parent?: Node\n    children: {[key: string]: Node} = {}\n    calls: NodeCallTuple[] = []\n    startPosition: Point = {row: 0, column: 0}\n    endPosition: Point = {row: 99999, column: 0}\n    inDegree: number = 0\n    outDegree: number = 0\n\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n        this.id  = id\n        this.code  = code || ''\n        this.type  = type || 'function'\n        this.language  = language || 'js'\n    }\n\n    getChild(childId: string): Node | undefined {\n        // recursive search over children, only if is a file\n        if (this.children[childId]) {\n            return this.children[childId]\n        } else if ( this.type === 'file') {\n            for (const child of Object.values(this.children)) {\n                const result = child.getChild(childId)\n                if (result) return result\n            }\n        }\n        return\n    }\n\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n        // get childrens recursively\n        const children: Node[] = []\n        if (parentTypes && !parentTypes.includes(this.type)) return []\n        for (const child of Object.values(this.children)) {\n            children.push(child)\n            children.push(...child.getAllChildren())\n        }\n        return children\n    }\n\n    addChild(child: Node) {\n        // child -> this\n        this.children[child.id] = child\n        child.parent = this\n        this.inDegree++\n        child.outDegree++\n    }\n\n    removeChild(child: Node)  {\n        if (Object.keys(this.children).includes(child.id)) {\n            // child.parent = undefined\n            delete this.children[child.id]\n            this.inDegree--\n            child.outDegree--\n        }\n     }\n\n    addCall(node: Node, lines: number[] = []){\n        // this -> node\n        this.calls.push({node, lines})\n        node.inDegree++\n        this.outDegree++\n    }\n\n    addImportStatement(importStatement: ImportStatement) {\n        this.importStatements.push(importStatement)\n    }\n\n    // Checks if this node is within another node\n    isWithin(node: Node): boolean {\n        return this.startPosition.row >= node.startPosition.row && this.endPosition.row <= node.endPosition.row\n    }\n\n    addNodeRelationship(node: Node) {\n        // if (node.type === this.type && node.name === this.name) return\n        if (this.isWithin(node) && !this.parent) {\n            if (node.type === 'export') { // in js, ts the export clause is parent\n                this.exportable = true\n                if (!this.documentation) this.documentation = node.documentation\n                return\n            }\n            if (this.type === 'export') return // export are not added as nodes\n\n            // const parentCode = node.code.replace(node.body, '')\n            // this.code = `${parentCode}\\n${this.code}`\n            \n            // Case for py, js and ts\n            if (['class', 'interface'].includes(node.type) && this.type === 'function') {\n                this.type = 'method'\n                this.name = `${node.name}.${this.name}`\n                this.alias = this.name // methods has no alias\n            }\n            this.id = `${this.id.split('::')[0]}::${this.name}`\n            node.addChild(this)\n        }\n    }\n\n    getCodeWithoutBody() {\n        let code = this.code\n\n        if (this.body || this.type === 'file') {\n            if (Object.keys(this.children).length > 0) {\n                // const extension = this.id.split('::')[0].split('.').pop() || '';\n                const classMethodInit = this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\n                Object.values(this.children).forEach(n  => {\n                    if (classMethodInit && this.type === 'class') {\n                        // do not remove init methods\n                        if (n.name?.endsWith(classMethodInit)) return\n\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `\\n${spaces}    ...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}    //...\\n${spaces}}`)\n                            }\n                        }\n                    } else if (this.type === 'file' && !['assignment', 'type', 'enum'].includes(n.type)) {\n                        if (n.body) {\n                            let bodyToRemove = n.body\n                            bodyToRemove = bodyToRemove.replace(n.documentation, '')\n                            const spaces = ' '.repeat(n.startPosition.column)\n                            if (this.language === 'python') {\n                                code = code.replace(bodyToRemove, `${spaces}...`)\n                            } else {\n                                code = code.replace(bodyToRemove, `{\\n${spaces}//...\\n${spaces}}`)\n                            }\n\n                        }\n                    }\n                })\n\n            } else {\n                const spaces = ' '.repeat(this.startPosition.column)\n                if (this.language === 'python') {\n                    code = code.replace(this.body, '').trim() + `\\n${spaces}    ...`\n                } else {\n                    code = code.replace(this.body, '').trim() + `{\\n${spaces}    //...\\n${spaces}}`\n                }\n\n                \n            }\n        }\n        code = code.trim().replace(/\\n\\s*\\n/, '\\n')\n        if (this.parent && ['class', 'interface'].includes(this.parent?.type))\n            code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\n        return code\n    }\n\n    generateImports() {\n        if (this.type !== 'file') return\n        const captures = captureQuery(this.language, 'importStatements', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\n        const importStatements: ImportStatement[] = []\n        let newImportStatement = new ImportStatement()\n        let alias: string\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'module':\n                    newImportStatement.module = c.node.text\n                    break\n                case 'name':\n                    const name = c.node.text\n                    if (!alias) alias = name\n                    const newImportName = new ImportName(name, alias)\n                    newImportStatement.names.push(newImportName)\n                    alias = ''\n                    break\n                // case 'submodule':\n                //     break\n                // case 'wildcard':\n                //     break\n                case 'import_statement':\n                    if (alias && newImportStatement.names.length === 0) {\n                        newImportStatement.moduleAlias = alias\n                        alias = ''\n                    } else {\n                        newImportStatement.moduleAlias = newImportStatement.module\n                    }\n                    \n                    newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\n                    newImportStatement.code = c.node.text\n                    // newImportStatement.startPosition = c.node.startPosition\n                    // newImportStatement.endPosition = c.node.endPosition\n                    importStatements.push(newImportStatement)\n                    newImportStatement = new ImportStatement()\n                    break;\n            }\n        })\n        this.importStatements = importStatements.reverse()\n    }\n\n    parseExportClauses(nodesMap: {[id: string]: Node} = {}) {\n        // only js, ts have the \"export { ... }\" clause\n        if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\n        const captures = captureQuery(this.language, 'exportClauses', this.code) \n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let name = ''\n        let alias = ''\n        let moduleName = this.id\n        captures.forEach(c => {\n            switch (c.name) {\n                case 'module':\n                    moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\n                case 'alias':\n                    alias = c.node.text\n                    break\n                case 'name':\n                    name = c.node.text\n                    // the name is imported\n                    const importedName = this.importStatements.filter(i => i.names.map(n => n.alias).includes(name))[0]\n                    if (importedName) moduleName = importedName.path\n                    const node = this.children[`${this.id}::${name}`] || nodesMap[`${moduleName}::${name}`]\n                    if (node) {\n                        node.exportable = true\n                        node.alias = alias? alias : name\n                        // if the export clause includes an alias, then we have to update the id\n                        // since this is used to resolve imports and get calls \n                        node.id = `${this.id}::${node.alias}`\n\n                        // the node is exported from the same file \n                        if (moduleName === this.id) {\n                            delete this.children[`${this.id}::${name}`]\n                            this.children[node.id] = node\n                            const childrenNodes = Object.values(node.children)\n                            childrenNodes.forEach(n => {\n                                n.alias = n.name.replace(name, alias)\n                                delete node.children[n.id]\n                                n.id = `${this.id}::${n.alias}`\n                                node.children[n.id] = n\n                            })\n                        \n                        // it's using export { ... } from 'file'\n                        }\n                        // } else {\n                        //     node.exportable = true\n                        //     node.alias = alias? alias : name\n                        //     // add the node to the file node\n                        //     node.id = `${this.id}::${node.alias}`\n                        //     this.children[node.id] = node\n                        // }\n\n                    } \n                    // else {\n                    //     console.log(`Export clause ${name} not found in ${this.id}`)\n                    // }\n            }\n        })\n    }\n\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n        if (this.type !== 'file') return\n        const suffix = indexSuffixesMap[this.language];\n        const fileSet = new Set(allFiles.map(p => p.split('.').slice(0, -1).join('.')));\n        \n        this.importStatements.forEach((importStatement) => {\n            const possiblePaths = [\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}${suffix}`)),\n                ...importStatement.names.map(name => path.resolve(`${importStatement.path}/${name.name}`)),\n                path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\n                path.resolve(`${rootFolderPath}/${importStatement.path}`),\n                path.resolve(`${importStatement.path}${suffix}`),\n                path.resolve(importStatement.path)\n            ];\n    \n            for (const possiblePath of possiblePaths) {\n                if (fileSet.has(possiblePath)) {\n                    importStatement.path = possiblePath\n                    break;\n                }\n            }\n    \n            if (importStatement.path.startsWith('@/')) {\n                importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2));\n            }\n        });\n    }\n\n    getChildrenDefinitions(): {[id: string]: Node}{\n        if (!['file', 'header'].includes(this.type)) return {}\n        const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\n        const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\n        captures.sort((a, b) => b.node.startPosition.row - a.node.startPosition.row || b.node.startPosition.column - a.node.startPosition.column)\n        let exportable = ['python', 'php'].includes(this.language) ? true : false\n        let childrenNodes: Node[] = []\n    \n        captures.forEach((c)  => {\n            if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\n                const newNode  = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\n    \n                newNode.startPosition  = c.node.startPosition\n                newNode.endPosition  = c.node.endPosition\n                newNode.exportable = exportable\n                \n                // In many languages the documentation is the prev sibling\n                let prevTreeSitterNode = c.node.previousNamedSibling\n                if (prevTreeSitterNode) { \n                    // if the previous node is a comment and it's in the previous line\n                    if (treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\n                    prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                        newNode.documentation  = prevTreeSitterNode.text\n                    }\n    \n                }\n                childrenNodes.push(newNode)\n\n                // In python the decorator is the prev sibling\n                if (this.language === 'python') {\n                    prevTreeSitterNode = c.node.previousSibling\n                    if (prevTreeSitterNode) { \n                        if (['decorator'].includes(prevTreeSitterNode.type) &&\n                        prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1) {\n                            // include the decorator\n                            newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\n                        }\n                    }\n                }\n            }\n        })\n    \n        childrenNodes.forEach(n => {\n            // if (unnecessaryNodeTypes.includes(n.type)) return\n            let code = n.code\n            if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\n                if (n.type === 'method' ) {\n                    // Fix bug with methods\n                    code = `function ${n.code}`\n                    n.type = 'function'\n                } else if (n.type === 'assignment') code = `const ${n.code}`\n            } else if (['java'].includes(this.language)) {\n                if (n.type == 'function') {\n                    const firstLine = code.split('(')[0]\n                    const firstLineSplit = firstLine.split(' ')\n                    // if has no return type, add void between modifier and name\n                    if (firstLineSplit.length !== 3) {\n                        code = code.replace(firstLine, `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`)\n                    }\n                }\n            }\n            \n            let captures = captureQuery(this.language, 'definitionTemplate', code)\n            // console.log(`/////${n.type}, ${n.language}/////`)\n            // console.log(`${code}`)\n            // console.log('--------------')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\n            // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n            captures.forEach((c)  =>  {\n                switch (c.name) {\n                    case 'modifier': // java, php only\n                        if (['php', 'java'].includes(n.language) && c.node.text.includes('public')) n.exportable = true\n                        break\n                    case 'name':\n                        n.name = c.node.text\n                        n.id = `${n.id}::${n.name}`\n                        break\n                    case 'alias':\n                        n.alias  = c.node.text\n                        break\n                    case 'documentation':\n                        n.documentation = c.node.text\n                        if (n.language === 'python') {\n                            n.code = n.code.replace(n.documentation, '')\n                            n.body = n.body.replace(n.documentation, '')\n                        }\n                        break\n                    case 'body':\n                        n.body  = c.node.text\n                        break\n                }\n            })\n            if (!n.alias) n.alias = n.name\n    \n            if (n.type === 'assignment') {\n                const assignmentCaptures = captureQuery(this.language, 'extraAssignmentCode', this.code, n.name)\n                // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\n                assignmentCaptures.forEach((c)  =>  {\n                    if (c.name === 'code') n.code += '\\n' + c.node.text\n                })\n            }\n        })\n    \n        // must have a name\n        childrenNodes = childrenNodes.filter(c => c.name)\n    \n        childrenNodes.forEach((n, i) => {\n            for (let j = i+1; j < childrenNodes.length; j++) {\n                n.addNodeRelationship(childrenNodes[j])\n                childrenNodes[j].addNodeRelationship(n)\n            }\n            if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\n        })\n    \n        // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\n        const nodesMap = childrenNodes.reduce<{[id: string]: Node}>((map, n)  =>  {\n            if (!unnecessaryNodeTypes.includes(n.type)) map[n.id]  = n\n            return map\n        }, {})\n        return nodesMap\n    }\n\n    simplify(attributes: string[] = []) {\n        const allAttributes: { [key: string]: any } = {\n            id: this.id,\n            type: this.type,\n            name: this.name,\n            label: this.alias,\n            language: this.language,\n            exportable: this.exportable,\n            totalTokens: this.totalTokens,\n            documentation: this.documentation,\n            code: this.parent && ['class', 'interface'].includes(this.parent?.type)  ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}` : this.code,\n            codeNoBody: this.getCodeWithoutBody(),\n            importStatements: this.importStatements.map(i => i.code),\n            parent: this.parent?.id,\n            children: Object.keys(this.children),\n            calls: this.calls.map(c => c.node.id),\n            inDegree: this.inDegree,\n            outDegree: this.outDegree\n        };\n    \n        if (attributes.length === 0) {\n            return allAttributes;\n        }\n    \n        return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\n            if (allAttributes.hasOwnProperty(attr)) {\n                acc[attr] = allAttributes[attr];\n            }\n            return acc;\n        }, {});\n    }\n}\n\n\nexport class Codebase {\n     // NOTE: rootFolderPath should be an absolute path\n    rootFolderPath: string = ''\n    nodesMap: { [id: string]: Node } = {}\n\n    constructor(rootFolderPath: string)  { this.rootFolderPath  = rootFolderPath }\n    addNode(node: Node) { this.nodesMap[node.id] = node; }\n    getNode(id: string): Node | undefined { return this.nodesMap[id];  }\n    addNodeMap(nodeMap: {[id: string]: Node}) { this.nodesMap  = {...this.nodesMap, ...nodeMap} }\n\n    async generateNodesFromFilePath(filePath: string): Promise<{nodesMap: {[id: string]: Node}, isHeader: boolean}> {\n        const fileExtension  = filePath.split('.').pop()\n        if (!fileExtension) return {nodesMap : {}, isHeader: false}\n        const data = await fs.readFile(filePath)\n        const dataString = Buffer.from(data).toString()\n        // Nodes are created using id, code, type, language. The id does not include the extension\n        const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\n        \n        let fileNode\n        let isHeader = false\n        // Special case: .h files (headers)\n        if (fileExtension === 'h') {\n            fileNode = new Node(`${filePathNoExtension}::header`, dataString, 'header', languageExtensionMap[fileExtension])\n            isHeader = true\n        } else {\n            fileNode = new Node(filePathNoExtension, dataString, 'file', languageExtensionMap[fileExtension])\n        }\n        fileNode.name = filePath\n        fileNode.alias = filePath.split('/').pop() || ''\n        const nodesMap = fileNode.getChildrenDefinitions()\n        fileNode.generateImports()\n        fileNode.parseExportClauses(this.nodesMap)\n        nodesMap[fileNode.id] = fileNode\n\n        // get tokens\n        Object.values(nodesMap).forEach(n => n.totalTokens = enc.encode(n.code, 'all', []).length)\n\n        return {nodesMap, isHeader}\n    }\n    \n\n    async parseFolder(): Promise<{[id: string]: Node}> {\n        if (!this.rootFolderPath) return {}\n        const fileNodesMap: {[id: string]: Node} = {}\n        const allFiles = await getAllFiles(this.rootFolderPath)\n        for (const filePath of allFiles) { // can't be forEach\n            let id = filePath.split('.').slice(0, -1).join('.')\n            try {\n                const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\n                this.addNodeMap(nodesMap)\n                id = isHeader ? `${id}::header` : id\n                const fileNode = nodesMap[id]\n                fileNodesMap[id] = fileNode\n                fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\n            } catch (error: any) {\n                console.log(`Cannot parse file Id ${id}`)\n                console.log(error.message)\n                throw error\n            }\n        }\n        // python special case\n        this.resolvePythonInitImportStatements()\n        this.resolveImportStatementsNodes()\n        return fileNodesMap \n    }\n\n    getCalls(fileNodesMap: {[id: string]: Node}, verbose: boolean = false) {\n        Object.keys(fileNodesMap).forEach(fileId => {\n            const fileNode = fileNodesMap[fileId]\n            if (Object.values(fileNode.children).length === 0) {\n                if (verbose) console.log(`File ${fileId} has no children`)\n                return\n            }\n\n            const callsCapturer = new CallsCapturer(fileNode, verbose)\n            const nodes: Node[] = [fileNode , ...fileNode.getAllChildren()]\n            nodes.forEach((n: Node) => {\n                const callNodeIds = callsCapturer.getCallsFromNode(fileId, n)\n                // const importFromFailed: Set<string> = new Set()\n                // console.log( `### ${n.id}`)\n                // console.log(n.code)\n                // console.log(calls)\n                Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\n                    // if (importFromFailed.has(c.importFrom)) return\n                    const calledNode = this.nodesMap[nodeId]\n                    if (calledNode) {\n                        n.addCall(calledNode, lines) // first line\n                        // console.log(`Added call from ${n.id} to ${calledNode.id}`)\n                    } else {\n                        if (verbose) console.log(`Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`)\n                        // importFromFailed.add(c.importFrom)\n                    }\n                })\n            })\n        })\n    }\n\n    simplify(attributes: string[] = []) {\n        return Object.values(this.nodesMap).map( n => n.simplify(attributes))\n\n    }\n\n    getLinks(): Link[] {\n        const links: Link[] = []\n        const nodes = Object.values(this.nodesMap)\n        for (const n of nodes){\n            if (n.parent) {\n                // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\n                const label = 'defines'\n                links.push({source: n.parent.id, target: n.id, label, line: null})\n            }\n            if (n.calls.length > 0) n.calls.forEach(c => links.push({source: n.id, target: c.node.id, label: 'calls', line: c.lines[0]}))\n        }\n        return links\n    }\n\n    resolvePythonInitImportStatements() {\n        // THIS IS A TEMPORARY FIX\n        // In many cases, the __init__.py file just contains the import statements for the other files\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (n.type !== 'file' || n.language !== 'python') return\n            let newImportStatements: ImportStatement[] = [...n.importStatements]\n            n.importStatements.forEach(i => {\n                if (i.path.endsWith('__init__')) {\n                    newImportStatements = newImportStatements.filter(s => s.path != i.path)\n                    newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\n                }\n            })\n            n.importStatements = newImportStatements\n        })\n    }\n\n    resolveImportStatementsNodes() {\n        const nodes = Object.values(this.nodesMap)\n        nodes.forEach(n => {\n            if (!['file', 'header'].includes(n.type) ) return\n            n.importStatements.forEach(i => {\n                i.names.forEach(n => {\n                    n.node = this.nodesMap[`${i.path}::${n.name}`]\n                })\n                const namesIds = i.names.map(n => n.node?.id || '')\n                namesIds.forEach(id => {\n                    this.nodesMap[id]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                })\n                if (['c', 'cpp'].includes(n.language)) {\n                    const headerNode = this.nodesMap[i.path]\n                    if (headerNode) {\n                        this.resolveHeaderC(n, headerNode)\n                    }\n                }  \n                // cases like import *, #define \"file\", etc.\n                if (i.names.length === 0) {\n                    this.nodesMap[i.path]?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header']).forEach(c => {\n                        const newName = new ImportName(c.alias, c.alias)\n                        newName.node = c\n                        i.names.push(newName)\n                    })\n                }\n                \n            })\n        })\n    }\n\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n        if ( headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\n        const childIds = headerNode.getAllChildren().map(c => c.id)\n        childIds.forEach(id => {\n            const nodeRef = fileNode.getAllChildren().find(c => c.id === id.replace('::header', ''))\n            if (nodeRef) {\n                delete this.nodesMap[id]\n                headerNode.removeChild(headerNode.children[id])\n                headerNode.addChild(nodeRef)\n                headerNode.children[nodeRef.id] = nodeRef\n                headerNode.inDegree++\n            }\n        })\n    }\n\n}\n\n\n",
    "importStatements": [
      "import fs from 'node:fs/promises';",
      "import { Point } from 'tree-sitter'",
      "import {\n    captureQuery,\n    getAllFiles,\n    renameSource,\n    getCalledNode,\n    cleanDefCaptures\n} from \"./utils\"",
      "import {\n    languageExtensionMap,\n    AllowedTypes,\n    newClassMethodsMap,\n    indexSuffixesMap,\n    AllowedTypesArray,\n    treeSitterCommentTypes\n} from \"./consts\"",
      "import { CallsCapturer } from './calls';",
      "import path from 'path'",
      "import {  encoding_for_model } from \"tiktoken\";"
    ],
    "codeNoBody": "import fs from 'node:fs/promises';\nimport { Point } from 'tree-sitter'\nimport {\n    captureQuery,\n    getAllFiles,\n    renameSource,\n    getCalledNode,\n    cleanDefCaptures\n} from \"./utils\"\nimport {\n    languageExtensionMap,\n    AllowedTypes,\n    newClassMethodsMap,\n    indexSuffixesMap,\n    AllowedTypesArray,\n    treeSitterCommentTypes\n} from \"./consts\"\nimport { CallsCapturer } from './calls';\nimport path from 'path'\nimport {  encoding_for_model } from \"tiktoken\";\nconst enc = encoding_for_model(\"gpt-4-turbo\");\nexport class ImportName {\n       //...\n       }\nexport class ImportStatement {\n       //...\n       }\n\ninterface Link {\n//...\n}\n\ntype NodeCallTuple = {node: Node, lines: number[]} // nodeId, first line\n\nexport class Node {\n       //...\n       }\n\n\nexport class Codebase {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::treeSitterCommentTypes",
    "language": "typescript",
    "label": "treeSitterCommentTypes",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 17,
    "inDegree": 1,
    "outDegree": 1,
    "code": "treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": [],
    "codeNoBody": "treeSitterCommentTypes ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::indexSuffixesMap",
    "language": "typescript",
    "label": "indexSuffixesMap",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 76,
    "inDegree": 1,
    "outDegree": 1,
    "code": "indexSuffixesMap: Record<string, string> = {\n    'python': '/__init__',\n    'javascript': '/index',\n    'typescript': '/index',\n    'tsx': '/index',\n    'java': '', // java has no index\n    'rust': '', // rust has no index\n    'php': '', // php has no index\n}",
    "importStatements": [],
    "codeNoBody": "indexSuffixesMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::itselfClassMap",
    "language": "typescript",
    "label": "itselfClassMap",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 62,
    "inDegree": 1,
    "outDegree": 1,
    "code": "itselfClassMap: Record<string, string> = {\n    'python': 'self',\n    'javascript': 'this',\n    'typescript': 'this',\n    'tsx': 'this',\n    'java': 'this',\n    'rust': 'self',\n    'php': '$this'\n}",
    "importStatements": [],
    "codeNoBody": "itselfClassMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::newClassMethodsMap",
    "language": "typescript",
    "label": "newClassMethodsMap",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 72,
    "inDegree": 1,
    "outDegree": 1,
    "code": "newClassMethodsMap: Record<string, string> = {\n    'python': '__init__',\n    'javascript': 'constructor',\n    'typescript': 'constructor',\n    'tsx': 'constructor',\n    'java': '', // java constructor has the same name as the class\n    'rust': 'new',\n    'php': '__construct'\n}",
    "importStatements": [],
    "codeNoBody": "newClassMethodsMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::languageExtensionMap",
    "language": "typescript",
    "label": "languageExtensionMap",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 93,
    "inDegree": 3,
    "outDegree": 1,
    "code": "languageExtensionMap: Record<string, string> = {\n  'py': 'python',\n  'c': 'c',\n  'h': 'c',\n  // 'ipynb': 'python',\n  'js': 'typescript',\n  'mjs': 'typescript',\n  'jsx': 'typescript',\n  'ts': 'typescript',\n  'tsx': 'tsx',\n  'java': 'java',\n  'php': 'php'\n}",
    "importStatements": [],
    "codeNoBody": "languageExtensionMap: Record<string, string> ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::languages",
    "language": "typescript",
    "label": "languages",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 26,
    "inDegree": 1,
    "outDegree": 1,
    "code": "languages = {\n    JavaScript,\n    Python,\n    TypeScript,\n    TSX,\n    Java,\n    C,\n    PHP\n}",
    "importStatements": [],
    "codeNoBody": "languages ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::excludedExtensions",
    "language": "typescript",
    "label": "excludedExtensions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 30,
    "inDegree": 1,
    "outDegree": 1,
    "code": "excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']",
    "importStatements": [],
    "codeNoBody": "excludedExtensions ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::excludedFolders",
    "language": "typescript",
    "label": "excludedFolders",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 42,
    "inDegree": 1,
    "outDegree": 1,
    "code": "excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']",
    "importStatements": [],
    "codeNoBody": "excludedFolders ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::AllowedTypesArray",
    "language": "typescript",
    "label": "AllowedTypesArray",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 57,
    "inDegree": 1,
    "outDegree": 2,
    "code": "AllowedTypesArray: AllowedTypes[] = [\n    'function', 'class', 'interface', 'method', 'enum', \n    'struct', 'export', 'type', 'assignment', 'file', 'union',\n    'namespace', 'mod', 'header'\n  ]",
    "importStatements": [],
    "codeNoBody": "AllowedTypesArray: AllowedTypes[] ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::AllowedTypes",
    "language": "typescript",
    "label": "AllowedTypes",
    "type": "type",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 60,
    "inDegree": 7,
    "outDegree": 2,
    "code": "type AllowedTypes = 'function' | 'class' | 'interface' | 'method' | 'enum' | 'struct' | 'export' | 'type' | 'assignment' | 'file' | 'union' | 'namespace' | 'mod' | 'header' ;",
    "importStatements": [],
    "codeNoBody": "type AllowedTypes =  ;{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::PHP",
    "language": "typescript",
    "label": "PHP",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 10,
    "inDegree": 0,
    "outDegree": 1,
    "code": "PHP = require(\"tree-sitter-php\").php",
    "importStatements": [],
    "codeNoBody": "PHP ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::C",
    "language": "typescript",
    "label": "C",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "C = require(\"tree-sitter-c\")",
    "importStatements": [],
    "codeNoBody": "C ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::Java",
    "language": "typescript",
    "label": "Java",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Java = require(\"tree-sitter-java\")",
    "importStatements": [],
    "codeNoBody": "Java ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::TSX",
    "language": "typescript",
    "label": "TSX",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TSX = require(\"tree-sitter-typescript\").tsx",
    "importStatements": [],
    "codeNoBody": "TSX ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::TypeScript",
    "language": "typescript",
    "label": "TypeScript",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "TypeScript  = require('tree-sitter-typescript').typescript",
    "importStatements": [],
    "codeNoBody": "TypeScript  ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::Python",
    "language": "typescript",
    "label": "Python",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "Python = require(\"tree-sitter-python\")",
    "importStatements": [],
    "codeNoBody": "Python ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts::JavaScript",
    "language": "typescript",
    "label": "JavaScript",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "totalTokens": 10,
    "inDegree": 0,
    "outDegree": 1,
    "code": "JavaScript = require(\"tree-sitter-javascript\")",
    "importStatements": [],
    "codeNoBody": "JavaScript ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/consts",
    "language": "typescript",
    "label": "consts.ts",
    "type": "file",
    "totalTokens": 709,
    "inDegree": 17,
    "outDegree": 1,
    "code": "// const Ruby = require(\"tree-sitter-ruby\");\n// const Rust = require(\"tree-sitter-rust\");\nconst JavaScript = require(\"tree-sitter-javascript\");\nconst Python = require(\"tree-sitter-python\");\nconst TypeScript  = require('tree-sitter-typescript').typescript;\nconst TSX = require(\"tree-sitter-typescript\").tsx;\nconst Java = require(\"tree-sitter-java\");\nconst C = require(\"tree-sitter-c\");\nconst PHP = require(\"tree-sitter-php\").php;\n\n// namespace, mod and header are equivalent:\n// - a namespace define a scope that contains a set of declarations\n// - a mod defined a module, which contains a set of declarations\n// - a header is a file that contains a set of declarations\nexport type AllowedTypes = 'function' | 'class' | 'interface' | 'method' | 'enum' | 'struct' | 'export' | 'type' | 'assignment' | 'file' | 'union' | 'namespace' | 'mod' | 'header' ; \n\nexport const AllowedTypesArray: AllowedTypes[] = [\n    'function', 'class', 'interface', 'method', 'enum', \n    'struct', 'export', 'type', 'assignment', 'file', 'union',\n    'namespace', 'mod', 'header'\n  ]\n\nexport const excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']\nexport const excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']\n\nexport const languages = {\n    JavaScript,\n    Python,\n    TypeScript,\n    TSX,\n    Java,\n    C,\n    PHP\n}\n\n\nexport const languageExtensionMap: Record<string, string> = {\n  'py': 'python',\n  'c': 'c',\n  'h': 'c',\n  // 'ipynb': 'python',\n  'js': 'typescript',\n  'mjs': 'typescript',\n  'jsx': 'typescript',\n  'ts': 'typescript',\n  'tsx': 'tsx',\n  'java': 'java',\n  'php': 'php'\n}\n\nexport const newClassMethodsMap: Record<string, string> = {\n    'python': '__init__',\n    'javascript': 'constructor',\n    'typescript': 'constructor',\n    'tsx': 'constructor',\n    'java': '', // java constructor has the same name as the class\n    'rust': 'new',\n    'php': '__construct'\n}\n\nexport const itselfClassMap: Record<string, string> = {\n    'python': 'self',\n    'javascript': 'this',\n    'typescript': 'this',\n    'tsx': 'this',\n    'java': 'this',\n    'rust': 'self',\n    'php': '$this'\n}\n\nexport const indexSuffixesMap: Record<string, string> = {\n    'python': '/__init__',\n    'javascript': '/index',\n    'typescript': '/index',\n    'tsx': '/index',\n    'java': '', // java has no index\n    'rust': '', // rust has no index\n    'php': '', // php has no index\n}\n\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": [
      "const JavaScript = require(\"tree-sitter-javascript\");",
      "const Python = require(\"tree-sitter-python\");",
      "const TypeScript  = require('tree-sitter-typescript').typescript;",
      "const TSX = require(\"tree-sitter-typescript\").tsx;",
      "const Java = require(\"tree-sitter-java\");",
      "const C = require(\"tree-sitter-c\");",
      "const PHP = require(\"tree-sitter-php\").php;"
    ],
    "codeNoBody": "// const Ruby = require(\"tree-sitter-ruby\");\n// const Rust = require(\"tree-sitter-rust\");\nconst JavaScript = require(\"tree-sitter-javascript\");\nconst Python = require(\"tree-sitter-python\");\nconst TypeScript  = require('tree-sitter-typescript').typescript;\nconst TSX = require(\"tree-sitter-typescript\").tsx;\nconst Java = require(\"tree-sitter-java\");\nconst C = require(\"tree-sitter-c\");\nconst PHP = require(\"tree-sitter-php\").php;\n// namespace, mod and header are equivalent:\n// - a namespace define a scope that contains a set of declarations\n// - a mod defined a module, which contains a set of declarations\n// - a header is a file that contains a set of declarations\nexport type AllowedTypes = 'function' | 'class' | 'interface' | 'method' | 'enum' | 'struct' | 'export' | 'type' | 'assignment' | 'file' | 'union' | 'namespace' | 'mod' | 'header' ; \n\nexport const AllowedTypesArray: AllowedTypes[] = [\n    'function', 'class', 'interface', 'method', 'enum', \n    'struct', 'export', 'type', 'assignment', 'file', 'union',\n    'namespace', 'mod', 'header'\n  ]\n\nexport const excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']\nexport const excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']\n\nexport const languages = {\n    JavaScript,\n    Python,\n    TypeScript,\n    TSX,\n    Java,\n    C,\n    PHP\n}\n\n\nexport const languageExtensionMap: Record<string, string> = {\n  'py': 'python',\n  'c': 'c',\n  'h': 'c',\n  // 'ipynb': 'python',\n  'js': 'typescript',\n  'mjs': 'typescript',\n  'jsx': 'typescript',\n  'ts': 'typescript',\n  'tsx': 'tsx',\n  'java': 'java',\n  'php': 'php'\n}\n\nexport const newClassMethodsMap: Record<string, string> = {\n    'python': '__init__',\n    'javascript': 'constructor',\n    'typescript': 'constructor',\n    'tsx': 'constructor',\n    'java': '', // java constructor has the same name as the class\n    'rust': 'new',\n    'php': '__construct'\n}\n\nexport const itselfClassMap: Record<string, string> = {\n    'python': 'self',\n    'javascript': 'this',\n    'typescript': 'this',\n    'tsx': 'this',\n    'java': 'this',\n    'rust': 'self',\n    'php': '$this'\n}\n\nexport const indexSuffixesMap: Record<string, string> = {\n    'python': '/__init__',\n    'javascript': '/index',\n    'typescript': '/index',\n    'tsx': '/index',\n    'java': '', // java has no index\n    'rust': '', // rust has no index\n    'php': '', // php has no index\n}\n\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::getCalledNode",
    "language": "typescript",
    "label": "getCalledNode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 76,
    "inDegree": 0,
    "outDegree": 3,
    "code": "function getCalledNode(callName: string, importFrom: string, importedFileNodes: Record<string, {fileNode: Node, importStatement: ImportStatement}>) {\n    const importedFile = importedFileNodes[importFrom].fileNode\n    const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`)\n    return calledNode\n}",
    "importStatements": [],
    "codeNoBody": "function getCalledNode(callName: string, importFrom: string, importedFileNodes: Record<string, {fileNode: Node, importStatement: ImportStatement}>){\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::cleanAndSplitContent",
    "language": "typescript",
    "label": "cleanAndSplitContent",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 120,
    "inDegree": 1,
    "outDegree": 1,
    "code": "const cleanAndSplitContent = (content: string): string[] => {\n    // Remove parentheses and their contents, newlines, and unwanted characters\n    // Replace ':' and '|' with ','\n    content = content.replace(/\\(|\\)|\\n|\\s{2,}/gs, '')\n                     .replace(/[:|]/g, ',')\n                     .trim();\n  \n    // Split the content by commas, remove surrounding brackets/braces, and trim each part\n    return content.split(',').map(item => item.replace(/[\\[\\]\\{\\}]/g, '').trim());\n  }",
    "importStatements": [],
    "codeNoBody": "const cleanAndSplitContent = (content: string): string[] =>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::firstConsecutiveDots",
    "language": "typescript",
    "label": "firstConsecutiveDots",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 38,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function firstConsecutiveDots(s: string): number {\n    const match = s.match(/^\\.{1,}/);\n    return match ? match[0].length : 0;\n}",
    "importStatements": [],
    "codeNoBody": "function firstConsecutiveDots(s: string): number{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::renameSource",
    "language": "typescript",
    "label": "renameSource",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 352,
    "inDegree": 1,
    "outDegree": 3,
    "code": "function renameSource(filePath: string, sourceName: string, language: string): string {\n    let newSourceName = sourceName\n    const sourceNameSplit = sourceName.split('.')\n    const sourceNameExtension = sourceNameSplit.slice(-1)[0]\n    // remove extension if is in languageExtensionMap\n    if (Object.keys(languageExtensionMap).includes(sourceNameExtension)) newSourceName = sourceNameSplit.slice(0, -1).join('.')\n    const fileDirectory = filePath.split('/').slice(0, -1).join('/')\n    \n    if ((['javascript', 'typescript', 'tsx', 'java', 'c', 'cpp', 'csharp'].includes(language) && newSourceName.startsWith('.') ||\n        (['c', 'cpp', 'csharp'].includes(language) && !newSourceName.startsWith('<'))) ) {\n        newSourceName = path.join(fileDirectory, newSourceName)\n        if (['c', 'cpp'].includes(language) && sourceNameExtension == 'h' ) {\n            newSourceName += '::header'\n        }\n    } else if ( language == 'python') {\n        const dotCount = firstConsecutiveDots(newSourceName)\n        newSourceName = newSourceName.replace(/\\./g, '/')\n        if (dotCount) {\n            if (dotCount == 1) {\n                newSourceName = path.join(fileDirectory, newSourceName)\n            } else {\n                const moveUpCount = dotCount - 1\n                const newDirectory = fileDirectory.split('/').slice(0, -moveUpCount).join('/')\n                newSourceName = path.join(newDirectory, newSourceName)\n            }\n        }\n    }\n    return newSourceName\n}",
    "importStatements": [],
    "codeNoBody": "function renameSource(filePath: string, sourceName: string, language: string): string{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::cleanDefCaptures",
    "language": "typescript",
    "label": "cleanDefCaptures",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 156,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function cleanDefCaptures(captures: Parser.QueryCapture[], keyword: string = 'name') : Parser.QueryCapture[] {\n    captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\n    let keywordSeen = false\n    \n    const updatedCaptures = []\n    for (let i = 0; i < captures.length; i++) {\n        if (captures[i].name === keyword) {\n            if (!keywordSeen) {\n                updatedCaptures.push(captures[i])\n                keywordSeen = true\n            }\n            else break\n        } else {\n            updatedCaptures.push(captures[i])\n        }\n\n        \n    }\n    return updatedCaptures\n}",
    "importStatements": [],
    "codeNoBody": "function cleanDefCaptures(captures: Parser.QueryCapture[], keyword: string = 'name') : Parser.QueryCapture[]{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::captureQuery",
    "language": "typescript",
    "label": "captureQuery",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 305,
    "inDegree": 5,
    "outDegree": 3,
    "code": "function captureQuery(language: string, queryName: keyof treeSitterQueries, code: string, queryArg?: string) : Parser.QueryCapture[] {\n    const { parser, queries } = getRequiredDefinitions(language)\n    const treeSitterQuery = (queryName === 'extraAssignmentCode') ? queries[queryName](queryArg || '') : queries[queryName] as string\n    let uniqueCaptures = []\n    try {\n        const query = new Parser.Query(parser.getLanguage(), treeSitterQuery)\n        if (language === 'php' && !code.includes('<?php')){\n            code = `<?php\\n${code}`\n        }\n        const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024})\n        const captures = query.captures(tree.rootNode)\n        const uniqueMap = new Map();\n        captures.forEach(c => {\n            const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\n            if (!uniqueMap.has(key)) {\n                uniqueMap.set(key, c);\n            }\n        });\n\n        uniqueCaptures = Array.from(uniqueMap.values());\n        \n    } catch (error: any) {\n        const errorMessage = `${language} captureQuery ${queryName}${queryArg ? '(' + queryArg + ')' : ''}: ${error.message}`\n        throw Error(errorMessage)\n    }\n    return uniqueCaptures\n}",
    "importStatements": [],
    "codeNoBody": "function captureQuery(language: string, queryName: keyof treeSitterQueries, code: string, queryArg?: string) : Parser.QueryCapture[]{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::getRequiredDefinitions",
    "language": "typescript",
    "label": "getRequiredDefinitions",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 235,
    "inDegree": 1,
    "outDegree": 4,
    "code": "function getRequiredDefinitions(language: string): { parser: Parser, queries: treeSitterQueries} {\n    const parser = new Parser()\n    let queries\n    switch (language) {\n        case 'javascript':\n            parser.setLanguage(languages.JavaScript)\n            queries = languageQueries.Javascript\n            break\n        case 'python':\n            parser.setLanguage(languages.Python)\n            queries = languageQueries.Python\n            break\n        case 'typescript':\n            parser.setLanguage(languages.TypeScript)\n            queries = languageQueries.Typescript\n            break\n        case 'tsx':\n            parser.setLanguage(languages.TSX)\n            queries = languageQueries.Typescript\n            break\n        case 'java':\n            parser.setLanguage(languages.Java)\n            queries = languageQueries.Java\n            break\n        case 'c':\n            parser.setLanguage(languages.C)\n            queries = languageQueries.C\n            break\n        case 'php':\n            parser.setLanguage(languages.PHP)\n            queries = languageQueries.PHP\n            break\n        default:\n            throw new Error(`Language ${language} not supported.`)\n    }\n    return { parser, queries }\n}",
    "importStatements": [],
    "codeNoBody": "function getRequiredDefinitions(language: string): { parser: Parser, queries: treeSitterQueries}{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::getTotalSize",
    "language": "typescript",
    "label": "getTotalSize",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 84,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\n    const matchingFiles = await getAllFiles(rootFolderPath);\n    const sizes = await Promise.all(matchingFiles.map(async (file) => {\n        const { size } = await fs.stat(file);\n        return size;\n    }));\n    const totalSize = sizes.reduce((acc, size) => acc + size, 0);\n    return totalSize;\n}",
    "importStatements": [],
    "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils::getAllFiles",
    "language": "typescript",
    "label": "getAllFiles",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "totalTokens": 208,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n    const extensionsPattern =  Object.keys(languageExtensionMap).map(ext => `\\\\.${ext}$`).join('|');\n    const regex = new RegExp(extensionsPattern);\n    const excludedExtensionPattern = new RegExp(excludedExtensions.map(ext  => `\\\\.${ext}$`).join('|'));\n    const excludedFolderPattern = new RegExp(excludedFolders.map(f => `${f}/`).join('|'))\n    const files = await glob(`**/*`, {\n        cwd: rootFolderPath,\n        absolute: true\n    })\n    // no sync\n    const validFiles = await Promise.all(files.map(async (file) => (await fs.lstat(file)).isFile()))\n    const matchingFiles  = files.filter((file, i)  => regex.test(file) && validFiles[i] && !excludedExtensionPattern.test(file) && !excludedFolderPattern.test(file) && !file.includes('@'))\n    matchingFiles.sort() // sorted\n    return matchingFiles;\n}",
    "importStatements": [],
    "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/model/utils",
    "language": "typescript",
    "label": "utils.ts",
    "type": "file",
    "totalTokens": 2004,
    "inDegree": 9,
    "outDegree": 3,
    "code": "import {\n    languageExtensionMap,\n    excludedFolders,\n    excludedExtensions,\n    languages,\n} from \"./consts\"\nimport { treeSitterQueries, languageQueries } from \"../queries\"\nimport { glob } from 'glob'\nimport fs from 'node:fs/promises';\nimport path from 'path'\nimport Parser from 'tree-sitter';\nimport { Node, ImportStatement } from './codebase'\n\n/**\n * Get a list of all files in a given folder, including only files with the given extensions\n * from languageExtensionMap, and excluding from excludedExtensions\n * \n * @param rootFolderPath - The root folder to search in\n * @returns - The list of files from the given folder\n */\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n    const extensionsPattern =  Object.keys(languageExtensionMap).map(ext => `\\\\.${ext}$`).join('|');\n    const regex = new RegExp(extensionsPattern);\n    const excludedExtensionPattern = new RegExp(excludedExtensions.map(ext  => `\\\\.${ext}$`).join('|'));\n    const excludedFolderPattern = new RegExp(excludedFolders.map(f => `${f}/`).join('|'))\n    const files = await glob(`**/*`, {\n        cwd: rootFolderPath,\n        absolute: true\n    })\n    // no sync\n    const validFiles = await Promise.all(files.map(async (file) => (await fs.lstat(file)).isFile()))\n    const matchingFiles  = files.filter((file, i)  => regex.test(file) && validFiles[i] && !excludedExtensionPattern.test(file) && !excludedFolderPattern.test(file) && !file.includes('@'))\n    matchingFiles.sort() // sorted\n    return matchingFiles;\n}\n\n/**\n * Get the total size of all files returned by getAllFiles\n * \n * @param rootFolderPath - The root folder to search in\n * @returns - The total size in bytes of the matching files\n */\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n    const matchingFiles = await getAllFiles(rootFolderPath);\n    const sizes = await Promise.all(matchingFiles.map(async (file) => {\n        const { size } = await fs.stat(file);\n        return size;\n    }));\n    const totalSize = sizes.reduce((acc, size) => acc + size, 0);\n    return totalSize;\n}\n\n/**\n * Returns the Tree-Sitter parser and queries for a given language\n * @param language - The language to use\n * @returns - The parser and queries for the given language\n */\nexport function getRequiredDefinitions(language: string): { parser: Parser, queries: treeSitterQueries} {\n    const parser = new Parser()\n    let queries\n    switch (language) {\n        case 'javascript':\n            parser.setLanguage(languages.JavaScript)\n            queries = languageQueries.Javascript\n            break\n        case 'python':\n            parser.setLanguage(languages.Python)\n            queries = languageQueries.Python\n            break\n        case 'typescript':\n            parser.setLanguage(languages.TypeScript)\n            queries = languageQueries.Typescript\n            break\n        case 'tsx':\n            parser.setLanguage(languages.TSX)\n            queries = languageQueries.Typescript\n            break\n        case 'java':\n            parser.setLanguage(languages.Java)\n            queries = languageQueries.Java\n            break\n        case 'c':\n            parser.setLanguage(languages.C)\n            queries = languageQueries.C\n            break\n        case 'php':\n            parser.setLanguage(languages.PHP)\n            queries = languageQueries.PHP\n            break\n        default:\n            throw new Error(`Language ${language} not supported.`)\n    }\n    return { parser, queries }\n}\n\n/**\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\n * \n * @param language - The language to use\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\n * @param code - The code to parse\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\n * @returns \n */\nexport function captureQuery(language: string, queryName: keyof treeSitterQueries, code: string, queryArg?: string) : Parser.QueryCapture[] {\n    const { parser, queries } = getRequiredDefinitions(language)\n    const treeSitterQuery = (queryName === 'extraAssignmentCode') ? queries[queryName](queryArg || '') : queries[queryName] as string\n    let uniqueCaptures = []\n    try {\n        const query = new Parser.Query(parser.getLanguage(), treeSitterQuery)\n        if (language === 'php' && !code.includes('<?php')){\n            code = `<?php\\n${code}`\n        }\n        const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024})\n        const captures = query.captures(tree.rootNode)\n        const uniqueMap = new Map();\n        captures.forEach(c => {\n            const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\n            if (!uniqueMap.has(key)) {\n                uniqueMap.set(key, c);\n            }\n        });\n\n        uniqueCaptures = Array.from(uniqueMap.values());\n        \n    } catch (error: any) {\n        const errorMessage = `${language} captureQuery ${queryName}${queryArg ? '(' + queryArg + ')' : ''}: ${error.message}`\n        throw Error(errorMessage)\n    }\n    return uniqueCaptures\n}\n\n/**\n * Returns a cleaned list of captures up to the first occurence of the given keyword\n * @param captures - The captures to clean\n * @param keyword - The keyword to stop at\n */\nexport function cleanDefCaptures(captures: Parser.QueryCapture[], keyword: string = 'name') : Parser.QueryCapture[] {\n    captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\n    let keywordSeen = false\n    \n    const updatedCaptures = []\n    for (let i = 0; i < captures.length; i++) {\n        if (captures[i].name === keyword) {\n            if (!keywordSeen) {\n                updatedCaptures.push(captures[i])\n                keywordSeen = true\n            }\n            else break\n        } else {\n            updatedCaptures.push(captures[i])\n        }\n\n        \n    }\n    return updatedCaptures\n}\n\n/**\n * Rename the sourceName if it is a relative to filePath\n * @param filePath - The filePath to rename from\n * @param sourceName - The sourceName to rename to\n * @param language - The language to rename from\n * @returns The renamed sourceName\n */\nexport function renameSource(filePath: string, sourceName: string, language: string): string {\n    let newSourceName = sourceName\n    const sourceNameSplit = sourceName.split('.')\n    const sourceNameExtension = sourceNameSplit.slice(-1)[0]\n    // remove extension if is in languageExtensionMap\n    if (Object.keys(languageExtensionMap).includes(sourceNameExtension)) newSourceName = sourceNameSplit.slice(0, -1).join('.')\n    const fileDirectory = filePath.split('/').slice(0, -1).join('/')\n    \n    if ((['javascript', 'typescript', 'tsx', 'java', 'c', 'cpp', 'csharp'].includes(language) && newSourceName.startsWith('.') ||\n        (['c', 'cpp', 'csharp'].includes(language) && !newSourceName.startsWith('<'))) ) {\n        newSourceName = path.join(fileDirectory, newSourceName)\n        if (['c', 'cpp'].includes(language) && sourceNameExtension == 'h' ) {\n            newSourceName += '::header'\n        }\n    } else if ( language == 'python') {\n        const dotCount = firstConsecutiveDots(newSourceName)\n        newSourceName = newSourceName.replace(/\\./g, '/')\n        if (dotCount) {\n            if (dotCount == 1) {\n                newSourceName = path.join(fileDirectory, newSourceName)\n            } else {\n                const moveUpCount = dotCount - 1\n                const newDirectory = fileDirectory.split('/').slice(0, -moveUpCount).join('/')\n                newSourceName = path.join(newDirectory, newSourceName)\n            }\n        }\n    }\n    return newSourceName\n}\n\nfunction firstConsecutiveDots(s: string): number {\n    const match = s.match(/^\\.{1,}/);\n    return match ? match[0].length : 0;\n}\n\nexport const cleanAndSplitContent = (content: string): string[] => {\n    // Remove parentheses and their contents, newlines, and unwanted characters\n    // Replace ':' and '|' with ','\n    content = content.replace(/\\(|\\)|\\n|\\s{2,}/gs, '')\n                     .replace(/[:|]/g, ',')\n                     .trim();\n  \n    // Split the content by commas, remove surrounding brackets/braces, and trim each part\n    return content.split(',').map(item => item.replace(/[\\[\\]\\{\\}]/g, '').trim());\n  }\n  \n\nexport function getCalledNode(callName: string, importFrom: string, importedFileNodes: Record<string, {fileNode: Node, importStatement: ImportStatement}>) {\n    const importedFile = importedFileNodes[importFrom].fileNode\n    const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`)\n    return calledNode\n}",
    "importStatements": [
      "import {\n    languageExtensionMap,\n    excludedFolders,\n    excludedExtensions,\n    languages,\n} from \"./consts\"",
      "import { treeSitterQueries, languageQueries } from \"../queries\"",
      "import { glob } from 'glob'",
      "import fs from 'node:fs/promises';",
      "import path from 'path'",
      "import Parser from 'tree-sitter';",
      "import { Node, ImportStatement } from './codebase'"
    ],
    "codeNoBody": "import {\n    languageExtensionMap,\n    excludedFolders,\n    excludedExtensions,\n    languages,\n} from \"./consts\"\nimport { treeSitterQueries, languageQueries } from \"../queries\"\nimport { glob } from 'glob'\nimport fs from 'node:fs/promises';\nimport path from 'path'\nimport Parser from 'tree-sitter';\nimport { Node, ImportStatement } from './codebase'\n/**\n * Get a list of all files in a given folder, including only files with the given extensions\n * from languageExtensionMap, and excluding from excludedExtensions\n * \n * @param rootFolderPath - The root folder to search in\n * @returns - The list of files from the given folder\n */\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }\n\n/**\n * Get the total size of all files returned by getAllFiles\n * \n * @param rootFolderPath - The root folder to search in\n * @returns - The total size in bytes of the matching files\n */\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }\n\n/**\n * Returns the Tree-Sitter parser and queries for a given language\n * @param language - The language to use\n * @returns - The parser and queries for the given language\n */\nexport function getRequiredDefinitions(language: string): { parser: Parser, queries: treeSitterQueries} {\n       //...\n       }\n\n/**\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\n * \n * @param language - The language to use\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\n * @param code - The code to parse\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\n * @returns \n */\nexport function captureQuery(language: string, queryName: keyof treeSitterQueries, code: string, queryArg?: string) : Parser.QueryCapture[] {\n       //...\n       }\n\n/**\n * Returns a cleaned list of captures up to the first occurence of the given keyword\n * @param captures - The captures to clean\n * @param keyword - The keyword to stop at\n */\nexport function cleanDefCaptures(captures: Parser.QueryCapture[], keyword: string = 'name') : Parser.QueryCapture[] {\n       //...\n       }\n\n/**\n * Rename the sourceName if it is a relative to filePath\n * @param filePath - The filePath to rename from\n * @param sourceName - The sourceName to rename to\n * @param language - The language to rename from\n * @returns The renamed sourceName\n */\nexport function renameSource(filePath: string, sourceName: string, language: string): string {\n       //...\n       }\n\nfunction firstConsecutiveDots(s: string): number {\n//...\n}\n\nexport const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       }\n  \n\nexport function getCalledNode(callName: string, importFrom: string, importedFileNodes: Record<string, {fileNode: Node, importStatement: ImportStatement}>) {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::cQueries",
    "language": "typescript",
    "label": "cQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 47,
    "inDegree": 2,
    "outDegree": 2,
    "code": "cQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [],
    "codeNoBody": "cQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 63,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @left\n                (pointer_declarator declarator: (identifier) @left)\n                ]\n            value: (_) @right\n        ) \n) @assignment\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 28,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\n(call_expression function: _ @identifier.name)\n( _ arguments: (argument_list (identifier) @identifier.name) )\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 72,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\n( translation_unit\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (field_expression (identifier)  @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n    )\n)\n    `",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 37,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\n(function_definition) @function\n(declaration (function_declarator)) @function\n(struct_specifier) @struct\n(union_specifier) @union\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 125,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n    type: (_)? @return_type\n    [\n     name: (_) @name\n     declarator: (function_declarator declarator: (identifier) @name) \n    ]\n    parameters: (parameter_list (_) @param)?\n    body: (_)? @body\n)?\n\n; For global assignments\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @name\n                (pointer_declarator declarator: (identifier) @name)\n                ]\n            value: (_) @body\n        ) \n) \n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 45,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\n(translation_unit\n\t(declaration\n    \tdeclarator: (init_declarator\n        \t\tdeclarator: (_)\n                value: (_)\n        \t) \n    ) @assignment\n)\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "totalTokens": 40,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\n( preproc_include path: (system_lib_string) @module) @import_statement\n( preproc_include path: (string_literal (_) @module)) @import_statement\n\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/c",
    "language": "typescript",
    "label": "c.ts",
    "type": "file",
    "totalTokens": 672,
    "inDegree": 9,
    "outDegree": 2,
    "code": "// Tree-sitter definition + call queries for Java\n\n// It considers:\n// - Import statements\n// - Class definitions\n\n// - Class and methods\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\nconst importStatements = `\n( preproc_include path: (system_lib_string) @module) @import_statement\n( preproc_include path: (string_literal (_) @module)) @import_statement\n\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Java has no global assignments\nconst assignments = `\n(translation_unit\n\t(declaration\n    \tdeclarator: (init_declarator\n        \t\tdeclarator: (_)\n                value: (_)\n        \t) \n    ) @assignment\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n// modifier can be public, private or protected. By default is private\nconst definitionTemplate = `\n( _\n    type: (_)? @return_type\n    [\n     name: (_) @name\n     declarator: (function_declarator declarator: (identifier) @name) \n    ]\n    parameters: (parameter_list (_) @param)?\n    body: (_)? @body\n)?\n\n; For global assignments\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @name\n                (pointer_declarator declarator: (identifier) @name)\n                ]\n            value: (_) @body\n        ) \n) \n`\n\n\n// constructor methods have the same name as the class\n// NOTE: @function is passed as method if is inside a class\nconst constructorDefinitions = `\n(function_definition) @function\n(declaration (function_declarator)) @function\n(struct_specifier) @struct\n(union_specifier) @union\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// No export clauses\nconst exportClauses = ``\n\n// ASSIGNMENT SPECIAL CASE\n// TODO\nconst extraAssignmentCode = (name: string) => `\n( translation_unit\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (field_expression (identifier)  @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n    )\n)\n    ` \n\n// TODO\nconst calls = `\n(call_expression function: _ @identifier.name)\n( _ arguments: (argument_list (identifier) @identifier.name) )\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// TODO\nconst anyAssignments = `\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @left\n                (pointer_declarator declarator: (identifier) @left)\n                ]\n            value: (_) @right\n        ) \n) @assignment\n`\n\nexport const cQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for Java\n// It considers:\n// - Import statements\n// - Class definitions\n\n// - Class and methods\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\nconst importStatements = `\n( preproc_include path: (system_lib_string) @module) @import_statement\n( preproc_include path: (string_literal (_) @module)) @import_statement\n\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Java has no global assignments\nconst assignments = `\n(translation_unit\n\t(declaration\n    \tdeclarator: (init_declarator\n        \t\tdeclarator: (_)\n                value: (_)\n        \t) \n    ) @assignment\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n// modifier can be public, private or protected. By default is private\nconst definitionTemplate = `\n( _\n    type: (_)? @return_type\n    [\n     name: (_) @name\n     declarator: (function_declarator declarator: (identifier) @name) \n    ]\n    parameters: (parameter_list (_) @param)?\n    body: (_)? @body\n)?\n\n; For global assignments\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @name\n                (pointer_declarator declarator: (identifier) @name)\n                ]\n            value: (_) @body\n        ) \n) \n`\n\n\n// constructor methods have the same name as the class\n// NOTE: @function is passed as method if is inside a class\nconst constructorDefinitions = `\n(function_definition) @function\n(declaration (function_declarator)) @function\n(struct_specifier) @struct\n(union_specifier) @union\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// No export clauses\nconst exportClauses = ``\n\n// ASSIGNMENT SPECIAL CASE\n// TODO\nconst extraAssignmentCode = (name: string) => {\n//...\n} \n\n// TODO\nconst calls = `\n(call_expression function: _ @identifier.name)\n( _ arguments: (argument_list (identifier) @identifier.name) )\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// TODO\nconst anyAssignments = `\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @left\n                (pointer_declarator declarator: (identifier) @left)\n                ]\n            value: (_) @right\n        ) \n) @assignment\n`\n\nexport const cQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/index::treeSitterQueries",
    "language": "typescript",
    "label": "treeSitterQueries",
    "type": "interface",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/index",
    "totalTokens": 55,
    "inDegree": 11,
    "outDegree": 2,
    "code": "interface treeSitterQueries {\n    importStatements: string\n    constructorDefinitions: string\n    definitionTemplate: string\n    exportClauses: string\n    extraAssignmentCode: (name: string) => string\n    calls: string\n    assignments: string\n}",
    "importStatements": [],
    "codeNoBody": "interface treeSitterQueries{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/index::languageQueries",
    "language": "typescript",
    "label": "languageQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/index",
    "totalTokens": 42,
    "inDegree": 1,
    "outDegree": 7,
    "code": "languageQueries = {\n    Javascript: jsQueries,\n    Typescript: tsQueries,\n    Python: pyQueries,\n    Java: javaQueries,\n    C: cQueries,\n    PHP: phpQueries,\n}",
    "importStatements": [],
    "codeNoBody": "languageQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/index",
    "language": "typescript",
    "label": "index.ts",
    "type": "file",
    "totalTokens": 154,
    "inDegree": 2,
    "outDegree": 7,
    "code": "import { jsQueries } from \"./javascript\"\nimport { tsQueries } from \"./typescript\"\nimport { pyQueries } from \"./python\"\nimport { javaQueries } from \"./java\"\nimport { cQueries } from \"./c\"\nimport { phpQueries } from \"./php\"\n\nexport const languageQueries = {\n    Javascript: jsQueries,\n    Typescript: tsQueries,\n    Python: pyQueries,\n    Java: javaQueries,\n    C: cQueries,\n    PHP: phpQueries,\n}\n\n\nexport interface treeSitterQueries {\n    importStatements: string\n    constructorDefinitions: string\n    definitionTemplate: string\n    exportClauses: string\n    extraAssignmentCode: (name: string) => string\n    calls: string\n    assignments: string\n}",
    "importStatements": [
      "import { jsQueries } from \"./javascript\"",
      "import { tsQueries } from \"./typescript\"",
      "import { pyQueries } from \"./python\"",
      "import { javaQueries } from \"./java\"",
      "import { cQueries } from \"./c\"",
      "import { phpQueries } from \"./php\""
    ],
    "codeNoBody": "import { jsQueries } from \"./javascript\"\nimport { tsQueries } from \"./typescript\"\nimport { pyQueries } from \"./python\"\nimport { javaQueries } from \"./java\"\nimport { cQueries } from \"./c\"\nimport { phpQueries } from \"./php\"\nexport const languageQueries = {\n    Javascript: jsQueries,\n    Typescript: tsQueries,\n    Python: pyQueries,\n    Java: javaQueries,\n    C: cQueries,\n    PHP: phpQueries,\n}\n\n\nexport interface treeSitterQueries {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::javaQueries",
    "language": "typescript",
    "label": "javaQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 47,
    "inDegree": 2,
    "outDegree": 2,
    "code": "javaQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [],
    "codeNoBody": "javaQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 49,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (object_creation_expression type: _ @right) \n    ] \n) @assignment\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 28,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\n(method_invocation) @identifier.name\n(type_identifier) @parameter_type\n( _ object: _ @identifier.name)\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => ``",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = ``",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 24,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\n(constructor_declaration)? @function\n(method_declaration)? @function\n(class_declaration) @class\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 49,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n\t(modifiers) @modifier \n    type: (_)? @return_type\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    body: (_) @body\n)?\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 3,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = ``",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "totalTokens": 41,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\n(import_declaration \n\t[(scoped_identifier\n    \tscope: (_) @module\n        name: (_) @name)\n    (identifier) @module\n    ]\n) @import_statement\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/java",
    "language": "typescript",
    "label": "java.ts",
    "type": "file",
    "totalTokens": 469,
    "inDegree": 9,
    "outDegree": 2,
    "code": "// Tree-sitter definition + call queries for Java\n\n// It considers:\n// - Import statements\n// - Class definitions\n\n// - Class and methods\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\nconst importStatements = `\n(import_declaration \n\t[(scoped_identifier\n    \tscope: (_) @module\n        name: (_) @name)\n    (identifier) @module\n    ]\n) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Java has no global assignments\nconst assignments = ``\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n// modifier can be public, private or protected. By default is private\nconst definitionTemplate = `\n( _\n\t(modifiers) @modifier \n    type: (_)? @return_type\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    body: (_) @body\n)?\n`\n\n\n// constructor methods have the same name as the class\n// NOTE: @function is passed as method if is inside a class\nconst constructorDefinitions = `\n(constructor_declaration)? @function\n(method_declaration)? @function\n(class_declaration) @class\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// No export clauses\nconst exportClauses = ``\n\n// ASSIGNMENT SPECIAL CASE\n// TODO\nconst extraAssignmentCode = (name: string) => `` \n\n// TODO\nconst calls = `\n(method_invocation) @identifier.name\n(type_identifier) @parameter_type\n( _ object: _ @identifier.name)\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// TODO\nconst anyAssignments = `\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (object_creation_expression type: _ @right) \n    ] \n) @assignment\n`\n\nexport const javaQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for Java\n// It considers:\n// - Import statements\n// - Class definitions\n\n// - Class and methods\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\nconst importStatements = `\n(import_declaration \n\t[(scoped_identifier\n    \tscope: (_) @module\n        name: (_) @name)\n    (identifier) @module\n    ]\n) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Java has no global assignments\nconst assignments = {\n//...\n}\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n// modifier can be public, private or protected. By default is private\nconst definitionTemplate = `\n( _\n\t(modifiers) @modifier \n    type: (_)? @return_type\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    body: (_) @body\n)?\n`\n\n\n// constructor methods have the same name as the class\n// NOTE: @function is passed as method if is inside a class\nconst constructorDefinitions = `\n(constructor_declaration)? @function\n(method_declaration)? @function\n(class_declaration) @class\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// No export clauses\nconst exportClauses = ``\n\n// ASSIGNMENT SPECIAL CASE\n// TODO\nconst extraAssignmentCode = (name: string) => `` \n\n// TODO\nconst calls = `\n(method_invocation) @identifier.name\n(type_identifier) @parameter_type\n( _ object: _ @identifier.name)\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// TODO\nconst anyAssignments = `\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (object_creation_expression type: _ @right) \n    ] \n) @assignment\n`\n\nexport const javaQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::jsQueries",
    "language": "typescript",
    "label": "jsQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 47,
    "inDegree": 9,
    "outDegree": 2,
    "code": "jsQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [],
    "codeNoBody": "jsQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 288,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\n(assignment_expression\n\tleft: (identifier) @left\n    right: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"forEach\" \"map\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters . ((_) @right) ;first param\n           )\n         )\n    ) \n) @assignment\n\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"reduce\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters  ( (_) @right) . ;last param\n           )\n         )\n    ) \n) @assignment\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 116,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\n; any call\n(call_expression function: (_) @identifier.name)\n\n; calls to member expressions \n(assignment_expression right: (member_expression) @identifier.name)\n\n; arguments\n(arguments (identifier) @identifier.name)\n\n; any member_expression\n( _ (member_expression) @identifier.name)\n\n; new_expression\n(new_expression (identifier) @identifier.name)\n\n; keyword arguments\n(pair value: (identifier) @identifier.name)\n( variable_declarator value: (identifier) @identifier.name)\n\n; any object\n( _ object: _ @identifier.name)\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 72,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\n( program\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (member_expression object: (identifier) @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n    )\n) \n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 49,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = `\n( export_statement \n (export_clause (\n    export_specifier\n        name: (_) @name\n          alias: (_)? @alias\n          )\n    )\n  (string (string_fragment) @module)?\n)\n`",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 51,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\n; export\n(export_statement) @export\n\n; functions\n(function_declaration) @function\n\n; arrow functions\n${arrowFunctionConstructor} @function\n\n; classes\n(method_definition)? @method\n(class_declaration) @class\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::arrowFunctionConstructor",
    "language": "typescript",
    "label": "arrowFunctionConstructor",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 1,
    "code": "arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"",
    "importStatements": [],
    "codeNoBody": "arrowFunctionConstructor ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        body: (_)? @body\n\t\t\t)\n)?\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 88,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\n(program\n    (_\n        (variable_declarator\n            name: (identifier)\n            value: (_ !body) ; to exclude arrow functions\n        ) @assignment\n    )\n) \n\n; exportables\n(program\n    (export_statement\n        (_\n            (variable_declarator\n                name: (identifier)\n                value: (_ !body)\n            ) @assignment\n        )\n    )\n)\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "totalTokens": 208,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\n(import_statement \n    (import_clause [\n    (namespace_import (identifier) @alias)\n    (identifier) @name\n    (named_imports (import_specifier\n\t\t    name: (_) @name\n    \t\talias: (_)? @alias))\n    ])?\n\tsource: (string (string_fragment) @module)\n) @import_statement\n\n\n(lexical_declaration\n    (variable_declarator\n      name: [\n          (identifier) @name\n          (object_pattern (_) @name)\n      ]\n      value: [(call_expression\n                  function: _ @function\n                  arguments: (arguments (string (string_fragment) @module))\n                  (#eq? @function \"require\"))\n              ( member_expression\n                (call_expression\n                    function: _ @function\n                    arguments: (arguments (string (string_fragment) @module))\n                    (#eq? @function \"require\")\n                )\n                (property_identifier) @submodule\n               )\n              ]\n    )           \n  ) @import_statement\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/javascript",
    "language": "typescript",
    "label": "javascript.ts",
    "type": "file",
    "totalTokens": 1345,
    "inDegree": 10,
    "outDegree": 2,
    "code": "// Tree-sitter definition + call queries for JavaScript\n\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Export clauses\n\n// - Class, Method and Function calls\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// If there is no import.name  then no component is really imported\n// import.module considers only the string fragment\nconst importStatements = `\n(import_statement \n    (import_clause [\n    (namespace_import (identifier) @alias)\n    (identifier) @name\n    (named_imports (import_specifier\n\t\t    name: (_) @name\n    \t\talias: (_)? @alias))\n    ])?\n\tsource: (string (string_fragment) @module)\n) @import_statement\n\n\n(lexical_declaration\n    (variable_declarator\n      name: [\n          (identifier) @name\n          (object_pattern (_) @name)\n      ]\n      value: [(call_expression\n                  function: _ @function\n                  arguments: (arguments (string (string_fragment) @module))\n                  (#eq? @function \"require\"))\n              ( member_expression\n                (call_expression\n                    function: _ @function\n                    arguments: (arguments (string (string_fragment) @module))\n                    (#eq? @function \"require\")\n                )\n                (property_identifier) @submodule\n               )\n              ]\n    )           \n  ) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Arrow functions are like assignments but contains a body in value\n// Therefore, to remove them from assignments check if body exists in @right\n\n// Global only\nconst assignments = `\n(program\n    (_\n        (variable_declarator\n            name: (identifier)\n            value: (_ !body) ; to exclude arrow functions\n        ) @assignment\n    )\n) \n\n; exportables\n(program\n    (export_statement\n        (_\n            (variable_declarator\n                name: (identifier)\n                value: (_ !body)\n            ) @assignment\n        )\n    )\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        body: (_)? @body\n\t\t\t)\n)?\n`\n\nconst arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"\n\n// The only way to detect if is async is to check if the function definition contains \"async\"\nconst constructorDefinitions = `\n; export\n(export_statement) @export\n\n; functions\n(function_declaration) @function\n\n; arrow functions\n${arrowFunctionConstructor} @function\n\n; classes\n(method_definition)? @method\n(class_declaration) @class\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// Export clauses can contain an alias\nconst exportClauses = `\n( export_statement \n (export_clause (\n    export_specifier\n        name: (_) @name\n          alias: (_)? @alias\n          )\n    )\n  (string (string_fragment) @module)?\n)\n`\n\n// ASSIGNMENT SPECIAL CASE\n// this is for example if I use something like\n// ```\n// const myEndpoint = new Hono()\n// myEndpoint.get('/', (c) => c.text('Hello World'))\n// ```\n// It will include the myEndpoint.get to the code of the assignment\nconst extraAssignmentCode = (name: string) => `\n( program\n    (expression_statement\n        (call_expression function:\n        \t[(identifier) @identifier.name\n             (member_expression object: (identifier) @identifier.name  ) \n            ]\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n    )\n) \n`\n\nconst calls = `\n; any call\n(call_expression function: (_) @identifier.name)\n\n; calls to member expressions \n(assignment_expression right: (member_expression) @identifier.name)\n\n; arguments\n(arguments (identifier) @identifier.name)\n\n; any member_expression\n( _ (member_expression) @identifier.name)\n\n; new_expression\n(new_expression (identifier) @identifier.name)\n\n; keyword arguments\n(pair value: (identifier) @identifier.name)\n( variable_declarator value: (identifier) @identifier.name)\n\n; any object\n( _ object: _ @identifier.name)\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = `\n(assignment_expression\n\tleft: (identifier) @left\n    right: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"forEach\" \"map\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters . ((_) @right) ;first param\n           )\n         )\n    ) \n) @assignment\n\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"reduce\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters  ( (_) @right) . ;last param\n           )\n         )\n    ) \n) @assignment\n`\n\nexport const jsQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for JavaScript\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Export clauses\n\n// - Class, Method and Function calls\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// If there is no import.name  then no component is really imported\n// import.module considers only the string fragment\nconst importStatements = `\n(import_statement \n    (import_clause [\n    (namespace_import (identifier) @alias)\n    (identifier) @name\n    (named_imports (import_specifier\n\t\t    name: (_) @name\n    \t\talias: (_)? @alias))\n    ])?\n\tsource: (string (string_fragment) @module)\n) @import_statement\n\n\n(lexical_declaration\n    (variable_declarator\n      name: [\n          (identifier) @name\n          (object_pattern (_) @name)\n      ]\n      value: [(call_expression\n                  function: _ @function\n                  arguments: (arguments (string (string_fragment) @module))\n                  (#eq? @function \"require\"))\n              ( member_expression\n                (call_expression\n                    function: _ @function\n                    arguments: (arguments (string (string_fragment) @module))\n                    (#eq? @function \"require\")\n                )\n                (property_identifier) @submodule\n               )\n              ]\n    )           \n  ) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Arrow functions are like assignments but contains a body in value\n// Therefore, to remove them from assignments check if body exists in @right\n\n// Global only\nconst assignments = `\n(program\n    (_\n        (variable_declarator\n            name: (identifier)\n            value: (_ !body) ; to exclude arrow functions\n        ) @assignment\n    )\n) \n\n; exportables\n(program\n    (export_statement\n        (_\n            (variable_declarator\n                name: (identifier)\n                value: (_ !body)\n            ) @assignment\n        )\n    )\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        body: (_)? @body\n\t\t\t)\n)?\n`\n\nconst arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"\n\n// The only way to detect if is async is to check if the function definition contains \"async\"\nconst constructorDefinitions = `\n; export\n(export_statement) @export\n\n; functions\n(function_declaration) @function\n\n; arrow functions\n${arrowFunctionConstructor} @function\n\n; classes\n(method_definition)? @method\n(class_declaration) @class\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// Export clauses can contain an alias\nconst exportClauses = `\n( export_statement \n (export_clause (\n    export_specifier\n        name: (_) @name\n          alias: (_)? @alias\n          )\n    )\n  (string (string_fragment) @module)?\n)\n`\n\n// ASSIGNMENT SPECIAL CASE\n// this is for example if I use something like\n// ```\n// const myEndpoint = new Hono()\n// myEndpoint.get('/', (c) => c.text('Hello World'))\n// ```\n// It will include the myEndpoint.get to the code of the assignment\nconst extraAssignmentCode = (name: string) => {\n//...\n}\n\nconst calls = `\n; any call\n(call_expression function: (_) @identifier.name)\n\n; calls to member expressions \n(assignment_expression right: (member_expression) @identifier.name)\n\n; arguments\n(arguments (identifier) @identifier.name)\n\n; any member_expression\n( _ (member_expression) @identifier.name)\n\n; new_expression\n(new_expression (identifier) @identifier.name)\n\n; keyword arguments\n(pair value: (identifier) @identifier.name)\n( variable_declarator value: (identifier) @identifier.name)\n\n; any object\n( _ object: _ @identifier.name)\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = `\n(assignment_expression\n\tleft: (identifier) @left\n    right: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (member_expression) @right\n    (new_expression constructor: _ @right )\n    ] \n) @assignment\n\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"forEach\" \"map\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters . ((_) @right) ;first param\n           )\n         )\n    ) \n) @assignment\n\n(call_expression\n    function:\n    ( member_expression .\n      object: (identifier) @left\n      property: (property_identifier) @property\n      (#any-of? @property \"reduce\")\n    )\n     arguments:\n     (arguments\n          (arrow_function parameters:\n            (formal_parameters  ( (_) @right) . ;last param\n           )\n         )\n    ) \n) @assignment\n`\n\nexport const jsQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::phpQueries",
    "language": "typescript",
    "label": "phpQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 47,
    "inDegree": 2,
    "outDegree": 2,
    "code": "phpQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [],
    "codeNoBody": "phpQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 6,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 4,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 57,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\n(program\n\t(expression_statement\n\t\t(binary_expression left: (_\n        \t\t(variable_name (name) @identifier.name))\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n\t) \n)\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 6,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = `\n`",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 35,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\n(class_declaration) @class\n(method_declaration) @function ; also considered as a function\n(function_definition) @function\n(interface_declaration) @interface\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 79,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n  (visibility_modifier)? @modifier\n  name: (_) @name\n  parameters: (formal_parameters (_) @param)?\n  return_type: _? @return_type\n  body: (_) @body ; NOTE: interfaces do not have a body\n)\n\n; For global assignments   \n(assignment_expression left: (variable_name (name) @name))\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 36,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\n(program\n\t(expression_statement\n\t\t(assignment_expression left: (variable_name)\n        \t\t\t\t\t   right: (_)\n        ) @assignment \n\t) \n)\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "totalTokens": 67,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\n(include_expression (string (string_content) @module )) @import_statement\n(include_once_expression (string (string_content) @module )) @import_statement\n(require_expression (string (string_content) @module )) @import_statement\n(require_once_expression (string (string_content) @module )) @import_statement\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/php",
    "language": "typescript",
    "label": "php.ts",
    "type": "file",
    "totalTokens": 633,
    "inDegree": 9,
    "outDegree": 2,
    "code": "// Tree-sitter definition + call queries for PHP\n\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Export clauses\n\n// - Class, Method and Function calls\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// If there is no import.name  then no component is really imported\n// import.module considers only the string fragment\nconst importStatements = `\n(include_expression (string (string_content) @module )) @import_statement\n(include_once_expression (string (string_content) @module )) @import_statement\n(require_expression (string (string_content) @module )) @import_statement\n(require_once_expression (string (string_content) @module )) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Arrow functions are like assignments but contains a body in value\n// Therefore, to remove them from assignments check if body exists in @right\n\n// Global only\nconst assignments = `\n(program\n\t(expression_statement\n\t\t(assignment_expression left: (variable_name)\n        \t\t\t\t\t   right: (_)\n        ) @assignment \n\t) \n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n  (visibility_modifier)? @modifier\n  name: (_) @name\n  parameters: (formal_parameters (_) @param)?\n  return_type: _? @return_type\n  body: (_) @body ; NOTE: interfaces do not have a body\n)\n\n; For global assignments   \n(assignment_expression left: (variable_name (name) @name))\n`\n\n\nconst constructorDefinitions = `\n(class_declaration) @class\n(method_declaration) @function ; also considered as a function\n(function_definition) @function\n(interface_declaration) @interface\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// Export clauses can contain an alias\nconst exportClauses = `\n`\n\n// ASSIGNMENT SPECIAL CASE\n// this is for example if I use something like\n// ```\n// const myEndpoint = new Hono()\n// myEndpoint.get('/', (c) => c.text('Hello World'))\n// ```\n// It will include the myEndpoint.get to the code of the assignment\nconst extraAssignmentCode = (name: string) => `\n(program\n\t(expression_statement\n\t\t(binary_expression left: (_\n        \t\t(variable_name (name) @identifier.name))\n        (#eq? @identifier.name \"${name}\")\n        ) @code\n\t) \n)\n`\n\nconst calls = `\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = `\n`\n\nexport const phpQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for PHP\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Export clauses\n\n// - Class, Method and Function calls\n// - member expressions like this.my_method and Class.my_method\n// - Arguments\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// If there is no import.name  then no component is really imported\n// import.module considers only the string fragment\nconst importStatements = `\n(include_expression (string (string_content) @module )) @import_statement\n(include_once_expression (string (string_content) @module )) @import_statement\n(require_expression (string (string_content) @module )) @import_statement\n(require_once_expression (string (string_content) @module )) @import_statement\n`\n\n/////////////////\n// ASSIGNMENTS //\n/////////////////\n// Arrow functions are like assignments but contains a body in value\n// Therefore, to remove them from assignments check if body exists in @right\n\n// Global only\nconst assignments = `\n(program\n\t(expression_statement\n\t\t(assignment_expression left: (variable_name)\n        \t\t\t\t\t   right: (_)\n        ) @assignment \n\t) \n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n  (visibility_modifier)? @modifier\n  name: (_) @name\n  parameters: (formal_parameters (_) @param)?\n  return_type: _? @return_type\n  body: (_) @body ; NOTE: interfaces do not have a body\n)\n\n; For global assignments   \n(assignment_expression left: (variable_name (name) @name))\n`\n\n\nconst constructorDefinitions = `\n(class_declaration) @class\n(method_declaration) @function ; also considered as a function\n(function_definition) @function\n(interface_declaration) @interface\n`\n\n////////////////////\n// EXPORTS_CLAUSES //\n////////////////////\n// Export clauses can contain an alias\nconst exportClauses = `\n`\n\n// ASSIGNMENT SPECIAL CASE\n// this is for example if I use something like\n// ```\n// const myEndpoint = new Hono()\n// myEndpoint.get('/', (c) => c.text('Hello World'))\n// ```\n// It will include the myEndpoint.get to the code of the assignment\nconst extraAssignmentCode = (name: string) => {\n//...\n}\n\nconst calls = `\n`\n\n///////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = `\n`\n\nexport const phpQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::pyQueries",
    "language": "typescript",
    "label": "pyQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 50,
    "inDegree": 2,
    "outDegree": 2,
    "code": "pyQueries: treeSitterQueries = { \n  importStatements,\n  constructorDefinitions: assignments + constructorDefinitions,\n  definitionTemplate,\n  extraAssignmentCode,\n  exportClauses: '',\n  calls,\n  assignments: anyAssignments \n   }",
    "importStatements": [],
    "codeNoBody": "pyQueries: treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 62,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\n(assignment\n    left: (identifier) @left\n    right: (_) @right\n) @assignment\n                          \n(function_definition\n  parameters: (\n  parameters( typed_parameter (\n              (identifier) @left)\n                  type: _ @right)\n  @assignment)\n)\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 299,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\n; class and function calls\n(call function: ( (identifier) @identifier.name))\n\n; method calls like Class.method\n(call function: ( (attribute) @identifier.name))\n\n; self.parameter calls like self.parameter\n((attribute\n    object: (identifier) @object\n    attribute: (identifier) @property\n    (#eq? @object \"self\")) @identifier.name)\n\n\n; class extensions\n(class_definition\n    superclasses : (argument_list (_) @class.extends)?\n    body: (block\n            (function_definition name: _ @class.method)?)) @class.definition\n\n; pydantic like parameters                                        \n(class_definition\n        superclasses : (argument_list (_) @class.extends)?\n        body: (block\n                (expression_statement\n                    (assignment type: (_)? @parameter_type) @assignment))\n        ) @class.definition\n\n; typed parameters and return types\n(function_definition\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\n    return_type: (_)? @return_type) @function.definiton\n\n; assignments where they are identifiers\n(expression_statement\n\t(assignment right: (identifier) @identifier.name)\n)\n\n; keyword arguments\n(keyword_argument  value: (identifier) @identifier.name)\n\n; any attribute\n(_ (attribute) @identifier.name)\n\n; arguments (identifier only)\n(argument_list (identifier) @identifier.name)\n\n; any object name\n( _ object: _ @identifier.name)\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 137,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\n( module\n  (expression_statement\n      (call function:\n        [(identifier) @identifier.name\n           (attribute object: (identifier) @identifier.name  ) \n          ]\n      (#eq? @identifier.name \"${name}\")\n      ) @code\n  )\n) \n\n; not used\n;( module\n;  ( decorated_definition\n;\t(decorator [\n;    \t( call (attribute object: _ @identifier.name)) \n;        (attribute object: _ @identifier.name)\n;    \t]) @code\n;    (#eq? @identifier.name \"${name}\")\n;  )\n;)\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) =>{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\n(function_definition) @function\n(class_definition) @class\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 78,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n      name: (identifier) @name\n      parameters: (parameters (_) @param)?\n      return_type: _? @return_type\n      body: (block . (expression_statement (string) @documentation)? .\n          _ ) @body )\n\n; For global assignments   \n(expression_statement\n\t(assignment left: (identifier) @name)\n      )\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\n(module (expression_statement\n\t(assignment left: (identifier)\n    \t\t      right: (_)) \n      ) @assignment\n)\n`",
    "importStatements": [],
    "codeNoBody": "assignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "totalTokens": 141,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\n(import_statement\n\tname: [\n      (dotted_name) @module\n      (aliased_import name: _ @module alias: _ @alias)\n    ] ) @import_statement\n\n(import_from_statement\n\tmodule_name: _ @module\n\tname: [\n      (dotted_name) @name\n      (aliased_import name: _ @name alias: _ @alias)\n    ]?\n    (wildcard_import _ @wildcard)?\n    ) @import_statement\n    \n(future_import_statement \n\tname: [\n\t\t(dotted_name) @name\n\t\t(aliased_import name: _ @name alias: _ @alias)\n    ]) @import_statement\n`",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/python",
    "language": "typescript",
    "label": "python.ts",
    "type": "file",
    "totalTokens": 1060,
    "inDegree": 8,
    "outDegree": 2,
    "code": "// Tree-sitter definition queries for Python\n\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n\n// - Class and Function calls\n// - Method and self.parameter calls\n// - Class extensions\n// - Pydantic like parameters\n// - Typed parameters and return types of methods and functions\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// Future imports have __future__ as module name\n// if import.has_wildcard exists then it is a wildcard (*) import of name \nconst importStatements = `\n(import_statement\n\tname: [\n      (dotted_name) @module\n      (aliased_import name: _ @module alias: _ @alias)\n    ] ) @import_statement\n\n(import_from_statement\n\tmodule_name: _ @module\n\tname: [\n      (dotted_name) @name\n      (aliased_import name: _ @name alias: _ @alias)\n    ]?\n    (wildcard_import _ @wildcard)?\n    ) @import_statement\n    \n(future_import_statement \n\tname: [\n\t\t(dotted_name) @name\n\t\t(aliased_import name: _ @name alias: _ @alias)\n    ]) @import_statement\n`\n\n//////////////////////////////\n// ASSIGNMENTS //\n//////////////////////////////\n// Globals only\nconst assignments = `\n(module (expression_statement\n\t(assignment left: (identifier)\n    \t\t      right: (_)) \n      ) @assignment\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n      name: (identifier) @name\n      parameters: (parameters (_) @param)?\n      return_type: _? @return_type\n      body: (block . (expression_statement (string) @documentation)? .\n          _ ) @body )\n\n; For global assignments   \n(expression_statement\n\t(assignment left: (identifier) @name)\n      )\n`\n\n// The only way to detect if is async is to check if the function definition contains \"async\"\n// In Python all constructor are exportable by default\nconst constructorDefinitions = `\n(function_definition) @function\n(class_definition) @class\n`\n\n//// ASSIGNMENT SPECIAL CASE\n// We need to know the assignment name\nconst extraAssignmentCode = (name: string) => `\n( module\n  (expression_statement\n      (call function:\n        [(identifier) @identifier.name\n           (attribute object: (identifier) @identifier.name  ) \n          ]\n      (#eq? @identifier.name \"${name}\")\n      ) @code\n  )\n) \n\n; not used\n;( module\n;  ( decorated_definition\n;\t(decorator [\n;    \t( call (attribute object: _ @identifier.name)) \n;        (attribute object: _ @identifier.name)\n;    \t]) @code\n;    (#eq? @identifier.name \"${name}\")\n;  )\n;)\n`\n\nconst calls = `\n; class and function calls\n(call function: ( (identifier) @identifier.name))\n\n; method calls like Class.method\n(call function: ( (attribute) @identifier.name))\n\n; self.parameter calls like self.parameter\n((attribute\n    object: (identifier) @object\n    attribute: (identifier) @property\n    (#eq? @object \"self\")) @identifier.name)\n\n\n; class extensions\n(class_definition\n    superclasses : (argument_list (_) @class.extends)?\n    body: (block\n            (function_definition name: _ @class.method)?)) @class.definition\n\n; pydantic like parameters                                        \n(class_definition\n        superclasses : (argument_list (_) @class.extends)?\n        body: (block\n                (expression_statement\n                    (assignment type: (_)? @parameter_type) @assignment))\n        ) @class.definition\n\n; typed parameters and return types\n(function_definition\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\n    return_type: (_)? @return_type) @function.definiton\n\n; assignments where they are identifiers\n(expression_statement\n\t(assignment right: (identifier) @identifier.name)\n)\n\n; keyword arguments\n(keyword_argument  value: (identifier) @identifier.name)\n\n; any attribute\n(_ (attribute) @identifier.name)\n\n; arguments (identifier only)\n(argument_list (identifier) @identifier.name)\n\n; any object name\n( _ object: _ @identifier.name)\n`\n\n/////////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\n\nconst anyAssignments = `\n(assignment\n    left: (identifier) @left\n    right: (_) @right\n) @assignment\n                          \n(function_definition\n  parameters: (\n  parameters( typed_parameter (\n              (identifier) @left)\n                  type: _ @right)\n  @assignment)\n)\n`\n\nexport const pyQueries: treeSitterQueries = { \n  importStatements,\n  constructorDefinitions: assignments + constructorDefinitions,\n  definitionTemplate,\n  extraAssignmentCode,\n  exportClauses: '',\n  calls,\n  assignments: anyAssignments \n   }\n",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition queries for Python\n// It considers:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n\n// - Class and Function calls\n// - Method and self.parameter calls\n// - Class extensions\n// - Pydantic like parameters\n// - Typed parameters and return types of methods and functions\n\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// Future imports have __future__ as module name\n// if import.has_wildcard exists then it is a wildcard (*) import of name \nconst importStatements = `\n(import_statement\n\tname: [\n      (dotted_name) @module\n      (aliased_import name: _ @module alias: _ @alias)\n    ] ) @import_statement\n\n(import_from_statement\n\tmodule_name: _ @module\n\tname: [\n      (dotted_name) @name\n      (aliased_import name: _ @name alias: _ @alias)\n    ]?\n    (wildcard_import _ @wildcard)?\n    ) @import_statement\n    \n(future_import_statement \n\tname: [\n\t\t(dotted_name) @name\n\t\t(aliased_import name: _ @name alias: _ @alias)\n    ]) @import_statement\n`\n\n//////////////////////////////\n// ASSIGNMENTS //\n//////////////////////////////\n// Globals only\nconst assignments = `\n(module (expression_statement\n\t(assignment left: (identifier)\n    \t\t      right: (_)) \n      ) @assignment\n)\n`\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\n\nconst definitionTemplate = `\n( _\n      name: (identifier) @name\n      parameters: (parameters (_) @param)?\n      return_type: _? @return_type\n      body: (block . (expression_statement (string) @documentation)? .\n          _ ) @body )\n\n; For global assignments   \n(expression_statement\n\t(assignment left: (identifier) @name)\n      )\n`\n\n// The only way to detect if is async is to check if the function definition contains \"async\"\n// In Python all constructor are exportable by default\nconst constructorDefinitions = `\n(function_definition) @function\n(class_definition) @class\n`\n\n//// ASSIGNMENT SPECIAL CASE\n// We need to know the assignment name\nconst extraAssignmentCode = (name: string) => {\n//...\n}\n\nconst calls = `\n; class and function calls\n(call function: ( (identifier) @identifier.name))\n\n; method calls like Class.method\n(call function: ( (attribute) @identifier.name))\n\n; self.parameter calls like self.parameter\n((attribute\n    object: (identifier) @object\n    attribute: (identifier) @property\n    (#eq? @object \"self\")) @identifier.name)\n\n\n; class extensions\n(class_definition\n    superclasses : (argument_list (_) @class.extends)?\n    body: (block\n            (function_definition name: _ @class.method)?)) @class.definition\n\n; pydantic like parameters                                        \n(class_definition\n        superclasses : (argument_list (_) @class.extends)?\n        body: (block\n                (expression_statement\n                    (assignment type: (_)? @parameter_type) @assignment))\n        ) @class.definition\n\n; typed parameters and return types\n(function_definition\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\n    return_type: (_)? @return_type) @function.definiton\n\n; assignments where they are identifiers\n(expression_statement\n\t(assignment right: (identifier) @identifier.name)\n)\n\n; keyword arguments\n(keyword_argument  value: (identifier) @identifier.name)\n\n; any attribute\n(_ (attribute) @identifier.name)\n\n; arguments (identifier only)\n(argument_list (identifier) @identifier.name)\n\n; any object name\n( _ object: _ @identifier.name)\n`\n\n/////////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\n\nconst anyAssignments = `\n(assignment\n    left: (identifier) @left\n    right: (_) @right\n) @assignment\n                          \n(function_definition\n  parameters: (\n  parameters( typed_parameter (\n              (identifier) @left)\n                  type: _ @right)\n  @assignment)\n)\n`\n\nexport const pyQueries: treeSitterQueries = { \n  importStatements,\n  constructorDefinitions: assignments + constructorDefinitions,\n  definitionTemplate,\n  extraAssignmentCode,\n  exportClauses: '',\n  calls,\n  assignments: anyAssignments \n   }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::tsQueries",
    "language": "typescript",
    "label": "tsQueries",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 42,
    "inDegree": 2,
    "outDegree": 2,
    "code": "tsQueries : treeSitterQueries = {\n    importStatements,\n    constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [],
    "codeNoBody": "tsQueries : treeSitterQueries ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 50,
    "inDegree": 2,
    "outDegree": 2,
    "code": "anyAssignments = jsQueries.assignments + `\n(function_declaration\n\tparameters: (formal_parameters \n    \t(_\n        \t(identifier) @left\n        \t(type_annotation (type_identifier) @right)\n        ) @assignment) \n)\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 36,
    "inDegree": 0,
    "outDegree": 2,
    "code": "calls = jsQueries.calls + `\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\n(type_identifier) @parameter_type\n`",
    "importStatements": [],
    "codeNoBody": "calls ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 2,
    "code": "extraAssignmentCode = jsQueries.extraAssignmentCode",
    "importStatements": [],
    "codeNoBody": "extraAssignmentCode ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 2,
    "code": "exportClauses = jsQueries.exportClauses",
    "importStatements": [],
    "codeNoBody": "exportClauses ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 102,
    "inDegree": 0,
    "outDegree": 2,
    "code": "constructorDefinitions = jsQueries.constructorDefinitions + `\n; interfaces\n(method_signature)? @function\n(interface_declaration) @interface\n\n; enums\n(enum_declaration) @enum\n\n; type\n(program\n    ( type_alias_declaration\n        name: (_)\n        value: (_ !body)\n    ) @type\n) \n\n; type exportables\n(program\n    (export_statement\n        ( type_alias_declaration\n            name: (_)\n            value: (_ !body)\n        ) @type\n    )\n)\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 121,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    return_type: (type_annotation)? @return_type\n    ; method signatures has no body\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        return_type: (type_annotation)? @return_type\n        body: (_)? @body\n\t\t\t)\n)?\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "totalTokens": 7,
    "inDegree": 0,
    "outDegree": 2,
    "code": "importStatements = jsQueries.importStatements",
    "importStatements": [],
    "codeNoBody": "importStatements ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/queries/typescript",
    "language": "typescript",
    "label": "typescript.ts",
    "type": "file",
    "totalTokens": 582,
    "inDegree": 8,
    "outDegree": 3,
    "code": "// Tree-sitter definition queries for Typescript\n\n// It consider:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Interface definitions\n// - Enums definitions\n// - Export clauses\n\nimport { jsQueries } from './javascript';\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// The same as for JavaScript\nconst importStatements = jsQueries.importStatements\n\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\nconst definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    return_type: (type_annotation)? @return_type\n    ; method signatures has no body\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        return_type: (type_annotation)? @return_type\n        body: (_)? @body\n\t\t\t)\n)?\n`\n\n\n// The same as for JavaScript, but with interfaces and enums\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\n; interfaces\n(method_signature)? @function\n(interface_declaration) @interface\n\n; enums\n(enum_declaration) @enum\n\n; type\n(program\n    ( type_alias_declaration\n        name: (_)\n        value: (_ !body)\n    ) @type\n) \n\n; type exportables\n(program\n    (export_statement\n        ( type_alias_declaration\n            name: (_)\n            value: (_ !body)\n        ) @type\n    )\n)\n`\n\n\n/////////////////////\n// EXPORTS_CLAUSES //\n/////////////////////\n//The same as for JavaScript\nconst exportClauses = jsQueries.exportClauses\n\n////////////////////\n////ASSIGNMENT SPECIAL CASE\n// We need to know the assignment name\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\n\n\nconst calls = jsQueries.calls + `\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\n(type_identifier) @parameter_type\n`\n\n////////////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = jsQueries.assignments + `\n(function_declaration\n\tparameters: (formal_parameters \n    \t(_\n        \t(identifier) @left\n        \t(type_annotation (type_identifier) @right)\n        ) @assignment) \n)\n`\n\nexport const tsQueries : treeSitterQueries = {\n    importStatements,\n    constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}",
    "importStatements": [
      "import { jsQueries } from './javascript';",
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition queries for Typescript\n// It consider:\n// - Import statements\n// - Global Assignments\n// - Function definitions\n// - Class definitions\n// - Interface definitions\n// - Enums definitions\n// - Export clauses\n\nimport { jsQueries } from './javascript';\nimport { treeSitterQueries } from './index';\n\n///////////////////////\n// IMPORT_STATEMENTS //\n///////////////////////\n// The same as for JavaScript\nconst importStatements = jsQueries.importStatements\n\n\n//////////////////////////\n// DEFINITIONS TEMPLATE //\n//////////////////////////\nconst definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    return_type: (type_annotation)? @return_type\n    ; method signatures has no body\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n\n; arrow function\n(variable_declarator\n\tname: (_) @name\n\tvalue: (arrow_function\n    \tparameters: (formal_parameters (_) @param)?\n        return_type: (type_annotation)? @return_type\n        body: (_)? @body\n\t\t\t)\n)?\n`\n\n\n// The same as for JavaScript, but with interfaces and enums\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\n; interfaces\n(method_signature)? @function\n(interface_declaration) @interface\n\n; enums\n(enum_declaration) @enum\n\n; type\n(program\n    ( type_alias_declaration\n        name: (_)\n        value: (_ !body)\n    ) @type\n) \n\n; type exportables\n(program\n    (export_statement\n        ( type_alias_declaration\n            name: (_)\n            value: (_ !body)\n        ) @type\n    )\n)\n`\n\n\n/////////////////////\n// EXPORTS_CLAUSES //\n/////////////////////\n//The same as for JavaScript\nconst exportClauses = jsQueries.exportClauses\n\n////////////////////\n////ASSIGNMENT SPECIAL CASE\n// We need to know the assignment name\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\n\n\nconst calls = jsQueries.calls + `\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\n(type_identifier) @parameter_type\n`\n\n////////////////\n// Assignments are necessary to get the correct calls. For example:\n// > my_class = MyClass()\n// > my_class.my_method()\n// should be considered as a call to MyClass.my_method()\nconst anyAssignments = jsQueries.assignments + `\n(function_declaration\n\tparameters: (formal_parameters \n    \t(_\n        \t(identifier) @left\n        \t(type_annotation (type_identifier) @right)\n        ) @assignment) \n)\n`\n\nexport const tsQueries : treeSitterQueries = {\n    importStatements,\n    constructorDefinitions,\n    definitionTemplate,\n    exportClauses,\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph-test::createGraphTest",
    "language": "typescript",
    "label": "createGraphTest",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph-test",
    "totalTokens": 286,
    "inDegree": 2,
    "outDegree": 9,
    "code": "createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    user: repoOrg,\n    repo: repoName,\n    branch,\n    token: gitAccessToken\n  } = request\n  console.time(repoName)\n  const gitProvider = 'github'\n  console.log({ gitProvider, repoOrg, repoName, branch })\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return c.json({ message: 'Failed to download repo' }, 500)\n    }\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n    const links = codebase.getLinks()\n  \n    console.timeEnd(repoName)\n    return c.json({ graph: { nodes, links } })\n  } catch (error: any) {\n    console.log(error)\n    return c.json({ message: error.message }, 500)\n  }\n})",
    "importStatements": [],
    "codeNoBody": "createGraphTest = \ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    user: repoOrg,\n    repo: repoName,\n    branch,\n    token: gitAccessToken\n  } = request\n  console.time(repoName)\n  const gitProvider = 'github'\n  console.log({ gitProvider, repoOrg, repoName, branch })\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return c.json({ message: 'Failed to download repo' }, 500)\n    }\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n    const links = codebase.getLinks()\n  \n    console.timeEnd(repoName)\n    return c.json({ graph: { nodes, links } })\n  } catch (error: any) {\n    console.log(error)\n    return c.json({ message: error.message }, 500)\n  }\n}){\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph-test::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph-test",
    "totalTokens": 42,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    user: z.string(),\n    repo: z.string(),\n    branch: z.string(),\n    token: z.string()\n  })\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph-test",
    "language": "typescript",
    "label": "create_graph-test.ts",
    "type": "file",
    "totalTokens": 395,
    "inDegree": 2,
    "outDegree": 8,
    "code": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\n\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    user: z.string(),\n    repo: z.string(),\n    branch: z.string(),\n    token: z.string()\n  })\n)\n\nconst createGraphTest = new Hono()\n\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    user: repoOrg,\n    repo: repoName,\n    branch,\n    token: gitAccessToken\n  } = request\n  console.time(repoName)\n  const gitProvider = 'github'\n  console.log({ gitProvider, repoOrg, repoName, branch })\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return c.json({ message: 'Failed to download repo' }, 500)\n    }\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n    const links = codebase.getLinks()\n  \n    console.timeEnd(repoName)\n    return c.json({ graph: { nodes, links } })\n  } catch (error: any) {\n    console.log(error)\n    return c.json({ message: error.message }, 500)\n  }\n})\n\nexport { createGraphTest }",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { z } from 'zod'",
      "import { zValidator } from '@hono/zod-validator'",
      "import { downloadAndExtractRepo, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    user: z.string(),\n    repo: z.string(),\n    branch: z.string(),\n    token: z.string()\n  })\n)\n\nconst createGraphTest = new Hono()\n\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    user: repoOrg,\n    repo: repoName,\n    branch,\n    token: gitAccessToken\n  } = request\n  console.time(repoName)\n  const gitProvider = 'github'\n  console.log({ gitProvider, repoOrg, repoName, branch })\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return c.json({ message: 'Failed to download repo' }, 500)\n    }\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n    const links = codebase.getLinks()\n  \n    console.timeEnd(repoName)\n    return c.json({ graph: { nodes, links } })\n  } catch (error: any) {\n    console.log(error)\n    return c.json({ message: error.message }, 500)\n  }\n})\n\nexport { createGraphTest }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph::processGraphCreation",
    "language": "typescript",
    "label": "processGraphCreation",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 688,
    "inDegree": 2,
    "outDegree": 8,
    "code": "async function processGraphCreation({\n  gitProvider,\n  repoId,\n  userOrgId,\n  userId,\n  graphExists,\n  connectionId,\n  codebasePath\n}: {\n  gitProvider: GitServiceType\n  repoId: string\n  userOrgId: string\n  userId: string\n  graphExists: boolean,\n  connectionId: string,\n  codebasePath: string\n}) {\n  let graphId = uuidv4()\n  try {\n    const status = graphExists ? 'completed' : 'pending'\n\n    // graph does not exist\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return\n    }\n\n    const graph: Record<string, string | number> = {\n      id: graphId,\n      repo_id: repoId,\n      status,\n      org_id: userOrgId,\n      user_id: userId\n    }\n\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\n\n    await sql`INSERT INTO graphs ${sql([graph])}`\n\n    if (graphExists) {\n      console.log('Graph creation completed:', graphId)\n      return\n    }\n\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n\n    // create a uuid for each node\n    const nodeDBIds: { [key: string]: string } = {}\n    for (const node of nodes) {\n      nodeDBIds[node.id] = uuidv4()\n    }\n\n    // Insert nodes into the database, note that the node.id is now the full_name\n    const insertNodePromises = nodes.map((node) => {\n      const fullName = node.id.replace(codebasePath, '')\n      return sql`\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\n        }, ${fullName}, ${node.label})\n    `\n    })\n\n    const links = codebase.getLinks()\n    // Insert links into the database\n    const insertLinkPromises = links.map((link) => {\n      return sql`\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label)\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label})\n    `\n    })\n\n    await Promise.all(insertNodePromises)\n    await Promise.all(insertLinkPromises)\n\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\n    console.log('Graph creation completed:', graphId)\n  } catch (error) {\n    console.error('Error in background processing:', error)\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function processGraphCreation({\n  gitProvider,\n  repoId,\n  userOrgId,\n  userId,\n  graphExists,\n  connectionId,\n  codebasePath\n}: {\n  gitProvider: GitServiceType\n  repoId: string\n  userOrgId: string\n  userId: string\n  graphExists: boolean,\n  connectionId: string,\n  codebasePath: string\n}){\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph::createGraph",
    "language": "typescript",
    "label": "createGraph",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 931,
    "inDegree": 2,
    "outDegree": 8,
    "code": "createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    git_provider: gitProvider,\n    repo_org: repoOrg,\n    repo_name: repoName,\n    branch,\n    connection_id: connectionId,\n    gitlab_repo_id: gitlabRepoId,\n  } = request\n\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  if (!jwt) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\n  const userId = payload.sub\n\n  if (!userId) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\n  const userOrgId = resOrg[0].org_sel_id\n\n  const {\n    accessToken,\n    refreshToken\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n  if (!accessToken) {\n    console.log('Failed to get access token')\n    return c.json({ message: 'Failed to get access token' }, 500)\n  }\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n  if (!commitHash) {\n    console.log('Failed to get commit')\n    return c.json({ message: 'Failed to get commit' }, 500)\n  }\n\n\n  // check if repo exists\n  const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE \n        git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n  let repoId = uuidv4()\n\n  if (rows.length == 0) {\n\n    const respository: Record<string, string | number> = {\n      id: repoId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\n\n    if (!res) {\n      console.log('Failed to create repository')\n      return c.json({ message: 'Failed to create repository' }, 500)\n    }\n  } else {\n    repoId = rows[0].id\n  }\n\n  const graphUsersData = await sql`\n    SELECT g.org_id, g.user_id\n    FROM nodes n -- must have at least one node\n    LEFT JOIN repositories r \n      ON n.repo_id = r.id\n    LEFT JOIN graphs g\n      ON g.repo_id = n.repo_id\n    WHERE\n      n.repo_id = ${repoId}\n      AND r.git_provider = ${gitProvider}\n      AND r.commit_hash = ${commitHash}`\n\n  let graphExists = false\n\n  // graph already exists with that commit\n  if (graphUsersData.length > 0) {\n    const orgIds = graphUsersData.map((row) => row.org_id)\n    const userIds = graphUsersData.map((row) => row.user_id)\n    // the user and org already have this graph\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\n      console.log('Graph already exists')\n      return c.json({ message: 'Graph already exists' }, 500)\n    }\n    graphExists = true\n  }\n\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n    // Perform background task\n    processGraphCreation({\n      gitProvider,\n      repoId,\n      userOrgId,\n      userId,\n      graphExists,\n      connectionId,\n      codebasePath\n    })\n\n    return c.json({ message: 'Graph creation started' })\n  } catch (error: any) {\n    return c.json({ message: error.message }, 500)\n  }\n\n\n})",
    "importStatements": [],
    "codeNoBody": "createGraph = \ncreateGraph.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    git_provider: gitProvider,\n    repo_org: repoOrg,\n    repo_name: repoName,\n    branch,\n    connection_id: connectionId,\n    gitlab_repo_id: gitlabRepoId,\n  } = request\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  if (!jwt) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\n  const userId = payload.sub\n\n  if (!userId) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\n  const userOrgId = resOrg[0].org_sel_id\n\n  const {\n    accessToken,\n    refreshToken\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n  if (!accessToken) {\n    console.log('Failed to get access token')\n    return c.json({ message: 'Failed to get access token' }, 500)\n  }\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n  if (!commitHash) {\n    console.log('Failed to get commit')\n    return c.json({ message: 'Failed to get commit' }, 500)\n  }\n\n\n  // check if repo exists\n  const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE \n        git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n  let repoId = uuidv4()\n\n  if (rows.length == 0) {\n\n    const respository: Record<string, string | number> = {\n      id: repoId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\n\n    if (!res) {\n      console.log('Failed to create repository')\n      return c.json({ message: 'Failed to create repository' }, 500)\n    }\n  } else {\n    repoId = rows[0].id\n  }\n\n  const graphUsersData = await sql`\n    SELECT g.org_id, g.user_id\n    FROM nodes n -- must have at least one node\n    LEFT JOIN repositories r \n      ON n.repo_id = r.id\n    LEFT JOIN graphs g\n      ON g.repo_id = n.repo_id\n    WHERE\n      n.repo_id = ${repoId}\n      AND r.git_provider = ${gitProvider}\n      AND r.commit_hash = ${commitHash}`\n\n  let graphExists = false\n\n  // graph already exists with that commit\n  if (graphUsersData.length > 0) {\n    const orgIds = graphUsersData.map((row) => row.org_id)\n    const userIds = graphUsersData.map((row) => row.user_id)\n    // the user and org already have this graph\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\n      console.log('Graph already exists')\n      return c.json({ message: 'Graph already exists' }, 500)\n    }\n    graphExists = true\n  }\n\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n    // Perform background task\n    processGraphCreation({\n      gitProvider,\n      repoId,\n      userOrgId,\n      userId,\n      graphExists,\n      connectionId,\n      codebasePath\n    })\n\n    return c.json({ message: 'Graph creation started' })\n  } catch (error: any) {\n    return c.json({ message: error.message }, 500)\n  }\n\n\n}){\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 73,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\n    repo_org: z.string(),\n    repo_name: z.string(),\n    branch: z.string(),\n    connection_id: z.string(),\n    gitlab_repo_id: z.number().optional()\n  })\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph::secret",
    "language": "typescript",
    "label": "secret",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 2,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "importStatements": [],
    "codeNoBody": "secret ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/create_graph",
    "language": "typescript",
    "label": "create_graph.ts",
    "type": "file",
    "totalTokens": 1826,
    "inDegree": 4,
    "outDegree": 9,
    "code": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { sql } from '../utils/db'\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '../utils/utils'\nimport { GitServiceType } from '../utils/git'\nconst secret = getEnv('SUPABASE_JWT')\n\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\n    repo_org: z.string(),\n    repo_name: z.string(),\n    branch: z.string(),\n    connection_id: z.string(),\n    gitlab_repo_id: z.number().optional()\n  })\n)\n\nconst createGraph = new Hono()\n\ncreateGraph.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    git_provider: gitProvider,\n    repo_org: repoOrg,\n    repo_name: repoName,\n    branch,\n    connection_id: connectionId,\n    gitlab_repo_id: gitlabRepoId,\n  } = request\n\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  if (!jwt) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\n  const userId = payload.sub\n\n  if (!userId) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\n  const userOrgId = resOrg[0].org_sel_id\n\n  const {\n    accessToken,\n    refreshToken\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n  if (!accessToken) {\n    console.log('Failed to get access token')\n    return c.json({ message: 'Failed to get access token' }, 500)\n  }\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n  if (!commitHash) {\n    console.log('Failed to get commit')\n    return c.json({ message: 'Failed to get commit' }, 500)\n  }\n\n\n  // check if repo exists\n  const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE \n        git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n  let repoId = uuidv4()\n\n  if (rows.length == 0) {\n\n    const respository: Record<string, string | number> = {\n      id: repoId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\n\n    if (!res) {\n      console.log('Failed to create repository')\n      return c.json({ message: 'Failed to create repository' }, 500)\n    }\n  } else {\n    repoId = rows[0].id\n  }\n\n  const graphUsersData = await sql`\n    SELECT g.org_id, g.user_id\n    FROM nodes n -- must have at least one node\n    LEFT JOIN repositories r \n      ON n.repo_id = r.id\n    LEFT JOIN graphs g\n      ON g.repo_id = n.repo_id\n    WHERE\n      n.repo_id = ${repoId}\n      AND r.git_provider = ${gitProvider}\n      AND r.commit_hash = ${commitHash}`\n\n  let graphExists = false\n\n  // graph already exists with that commit\n  if (graphUsersData.length > 0) {\n    const orgIds = graphUsersData.map((row) => row.org_id)\n    const userIds = graphUsersData.map((row) => row.user_id)\n    // the user and org already have this graph\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\n      console.log('Graph already exists')\n      return c.json({ message: 'Graph already exists' }, 500)\n    }\n    graphExists = true\n  }\n\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n    // Perform background task\n    processGraphCreation({\n      gitProvider,\n      repoId,\n      userOrgId,\n      userId,\n      graphExists,\n      connectionId,\n      codebasePath\n    })\n\n    return c.json({ message: 'Graph creation started' })\n  } catch (error: any) {\n    return c.json({ message: error.message }, 500)\n  }\n\n\n})\n\nasync function processGraphCreation({\n  gitProvider,\n  repoId,\n  userOrgId,\n  userId,\n  graphExists,\n  connectionId,\n  codebasePath\n}: {\n  gitProvider: GitServiceType\n  repoId: string\n  userOrgId: string\n  userId: string\n  graphExists: boolean,\n  connectionId: string,\n  codebasePath: string\n}) {\n  let graphId = uuidv4()\n  try {\n    const status = graphExists ? 'completed' : 'pending'\n\n    // graph does not exist\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return\n    }\n\n    const graph: Record<string, string | number> = {\n      id: graphId,\n      repo_id: repoId,\n      status,\n      org_id: userOrgId,\n      user_id: userId\n    }\n\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\n\n    await sql`INSERT INTO graphs ${sql([graph])}`\n\n    if (graphExists) {\n      console.log('Graph creation completed:', graphId)\n      return\n    }\n\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n\n    // create a uuid for each node\n    const nodeDBIds: { [key: string]: string } = {}\n    for (const node of nodes) {\n      nodeDBIds[node.id] = uuidv4()\n    }\n\n    // Insert nodes into the database, note that the node.id is now the full_name\n    const insertNodePromises = nodes.map((node) => {\n      const fullName = node.id.replace(codebasePath, '')\n      return sql`\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\n        }, ${fullName}, ${node.label})\n    `\n    })\n\n    const links = codebase.getLinks()\n    // Insert links into the database\n    const insertLinkPromises = links.map((link) => {\n      return sql`\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label)\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label})\n    `\n    })\n\n    await Promise.all(insertNodePromises)\n    await Promise.all(insertLinkPromises)\n\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\n    console.log('Graph creation completed:', graphId)\n  } catch (error) {\n    console.error('Error in background processing:', error)\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n  }\n}\n\nexport { createGraph }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { z } from 'zod'",
      "import { zValidator } from '@hono/zod-validator'",
      "import { sql } from '../utils/db'",
      "import { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'",
      "import { v4 as uuidv4 } from 'uuid'",
      "import { jwtVerify } from 'jose'",
      "import { getEnv } from '../utils/utils'",
      "import { GitServiceType } from '../utils/git'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { sql } from '../utils/db'\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '../utils/utils'\nimport { GitServiceType } from '../utils/git'\nconst secret = getEnv('SUPABASE_JWT')\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\n    repo_org: z.string(),\n    repo_name: z.string(),\n    branch: z.string(),\n    connection_id: z.string(),\n    gitlab_repo_id: z.number().optional()\n  })\n)\n\nconst createGraph = new Hono()\n\ncreateGraph.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const {\n    git_provider: gitProvider,\n    repo_org: repoOrg,\n    repo_name: repoName,\n    branch,\n    connection_id: connectionId,\n    gitlab_repo_id: gitlabRepoId,\n  } = request\n\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  if (!jwt) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\n  const userId = payload.sub\n\n  if (!userId) {\n    return c.json(\n      {\n        message: 'Unauthorized'\n      },\n      401\n    )\n  }\n\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\n  const userOrgId = resOrg[0].org_sel_id\n\n  const {\n    accessToken,\n    refreshToken\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n  if (!accessToken) {\n    console.log('Failed to get access token')\n    return c.json({ message: 'Failed to get access token' }, 500)\n  }\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n  if (!commitHash) {\n    console.log('Failed to get commit')\n    return c.json({ message: 'Failed to get commit' }, 500)\n  }\n\n\n  // check if repo exists\n  const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE \n        git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n  let repoId = uuidv4()\n\n  if (rows.length == 0) {\n\n    const respository: Record<string, string | number> = {\n      id: repoId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\n\n    if (!res) {\n      console.log('Failed to create repository')\n      return c.json({ message: 'Failed to create repository' }, 500)\n    }\n  } else {\n    repoId = rows[0].id\n  }\n\n  const graphUsersData = await sql`\n    SELECT g.org_id, g.user_id\n    FROM nodes n -- must have at least one node\n    LEFT JOIN repositories r \n      ON n.repo_id = r.id\n    LEFT JOIN graphs g\n      ON g.repo_id = n.repo_id\n    WHERE\n      n.repo_id = ${repoId}\n      AND r.git_provider = ${gitProvider}\n      AND r.commit_hash = ${commitHash}`\n\n  let graphExists = false\n\n  // graph already exists with that commit\n  if (graphUsersData.length > 0) {\n    const orgIds = graphUsersData.map((row) => row.org_id)\n    const userIds = graphUsersData.map((row) => row.user_id)\n    // the user and org already have this graph\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\n      console.log('Graph already exists')\n      return c.json({ message: 'Graph already exists' }, 500)\n    }\n    graphExists = true\n  }\n\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n    // Perform background task\n    processGraphCreation({\n      gitProvider,\n      repoId,\n      userOrgId,\n      userId,\n      graphExists,\n      connectionId,\n      codebasePath\n    })\n\n    return c.json({ message: 'Graph creation started' })\n  } catch (error: any) {\n    return c.json({ message: error.message }, 500)\n  }\n\n\n})\n\nasync function processGraphCreation({\n  gitProvider,\n  repoId,\n  userOrgId,\n  userId,\n  graphExists,\n  connectionId,\n  codebasePath\n}: {\n  gitProvider: GitServiceType\n  repoId: string\n  userOrgId: string\n  userId: string\n  graphExists: boolean,\n  connectionId: string,\n  codebasePath: string\n}) {\n//...\n}\n\nexport { createGraph }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs::updateGraph",
    "language": "typescript",
    "label": "updateGraph",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs",
    "totalTokens": 708,
    "inDegree": 2,
    "outDegree": 9,
    "code": "async function updateGraph({\n  gitProvider,\n  repoOrg,\n  repoName,\n  branch,\n  accessToken,\n  commitHash,\n  gitlabRepoId,\n  graphId\n}: UpdateGraph) {\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n      return\n    }\n\n    const respository: Record<string, string | number> = {\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\n\n    if (res.length === 0) {\n      console.log('Failed to create repository')\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n      return\n    }\n\n    const repoId = res[0].id\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n\n    const nodeDBIds: { [key: string]: string } = {}\n\n    for (const node of nodes) {\n      nodeDBIds[node.id] = uuidv4()\n    }\n\n    const insertNodePromises = nodes.map((node) => {\n      const fullName = node.id.replace(codebasePath, '')\n\n      return sql`\n        INSERT INTO nodes (\n          id, \n          repo_id, \n          type, \n          language, \n          total_tokens, \n          documentation, \n          code, \n          code_no_body, \n          in_degree, \n          out_degree, \n          full_name, \n          label\n        ) VALUES (\n          ${nodeDBIds[node.id]},\n          ${repoId},\n          ${node.type},\n          ${node.language},\n          ${node.totalTokens},\n          ${node.documentation},\n          ${node.code},\n          ${node.codeNoBody},\n          ${node.inDegree},\n          ${node.outDegree},\n          ${fullName}, ${node.label}\n        )\n      `\n    })\n\n    const links = codebase.getLinks()\n\n    const insertLinkPromises = links.map((link) => {\n      return sql`\n        INSERT INTO links (\n          node_source_id, \n          node_target_id, \n          repo_id, \n          label\n        ) VALUES (\n          ${nodeDBIds[link.source]}, \n          ${nodeDBIds[link.target]}, \n          ${repoId}, \n          ${link.label}\n        ) \n      `\n    })\n\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'completed',\n        repo_id = ${repoId}\n      WHERE id = ${graphId}`\n\n  } catch (error) {\n    console.error('Error in background processing:', error)\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateGraph({\n  gitProvider,\n  repoOrg,\n  repoName,\n  branch,\n  accessToken,\n  commitHash,\n  gitlabRepoId,\n  graphId\n}: UpdateGraph){\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs::UpdateGraph",
    "language": "typescript",
    "label": "UpdateGraph",
    "type": "interface",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs",
    "totalTokens": 55,
    "inDegree": 3,
    "outDegree": 3,
    "code": "interface UpdateGraph {\n  gitProvider: GitServiceType\n  repoOrg: string\n  repoName: string\n  branch: string\n  accessToken: string\n  commitHash: string\n  gitlabRepoId?: number\n  graphId: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UpdateGraph{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs::graphs",
    "language": "typescript",
    "label": "graphs",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs",
    "totalTokens": 831,
    "inDegree": 2,
    "outDegree": 6,
    "code": "graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\n\n  try {\n\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n    if (!jwt) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\n\n    const userId = payload.sub\n\n    if (!userId) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const graphId = c.req.param('id')\n\n\n    const graph = await sql`\n      SELECT\n        r.git_provider,\n        r.repo_org,\n        r.repo_name,\n        r.branch,\n        r.commit_hash,\n        r.gitlab_repo_id,\n        g.github_connection_id,\n        g.gitlab_connection_id,\n        g.bitbucket_connection_id,\n        p.org_sel_id\n      FROM profiles p\n      JOIN graphs g ON g.org_id = p.org_sel_id\n      JOIN repositories r ON g.repo_id = r.id\n      WHERE p.id = ${userId}\n        AND g.id = ${graphId}\n    `\n\n    if (graph.length === 0) {\n      return c.json(\n        {\n          error: 'Graph not found'\n        },\n        404\n      )\n    }\n\n    const {\n      org_sel_id: userOrgId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      commit_hash: repoCommitHash,\n      branch,\n      gitlab_repo_id: gitlabRepoId,\n      github_connection_id,\n      gitlab_connection_id,\n      bitbucket_connection_id\n    } = graph[0]\n\n    const connections: Record<string, string | number> = {\n      github: github_connection_id,\n      gitlab: gitlab_connection_id,\n      bitbucket: bitbucket_connection_id\n    }\n\n    const connectionId = String(connections[gitProvider])\n\n    const {\n      accessToken,\n      refreshToken\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n    if (!accessToken) {\n      console.log('Failed to get access token')\n      return c.json({ error: 'Failed to get access token' }, 400)\n    }\n\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n\n    if (!commitHash) {\n      console.log('Failed to get commit')\n      return c.json({ error: 'Failed to get commit' }, 400)\n    }\n\n    if (commitHash === repoCommitHash) {\n      return c.json({ message: 'Graph already up to date' }, 200)\n    }\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'updating'\n      WHERE id = ${graphId}\n    `\n\n\n    const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n    if (rows.length > 0) {\n      await sql`\n        UPDATE graphs \n        SET \n          status = 'completed',\n          repo_id = ${rows[0].id}\n        WHERE id = ${graphId}\n      `\n\n      return c.json({ message: 'Graph updated' }, 200)\n    }\n\n    updateGraph({\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId,\n      graphId\n    })\n\n    return c.json({ message: 'Graph updating' }, 200)\n\n  } catch (error) {\n    console.log('Error updating graph', error)\n    return c.json({ error: 'Error updating graph' }, 500)\n  }\n})",
    "importStatements": [],
    "codeNoBody": "graphs = \ngraphs.patch('/:id', async (c) => {\n  try {\n\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n    if (!jwt) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\n\n    const userId = payload.sub\n\n    if (!userId) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const graphId = c.req.param('id')\n\n\n    const graph = await sql`\n      SELECT\n        r.git_provider,\n        r.repo_org,\n        r.repo_name,\n        r.branch,\n        r.commit_hash,\n        r.gitlab_repo_id,\n        g.github_connection_id,\n        g.gitlab_connection_id,\n        g.bitbucket_connection_id,\n        p.org_sel_id\n      FROM profiles p\n      JOIN graphs g ON g.org_id = p.org_sel_id\n      JOIN repositories r ON g.repo_id = r.id\n      WHERE p.id = ${userId}\n        AND g.id = ${graphId}\n    `\n\n    if (graph.length === 0) {\n      return c.json(\n        {\n          error: 'Graph not found'\n        },\n        404\n      )\n    }\n\n    const {\n      org_sel_id: userOrgId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      commit_hash: repoCommitHash,\n      branch,\n      gitlab_repo_id: gitlabRepoId,\n      github_connection_id,\n      gitlab_connection_id,\n      bitbucket_connection_id\n    } = graph[0]\n\n    const connections: Record<string, string | number> = {\n      github: github_connection_id,\n      gitlab: gitlab_connection_id,\n      bitbucket: bitbucket_connection_id\n    }\n\n    const connectionId = String(connections[gitProvider])\n\n    const {\n      accessToken,\n      refreshToken\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n    if (!accessToken) {\n      console.log('Failed to get access token')\n      return c.json({ error: 'Failed to get access token' }, 400)\n    }\n\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n\n    if (!commitHash) {\n      console.log('Failed to get commit')\n      return c.json({ error: 'Failed to get commit' }, 400)\n    }\n\n    if (commitHash === repoCommitHash) {\n      return c.json({ message: 'Graph already up to date' }, 200)\n    }\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'updating'\n      WHERE id = ${graphId}\n    `\n\n\n    const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n    if (rows.length > 0) {\n      await sql`\n        UPDATE graphs \n        SET \n          status = 'completed',\n          repo_id = ${rows[0].id}\n        WHERE id = ${graphId}\n      `\n\n      return c.json({ message: 'Graph updated' }, 200)\n    }\n\n    updateGraph({\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId,\n      graphId\n    })\n\n    return c.json({ message: 'Graph updating' }, 200)\n\n  } catch (error) {\n    console.log('Error updating graph', error)\n    return c.json({ error: 'Error updating graph' }, 500)\n  }\n}){\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/routes/graphs",
    "language": "typescript",
    "label": "graphs.ts",
    "type": "file",
    "totalTokens": 1685,
    "inDegree": 3,
    "outDegree": 6,
    "code": "import { Hono } from 'hono'\nimport { sql } from '../utils/db'\nimport { getEnv } from '../utils/utils'\nimport { jwtVerify } from 'jose'\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\n\nconst graphs = new Hono()\n\ngraphs.patch('/:id', async (c) => {\n\n  try {\n\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n    if (!jwt) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\n\n    const userId = payload.sub\n\n    if (!userId) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const graphId = c.req.param('id')\n\n\n    const graph = await sql`\n      SELECT\n        r.git_provider,\n        r.repo_org,\n        r.repo_name,\n        r.branch,\n        r.commit_hash,\n        r.gitlab_repo_id,\n        g.github_connection_id,\n        g.gitlab_connection_id,\n        g.bitbucket_connection_id,\n        p.org_sel_id\n      FROM profiles p\n      JOIN graphs g ON g.org_id = p.org_sel_id\n      JOIN repositories r ON g.repo_id = r.id\n      WHERE p.id = ${userId}\n        AND g.id = ${graphId}\n    `\n\n    if (graph.length === 0) {\n      return c.json(\n        {\n          error: 'Graph not found'\n        },\n        404\n      )\n    }\n\n    const {\n      org_sel_id: userOrgId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      commit_hash: repoCommitHash,\n      branch,\n      gitlab_repo_id: gitlabRepoId,\n      github_connection_id,\n      gitlab_connection_id,\n      bitbucket_connection_id\n    } = graph[0]\n\n    const connections: Record<string, string | number> = {\n      github: github_connection_id,\n      gitlab: gitlab_connection_id,\n      bitbucket: bitbucket_connection_id\n    }\n\n    const connectionId = String(connections[gitProvider])\n\n    const {\n      accessToken,\n      refreshToken\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n    if (!accessToken) {\n      console.log('Failed to get access token')\n      return c.json({ error: 'Failed to get access token' }, 400)\n    }\n\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n\n    if (!commitHash) {\n      console.log('Failed to get commit')\n      return c.json({ error: 'Failed to get commit' }, 400)\n    }\n\n    if (commitHash === repoCommitHash) {\n      return c.json({ message: 'Graph already up to date' }, 200)\n    }\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'updating'\n      WHERE id = ${graphId}\n    `\n\n\n    const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n    if (rows.length > 0) {\n      await sql`\n        UPDATE graphs \n        SET \n          status = 'completed',\n          repo_id = ${rows[0].id}\n        WHERE id = ${graphId}\n      `\n\n      return c.json({ message: 'Graph updated' }, 200)\n    }\n\n    updateGraph({\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId,\n      graphId\n    })\n\n    return c.json({ message: 'Graph updating' }, 200)\n\n  } catch (error) {\n    console.log('Error updating graph', error)\n    return c.json({ error: 'Error updating graph' }, 500)\n  }\n})\n\ninterface UpdateGraph {\n  gitProvider: GitServiceType\n  repoOrg: string\n  repoName: string\n  branch: string\n  accessToken: string\n  commitHash: string\n  gitlabRepoId?: number\n  graphId: string\n}\n\nasync function updateGraph({\n  gitProvider,\n  repoOrg,\n  repoName,\n  branch,\n  accessToken,\n  commitHash,\n  gitlabRepoId,\n  graphId\n}: UpdateGraph) {\n  try {\n    const codebasePath = await downloadAndExtractRepo(\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId\n    )\n\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n      return\n    }\n\n    const respository: Record<string, string | number> = {\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\n\n    if (res.length === 0) {\n      console.log('Failed to create repository')\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n      return\n    }\n\n    const repoId = res[0].id\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n\n    const nodeDBIds: { [key: string]: string } = {}\n\n    for (const node of nodes) {\n      nodeDBIds[node.id] = uuidv4()\n    }\n\n    const insertNodePromises = nodes.map((node) => {\n      const fullName = node.id.replace(codebasePath, '')\n\n      return sql`\n        INSERT INTO nodes (\n          id, \n          repo_id, \n          type, \n          language, \n          total_tokens, \n          documentation, \n          code, \n          code_no_body, \n          in_degree, \n          out_degree, \n          full_name, \n          label\n        ) VALUES (\n          ${nodeDBIds[node.id]},\n          ${repoId},\n          ${node.type},\n          ${node.language},\n          ${node.totalTokens},\n          ${node.documentation},\n          ${node.code},\n          ${node.codeNoBody},\n          ${node.inDegree},\n          ${node.outDegree},\n          ${fullName}, ${node.label}\n        )\n      `\n    })\n\n    const links = codebase.getLinks()\n\n    const insertLinkPromises = links.map((link) => {\n      return sql`\n        INSERT INTO links (\n          node_source_id, \n          node_target_id, \n          repo_id, \n          label\n        ) VALUES (\n          ${nodeDBIds[link.source]}, \n          ${nodeDBIds[link.target]}, \n          ${repoId}, \n          ${link.label}\n        ) \n      `\n    })\n\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'completed',\n        repo_id = ${repoId}\n      WHERE id = ${graphId}`\n\n  } catch (error) {\n    console.error('Error in background processing:', error)\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\n  }\n}\n\nexport { graphs }",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '../utils/db'",
      "import { getEnv } from '../utils/utils'",
      "import { jwtVerify } from 'jose'",
      "import { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'",
      "import { v4 as uuidv4 } from 'uuid'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sql } from '../utils/db'\nimport { getEnv } from '../utils/utils'\nimport { jwtVerify } from 'jose'\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\nconst graphs = new Hono()\n\ngraphs.patch('/:id', async (c) => {\n\n  try {\n\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n    if (!jwt) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\n\n    const userId = payload.sub\n\n    if (!userId) {\n      return c.json(\n        {\n          error: 'Unauthorized'\n        },\n        401\n      )\n    }\n\n    const graphId = c.req.param('id')\n\n\n    const graph = await sql`\n      SELECT\n        r.git_provider,\n        r.repo_org,\n        r.repo_name,\n        r.branch,\n        r.commit_hash,\n        r.gitlab_repo_id,\n        g.github_connection_id,\n        g.gitlab_connection_id,\n        g.bitbucket_connection_id,\n        p.org_sel_id\n      FROM profiles p\n      JOIN graphs g ON g.org_id = p.org_sel_id\n      JOIN repositories r ON g.repo_id = r.id\n      WHERE p.id = ${userId}\n        AND g.id = ${graphId}\n    `\n\n    if (graph.length === 0) {\n      return c.json(\n        {\n          error: 'Graph not found'\n        },\n        404\n      )\n    }\n\n    const {\n      org_sel_id: userOrgId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      commit_hash: repoCommitHash,\n      branch,\n      gitlab_repo_id: gitlabRepoId,\n      github_connection_id,\n      gitlab_connection_id,\n      bitbucket_connection_id\n    } = graph[0]\n\n    const connections: Record<string, string | number> = {\n      github: github_connection_id,\n      gitlab: gitlab_connection_id,\n      bitbucket: bitbucket_connection_id\n    }\n\n    const connectionId = String(connections[gitProvider])\n\n    const {\n      accessToken,\n      refreshToken\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n    if (!accessToken) {\n      console.log('Failed to get access token')\n      return c.json({ error: 'Failed to get access token' }, 400)\n    }\n\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n\n    if (!commitHash) {\n      console.log('Failed to get commit')\n      return c.json({ error: 'Failed to get commit' }, 400)\n    }\n\n    if (commitHash === repoCommitHash) {\n      return c.json({ message: 'Graph already up to date' }, 200)\n    }\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'updating'\n      WHERE id = ${graphId}\n    `\n\n\n    const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n    if (rows.length > 0) {\n      await sql`\n        UPDATE graphs \n        SET \n          status = 'completed',\n          repo_id = ${rows[0].id}\n        WHERE id = ${graphId}\n      `\n\n      return c.json({ message: 'Graph updated' }, 200)\n    }\n\n    updateGraph({\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId,\n      graphId\n    })\n\n    return c.json({ message: 'Graph updating' }, 200)\n\n  } catch (error) {\n    console.log('Error updating graph', error)\n    return c.json({ error: 'Error updating graph' }, 500)\n  }\n})\n\ninterface UpdateGraph {\n//...\n}\n\nasync function updateGraph({\n  gitProvider,\n  repoOrg,\n  repoName,\n  branch,\n  accessToken,\n  commitHash,\n  gitlabRepoId,\n  graphId\n}: UpdateGraph) {\n//...\n}\n\nexport { graphs }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/bitbucket/refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/bitbucket/refresh-token",
    "totalTokens": 244,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n  try {\n    const rawBody = {\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n      client_id: getEnv('BITBUCKET_KEY'),\n      client_secret: getEnv('BITBUCKET_SECRET')\n    }\n\n    const body = Object.entries(rawBody)\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&')\n\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body\n    })\n\n    if (res.ok) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\n\n      return {\n        newAccessToken,\n        newRefreshToken\n      }\n    } else {\n      const data = await res.json()\n      console.error('Error al renovar el token de acceso:', data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/bitbucket/refresh-token",
    "language": "typescript",
    "label": "refresh-token.ts",
    "type": "file",
    "totalTokens": 254,
    "inDegree": 1,
    "outDegree": 0,
    "code": "import { getEnv } from \"../utils\"\n\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n  try {\n    const rawBody = {\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n      client_id: getEnv('BITBUCKET_KEY'),\n      client_secret: getEnv('BITBUCKET_SECRET')\n    }\n\n    const body = Object.entries(rawBody)\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&')\n\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body\n    })\n\n    if (res.ok) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\n\n      return {\n        newAccessToken,\n        newRefreshToken\n      }\n    } else {\n      const data = await res.json()\n      console.error('Error al renovar el token de acceso:', data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [
      "import { getEnv } from \"../utils\""
    ],
    "codeNoBody": "import { getEnv } from \"../utils\"\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/db::sql",
    "language": "typescript",
    "label": "sql",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/db",
    "totalTokens": 105,
    "inDegree": 8,
    "outDegree": 2,
    "code": "sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  prepare: false,\n  connect_timeout: 60,\n  idle_timeout: 60,\n  ssl: {\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\n  }\n  // ssl: {\n  //   rejectUnauthorized: false\n  // }\n})",
    "importStatements": [],
    "codeNoBody": "sql ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/db",
    "language": "typescript",
    "label": "db.ts",
    "type": "file",
    "totalTokens": 122,
    "inDegree": 1,
    "outDegree": 1,
    "code": "import { getEnv } from './utils'\nimport postgres from 'postgres'\n\nexport const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  prepare: false,\n  connect_timeout: 60,\n  idle_timeout: 60,\n  ssl: {\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\n  }\n  // ssl: {\n  //   rejectUnauthorized: false\n  // }\n})\n",
    "importStatements": [
      "import { getEnv } from './utils'",
      "import postgres from 'postgres'"
    ],
    "codeNoBody": "import { getEnv } from './utils'\nimport postgres from 'postgres'\nexport const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  prepare: false,\n  connect_timeout: 60,\n  idle_timeout: 60,\n  ssl: {\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\n  }\n  // ssl: {\n  //   rejectUnauthorized: false\n  // }\n})"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::getAccessToken",
    "language": "typescript",
    "label": "getAccessToken",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 216,
    "inDegree": 4,
    "outDegree": 3,
    "code": "async function getAccessToken(\n  gitProvider: GitServiceType,\n  connectionId: string,\n  UserOrgId: string\n): Promise<{\n  accessToken: string,\n  refreshToken: string\n} | null> {\n  if (connectionId === '-1') {\n    return {\n      accessToken: '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',\n      refreshToken: ''\n    }\n  }\n\n  try {\n    const table = `${gitProvider}_connections`\n    const rows = await sql`\n      SELECT \n        access_token,\n        refresh_token\n      FROM ${sql(table)}\n      WHERE \n        id = ${connectionId}\n        AND org_id = ${UserOrgId}\n    `\n\n    if (rows.length === 0) return null\n\n    return {\n      accessToken: rows[0].access_token,\n      refreshToken: rows[0].refresh_token\n    }\n  } catch (error) {\n    console.log(error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAccessToken(\n  gitProvider: GitServiceType,\n  connectionId: string,\n  UserOrgId: string\n): Promise<{\n  accessToken: string,\n  refreshToken: string\n} | null>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::getCommitHash",
    "language": "typescript",
    "label": "getCommitHash",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n  if (provider === 'github') {\n    return data[0].sha\n  } else if (provider === 'gitlab') {\n    return data[0].id\n  } else if (provider === 'bitbucket') {\n    return data.values[0].hash\n  }\n\n  return ''\n}",
    "importStatements": [],
    "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string{\n    //...\n}"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::getCommitRepo",
    "language": "typescript",
    "label": "getCommitRepo",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 608,
    "inDegree": 6,
    "outDegree": 4,
    "code": "async function getCommitRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  refreshToken: string,\n  connectionId: string,\n  gitlabRepoId?: number,\n): Promise<string> {\n  let commitUrl\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${accessToken}`\n  }\n\n  switch (gitService) {\n    case 'github':\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\n\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\n      headers['Accept'] = 'application/vnd.github+json'\n\n      break\n    case 'gitlab':\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\n      break\n    case 'bitbucket':\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\n      break\n  }\n  try {\n    const res = await fetch(commitUrl, {\n      headers\n    })\n\n    let data\n\n    if (!res.ok) {\n      const error = await res.json()\n\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\n        if (newAccessToken && newRefreshToken) {\n          await sql`\n            UPDATE gitlab_connections\n            SET \n              access_token = ${newAccessToken}, \n              refresh_token = ${newRefreshToken}\n            WHERE id = ${Number(connectionId)}\n          `\n        }\n\n        const res = await fetch(commitUrl, {\n          headers: {\n            Authorization: `Bearer ${newAccessToken}`\n          }\n        })\n        data = await res.json()\n      } else if (gitService === 'bitbucket' && res.status === 401) {\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\n\n        if (newAccessToken && newRefreshToken) {\n          await sql`\n            UPDATE bitbucket_connections\n            SET \n              access_token = ${newAccessToken}, \n              refresh_token = ${newRefreshToken}\n            WHERE id = ${connectionId}\n          `\n        }\n\n        const res = await fetch(commitUrl, {\n          headers: {\n            Authorization: `Bearer ${newAccessToken}`\n          }\n        })\n\n        data = await res.json()\n\n      } else {\n        console.log({ error })\n        throw new Error('Error fetching commit')\n\n      }\n\n    } else {\n      data = await res.json()\n    }\n\n\n    const commitSha = getCommitHash(gitService, data)\n    return commitSha\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getCommitRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  refreshToken: string,\n  connectionId: string,\n  gitlabRepoId?: number,\n): Promise<string>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::downloadAndExtractRepo",
    "language": "typescript",
    "label": "downloadAndExtractRepo",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 551,
    "inDegree": 5,
    "outDegree": 3,
    "code": "async function downloadAndExtractRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  commitSha: string,\n  gitlabRepoId?: number\n): Promise<string> {\n  let url\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${accessToken}`\n  }\n\n  switch (gitService) {\n    case 'github':\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\n\n      headers['Accept'] = 'application/vnd.github+json'\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\n      break\n    case 'gitlab':\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\n\n      break\n    case 'bitbucket':\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\n\n      break\n  }\n\n  try {\n    const response = await axios({\n      method: 'GET',\n      url,\n      responseType: 'arraybuffer',\n      headers\n    })\n\n    const tmpFolderPath = `${process.cwd()}/tmp`\n    await fs.mkdir(tmpFolderPath, { recursive: true })\n\n    const extractPath = path.join(tmpFolderPath, `${commitSha}_${repoOrg}_${repoName}_${branch}`)\n\n    // Save zip\n    const zipPath = `${extractPath}.zip`\n    await fs.writeFile(zipPath, response.data)\n\n    // Extract zip\n    const zip = new AdmZip(zipPath)\n\n    const zipEntries = zip.getEntries()\n\n    const mainFolderPath = zipEntries.find(\n      (entry: any) =>\n        entry.isDirectory &&\n        entry.entryName.endsWith('/') &&\n        (entry.entryName.match(/\\//g) || []).length == 1\n    )?.entryName\n    zip.extractAllTo(extractPath, true)\n\n    // Delete zip\n    await fs.unlink(zipPath)\n\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\n    const totalSize = await getTotalSize(finalPath) / 1024 / 1024\n    console.log(`${totalSize} MB`)\n    if (totalSize >= MAXSIZE) {\n      await fs.rm(extractPath, { recursive: true, force: true })\n      throw new Error(`Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`)\n   }\n    return finalPath\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function downloadAndExtractRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  commitSha: string,\n  gitlabRepoId?: number\n): Promise<string>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::MAXSIZE",
    "language": "typescript",
    "label": "MAXSIZE",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 5,
    "inDegree": 0,
    "outDegree": 1,
    "code": "MAXSIZE = 2",
    "importStatements": [],
    "codeNoBody": "MAXSIZE ={\n          //...\n      }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git::GitServiceType",
    "language": "typescript",
    "label": "GitServiceType",
    "type": "type",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "totalTokens": 18,
    "inDegree": 8,
    "outDegree": 2,
    "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "importStatements": [],
    "codeNoBody": "type GitServiceType ={\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/git",
    "language": "typescript",
    "label": "git.ts",
    "type": "file",
    "totalTokens": 1582,
    "inDegree": 6,
    "outDegree": 1,
    "code": "import axios from 'axios'\nimport fs from 'node:fs/promises'\nimport AdmZip from 'adm-zip'\nimport path from 'node:path'\nimport { sql } from './db'\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\nimport { getTotalSize } from '../model/utils'\n\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\n\nconst MAXSIZE = 2 // MB\n\nexport async function downloadAndExtractRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  commitSha: string,\n  gitlabRepoId?: number\n): Promise<string> {\n  let url\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${accessToken}`\n  }\n\n  switch (gitService) {\n    case 'github':\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\n\n      headers['Accept'] = 'application/vnd.github+json'\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\n      break\n    case 'gitlab':\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\n\n      break\n    case 'bitbucket':\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\n\n      break\n  }\n\n  try {\n    const response = await axios({\n      method: 'GET',\n      url,\n      responseType: 'arraybuffer',\n      headers\n    })\n\n    const tmpFolderPath = `${process.cwd()}/tmp`\n    await fs.mkdir(tmpFolderPath, { recursive: true })\n\n    const extractPath = path.join(tmpFolderPath, `${commitSha}_${repoOrg}_${repoName}_${branch}`)\n\n    // Save zip\n    const zipPath = `${extractPath}.zip`\n    await fs.writeFile(zipPath, response.data)\n\n    // Extract zip\n    const zip = new AdmZip(zipPath)\n\n    const zipEntries = zip.getEntries()\n\n    const mainFolderPath = zipEntries.find(\n      (entry: any) =>\n        entry.isDirectory &&\n        entry.entryName.endsWith('/') &&\n        (entry.entryName.match(/\\//g) || []).length == 1\n    )?.entryName\n    zip.extractAllTo(extractPath, true)\n\n    // Delete zip\n    await fs.unlink(zipPath)\n\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\n    const totalSize = await getTotalSize(finalPath) / 1024 / 1024\n    console.log(`${totalSize} MB`)\n    if (totalSize >= MAXSIZE) {\n      await fs.rm(extractPath, { recursive: true, force: true })\n      throw new Error(`Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`)\n   }\n    return finalPath\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}\n\nexport async function getCommitRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  refreshToken: string,\n  connectionId: string,\n  gitlabRepoId?: number,\n): Promise<string> {\n  let commitUrl\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${accessToken}`\n  }\n\n  switch (gitService) {\n    case 'github':\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\n\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\n      headers['Accept'] = 'application/vnd.github+json'\n\n      break\n    case 'gitlab':\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\n      break\n    case 'bitbucket':\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\n      break\n  }\n  try {\n    const res = await fetch(commitUrl, {\n      headers\n    })\n\n    let data\n\n    if (!res.ok) {\n      const error = await res.json()\n\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\n        if (newAccessToken && newRefreshToken) {\n          await sql`\n            UPDATE gitlab_connections\n            SET \n              access_token = ${newAccessToken}, \n              refresh_token = ${newRefreshToken}\n            WHERE id = ${Number(connectionId)}\n          `\n        }\n\n        const res = await fetch(commitUrl, {\n          headers: {\n            Authorization: `Bearer ${newAccessToken}`\n          }\n        })\n        data = await res.json()\n      } else if (gitService === 'bitbucket' && res.status === 401) {\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\n\n        if (newAccessToken && newRefreshToken) {\n          await sql`\n            UPDATE bitbucket_connections\n            SET \n              access_token = ${newAccessToken}, \n              refresh_token = ${newRefreshToken}\n            WHERE id = ${connectionId}\n          `\n        }\n\n        const res = await fetch(commitUrl, {\n          headers: {\n            Authorization: `Bearer ${newAccessToken}`\n          }\n        })\n\n        data = await res.json()\n\n      } else {\n        console.log({ error })\n        throw new Error('Error fetching commit')\n\n      }\n\n    } else {\n      data = await res.json()\n    }\n\n\n    const commitSha = getCommitHash(gitService, data)\n    return commitSha\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}\n\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n  if (provider === 'github') {\n    return data[0].sha\n  } else if (provider === 'gitlab') {\n    return data[0].id\n  } else if (provider === 'bitbucket') {\n    return data.values[0].hash\n  }\n\n  return ''\n}\n\nexport async function getAccessToken(\n  gitProvider: GitServiceType,\n  connectionId: string,\n  UserOrgId: string\n): Promise<{\n  accessToken: string,\n  refreshToken: string\n} | null> {\n  if (connectionId === '-1') {\n    return {\n      accessToken: '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',\n      refreshToken: ''\n    }\n  }\n\n  try {\n    const table = `${gitProvider}_connections`\n    const rows = await sql`\n      SELECT \n        access_token,\n        refresh_token\n      FROM ${sql(table)}\n      WHERE \n        id = ${connectionId}\n        AND org_id = ${UserOrgId}\n    `\n\n    if (rows.length === 0) return null\n\n    return {\n      accessToken: rows[0].access_token,\n      refreshToken: rows[0].refresh_token\n    }\n  } catch (error) {\n    console.log(error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import axios from 'axios'",
      "import fs from 'node:fs/promises'",
      "import AdmZip from 'adm-zip'",
      "import path from 'node:path'",
      "import { sql } from './db'",
      "import { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'",
      "import { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'",
      "import { getTotalSize } from '../model/utils'"
    ],
    "codeNoBody": "import axios from 'axios'\nimport fs from 'node:fs/promises'\nimport AdmZip from 'adm-zip'\nimport path from 'node:path'\nimport { sql } from './db'\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\nimport { getTotalSize } from '../model/utils'\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\n\nconst MAXSIZE = 2 // MB\n\nexport async function downloadAndExtractRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  commitSha: string,\n  gitlabRepoId?: number\n): Promise<string> {\n       //...\n       }\n\nexport async function getCommitRepo(\n  gitService: GitServiceType,\n  repoOrg: string,\n  repoName: string,\n  branch: string,\n  accessToken: string,\n  refreshToken: string,\n  connectionId: string,\n  gitlabRepoId?: number,\n): Promise<string> {\n       //...\n       }\n\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}\n\nexport async function getAccessToken(\n  gitProvider: GitServiceType,\n  connectionId: string,\n  UserOrgId: string\n): Promise<{\n  accessToken: string,\n  refreshToken: string\n} | null> {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/gitlab/refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/gitlab/refresh-token",
    "totalTokens": 236,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n  try {\n    const url = new URL('https://gitlab.com/oauth/token')\n    url.searchParams.set('refresh_token', refreshToken)\n    url.searchParams.set('grant_type', 'refresh_token')\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\n\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json'\n      }\n    })\n\n    if (res.ok) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\n\n      return {\n        newAccessToken,\n        newRefreshToken\n      }\n    } else {\n      const data = await res.json()\n      console.error('Error al renovar el token de acceso:', data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any>{\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/gitlab/refresh-token",
    "language": "typescript",
    "label": "refresh-token.ts",
    "type": "file",
    "totalTokens": 246,
    "inDegree": 1,
    "outDegree": 0,
    "code": "import { getEnv } from \"../utils\"\n\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n  try {\n    const url = new URL('https://gitlab.com/oauth/token')\n    url.searchParams.set('refresh_token', refreshToken)\n    url.searchParams.set('grant_type', 'refresh_token')\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\n\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json'\n      }\n    })\n\n    if (res.ok) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\n\n      return {\n        newAccessToken,\n        newRefreshToken\n      }\n    } else {\n      const data = await res.json()\n      console.error('Error al renovar el token de acceso:', data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [
      "import { getEnv } from \"../utils\""
    ],
    "codeNoBody": "import { getEnv } from \"../utils\"\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/utils::getEnv",
    "language": "typescript",
    "label": "getEnv",
    "type": "function",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/utils",
    "totalTokens": 49,
    "inDegree": 8,
    "outDegree": 2,
    "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\n  const env = ENV_VARS[envKey]\n  if (env == null) {\n    throw new Error(`Missing environment variable ${envKey}`)\n  }\n\n  return env\n}",
    "importStatements": [],
    "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS){\n           //...\n       }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/utils::ENV_VARS",
    "language": "typescript",
    "label": "ENV_VARS",
    "type": "assignment",
    "parent": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/utils",
    "totalTokens": 145,
    "inDegree": 1,
    "outDegree": 1,
    "code": "ENV_VARS = {\n\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\n  DATABASE_HOST: process.env.DATABASE_HOST,\n  DATABASE_PORT: process.env.DATABASE_PORT,\n  DATABASE_NAME: process.env.DATABASE_NAME,\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\n}",
    "importStatements": [],
    "codeNoBody": "ENV_VARS ={\n                 //...\n             }"
  },
  {
    "id": "/home/pudu/MISC/judini/codebase-index-ts/src/utils/utils",
    "language": "typescript",
    "label": "utils.ts",
    "type": "file",
    "totalTokens": 198,
    "inDegree": 2,
    "outDegree": 0,
    "code": "export const ENV_VARS = {\n\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\n  DATABASE_HOST: process.env.DATABASE_HOST,\n  DATABASE_PORT: process.env.DATABASE_PORT,\n  DATABASE_NAME: process.env.DATABASE_NAME,\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\n}\n//\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n  const env = ENV_VARS[envKey]\n  if (env == null) {\n    throw new Error(`Missing environment variable ${envKey}`)\n  }\n\n  return env\n}",
    "importStatements": [],
    "codeNoBody": "export const ENV_VARS = {\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\n  DATABASE_HOST: process.env.DATABASE_HOST,\n  DATABASE_PORT: process.env.DATABASE_PORT,\n  DATABASE_NAME: process.env.DATABASE_NAME,\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\n}\n//\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }"
  }
]