[
  {
    "id": "codebase-index-ts\\jest.config",
    "language": "typescript",
    "label": "codebase-index-ts\\jest.config.js",
    "type": "file",
    "totalTokens": 45,
    "inDegree": 0,
    "outDegree": 0,
    "code": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n  };\r\n  ",
    "importStatements": [],
    "codeNoBody": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n  };",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\index::port",
    "language": "typescript",
    "label": "port",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\index",
    "totalTokens": 5,
    "inDegree": 1,
    "outDegree": 1,
    "code": "port = 8001",
    "importStatements": [],
    "codeNoBody": "port = 8001",
    "originFile": "codebase-index-ts\\src\\index.ts"
  },
  {
    "id": "codebase-index-ts\\src\\index::app",
    "language": "typescript",
    "label": "app",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\index",
    "totalTokens": 376,
    "inDegree": 0,
    "outDegree": 1,
    "code": "app = new Hono()\napp.use(\"*\", prettyJSON())\napp.use(\"/v1/*\", cors())\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n})\napp.route(\"/v1/repo\", createGraph)\napp.route(\"/v1/graphs\", graphs)\napp.route(\"v1/repo-test\", createGraphTest)",
    "importStatements": [],
    "codeNoBody": "app = new Hono()\napp.use(\"*\", prettyJSON())\napp.use(\"/v1/*\", cors())\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n})\napp.route(\"/v1/repo\", createGraph)\napp.route(\"/v1/graphs\", graphs)\napp.route(\"v1/repo-test\", createGraphTest)",
    "originFile": "codebase-index-ts\\src\\index.ts"
  },
  {
    "id": "codebase-index-ts\\src\\index",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\index.ts",
    "type": "file",
    "totalTokens": 520,
    "inDegree": 2,
    "outDegree": 1,
    "code": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\n\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});\r\n",
    "importStatements": [
      "import { serve } from \"@hono/node-server\";",
      "import { Hono } from \"hono\";",
      "import { cors } from \"hono/cors\";",
      "import { prettyJSON } from \"hono/pretty-json\";",
      "import { createGraph } from \"./routes/create_graph\";",
      "import { createGraphTest } from \"./routes/create_graph-test\";",
      "import { graphs } from \"./routes/graphs\";",
      "import { Codebase } from \"./model/codebase\";",
      "import { writeFile } from \"node:fs/promises\";"
    ],
    "codeNoBody": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallsCapturer.getCallsFromNode",
    "language": "typescript",
    "label": "CallsCapturer.getCallsFromNode",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 758,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n    //...\n    }",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallsCapturer.captureCalls",
    "language": "typescript",
    "label": "CallsCapturer.captureCalls",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 469,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n    //...\n    }",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallsCapturer.captureAssignments",
    "language": "typescript",
    "label": "CallsCapturer.captureAssignments",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 425,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n    //...\n    }",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallsCapturer.constructor",
    "language": "typescript",
    "label": "CallsCapturer.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "totalTokens": 159,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\n    //...\n    }",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallsCapturer",
    "language": "typescript",
    "label": "CallsCapturer",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\calls",
    "totalTokens": 1847,
    "inDegree": 9,
    "outDegree": 4,
    "code": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "importStatements": [],
    "codeNoBody": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n        //...\n    }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallIdentifier.constructor",
    "language": "typescript",
    "label": "CallIdentifier.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\calls::CallIdentifier",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\n    //...\n    }",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::CallIdentifier",
    "language": "typescript",
    "label": "CallIdentifier",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\calls",
    "totalTokens": 45,
    "inDegree": 6,
    "outDegree": 2,
    "code": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "importStatements": [],
    "codeNoBody": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls::VariableAssignment",
    "language": "typescript",
    "label": "VariableAssignment",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\calls",
    "totalTokens": 36,
    "inDegree": 4,
    "outDegree": 2,
    "code": "class VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}",
    "importStatements": [],
    "codeNoBody": "class VariableAssignment {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\model\\calls.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\calls",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\model\\calls.ts",
    "type": "file",
    "totalTokens": 1965,
    "inDegree": 3,
    "outDegree": 3,
    "code": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\n\r\nclass VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}\r\n\r\nclass CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}\r\n\r\nexport class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "importStatements": [
      "import { cleanAndSplitContent, captureQuery } from \"./utils\"",
      "import { Node, ImportStatement} from \"./codebase\"",
      "import { itselfClassMap } from \"./consts\""
    ],
    "codeNoBody": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\nclass VariableAssignment {\n//...\n}\r\n\r\nclass CallIdentifier {\n//...\n}\r\n\r\nexport class CallsCapturer {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.resolveHeaderC",
    "language": "typescript",
    "label": "Codebase.resolveHeaderC",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 190,
    "inDegree": 1,
    "outDegree": 5,
    "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (\r\n      headerNode.type !== \"header\" ||\r\n      ![\"c\", \"cpp\"].includes(headerNode.language)\r\n    )\r\n      return;\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id);\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode\r\n        .getAllChildren()\r\n        .find((c) => c.id === id.replace(\"::header\", \"\"));\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id];\r\n        headerNode.removeChild(headerNode.children[id]);\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef;\r\n        headerNode.inDegree++;\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
    "language": "typescript",
    "label": "Codebase.resolveImportStatementsNodes",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 426,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (![\"file\", \"header\"].includes(n.type)) return;\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node =\r\n            this.nodesMap[`${i.path}::${n.name}`] ||\r\n            this.nodesMap[`${i.module}::${n.name}`];\r\n        });\r\n        const namesIds = i.names.map((n) => n.node?.id || \"\");\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"package\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        });\r\n        if ([\"c\", \"cpp\"].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path];\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode);\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        }\r\n      });\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
    "language": "typescript",
    "label": "Codebase.resolvePythonInitImportStatements",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 176,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (n.type !== \"file\" || n.language !== \"python\") return;\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements];\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith(\"__init__\")) {\r\n          newImportStatements = newImportStatements.filter(\r\n            (s) => s.path != i.path\r\n          );\r\n          newImportStatements = [\r\n            ...this.nodesMap[i.path].importStatements,\r\n            ...newImportStatements,\r\n          ];\r\n        }\r\n      });\r\n      n.importStatements = newImportStatements;\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.getLinks",
    "language": "typescript",
    "label": "Codebase.getLinks",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 171,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getLinks(): Link[] {\r\n    const links: Link[] = [];\r\n    const nodes = Object.values(this.nodesMap);\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = \"defines\";\r\n        links.push({\r\n          source: n.parent.id,\r\n          target: n.id,\r\n          label,\r\n          line: n.startPosition.row + 1,\r\n        });\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({\r\n            source: n.id,\r\n            target: c.node.id,\r\n            label: \"calls\",\r\n            line: c.lines[0] + 1,\r\n          })\r\n        );\r\n    }\r\n    return links;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[] {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.simplify",
    "language": "typescript",
    "label": "Codebase.simplify",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes));\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.getCalls",
    "language": "typescript",
    "label": "Codebase.getCalls",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 360,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId];\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`);\r\n        return;\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose);\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()];\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n);\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId];\r\n          if (\r\n            calledNode &&\r\n            ![\"package\", \"mod\", \"namespace\"].includes(calledNode.type)\r\n          ) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines); // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              );\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.parseFolder",
    "language": "typescript",
    "label": "Codebase.parseFolder",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 235,
    "inDegree": 0,
    "outDegree": 8,
    "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {};\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    const allFiles = await getAllFiles(this.rootFolderPath);\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split(\".\").slice(0, -1).join(\".\");\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(\r\n          filePath\r\n        );\r\n        this.addNodeMap(nodesMap);\r\n        id = isHeader ? `${id}::header` : id;\r\n        const fileNode = nodesMap[id];\r\n        fileNodesMap[id] = fileNode;\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles);\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`);\r\n        console.log(error.message);\r\n        throw error;\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements();\r\n    this.resolveSpaces();\r\n    this.resolveImportStatementsNodes();\r\n    return fileNodesMap;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.resolveSpaces",
    "language": "typescript",
    "label": "Codebase.resolveSpaces",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 328,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Codebase\n    ...\n    resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {};\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(\r\n        `${spaceName}`,\r\n        \"\",\r\n        nodes[0].type,\r\n        nodes[0].language\r\n      );\r\n      globalNode.name = spaceName;\r\n      globalNode.alias = spaceName;\r\n      globalNode.parent = nodes[0].parent;\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + \"\\n\\n\";\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id;\r\n          delete this.nodesMap[oldId];\r\n          c.id = `${spaceName}::${c.name}`;\r\n          if (\r\n            c.parent &&\r\n            [\"file\", \"package\", \"mod\", \"namespace\"].includes(c.parent.type)\r\n          )\r\n            globalNode.addChild(c);\r\n\r\n          this.nodesMap[c.id] = c;\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n);\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode;\r\n          this.nodesMap[n.parent.id].inDegree++;\r\n          delete this.nodesMap[n.id];\r\n          this.nodesMap[globalNode.id] = globalNode;\r\n        }\r\n      });\r\n      globalSpaceMap[spaceName] = [globalNode];\r\n    });\r\n\r\n    this.spaceMap = globalSpaceMap;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    resolveSpaces() {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
    "language": "typescript",
    "label": "Codebase.generateNodesFromFilePath",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 364,
    "inDegree": 1,
    "outDegree": 8,
    "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split(\".\").pop();\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false };\r\n    const data = await fs.readFile(filePath);\r\n    const dataString = Buffer.from(data).toString();\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split(\".\").slice(0, -1).join(\".\");\r\n\r\n    let fileNode;\r\n    let isHeader = false;\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === \"h\") {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        \"header\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n      isHeader = true;\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        \"file\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n    }\r\n    fileNode.name = filePath;\r\n    fileNode.alias = filePath.split(\"/\").pop() || \"\";\r\n    const nodesMap = fileNode.getChildrenDefinitions();\r\n    fileNode.generateImports();\r\n    fileNode.parseExportClauses(this.nodesMap);\r\n    nodesMap[fileNode.id] = fileNode;\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, \"all\", []).length;\r\n      // save space nodes\r\n      if ([\"namespace\", \"package\", \"mod\"].includes(n.type))\r\n        this.addNodeToSpaceMap(n);\r\n    });\r\n\r\n    return { nodesMap, isHeader };\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
    "language": "typescript",
    "label": "Codebase.addNodeToSpaceMap",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = [];\r\n    this.spaceMap[node.name].push(node);\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.addNodeMap",
    "language": "typescript",
    "label": "Codebase.addNodeMap",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 32,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap };\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.getNode",
    "language": "typescript",
    "label": "Codebase.getNode",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 18,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id];\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.addNode",
    "language": "typescript",
    "label": "Codebase.addNode",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 19,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Codebase\n    ...\n    addNode(node: Node) {\r\n    this.nodesMap[node.id] = node;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase.constructor",
    "language": "typescript",
    "label": "Codebase.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Codebase",
    "language": "typescript",
    "label": "Codebase",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 2490,
    "inDegree": 30,
    "outDegree": 4,
    "code": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = \"\";\r\n  nodesMap: { [id: string]: Node } = {};\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {};\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node;\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id];\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap };\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = [];\r\n    this.spaceMap[node.name].push(node);\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split(\".\").pop();\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false };\r\n    const data = await fs.readFile(filePath);\r\n    const dataString = Buffer.from(data).toString();\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split(\".\").slice(0, -1).join(\".\");\r\n\r\n    let fileNode;\r\n    let isHeader = false;\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === \"h\") {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        \"header\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n      isHeader = true;\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        \"file\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n    }\r\n    fileNode.name = filePath;\r\n    fileNode.alias = filePath.split(\"/\").pop() || \"\";\r\n    const nodesMap = fileNode.getChildrenDefinitions();\r\n    fileNode.generateImports();\r\n    fileNode.parseExportClauses(this.nodesMap);\r\n    nodesMap[fileNode.id] = fileNode;\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, \"all\", []).length;\r\n      // save space nodes\r\n      if ([\"namespace\", \"package\", \"mod\"].includes(n.type))\r\n        this.addNodeToSpaceMap(n);\r\n    });\r\n\r\n    return { nodesMap, isHeader };\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {};\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(\r\n        `${spaceName}`,\r\n        \"\",\r\n        nodes[0].type,\r\n        nodes[0].language\r\n      );\r\n      globalNode.name = spaceName;\r\n      globalNode.alias = spaceName;\r\n      globalNode.parent = nodes[0].parent;\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + \"\\n\\n\";\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id;\r\n          delete this.nodesMap[oldId];\r\n          c.id = `${spaceName}::${c.name}`;\r\n          if (\r\n            c.parent &&\r\n            [\"file\", \"package\", \"mod\", \"namespace\"].includes(c.parent.type)\r\n          )\r\n            globalNode.addChild(c);\r\n\r\n          this.nodesMap[c.id] = c;\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n);\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode;\r\n          this.nodesMap[n.parent.id].inDegree++;\r\n          delete this.nodesMap[n.id];\r\n          this.nodesMap[globalNode.id] = globalNode;\r\n        }\r\n      });\r\n      globalSpaceMap[spaceName] = [globalNode];\r\n    });\r\n\r\n    this.spaceMap = globalSpaceMap;\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {};\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    const allFiles = await getAllFiles(this.rootFolderPath);\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split(\".\").slice(0, -1).join(\".\");\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(\r\n          filePath\r\n        );\r\n        this.addNodeMap(nodesMap);\r\n        id = isHeader ? `${id}::header` : id;\r\n        const fileNode = nodesMap[id];\r\n        fileNodesMap[id] = fileNode;\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles);\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`);\r\n        console.log(error.message);\r\n        throw error;\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements();\r\n    this.resolveSpaces();\r\n    this.resolveImportStatementsNodes();\r\n    return fileNodesMap;\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId];\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`);\r\n        return;\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose);\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()];\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n);\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId];\r\n          if (\r\n            calledNode &&\r\n            ![\"package\", \"mod\", \"namespace\"].includes(calledNode.type)\r\n          ) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines); // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              );\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes));\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = [];\r\n    const nodes = Object.values(this.nodesMap);\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = \"defines\";\r\n        links.push({\r\n          source: n.parent.id,\r\n          target: n.id,\r\n          label,\r\n          line: n.startPosition.row + 1,\r\n        });\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({\r\n            source: n.id,\r\n            target: c.node.id,\r\n            label: \"calls\",\r\n            line: c.lines[0] + 1,\r\n          })\r\n        );\r\n    }\r\n    return links;\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (n.type !== \"file\" || n.language !== \"python\") return;\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements];\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith(\"__init__\")) {\r\n          newImportStatements = newImportStatements.filter(\r\n            (s) => s.path != i.path\r\n          );\r\n          newImportStatements = [\r\n            ...this.nodesMap[i.path].importStatements,\r\n            ...newImportStatements,\r\n          ];\r\n        }\r\n      });\r\n      n.importStatements = newImportStatements;\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (![\"file\", \"header\"].includes(n.type)) return;\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node =\r\n            this.nodesMap[`${i.path}::${n.name}`] ||\r\n            this.nodesMap[`${i.module}::${n.name}`];\r\n        });\r\n        const namesIds = i.names.map((n) => n.node?.id || \"\");\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"package\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        });\r\n        if ([\"c\", \"cpp\"].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path];\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode);\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (\r\n      headerNode.type !== \"header\" ||\r\n      ![\"c\", \"cpp\"].includes(headerNode.language)\r\n    )\r\n      return;\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id);\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode\r\n        .getAllChildren()\r\n        .find((c) => c.id === id.replace(\"::header\", \"\"));\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id];\r\n        headerNode.removeChild(headerNode.children[id]);\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef;\r\n        headerNode.inDegree++;\r\n      }\r\n    });\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = \"\";\r\n  nodesMap: { [id: string]: Node } = {};\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {};\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }\r\n  addNode(node: Node) {\n      //...\n  }\r\n  getNode(id: string): Node | undefined {\n      //...\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\n      //...\n  }\r\n  addNodeToSpaceMap(node: Node) {\n      //...\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n      //...\n  }\r\n\r\n  resolveSpaces() {\n      //...\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\n      //...\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n\r\n  getLinks(): Link[] {\n      //...\n  }\r\n\r\n  resolvePythonInitImportStatements() {\n      //...\n  }\r\n\r\n  resolveImportStatementsNodes() {\n      //...\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\n      //...\n  }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.simplify",
    "language": "typescript",
    "label": "Node.simplify",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 279,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && [\"class\", \"interface\"].includes(this.parent?.type)\r\n          ? `${this.parent.code\r\n              .replace(this.parent.body, \"\")\r\n              .trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile,\r\n    };\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes;\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr];\r\n      }\r\n      return acc;\r\n    }, {});\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.getChildrenDefinitions",
    "language": "typescript",
    "label": "Node.getChildrenDefinitions",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 1529,
    "inDegree": 1,
    "outDegree": 3,
    "code": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (![\"file\", \"header\"].includes(this.type)) return {};\r\n    const unnecessaryNodeTypes = [\"export\"]; // exclude it from the analysis\r\n    const captures = captureQuery(\r\n      this.language,\r\n      \"constructorDefinitions\",\r\n      this.code\r\n    );\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let exportable = [\"python\", \"php\"].includes(this.language) ? true : false;\r\n    let childrenNodes: Node[] = [];\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(\r\n          this.id,\r\n          c.node.text,\r\n          c.name as AllowedTypes,\r\n          this.language\r\n        );\r\n\r\n        newNode.startPosition = c.node.startPosition;\r\n        newNode.endPosition = c.node.endPosition;\r\n        newNode.exportable = exportable;\r\n        newNode.originFile = this.name;\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling;\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text;\r\n          }\r\n        }\r\n        childrenNodes.push(newNode);\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === \"python\") {\r\n          prevTreeSitterNode = c.node.previousSibling;\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              [\"decorator\"].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row ===\r\n                newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + \"\\n\" + newNode.code;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code;\r\n      if ([\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) {\r\n        if (n.type === \"method\") {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`;\r\n          n.type = \"function\";\r\n        } else if (n.type === \"assignment\") code = `const ${n.code}`;\r\n      } else if ([\"java\"].includes(this.language)) {\r\n        if (n.type == \"function\") {\r\n          const firstLine = code.split(\"(\")[0];\r\n          const firstLineSplit = firstLine.split(\" \");\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, \"definitionTemplate\", code);\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(\r\n        captures,\r\n        n.language === \"java\" ? \"modifier\" : \"name\"\r\n      );\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"modifier\": // java, php only\r\n            if (\r\n              [\"php\", \"java\"].includes(n.language) &&\r\n              c.node.text.includes(\"public\")\r\n            )\r\n              n.exportable = true;\r\n            break;\r\n          case \"name\":\r\n            n.name = c.node.text;\r\n            n.id = `${n.id}::${n.name}`;\r\n            break;\r\n          case \"alias\":\r\n            n.alias = c.node.text;\r\n            break;\r\n          case \"documentation\":\r\n            n.documentation = c.node.text;\r\n            if (n.language === \"python\") {\r\n              n.code = n.code.replace(n.documentation, \"\");\r\n              n.body = n.body.replace(n.documentation, \"\");\r\n            }\r\n            break;\r\n          case \"body\":\r\n            n.body = c.node.text;\r\n            break;\r\n        }\r\n      });\r\n      if (!n.alias) n.alias = n.name;\r\n\r\n      if (n.type === \"assignment\") {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          \"extraAssignmentCode\",\r\n          this.code,\r\n          n.name\r\n        );\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === \"code\") n.code += \"\\n\" + c.node.text;\r\n        });\r\n      }\r\n    });\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name);\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null;\r\n    if ([\"java\", \"php\"].includes(this.language)) {\r\n      const captures = captureQuery(\r\n        this.language,\r\n        \"spaceDeclaration\",\r\n        this.code\r\n      );\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"spaceName\":\r\n            const spaceName = c.node.text;\r\n            const initialLine = c.node.startPosition.row;\r\n            const type = \"java\" == this.language ? \"package\" : \"namespace\";\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split(\"\\n\").slice(initialLine, -1).join(\"\\n\"),\r\n              type,\r\n              this.language\r\n            );\r\n            spaceNode.name = spaceName;\r\n            spaceNode.alias = spaceName;\r\n            spaceNode.exportable = true;\r\n            break;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode);\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j]);\r\n        childrenNodes[j].addNodeRelationship(n);\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n);\r\n    });\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n;\r\n      return map;\r\n    }, {});\r\n    return nodesMap;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.resolveImportStatementsPath",
    "language": "typescript",
    "label": "Node.resolveImportStatementsPath",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 342,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== \"file\") return;\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language];\r\n    const fileSet = new Set(\r\n      allFiles.map((p) => p.split(\".\").slice(0, -1).join(\".\"))\r\n    );\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(\r\n            `${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`\r\n          )\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path),\r\n      ];\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith(\"@/\")) {\r\n        importStatement.path = path.join(\r\n          rootFolderPath,\r\n          importStatement.path.slice(2)\r\n        );\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.parseExportClauses",
    "language": "typescript",
    "label": "Node.parseExportClauses",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 572,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (![\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) return;\r\n    const captures = captureQuery(this.language, \"exportClauses\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let name = \"\";\r\n    let alias = \"\";\r\n    let moduleName = this.id;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"module\":\r\n          moduleName = path.join(\r\n            this.id.split(\"/\").slice(0, -1).join(\"/\"),\r\n            c.node.text\r\n          );\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          name = c.node.text;\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0];\r\n          if (importedName) moduleName = importedName.path;\r\n          const node =\r\n            this.children[`${this.id}::${name}`] ||\r\n            nodesMap[`${moduleName}::${name}`];\r\n          if (node) {\r\n            node.exportable = true;\r\n            node.alias = alias ? alias : name;\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            node.id = `${this.id}::${node.alias}`;\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`];\r\n              this.children[node.id] = node;\r\n              const childrenNodes = Object.values(node.children);\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias);\r\n                delete node.children[n.id];\r\n                n.id = `${this.id}::${n.alias}`;\r\n                node.children[n.id] = n;\r\n              });\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    });\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.generateImports",
    "language": "typescript",
    "label": "Node.generateImports",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 397,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class Node\n    ...\n    generateImports() {\r\n    if (this.type !== \"file\") return;\r\n    const captures = captureQuery(this.language, \"importStatements\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = [];\r\n    let newImportStatement = new ImportStatement();\r\n    let alias: string;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"module\":\r\n          newImportStatement.module = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          const name = c.node.text;\r\n          if (!alias) alias = name;\r\n          const newImportName = new ImportName(name, alias);\r\n          newImportStatement.names.push(newImportName);\r\n          alias = \"\";\r\n          break;\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case \"import_statement\":\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias;\r\n            alias = \"\";\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module;\r\n          }\r\n\r\n          newImportStatement.path = renameSource(\r\n            this.id,\r\n            newImportStatement.module,\r\n            this.language\r\n          );\r\n          newImportStatement.code = c.node.text.trimEnd();\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement);\r\n          newImportStatement = new ImportStatement();\r\n          break;\r\n      }\r\n    });\r\n    this.importStatements = importStatements.reverse();\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    generateImports() {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.getCodeWithoutBody",
    "language": "typescript",
    "label": "Node.getCodeWithoutBody",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 817,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false) {\r\n    let code = this.code;\r\n\r\n    if (\r\n      (this.body || this.type === \"file\") &&\r\n      ![\"assignment\", \"type\", \"enum\"].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== \"java\"\r\n            ? newClassMethodsMap[this.language]\r\n            : this.name;\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === \"class\") {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return;\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          } else if (\r\n            this.type === \"file\" &&\r\n            ![\"assignment\", \"type\", \"enum\"].includes(n.type)\r\n          ) {\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}//...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else if (this.body) {\r\n        const spaces = \" \".repeat(this.startPosition.column);\r\n        let bodyTotalLines = considerLines ? this.body.split(\"\\n\").length : 1;\r\n        if (this.language === \"python\") {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n          );\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` +\r\n              \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n          );\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, \"\\n\");\r\n    if (this.parent && [\"class\", \"interface\"].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines\r\n          ? this.parent.body.split(\"\\n\").length\r\n          : 1;\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, \"\")}` +\r\n          \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`;\r\n      } else {\r\n        code = `${this.parent.code\r\n          .replace(this.parent.body, \"\")\r\n          .trim()}\\n    ...\\n    ${code}`;\r\n      }\r\n    }\r\n    return code;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.addNodeRelationship",
    "language": "typescript",
    "label": "Node.addNodeRelationship",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 231,
    "inDegree": 0,
    "outDegree": 4,
    "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === \"export\") {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true;\r\n        if (!this.documentation) this.documentation = node.documentation;\r\n        return;\r\n      }\r\n      if (this.type === \"export\") return; // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (\r\n        [\"class\", \"interface\"].includes(node.type) &&\r\n        this.type === \"function\"\r\n      ) {\r\n        this.type = \"method\";\r\n        this.name = `${node.name}.${this.name}`;\r\n        this.alias = this.name; // methods has no alias\r\n      }\r\n      this.id = `${this.id.split(\"::\")[0]}::${this.name}`;\r\n      node.addChild(this);\r\n    }\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.isWithin",
    "language": "typescript",
    "label": "Node.isWithin",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 37,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    );\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.addImportStatement",
    "language": "typescript",
    "label": "Node.addImportStatement",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 20,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement);\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.addCall",
    "language": "typescript",
    "label": "Node.addCall",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 40,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines });\r\n    node.inDegree++;\r\n    this.outDegree++;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.removeChild",
    "language": "typescript",
    "label": "Node.removeChild",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 48,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id];\r\n      this.inDegree--;\r\n      child.outDegree--;\r\n    }\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    removeChild(child: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.addChild",
    "language": "typescript",
    "label": "Node.addChild",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 39,
    "inDegree": 3,
    "outDegree": 2,
    "code": "class Node\n    ...\n    addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child;\r\n    child.parent = this;\r\n    this.inDegree++;\r\n    child.outDegree++;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    addChild(child: Node) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.getAllChildren",
    "language": "typescript",
    "label": "Node.getAllChildren",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 74,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = [];\r\n    if (parentTypes && !parentTypes.includes(this.type)) return [];\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child);\r\n      children.push(...child.getAllChildren());\r\n    }\r\n    return children;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.getChild",
    "language": "typescript",
    "label": "Node.getChild",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 89,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId];\r\n    } else if (this.type === \"file\") {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId);\r\n        if (result) return result;\r\n      }\r\n    }\r\n    return;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node.constructor",
    "language": "typescript",
    "label": "Node.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::Node",
    "totalTokens": 59,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class Node\n    ...\n    constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }",
    "importStatements": [],
    "codeNoBody": "class Node\n    ...\n    constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Node",
    "language": "typescript",
    "label": "Node",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 4797,
    "inDegree": 44,
    "outDegree": 4,
    "code": "class Node {\r\n  id: string = \"\"; // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = \"function\";\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  language: string = \"\";\r\n  importStatements: ImportStatement[] = []; // only for files\r\n  totalTokens: number = 0;\r\n  documentation: string = \"\";\r\n  code: string = \"\";\r\n  body: string = \"\";\r\n  exportable: boolean = false;\r\n  parent?: Node;\r\n  children: { [key: string]: Node } = {};\r\n  calls: NodeCallTuple[] = [];\r\n  startPosition: Point = { row: 0, column: 0 };\r\n  endPosition: Point = { row: 99999, column: 0 };\r\n  inDegree: number = 0;\r\n  outDegree: number = 0;\r\n  // originFile is the file where the node is defined\r\n  originFile: string = \"\";\r\n\r\n  constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId];\r\n    } else if (this.type === \"file\") {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId);\r\n        if (result) return result;\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = [];\r\n    if (parentTypes && !parentTypes.includes(this.type)) return [];\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child);\r\n      children.push(...child.getAllChildren());\r\n    }\r\n    return children;\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child;\r\n    child.parent = this;\r\n    this.inDegree++;\r\n    child.outDegree++;\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id];\r\n      this.inDegree--;\r\n      child.outDegree--;\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines });\r\n    node.inDegree++;\r\n    this.outDegree++;\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement);\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    );\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === \"export\") {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true;\r\n        if (!this.documentation) this.documentation = node.documentation;\r\n        return;\r\n      }\r\n      if (this.type === \"export\") return; // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (\r\n        [\"class\", \"interface\"].includes(node.type) &&\r\n        this.type === \"function\"\r\n      ) {\r\n        this.type = \"method\";\r\n        this.name = `${node.name}.${this.name}`;\r\n        this.alias = this.name; // methods has no alias\r\n      }\r\n      this.id = `${this.id.split(\"::\")[0]}::${this.name}`;\r\n      node.addChild(this);\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false) {\r\n    let code = this.code;\r\n\r\n    if (\r\n      (this.body || this.type === \"file\") &&\r\n      ![\"assignment\", \"type\", \"enum\"].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== \"java\"\r\n            ? newClassMethodsMap[this.language]\r\n            : this.name;\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === \"class\") {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return;\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          } else if (\r\n            this.type === \"file\" &&\r\n            ![\"assignment\", \"type\", \"enum\"].includes(n.type)\r\n          ) {\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}//...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else if (this.body) {\r\n        const spaces = \" \".repeat(this.startPosition.column);\r\n        let bodyTotalLines = considerLines ? this.body.split(\"\\n\").length : 1;\r\n        if (this.language === \"python\") {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n          );\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` +\r\n              \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n          );\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, \"\\n\");\r\n    if (this.parent && [\"class\", \"interface\"].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines\r\n          ? this.parent.body.split(\"\\n\").length\r\n          : 1;\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, \"\")}` +\r\n          \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`;\r\n      } else {\r\n        code = `${this.parent.code\r\n          .replace(this.parent.body, \"\")\r\n          .trim()}\\n    ...\\n    ${code}`;\r\n      }\r\n    }\r\n    return code;\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== \"file\") return;\r\n    const captures = captureQuery(this.language, \"importStatements\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = [];\r\n    let newImportStatement = new ImportStatement();\r\n    let alias: string;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"module\":\r\n          newImportStatement.module = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          const name = c.node.text;\r\n          if (!alias) alias = name;\r\n          const newImportName = new ImportName(name, alias);\r\n          newImportStatement.names.push(newImportName);\r\n          alias = \"\";\r\n          break;\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case \"import_statement\":\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias;\r\n            alias = \"\";\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module;\r\n          }\r\n\r\n          newImportStatement.path = renameSource(\r\n            this.id,\r\n            newImportStatement.module,\r\n            this.language\r\n          );\r\n          newImportStatement.code = c.node.text.trimEnd();\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement);\r\n          newImportStatement = new ImportStatement();\r\n          break;\r\n      }\r\n    });\r\n    this.importStatements = importStatements.reverse();\r\n  }\r\n\r\n  parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (![\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) return;\r\n    const captures = captureQuery(this.language, \"exportClauses\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let name = \"\";\r\n    let alias = \"\";\r\n    let moduleName = this.id;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"module\":\r\n          moduleName = path.join(\r\n            this.id.split(\"/\").slice(0, -1).join(\"/\"),\r\n            c.node.text\r\n          );\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          name = c.node.text;\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0];\r\n          if (importedName) moduleName = importedName.path;\r\n          const node =\r\n            this.children[`${this.id}::${name}`] ||\r\n            nodesMap[`${moduleName}::${name}`];\r\n          if (node) {\r\n            node.exportable = true;\r\n            node.alias = alias ? alias : name;\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            node.id = `${this.id}::${node.alias}`;\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`];\r\n              this.children[node.id] = node;\r\n              const childrenNodes = Object.values(node.children);\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias);\r\n                delete node.children[n.id];\r\n                n.id = `${this.id}::${n.alias}`;\r\n                node.children[n.id] = n;\r\n              });\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== \"file\") return;\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language];\r\n    const fileSet = new Set(\r\n      allFiles.map((p) => p.split(\".\").slice(0, -1).join(\".\"))\r\n    );\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(\r\n            `${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`\r\n          )\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path),\r\n      ];\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith(\"@/\")) {\r\n        importStatement.path = path.join(\r\n          rootFolderPath,\r\n          importStatement.path.slice(2)\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (![\"file\", \"header\"].includes(this.type)) return {};\r\n    const unnecessaryNodeTypes = [\"export\"]; // exclude it from the analysis\r\n    const captures = captureQuery(\r\n      this.language,\r\n      \"constructorDefinitions\",\r\n      this.code\r\n    );\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let exportable = [\"python\", \"php\"].includes(this.language) ? true : false;\r\n    let childrenNodes: Node[] = [];\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(\r\n          this.id,\r\n          c.node.text,\r\n          c.name as AllowedTypes,\r\n          this.language\r\n        );\r\n\r\n        newNode.startPosition = c.node.startPosition;\r\n        newNode.endPosition = c.node.endPosition;\r\n        newNode.exportable = exportable;\r\n        newNode.originFile = this.name;\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling;\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text;\r\n          }\r\n        }\r\n        childrenNodes.push(newNode);\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === \"python\") {\r\n          prevTreeSitterNode = c.node.previousSibling;\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              [\"decorator\"].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row ===\r\n                newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + \"\\n\" + newNode.code;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code;\r\n      if ([\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) {\r\n        if (n.type === \"method\") {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`;\r\n          n.type = \"function\";\r\n        } else if (n.type === \"assignment\") code = `const ${n.code}`;\r\n      } else if ([\"java\"].includes(this.language)) {\r\n        if (n.type == \"function\") {\r\n          const firstLine = code.split(\"(\")[0];\r\n          const firstLineSplit = firstLine.split(\" \");\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, \"definitionTemplate\", code);\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(\r\n        captures,\r\n        n.language === \"java\" ? \"modifier\" : \"name\"\r\n      );\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"modifier\": // java, php only\r\n            if (\r\n              [\"php\", \"java\"].includes(n.language) &&\r\n              c.node.text.includes(\"public\")\r\n            )\r\n              n.exportable = true;\r\n            break;\r\n          case \"name\":\r\n            n.name = c.node.text;\r\n            n.id = `${n.id}::${n.name}`;\r\n            break;\r\n          case \"alias\":\r\n            n.alias = c.node.text;\r\n            break;\r\n          case \"documentation\":\r\n            n.documentation = c.node.text;\r\n            if (n.language === \"python\") {\r\n              n.code = n.code.replace(n.documentation, \"\");\r\n              n.body = n.body.replace(n.documentation, \"\");\r\n            }\r\n            break;\r\n          case \"body\":\r\n            n.body = c.node.text;\r\n            break;\r\n        }\r\n      });\r\n      if (!n.alias) n.alias = n.name;\r\n\r\n      if (n.type === \"assignment\") {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          \"extraAssignmentCode\",\r\n          this.code,\r\n          n.name\r\n        );\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === \"code\") n.code += \"\\n\" + c.node.text;\r\n        });\r\n      }\r\n    });\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name);\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null;\r\n    if ([\"java\", \"php\"].includes(this.language)) {\r\n      const captures = captureQuery(\r\n        this.language,\r\n        \"spaceDeclaration\",\r\n        this.code\r\n      );\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"spaceName\":\r\n            const spaceName = c.node.text;\r\n            const initialLine = c.node.startPosition.row;\r\n            const type = \"java\" == this.language ? \"package\" : \"namespace\";\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split(\"\\n\").slice(initialLine, -1).join(\"\\n\"),\r\n              type,\r\n              this.language\r\n            );\r\n            spaceNode.name = spaceName;\r\n            spaceNode.alias = spaceName;\r\n            spaceNode.exportable = true;\r\n            break;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode);\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j]);\r\n        childrenNodes[j].addNodeRelationship(n);\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n);\r\n    });\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n;\r\n      return map;\r\n    }, {});\r\n    return nodesMap;\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && [\"class\", \"interface\"].includes(this.parent?.type)\r\n          ? `${this.parent.code\r\n              .replace(this.parent.body, \"\")\r\n              .trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile,\r\n    };\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes;\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr];\r\n      }\r\n      return acc;\r\n    }, {});\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class Node {\r\n  id: string = \"\"; // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = \"function\";\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  language: string = \"\";\r\n  importStatements: ImportStatement[] = []; // only for files\r\n  totalTokens: number = 0;\r\n  documentation: string = \"\";\r\n  code: string = \"\";\r\n  body: string = \"\";\r\n  exportable: boolean = false;\r\n  parent?: Node;\r\n  children: { [key: string]: Node } = {};\r\n  calls: NodeCallTuple[] = [];\r\n  startPosition: Point = { row: 0, column: 0 };\r\n  endPosition: Point = { row: 99999, column: 0 };\r\n  inDegree: number = 0;\r\n  outDegree: number = 0;\r\n  // originFile is the file where the node is defined\r\n  originFile: string = \"\";\r\n  constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\n      //...\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n      //...\n  }\r\n\r\n  addChild(child: Node) {\n      //...\n  }\r\n\r\n  removeChild(child: Node) {\n      //...\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\n      //...\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\n      //...\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\n      //...\n  }\r\n\r\n  addNodeRelationship(node: Node) {\n      //...\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false) {\n      //...\n  }\r\n\r\n  generateImports() {\n      //...\n  }\r\n\r\n  parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\n      //...\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n      //...\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::NodeCallTuple",
    "language": "typescript",
    "label": "NodeCallTuple",
    "type": "type",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 15,
    "inDegree": 3,
    "outDegree": 3,
    "code": "type NodeCallTuple = { node: Node; lines: number[] };",
    "importStatements": [],
    "codeNoBody": "type NodeCallTuple = { node: Node; lines: number[] };",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::Link",
    "language": "typescript",
    "label": "Link",
    "type": "interface",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 24,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Link {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n  line: number;\r\n}",
    "importStatements": [],
    "codeNoBody": "interface Link {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::ImportStatement.constructor",
    "language": "typescript",
    "label": "ImportStatement.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::ImportStatement",
    "totalTokens": 72,
    "inDegree": 0,
    "outDegree": 3,
    "code": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::ImportStatement",
    "language": "typescript",
    "label": "ImportStatement",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 105,
    "inDegree": 8,
    "outDegree": 3,
    "code": "class ImportStatement {\r\n  module: string;\r\n  names: ImportName[];\r\n  moduleAlias: string;\r\n  path: string;\r\n  code?: string;\r\n\r\n  constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code;\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class ImportStatement {\r\n  module: string;\r\n  names: ImportName[];\r\n  moduleAlias: string;\r\n  path: string;\r\n  code?: string;\r\n  constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code;\r\n  }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::ImportName.constructor",
    "language": "typescript",
    "label": "ImportName.constructor",
    "type": "method",
    "parent": "codebase-index-ts\\src\\model\\codebase::ImportName",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 2,
    "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }",
    "importStatements": [],
    "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\n  //...\n  }",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::ImportName",
    "language": "typescript",
    "label": "ImportName",
    "type": "class",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 58,
    "inDegree": 8,
    "outDegree": 3,
    "code": "class ImportName {\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  node?: Node;\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "class ImportName {\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  node?: Node;\r\n  // subpath: string = ''\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase::enc",
    "language": "typescript",
    "label": "enc",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\codebase",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 1,
    "code": "enc = encoding_for_model(\"gpt-4-turbo\")",
    "importStatements": [],
    "codeNoBody": "enc = encoding_for_model(\"gpt-4-turbo\")",
    "originFile": "codebase-index-ts\\src\\model\\codebase.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\codebase",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\model\\codebase.ts",
    "type": "file",
    "totalTokens": 7632,
    "inDegree": 7,
    "outDegree": 6,
    "code": "import fs from \"node:fs/promises\";\r\nimport { Point } from \"tree-sitter\";\r\nimport {\r\n  captureQuery,\r\n  getAllFiles,\r\n  renameSource,\r\n  getCalledNode,\r\n  cleanDefCaptures,\r\n} from \"./utils\";\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes,\r\n} from \"./consts\";\r\nimport { CallsCapturer } from \"./calls\";\r\nimport path from \"path\";\r\nimport { encoding_for_model } from \"tiktoken\";\r\nconst enc = encoding_for_model(\"gpt-4-turbo\");\r\n\r\nexport class ImportName {\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  node?: Node;\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name;\r\n    this.alias = alias || name;\r\n  }\r\n}\r\nexport class ImportStatement {\r\n  module: string;\r\n  names: ImportName[];\r\n  moduleAlias: string;\r\n  path: string;\r\n  code?: string;\r\n\r\n  constructor(\r\n    module: string = \"\",\r\n    names: ImportName[] = [],\r\n    path: string = \"\",\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module;\r\n    this.names = names;\r\n    this.moduleAlias = moduleAlias || module;\r\n    this.path = path;\r\n    this.code = code;\r\n  }\r\n}\r\n\r\ninterface Link {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n  line: number;\r\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] }; // nodeId, first line\r\n\r\nexport class Node {\r\n  id: string = \"\"; // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = \"function\";\r\n  name: string = \"\";\r\n  alias: string = \"\";\r\n  language: string = \"\";\r\n  importStatements: ImportStatement[] = []; // only for files\r\n  totalTokens: number = 0;\r\n  documentation: string = \"\";\r\n  code: string = \"\";\r\n  body: string = \"\";\r\n  exportable: boolean = false;\r\n  parent?: Node;\r\n  children: { [key: string]: Node } = {};\r\n  calls: NodeCallTuple[] = [];\r\n  startPosition: Point = { row: 0, column: 0 };\r\n  endPosition: Point = { row: 99999, column: 0 };\r\n  inDegree: number = 0;\r\n  outDegree: number = 0;\r\n  // originFile is the file where the node is defined\r\n  originFile: string = \"\";\r\n\r\n  constructor(\r\n    id: string,\r\n    code?: string,\r\n    type?: AllowedTypes,\r\n    language?: string\r\n  ) {\r\n    this.id = id;\r\n    this.code = code || \"\";\r\n    this.type = type || \"function\";\r\n    this.language = language || \"js\";\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId];\r\n    } else if (this.type === \"file\") {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId);\r\n        if (result) return result;\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = [];\r\n    if (parentTypes && !parentTypes.includes(this.type)) return [];\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child);\r\n      children.push(...child.getAllChildren());\r\n    }\r\n    return children;\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child;\r\n    child.parent = this;\r\n    this.inDegree++;\r\n    child.outDegree++;\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id];\r\n      this.inDegree--;\r\n      child.outDegree--;\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines });\r\n    node.inDegree++;\r\n    this.outDegree++;\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement);\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    );\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === \"export\") {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true;\r\n        if (!this.documentation) this.documentation = node.documentation;\r\n        return;\r\n      }\r\n      if (this.type === \"export\") return; // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (\r\n        [\"class\", \"interface\"].includes(node.type) &&\r\n        this.type === \"function\"\r\n      ) {\r\n        this.type = \"method\";\r\n        this.name = `${node.name}.${this.name}`;\r\n        this.alias = this.name; // methods has no alias\r\n      }\r\n      this.id = `${this.id.split(\"::\")[0]}::${this.name}`;\r\n      node.addChild(this);\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false) {\r\n    let code = this.code;\r\n\r\n    if (\r\n      (this.body || this.type === \"file\") &&\r\n      ![\"assignment\", \"type\", \"enum\"].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== \"java\"\r\n            ? newClassMethodsMap[this.language]\r\n            : this.name;\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === \"class\") {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return;\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          } else if (\r\n            this.type === \"file\" &&\r\n            ![\"assignment\", \"type\", \"enum\"].includes(n.type)\r\n          ) {\r\n            if (n.body) {\r\n              let bodyToRemove = n.body;\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, \"\");\r\n              let bodyTotalLines = considerLines\r\n                ? bodyToRemove.split(\"\\n\").length\r\n                : 1;\r\n              const spaces = \" \".repeat(n.startPosition.column);\r\n              if (this.language === \"python\") {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n                );\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}//...\\n${spaces}}` +\r\n                    \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else if (this.body) {\r\n        const spaces = \" \".repeat(this.startPosition.column);\r\n        let bodyTotalLines = considerLines ? this.body.split(\"\\n\").length : 1;\r\n        if (this.language === \"python\") {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + \"\\n\".repeat(Math.max(bodyTotalLines - 1, 0))\r\n          );\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` +\r\n              \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0))\r\n          );\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, \"\\n\");\r\n    if (this.parent && [\"class\", \"interface\"].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines\r\n          ? this.parent.body.split(\"\\n\").length\r\n          : 1;\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, \"\")}` +\r\n          \"\\n\".repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`;\r\n      } else {\r\n        code = `${this.parent.code\r\n          .replace(this.parent.body, \"\")\r\n          .trim()}\\n    ...\\n    ${code}`;\r\n      }\r\n    }\r\n    return code;\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== \"file\") return;\r\n    const captures = captureQuery(this.language, \"importStatements\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = [];\r\n    let newImportStatement = new ImportStatement();\r\n    let alias: string;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"module\":\r\n          newImportStatement.module = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          const name = c.node.text;\r\n          if (!alias) alias = name;\r\n          const newImportName = new ImportName(name, alias);\r\n          newImportStatement.names.push(newImportName);\r\n          alias = \"\";\r\n          break;\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case \"import_statement\":\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias;\r\n            alias = \"\";\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module;\r\n          }\r\n\r\n          newImportStatement.path = renameSource(\r\n            this.id,\r\n            newImportStatement.module,\r\n            this.language\r\n          );\r\n          newImportStatement.code = c.node.text.trimEnd();\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement);\r\n          newImportStatement = new ImportStatement();\r\n          break;\r\n      }\r\n    });\r\n    this.importStatements = importStatements.reverse();\r\n  }\r\n\r\n  parseExportClauses(nodesMap: { [id: string]: Node } = {}) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (![\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) return;\r\n    const captures = captureQuery(this.language, \"exportClauses\", this.code);\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let name = \"\";\r\n    let alias = \"\";\r\n    let moduleName = this.id;\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case \"module\":\r\n          moduleName = path.join(\r\n            this.id.split(\"/\").slice(0, -1).join(\"/\"),\r\n            c.node.text\r\n          );\r\n        case \"alias\":\r\n          alias = c.node.text;\r\n          break;\r\n        case \"name\":\r\n          name = c.node.text;\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0];\r\n          if (importedName) moduleName = importedName.path;\r\n          const node =\r\n            this.children[`${this.id}::${name}`] ||\r\n            nodesMap[`${moduleName}::${name}`];\r\n          if (node) {\r\n            node.exportable = true;\r\n            node.alias = alias ? alias : name;\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            node.id = `${this.id}::${node.alias}`;\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`];\r\n              this.children[node.id] = node;\r\n              const childrenNodes = Object.values(node.children);\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias);\r\n                delete node.children[n.id];\r\n                n.id = `${this.id}::${n.alias}`;\r\n                node.children[n.id] = n;\r\n              });\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== \"file\") return;\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language];\r\n    const fileSet = new Set(\r\n      allFiles.map((p) => p.split(\".\").slice(0, -1).join(\".\"))\r\n    );\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(\r\n            `${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`\r\n          )\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path),\r\n      ];\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith(\"@/\")) {\r\n        importStatement.path = path.join(\r\n          rootFolderPath,\r\n          importStatement.path.slice(2)\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (![\"file\", \"header\"].includes(this.type)) return {};\r\n    const unnecessaryNodeTypes = [\"export\"]; // exclude it from the analysis\r\n    const captures = captureQuery(\r\n      this.language,\r\n      \"constructorDefinitions\",\r\n      this.code\r\n    );\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    );\r\n    let exportable = [\"python\", \"php\"].includes(this.language) ? true : false;\r\n    let childrenNodes: Node[] = [];\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(\r\n          this.id,\r\n          c.node.text,\r\n          c.name as AllowedTypes,\r\n          this.language\r\n        );\r\n\r\n        newNode.startPosition = c.node.startPosition;\r\n        newNode.endPosition = c.node.endPosition;\r\n        newNode.exportable = exportable;\r\n        newNode.originFile = this.name;\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling;\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text;\r\n          }\r\n        }\r\n        childrenNodes.push(newNode);\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === \"python\") {\r\n          prevTreeSitterNode = c.node.previousSibling;\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              [\"decorator\"].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row ===\r\n                newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + \"\\n\" + newNode.code;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code;\r\n      if ([\"javascript\", \"typescript\", \"tsx\"].includes(this.language)) {\r\n        if (n.type === \"method\") {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`;\r\n          n.type = \"function\";\r\n        } else if (n.type === \"assignment\") code = `const ${n.code}`;\r\n      } else if ([\"java\"].includes(this.language)) {\r\n        if (n.type == \"function\") {\r\n          const firstLine = code.split(\"(\")[0];\r\n          const firstLineSplit = firstLine.split(\" \");\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, \"definitionTemplate\", code);\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(\r\n        captures,\r\n        n.language === \"java\" ? \"modifier\" : \"name\"\r\n      );\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"modifier\": // java, php only\r\n            if (\r\n              [\"php\", \"java\"].includes(n.language) &&\r\n              c.node.text.includes(\"public\")\r\n            )\r\n              n.exportable = true;\r\n            break;\r\n          case \"name\":\r\n            n.name = c.node.text;\r\n            n.id = `${n.id}::${n.name}`;\r\n            break;\r\n          case \"alias\":\r\n            n.alias = c.node.text;\r\n            break;\r\n          case \"documentation\":\r\n            n.documentation = c.node.text;\r\n            if (n.language === \"python\") {\r\n              n.code = n.code.replace(n.documentation, \"\");\r\n              n.body = n.body.replace(n.documentation, \"\");\r\n            }\r\n            break;\r\n          case \"body\":\r\n            n.body = c.node.text;\r\n            break;\r\n        }\r\n      });\r\n      if (!n.alias) n.alias = n.name;\r\n\r\n      if (n.type === \"assignment\") {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          \"extraAssignmentCode\",\r\n          this.code,\r\n          n.name\r\n        );\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === \"code\") n.code += \"\\n\" + c.node.text;\r\n        });\r\n      }\r\n    });\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name);\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null;\r\n    if ([\"java\", \"php\"].includes(this.language)) {\r\n      const captures = captureQuery(\r\n        this.language,\r\n        \"spaceDeclaration\",\r\n        this.code\r\n      );\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case \"spaceName\":\r\n            const spaceName = c.node.text;\r\n            const initialLine = c.node.startPosition.row;\r\n            const type = \"java\" == this.language ? \"package\" : \"namespace\";\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split(\"\\n\").slice(initialLine, -1).join(\"\\n\"),\r\n              type,\r\n              this.language\r\n            );\r\n            spaceNode.name = spaceName;\r\n            spaceNode.alias = spaceName;\r\n            spaceNode.exportable = true;\r\n            break;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode);\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j]);\r\n        childrenNodes[j].addNodeRelationship(n);\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n);\r\n    });\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n;\r\n      return map;\r\n    }, {});\r\n    return nodesMap;\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && [\"class\", \"interface\"].includes(this.parent?.type)\r\n          ? `${this.parent.code\r\n              .replace(this.parent.body, \"\")\r\n              .trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile,\r\n    };\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes;\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr];\r\n      }\r\n      return acc;\r\n    }, {});\r\n  }\r\n}\r\n\r\nexport class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = \"\";\r\n  nodesMap: { [id: string]: Node } = {};\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {};\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath;\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node;\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id];\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap };\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = [];\r\n    this.spaceMap[node.name].push(node);\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split(\".\").pop();\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false };\r\n    const data = await fs.readFile(filePath);\r\n    const dataString = Buffer.from(data).toString();\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split(\".\").slice(0, -1).join(\".\");\r\n\r\n    let fileNode;\r\n    let isHeader = false;\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === \"h\") {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        \"header\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n      isHeader = true;\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        \"file\",\r\n        languageExtensionMap[fileExtension]\r\n      );\r\n    }\r\n    fileNode.name = filePath;\r\n    fileNode.alias = filePath.split(\"/\").pop() || \"\";\r\n    const nodesMap = fileNode.getChildrenDefinitions();\r\n    fileNode.generateImports();\r\n    fileNode.parseExportClauses(this.nodesMap);\r\n    nodesMap[fileNode.id] = fileNode;\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, \"all\", []).length;\r\n      // save space nodes\r\n      if ([\"namespace\", \"package\", \"mod\"].includes(n.type))\r\n        this.addNodeToSpaceMap(n);\r\n    });\r\n\r\n    return { nodesMap, isHeader };\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {};\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(\r\n        `${spaceName}`,\r\n        \"\",\r\n        nodes[0].type,\r\n        nodes[0].language\r\n      );\r\n      globalNode.name = spaceName;\r\n      globalNode.alias = spaceName;\r\n      globalNode.parent = nodes[0].parent;\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + \"\\n\\n\";\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id;\r\n          delete this.nodesMap[oldId];\r\n          c.id = `${spaceName}::${c.name}`;\r\n          if (\r\n            c.parent &&\r\n            [\"file\", \"package\", \"mod\", \"namespace\"].includes(c.parent.type)\r\n          )\r\n            globalNode.addChild(c);\r\n\r\n          this.nodesMap[c.id] = c;\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n);\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode;\r\n          this.nodesMap[n.parent.id].inDegree++;\r\n          delete this.nodesMap[n.id];\r\n          this.nodesMap[globalNode.id] = globalNode;\r\n        }\r\n      });\r\n      globalSpaceMap[spaceName] = [globalNode];\r\n    });\r\n\r\n    this.spaceMap = globalSpaceMap;\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {};\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    const allFiles = await getAllFiles(this.rootFolderPath);\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split(\".\").slice(0, -1).join(\".\");\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(\r\n          filePath\r\n        );\r\n        this.addNodeMap(nodesMap);\r\n        id = isHeader ? `${id}::header` : id;\r\n        const fileNode = nodesMap[id];\r\n        fileNodesMap[id] = fileNode;\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles);\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`);\r\n        console.log(error.message);\r\n        throw error;\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements();\r\n    this.resolveSpaces();\r\n    this.resolveImportStatementsNodes();\r\n    return fileNodesMap;\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId];\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`);\r\n        return;\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose);\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()];\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n);\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId];\r\n          if (\r\n            calledNode &&\r\n            ![\"package\", \"mod\", \"namespace\"].includes(calledNode.type)\r\n          ) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines); // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              );\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes));\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = [];\r\n    const nodes = Object.values(this.nodesMap);\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = \"defines\";\r\n        links.push({\r\n          source: n.parent.id,\r\n          target: n.id,\r\n          label,\r\n          line: n.startPosition.row + 1,\r\n        });\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({\r\n            source: n.id,\r\n            target: c.node.id,\r\n            label: \"calls\",\r\n            line: c.lines[0] + 1,\r\n          })\r\n        );\r\n    }\r\n    return links;\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (n.type !== \"file\" || n.language !== \"python\") return;\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements];\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith(\"__init__\")) {\r\n          newImportStatements = newImportStatements.filter(\r\n            (s) => s.path != i.path\r\n          );\r\n          newImportStatements = [\r\n            ...this.nodesMap[i.path].importStatements,\r\n            ...newImportStatements,\r\n          ];\r\n        }\r\n      });\r\n      n.importStatements = newImportStatements;\r\n    });\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap);\r\n    nodes.forEach((n) => {\r\n      if (![\"file\", \"header\"].includes(n.type)) return;\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node =\r\n            this.nodesMap[`${i.path}::${n.name}`] ||\r\n            this.nodesMap[`${i.module}::${n.name}`];\r\n        });\r\n        const namesIds = i.names.map((n) => n.node?.id || \"\");\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"package\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        });\r\n        if ([\"c\", \"cpp\"].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path];\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode);\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren([\r\n              \"file\",\r\n              \"class\",\r\n              \"interface\",\r\n              \"mod\",\r\n              \"namespace\",\r\n              \"header\",\r\n            ])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias);\r\n              newName.node = c;\r\n              i.names.push(newName);\r\n            });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (\r\n      headerNode.type !== \"header\" ||\r\n      ![\"c\", \"cpp\"].includes(headerNode.language)\r\n    )\r\n      return;\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id);\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode\r\n        .getAllChildren()\r\n        .find((c) => c.id === id.replace(\"::header\", \"\"));\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id];\r\n        headerNode.removeChild(headerNode.children[id]);\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef;\r\n        headerNode.inDegree++;\r\n      }\r\n    });\r\n  }\r\n}\r\n",
    "importStatements": [
      "import fs from \"node:fs/promises\";",
      "import { Point } from \"tree-sitter\";",
      "import {\r\n  captureQuery,\r\n  getAllFiles,\r\n  renameSource,\r\n  getCalledNode,\r\n  cleanDefCaptures,\r\n} from \"./utils\";",
      "import {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes,\r\n} from \"./consts\";",
      "import { CallsCapturer } from \"./calls\";",
      "import path from \"path\";",
      "import { encoding_for_model } from \"tiktoken\";"
    ],
    "codeNoBody": "import fs from \"node:fs/promises\";\r\nimport { Point } from \"tree-sitter\";\r\nimport {\r\n  captureQuery,\r\n  getAllFiles,\r\n  renameSource,\r\n  getCalledNode,\r\n  cleanDefCaptures,\r\n} from \"./utils\";\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes,\r\n} from \"./consts\";\r\nimport { CallsCapturer } from \"./calls\";\r\nimport path from \"path\";\r\nimport { encoding_for_model } from \"tiktoken\";\r\nconst enc = encoding_for_model(\"gpt-4-turbo\");\r\nexport class ImportName {\n       //...\n       }\r\nexport class ImportStatement {\n       //...\n       }\r\n\r\ninterface Link {\n//...\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] }; // nodeId, first line\r\n\r\nexport class Node {\n       //...\n       }\r\n\r\nexport class Codebase {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::treeSitterCommentTypes",
    "language": "typescript",
    "label": "treeSitterCommentTypes",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": [],
    "codeNoBody": "treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::indexSuffixesMap",
    "language": "typescript",
    "label": "indexSuffixesMap",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 76,
    "inDegree": 0,
    "outDegree": 1,
    "code": "indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '', // java has no index\r\n    'rust': '', // rust has no index\r\n    'php': '', // php has no index\r\n}",
    "importStatements": [],
    "codeNoBody": "indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '', // java has no index\r\n    'rust': '', // rust has no index\r\n    'php': '', // php has no index\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::itselfClassMap",
    "language": "typescript",
    "label": "itselfClassMap",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 62,
    "inDegree": 0,
    "outDegree": 1,
    "code": "itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this',\r\n    'rust': 'self',\r\n    'php': '$this'\r\n}",
    "importStatements": [],
    "codeNoBody": "itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this',\r\n    'rust': 'self',\r\n    'php': '$this'\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::newClassMethodsMap",
    "language": "typescript",
    "label": "newClassMethodsMap",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 72,
    "inDegree": 0,
    "outDegree": 1,
    "code": "newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new',\r\n    'php': '__construct'\r\n}",
    "importStatements": [],
    "codeNoBody": "newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new',\r\n    'php': '__construct'\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::languageExtensionMap",
    "language": "typescript",
    "label": "languageExtensionMap",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 93,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n  'php': 'php'\r\n}",
    "importStatements": [],
    "codeNoBody": "languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n  'php': 'php'\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::languages",
    "language": "typescript",
    "label": "languages",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 26,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C,\r\n    PHP\r\n}",
    "importStatements": [],
    "codeNoBody": "languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C,\r\n    PHP\r\n}",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::excludedExtensions",
    "language": "typescript",
    "label": "excludedExtensions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']",
    "importStatements": [],
    "codeNoBody": "excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::excludedFolders",
    "language": "typescript",
    "label": "excludedFolders",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']",
    "importStatements": [],
    "codeNoBody": "excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::AllowedTypesArray",
    "language": "typescript",
    "label": "AllowedTypesArray",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 60,
    "inDegree": 0,
    "outDegree": 2,
    "code": "AllowedTypesArray: AllowedTypes[] = [\r\n    'function', 'class', 'interface', 'method', 'enum', \r\n    'struct', 'export', 'type', 'assignment', 'file', 'union',\r\n    'namespace', 'mod', 'header', 'package'\r\n  ]",
    "importStatements": [],
    "codeNoBody": "AllowedTypesArray: AllowedTypes[] = [\r\n    'function', 'class', 'interface', 'method', 'enum', \r\n    'struct', 'export', 'type', 'assignment', 'file', 'union',\r\n    'namespace', 'mod', 'header', 'package'\r\n  ]",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts::AllowedTypes",
    "language": "typescript",
    "label": "AllowedTypes",
    "type": "type",
    "parent": "codebase-index-ts\\src\\model\\consts",
    "totalTokens": 80,
    "inDegree": 3,
    "outDegree": 2,
    "code": "type AllowedTypes = \r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "importStatements": [],
    "codeNoBody": "type AllowedTypes = \r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "originFile": "codebase-index-ts\\src\\model\\consts.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\consts",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\model\\consts.ts",
    "type": "file",
    "totalTokens": 733,
    "inDegree": 10,
    "outDegree": 1,
    "code": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require(\"tree-sitter-javascript\");\r\nconst Python = require(\"tree-sitter-python\");\r\nconst TypeScript  = require('tree-sitter-typescript').typescript;\r\nconst TSX = require(\"tree-sitter-typescript\").tsx;\r\nconst Java = require(\"tree-sitter-java\");\r\nconst C = require(\"tree-sitter-c\");\r\nconst PHP = require(\"tree-sitter-php\").php;\r\n\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes = \r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n    'function', 'class', 'interface', 'method', 'enum', \r\n    'struct', 'export', 'type', 'assignment', 'file', 'union',\r\n    'namespace', 'mod', 'header', 'package'\r\n  ]\r\n\r\nexport const excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']\r\nexport const excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']\r\n\r\nexport const languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C,\r\n    PHP\r\n}\r\n\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n  'php': 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new',\r\n    'php': '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this',\r\n    'rust': 'self',\r\n    'php': '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '', // java has no index\r\n    'rust': '', // rust has no index\r\n    'php': '', // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": [
      "const JavaScript = require(\"tree-sitter-javascript\");",
      "const Python = require(\"tree-sitter-python\");",
      "const TypeScript  = require('tree-sitter-typescript').typescript;",
      "const TSX = require(\"tree-sitter-typescript\").tsx;",
      "const Java = require(\"tree-sitter-java\");",
      "const C = require(\"tree-sitter-c\");",
      "const PHP = require(\"tree-sitter-php\").php;"
    ],
    "codeNoBody": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require(\"tree-sitter-javascript\");\r\nconst Python = require(\"tree-sitter-python\");\r\nconst TypeScript  = require('tree-sitter-typescript').typescript;\r\nconst TSX = require(\"tree-sitter-typescript\").tsx;\r\nconst Java = require(\"tree-sitter-java\");\r\nconst C = require(\"tree-sitter-c\");\r\nconst PHP = require(\"tree-sitter-php\").php;\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes = \r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n    'function', 'class', 'interface', 'method', 'enum', \r\n    'struct', 'export', 'type', 'assignment', 'file', 'union',\r\n    'namespace', 'mod', 'header', 'package'\r\n  ]\r\n\r\nexport const excludedFolders = ['.git', '.vscode', 'venv', 'node_modules', 'dist', '__pycache__', 'tests', 'build', '_static', 'jest', '__tests__']\r\nexport const excludedExtensions = ['min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', '.config.js']\r\n\r\nexport const languages = {\r\n    JavaScript,\r\n    Python,\r\n    TypeScript,\r\n    TSX,\r\n    Java,\r\n    C,\r\n    PHP\r\n}\r\n\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  'py': 'python',\r\n  'c': 'c',\r\n  'h': 'c',\r\n  // 'ipynb': 'python',\r\n  'js': 'typescript',\r\n  'mjs': 'typescript',\r\n  'jsx': 'typescript',\r\n  'ts': 'typescript',\r\n  'tsx': 'tsx',\r\n  'java': 'java',\r\n  'php': 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n    'python': '__init__',\r\n    'javascript': 'constructor',\r\n    'typescript': 'constructor',\r\n    'tsx': 'constructor',\r\n    'java': '', // java constructor has the same name as the class\r\n    'rust': 'new',\r\n    'php': '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n    'python': 'self',\r\n    'javascript': 'this',\r\n    'typescript': 'this',\r\n    'tsx': 'this',\r\n    'java': 'this',\r\n    'rust': 'self',\r\n    'php': '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n    'python': '/__init__',\r\n    'javascript': '/index',\r\n    'typescript': '/index',\r\n    'tsx': '/index',\r\n    'java': '', // java has no index\r\n    'rust': '', // rust has no index\r\n    'php': '', // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::getCalledNode",
    "language": "typescript",
    "label": "getCalledNode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 87,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
    "importStatements": [],
    "codeNoBody": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::cleanAndSplitContent",
    "language": "typescript",
    "label": "cleanAndSplitContent",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
    "importStatements": [],
    "codeNoBody": "const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::firstConsecutiveDots",
    "language": "typescript",
    "label": "firstConsecutiveDots",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 38,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
    "importStatements": [],
    "codeNoBody": "function firstConsecutiveDots(s: string): number {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::renameSource",
    "language": "typescript",
    "label": "renameSource",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 378,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}",
    "importStatements": [],
    "codeNoBody": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::cleanDefCaptures",
    "language": "typescript",
    "label": "cleanDefCaptures",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 162,
    "inDegree": 0,
    "outDegree": 1,
    "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
    "importStatements": [],
    "codeNoBody": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::captureQuery",
    "language": "typescript",
    "label": "captureQuery",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 320,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}",
    "importStatements": [],
    "codeNoBody": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::getRequiredDefinitions",
    "language": "typescript",
    "label": "getRequiredDefinitions",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 238,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
    "importStatements": [],
    "codeNoBody": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::getTotalSize",
    "language": "typescript",
    "label": "getTotalSize",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 87,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils::getAllFiles",
    "language": "typescript",
    "label": "getAllFiles",
    "type": "function",
    "parent": "codebase-index-ts\\src\\model\\utils",
    "totalTokens": 270,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\") //esto para que el Guille pueda correr el codigo de grafos.\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  //console.log(\"matchingFiles\", matchingFiles);\r\n  return matchingFiles;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\model\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\model\\utils",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\model\\utils.ts",
    "type": "file",
    "totalTokens": 2134,
    "inDegree": 9,
    "outDegree": 0,
    "code": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\") //esto para que el Guille pueda correr el codigo de grafos.\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  //console.log(\"matchingFiles\", matchingFiles);\r\n  return matchingFiles;\r\n}\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}\r\n\r\nfunction firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}\r\n",
    "importStatements": [
      "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";",
      "import { treeSitterQueries, languageQueries } from \"../queries\";",
      "import { glob } from \"glob\";",
      "import fs from \"node:fs/promises\";",
      "import path from \"path\";",
      "import Parser from \"tree-sitter\";",
      "import { Node, ImportStatement } from \"./codebase\";"
    ],
    "codeNoBody": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }\r\n\r\nfunction firstConsecutiveDots(s: string): number {\n//...\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::cQueries",
    "language": "typescript",
    "label": "cQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 53,
    "inDegree": 0,
    "outDegree": 2,
    "code": "cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [],
    "codeNoBody": "cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 38,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 128,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 46,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\c",
    "totalTokens": 41,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\c.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\c",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\c.ts",
    "type": "file",
    "totalTokens": 660,
    "inDegree": 8,
    "outDegree": 1,
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    ` \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => {\n//...\n} \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\index::treeSitterQueries",
    "language": "typescript",
    "label": "treeSitterQueries",
    "type": "interface",
    "parent": "codebase-index-ts\\src\\queries\\index",
    "totalTokens": 174,
    "inDegree": 2,
    "outDegree": 2,
    "code": "interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "importStatements": [],
    "codeNoBody": "interface treeSitterQueries {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\queries\\index.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\index::languageQueries",
    "language": "typescript",
    "label": "languageQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\index",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "importStatements": [],
    "codeNoBody": "languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\index.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\index",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\index.ts",
    "type": "file",
    "totalTokens": 273,
    "inDegree": 2,
    "outDegree": 1,
    "code": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\n\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "importStatements": [
      "import { jsQueries } from \"./javascript\"",
      "import { tsQueries } from \"./typescript\"",
      "import { pyQueries } from \"./python\"",
      "import { javaQueries } from \"./java\"",
      "import { cQueries } from \"./c\"",
      "import { phpQueries } from \"./php\""
    ],
    "codeNoBody": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::javaQueries",
    "language": "typescript",
    "label": "javaQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 2,
    "code": "javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "importStatements": [],
    "codeNoBody": "javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 50,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 29,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 12,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => ``",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::spaceDeclaration",
    "language": "typescript",
    "label": "spaceDeclaration",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "importStatements": [],
    "codeNoBody": "spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 25,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 3,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = ``",
    "importStatements": [],
    "codeNoBody": "assignments = ``",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\java",
    "totalTokens": 42,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\java.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\java",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\java.ts",
    "type": "file",
    "totalTokens": 481,
    "inDegree": 9,
    "outDegree": 1,
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = ``\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = {\n//...\n}\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::jsQueries",
    "language": "typescript",
    "label": "jsQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 2,
    "code": "jsQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [],
    "codeNoBody": "jsQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 289,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 129,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 73,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 51,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 2,
    "code": "constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::arrowFunctionConstructor",
    "language": "typescript",
    "label": "arrowFunctionConstructor",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 20,
    "inDegree": 2,
    "outDegree": 1,
    "code": "arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"",
    "importStatements": [],
    "codeNoBody": "arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\javascript",
    "totalTokens": 94,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\javascript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\javascript",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\javascript.ts",
    "type": "file",
    "totalTokens": 1408,
    "inDegree": 8,
    "outDegree": 2,
    "code": "// Tree-sitter definition + call queries for JavaScript\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) @assignment\r\n    )\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) @assignment\r\n        )\r\n    )\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\nconst arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for JavaScript\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) @assignment\r\n    )\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) @assignment\r\n        )\r\n    )\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\nconst arrowFunctionConstructor = \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\"\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: (identifier) @identifier.name)\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::phpQueries",
    "language": "typescript",
    "label": "phpQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 52,
    "inDegree": 0,
    "outDegree": 2,
    "code": "phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "importStatements": [],
    "codeNoBody": "phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 94,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 48,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 58,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::spaceDeclaration",
    "language": "typescript",
    "label": "spaceDeclaration",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 17,
    "inDegree": 0,
    "outDegree": 1,
    "code": "spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "importStatements": [],
    "codeNoBody": "spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 45,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 81,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\php",
    "totalTokens": 37,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\php.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\php",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\php.ts",
    "type": "file",
    "totalTokens": 863,
    "inDegree": 8,
    "outDegree": 1,
    "code": "// Tree-sitter definition + call queries for PHP\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition + call queries for PHP\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::pyQueries",
    "language": "typescript",
    "label": "pyQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 54,
    "inDegree": 0,
    "outDegree": 2,
    "code": "pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "importStatements": [],
    "codeNoBody": "pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 64,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 317,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "function",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 138,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
    "importStatements": [],
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 18,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 80,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::assignments",
    "language": "typescript",
    "label": "assignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 31,
    "inDegree": 0,
    "outDegree": 1,
    "code": "assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\python",
    "totalTokens": 143,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`",
    "importStatements": [],
    "codeNoBody": "importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\python.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\python",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\python.ts",
    "type": "file",
    "totalTokens": 1098,
    "inDegree": 8,
    "outDegree": 1,
    "code": "// Tree-sitter definition queries for Python\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}\r\n",
    "importStatements": [
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition queries for Python\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::tsQueries",
    "language": "typescript",
    "label": "tsQueries",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 47,
    "inDegree": 0,
    "outDegree": 2,
    "code": "tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [],
    "codeNoBody": "tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::anyAssignments",
    "language": "typescript",
    "label": "anyAssignments",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 51,
    "inDegree": 2,
    "outDegree": 1,
    "code": "anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::calls",
    "language": "typescript",
    "label": "calls",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 37,
    "inDegree": 0,
    "outDegree": 1,
    "code": "calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "importStatements": [],
    "codeNoBody": "calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::extraAssignmentCode",
    "language": "typescript",
    "label": "extraAssignmentCode",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "extraAssignmentCode = jsQueries.extraAssignmentCode",
    "importStatements": [],
    "codeNoBody": "extraAssignmentCode = jsQueries.extraAssignmentCode",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::exportClauses",
    "language": "typescript",
    "label": "exportClauses",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 1,
    "code": "exportClauses = jsQueries.exportClauses",
    "importStatements": [],
    "codeNoBody": "exportClauses = jsQueries.exportClauses",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::constructorDefinitions",
    "language": "typescript",
    "label": "constructorDefinitions",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 103,
    "inDegree": 0,
    "outDegree": 1,
    "code": "constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`",
    "importStatements": [],
    "codeNoBody": "constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::definitionTemplate",
    "language": "typescript",
    "label": "definitionTemplate",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 126,
    "inDegree": 0,
    "outDegree": 1,
    "code": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "importStatements": [],
    "codeNoBody": "definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript::importStatements",
    "language": "typescript",
    "label": "importStatements",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\queries\\typescript",
    "totalTokens": 7,
    "inDegree": 0,
    "outDegree": 1,
    "code": "importStatements = jsQueries.importStatements",
    "importStatements": [],
    "codeNoBody": "importStatements = jsQueries.importStatements",
    "originFile": "codebase-index-ts\\src\\queries\\typescript.ts"
  },
  {
    "id": "codebase-index-ts\\src\\queries\\typescript",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\queries\\typescript.ts",
    "type": "file",
    "totalTokens": 598,
    "inDegree": 8,
    "outDegree": 1,
    "code": "// Tree-sitter definition queries for Typescript\r\n\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "importStatements": [
      "import { jsQueries } from './javascript';",
      "import { treeSitterQueries } from './index';"
    ],
    "codeNoBody": "// Tree-sitter definition queries for Typescript\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph-test::createGraphTest",
    "language": "typescript",
    "label": "createGraphTest",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 433,
    "inDegree": 0,
    "outDegree": 3,
    "code": "createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n})",
    "importStatements": [],
    "codeNoBody": "createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n})",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph-test.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph-test::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 63,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph-test.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph-test::secret",
    "language": "typescript",
    "label": "secret",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph-test",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "importStatements": [],
    "codeNoBody": "secret = getEnv('SUPABASE_JWT')",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph-test.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph-test",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\routes\\create_graph-test.ts",
    "type": "file",
    "totalTokens": 607,
    "inDegree": 3,
    "outDegree": 2,
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\n\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n})\r\n\r\nexport { createGraphTest }\r\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { z } from 'zod'",
      "import { zValidator } from '@hono/zod-validator'",
      "import { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'",
      "import { jwtVerify } from 'jose'",
      "import { sql } from '../utils/db'",
      "import { getEnv } from '../utils/utils'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId\r\n  } = request\r\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!accessToken) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(accessToken, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const gitAccessToken = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!gitAccessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken)\r\n\r\n  const codebasePath = await downloadAndExtractRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    gitAccessToken,\r\n    commitHash\r\n  )\r\n  if (!codebasePath) {\r\n    console.log('Failed to download repo')\r\n    return c.json({ message: 'Failed to download repo' }, 500)\r\n  }\r\n\r\n  const codebase = new Codebase(codebasePath)\r\n  const fileNodesMap = await codebase.parseFolder()\r\n  codebase.getCalls(fileNodesMap, false)\r\n  const nodes = codebase.simplify()\r\n  const links = codebase.getLinks()\r\n\r\n  console.timeEnd(repoName)\r\n  return c.json({ graph: { nodes, links } })\r\n})\r\n\r\nexport { createGraphTest }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph::processGraphCreation",
    "language": "typescript",
    "label": "processGraphCreation",
    "type": "function",
    "parent": "codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 699,
    "inDegree": 2,
    "outDegree": 1,
    "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\r\n  let graphId = uuidv4()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    // create a uuid for each node\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\r\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\r\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\r\n        }, ${fullName}, ${node.label})\r\n    `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label, line)\r\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label}, ${link.line})\r\n    `\r\n    })\r\n\r\n    await Promise.all(insertNodePromises)\r\n    await Promise.all(insertLinkPromises)\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph::createGraph",
    "language": "typescript",
    "label": "createGraph",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 932,
    "inDegree": 0,
    "outDegree": 4,
    "code": "createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n})",
    "importStatements": [],
    "codeNoBody": "createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n})",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph::repoRequestValidator",
    "language": "typescript",
    "label": "repoRequestValidator",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 74,
    "inDegree": 2,
    "outDegree": 1,
    "code": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "importStatements": [],
    "codeNoBody": "repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph::secret",
    "language": "typescript",
    "label": "secret",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\create_graph",
    "totalTokens": 11,
    "inDegree": 2,
    "outDegree": 1,
    "code": "secret = getEnv('SUPABASE_JWT')",
    "importStatements": [],
    "codeNoBody": "secret = getEnv('SUPABASE_JWT')",
    "originFile": "codebase-index-ts\\src\\routes\\create_graph.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\create_graph",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\routes\\create_graph.ts",
    "type": "file",
    "totalTokens": 1839,
    "inDegree": 4,
    "outDegree": 3,
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\r\n  let graphId = uuidv4()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    // create a uuid for each node\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n    INSERT INTO nodes (id, repo_id, type, language, total_tokens, documentation, code, code_no_body, in_degree, out_degree, full_name, label)\r\n    VALUES (${nodeDBIds[node.id]}, ${repoId}, ${node.type}, ${node.language}, ${node.totalTokens\r\n        }, ${node.documentation}, ${node.code}, ${node.codeNoBody}, ${node.inDegree}, ${node.outDegree\r\n        }, ${fullName}, ${node.label})\r\n    `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n    INSERT INTO links (node_source_id, node_target_id, repo_id, label, line)\r\n    VALUES (${nodeDBIds[link.source]}, ${nodeDBIds[link.target]}, ${repoId}, ${link.label}, ${link.line})\r\n    `\r\n    })\r\n\r\n    await Promise.all(insertNodePromises)\r\n    await Promise.all(insertLinkPromises)\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { createGraph }\r\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { z } from 'zod'",
      "import { zValidator } from '@hono/zod-validator'",
      "import { sql } from '../utils/db'",
      "import { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'",
      "import { v4 as uuidv4 } from 'uuid'",
      "import { jwtVerify } from 'jose'",
      "import { getEnv } from '../utils/utils'",
      "import { GitServiceType } from '../utils/git'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nconst secret = getEnv('SUPABASE_JWT')\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const {\r\n    accessToken,\r\n    refreshToken\r\n  } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!accessToken) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = uuidv4()\r\n\r\n  if (rows.length == 0) {\r\n\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n\r\n\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean,\r\n  connectionId: string,\r\n  codebasePath: string\r\n}) {\n//...\n}\r\n\r\nexport { createGraph }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\routes\\graphs::updateGraph",
    "language": "typescript",
    "label": "updateGraph",
    "type": "function",
    "parent": "codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 724,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName}, ${node.label}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\routes\\graphs.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\graphs::UpdateGraph",
    "language": "typescript",
    "label": "UpdateGraph",
    "type": "interface",
    "parent": "codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 55,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n}",
    "importStatements": [],
    "codeNoBody": "interface UpdateGraph {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\routes\\graphs.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\graphs::graphs",
    "language": "typescript",
    "label": "graphs",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\routes\\graphs",
    "totalTokens": 832,
    "inDegree": 0,
    "outDegree": 2,
    "code": "graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})",
    "importStatements": [],
    "codeNoBody": "graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})",
    "originFile": "codebase-index-ts\\src\\routes\\graphs.ts"
  },
  {
    "id": "codebase-index-ts\\src\\routes\\graphs",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\routes\\graphs.ts",
    "type": "file",
    "totalTokens": 1702,
    "inDegree": 3,
    "outDegree": 2,
    "code": "import { Hono } from 'hono'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName}, ${node.label}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { graphs }",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '../utils/db'",
      "import { getEnv } from '../utils/utils'",
      "import { jwtVerify } from 'jose'",
      "import { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'",
      "import { Codebase } from '../model/codebase'",
      "import { v4 as uuidv4 } from 'uuid'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n\r\n  try {\r\n\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const {\r\n      accessToken,\r\n      refreshToken\r\n    } = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!accessToken) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ error: 'Failed to get access token' }, 400)\r\n    }\r\n\r\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\n//...\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\n//...\n}\r\n\r\nexport { graphs }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\bitbucket\\refresh-token",
    "totalTokens": 245,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\bitbucket\\refresh-token",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts",
    "type": "file",
    "totalTokens": 255,
    "inDegree": 1,
    "outDegree": 0,
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [
      "import { getEnv } from \"../utils\""
    ],
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\utils\\db::sql",
    "language": "typescript",
    "label": "sql",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\utils\\db",
    "totalTokens": 106,
    "inDegree": 0,
    "outDegree": 1,
    "code": "sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "importStatements": [],
    "codeNoBody": "sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "originFile": "codebase-index-ts\\src\\utils\\db.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\db",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\utils\\db.ts",
    "type": "file",
    "totalTokens": 123,
    "inDegree": 1,
    "outDegree": 0,
    "code": "import { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\n\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n",
    "importStatements": [
      "import { getEnv } from './utils'",
      "import postgres from 'postgres'"
    ],
    "codeNoBody": "import { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::getAccessToken",
    "language": "typescript",
    "label": "getAccessToken",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 217,
    "inDegree": 0,
    "outDegree": 2,
    "code": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::getCommitHash",
    "language": "typescript",
    "label": "getCommitHash",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
    "importStatements": [],
    "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::getCommitRepo",
    "language": "typescript",
    "label": "getCommitRepo",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 616,
    "inDegree": 0,
    "outDegree": 3,
    "code": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n\r\n      }\r\n\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::downloadAndExtractRepo",
    "language": "typescript",
    "label": "downloadAndExtractRepo",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 555,
    "inDegree": 0,
    "outDegree": 3,
    "code": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(tmpFolderPath, `${commitSha}_${repoOrg}_${repoName}_${branch}`)\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = await getTotalSize(finalPath) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(`Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`)\r\n   }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::MAXSIZE",
    "language": "typescript",
    "label": "MAXSIZE",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 5,
    "inDegree": 1,
    "outDegree": 1,
    "code": "MAXSIZE = 2",
    "importStatements": [],
    "codeNoBody": "MAXSIZE = 2",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git::GitServiceType",
    "language": "typescript",
    "label": "GitServiceType",
    "type": "type",
    "parent": "codebase-index-ts\\src\\utils\\git",
    "totalTokens": 18,
    "inDegree": 5,
    "outDegree": 2,
    "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "importStatements": [],
    "codeNoBody": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "originFile": "codebase-index-ts\\src\\utils\\git.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\git",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\utils\\git.ts",
    "type": "file",
    "totalTokens": 1595,
    "inDegree": 6,
    "outDegree": 1,
    "code": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\n\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(tmpFolderPath, `${commitSha}_${repoOrg}_${repoName}_${branch}`)\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = await getTotalSize(finalPath) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(`Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`)\r\n   }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n\r\n      }\r\n\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}\r\n",
    "importStatements": [
      "import axios from 'axios'",
      "import fs from 'node:fs/promises'",
      "import AdmZip from 'adm-zip'",
      "import path from 'node:path'",
      "import { sql } from './db'",
      "import { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'",
      "import { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'",
      "import { getTotalSize } from '../model/utils'"
    ],
    "codeNoBody": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number,\r\n): Promise<string> {\n       //...\n       }\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string,\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\gitlab\\refresh-token",
    "totalTokens": 237,
    "inDegree": 0,
    "outDegree": 1,
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\gitlab\\refresh-token",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts",
    "type": "file",
    "totalTokens": 247,
    "inDegree": 1,
    "outDegree": 0,
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "importStatements": [
      "import { getEnv } from \"../utils\""
    ],
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\utils\\utils::getEnv",
    "language": "typescript",
    "label": "getEnv",
    "type": "function",
    "parent": "codebase-index-ts\\src\\utils\\utils",
    "totalTokens": 50,
    "inDegree": 0,
    "outDegree": 2,
    "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "importStatements": [],
    "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "originFile": "codebase-index-ts\\src\\utils\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\utils::ENV_VARS",
    "language": "typescript",
    "label": "ENV_VARS",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\utils\\utils",
    "totalTokens": 145,
    "inDegree": 1,
    "outDegree": 1,
    "code": "ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "importStatements": [],
    "codeNoBody": "ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "originFile": "codebase-index-ts\\src\\utils\\utils.ts"
  },
  {
    "id": "codebase-index-ts\\src\\utils\\utils",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\utils\\utils.ts",
    "type": "file",
    "totalTokens": 199,
    "inDegree": 2,
    "outDegree": 0,
    "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "importStatements": [],
    "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::generateFolderDocumentation",
    "language": "typescript",
    "label": "generateFolderDocumentation",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 478,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder which are the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::documentFolders",
    "language": "typescript",
    "label": "documentFolders",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 275,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    const folderContent = folders[folderPath].join(\"\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function documentFolders(filesDocumentation: any) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::generateFileDocumentation",
    "language": "typescript",
    "label": "generateFileDocumentation",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 641,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::classifyAndDocumentFiles",
    "language": "typescript",
    "label": "classifyAndDocumentFiles",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 346,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const nodePath = node.id;\r\n    const until = nodePath.lastIndexOf(\"::\");\r\n    const correspondingFile = nodePath.slice(0, until);\r\n    //console.log(\"CF: \", correspondingFile);\r\n    if (!fileToNodes[correspondingFile]) {\r\n      fileToNodes[correspondingFile] = [];\r\n    }\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.id === filePath)!; //it should always be there\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::generateNodeDocumentation",
    "language": "typescript",
    "label": "generateNodeDocumentation",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 619,
    "inDegree": 1,
    "outDegree": 5,
    "code": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::bfs",
    "language": "typescript",
    "label": "bfs",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 364,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::findStartNodes",
    "language": "typescript",
    "label": "findStartNodes",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 48,
    "inDegree": 1,
    "outDegree": 1,
    "code": "function findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}",
    "importStatements": [],
    "codeNoBody": "function findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::buildGraphs",
    "language": "typescript",
    "label": "buildGraphs",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 229,
    "inDegree": 1,
    "outDegree": 3,
    "code": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}",
    "importStatements": [],
    "codeNoBody": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::readJson",
    "language": "typescript",
    "label": "readJson",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 83,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::findFileParent",
    "language": "typescript",
    "label": "findFileParent",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 93,
    "inDegree": 2,
    "outDegree": 3,
    "code": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::tokenizer",
    "language": "typescript",
    "label": "tokenizer",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 86,
    "inDegree": 0,
    "outDegree": 1,
    "code": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};",
    "importStatements": [],
    "codeNoBody": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::timeElapsedInSecconds",
    "language": "typescript",
    "label": "timeElapsedInSecconds",
    "type": "function",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 76,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};",
    "importStatements": [],
    "codeNoBody": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::totalTokensUsed",
    "language": "typescript",
    "label": "totalTokensUsed",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 6,
    "inDegree": 1,
    "outDegree": 1,
    "code": "totalTokensUsed = 0",
    "importStatements": [],
    "codeNoBody": "totalTokensUsed = 0",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::linksPath",
    "language": "typescript",
    "label": "linksPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 3,
    "code": "linksPath: string = `${forder_path}/${projectId}/links.json`",
    "importStatements": [],
    "codeNoBody": "linksPath: string = `${forder_path}/${projectId}/links.json`",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::nodesPath",
    "language": "typescript",
    "label": "nodesPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 14,
    "inDegree": 1,
    "outDegree": 3,
    "code": "nodesPath: string = `${forder_path}/${projectId}/nodes.json`",
    "importStatements": [],
    "codeNoBody": "nodesPath: string = `${forder_path}/${projectId}/nodes.json`",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::forder_path",
    "language": "typescript",
    "label": "forder_path",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 9,
    "inDegree": 3,
    "outDegree": 1,
    "code": "forder_path = `../../test_files/`",
    "importStatements": [],
    "codeNoBody": "forder_path = `../../test_files/`",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::projectId",
    "language": "typescript",
    "label": "projectId",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 8,
    "inDegree": 4,
    "outDegree": 1,
    "code": "projectId = \"codebase-index-ts\"",
    "importStatements": [],
    "codeNoBody": "projectId = \"codebase-index-ts\"",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::onlyLogs",
    "language": "typescript",
    "label": "onlyLogs",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 4,
    "inDegree": 0,
    "outDegree": 1,
    "code": "onlyLogs = false",
    "importStatements": [],
    "codeNoBody": "onlyLogs = false",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::response_format",
    "language": "typescript",
    "label": "response_format",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 11,
    "inDegree": 0,
    "outDegree": 1,
    "code": "response_format = { type: \"json_object\" }",
    "importStatements": [],
    "codeNoBody": "response_format = { type: \"json_object\" }",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::max_tokens",
    "language": "typescript",
    "label": "max_tokens",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 6,
    "inDegree": 0,
    "outDegree": 1,
    "code": "max_tokens = 1024",
    "importStatements": [],
    "codeNoBody": "max_tokens = 1024",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::temperature",
    "language": "typescript",
    "label": "temperature",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 4,
    "inDegree": 0,
    "outDegree": 1,
    "code": "temperature = 0",
    "importStatements": [],
    "codeNoBody": "temperature = 0",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::model",
    "language": "typescript",
    "label": "model",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 13,
    "inDegree": 0,
    "outDegree": 1,
    "code": "model = \"gpt-3.5-turbo\"",
    "importStatements": [],
    "codeNoBody": "model = \"gpt-3.5-turbo\"",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::startTime",
    "language": "typescript",
    "label": "startTime",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 5,
    "inDegree": 1,
    "outDegree": 1,
    "code": "startTime = new Date()",
    "importStatements": [],
    "codeNoBody": "startTime = new Date()",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::client2",
    "language": "typescript",
    "label": "client2",
    "type": "assignment",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 47,
    "inDegree": 3,
    "outDegree": 1,
    "code": "client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n})",
    "importStatements": [],
    "codeNoBody": "client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n})",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::wikiLink",
    "language": "typescript",
    "label": "wikiLink",
    "type": "type",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 21,
    "inDegree": 3,
    "outDegree": 2,
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2::wikiNode",
    "language": "typescript",
    "label": "wikiNode",
    "type": "type",
    "parent": "codebase-index-ts\\src\\wiki\\wiki2",
    "totalTokens": 84,
    "inDegree": 8,
    "outDegree": 2,
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n};",
    "originFile": "codebase-index-ts\\src\\wiki\\wiki2.ts"
  },
  {
    "id": "codebase-index-ts\\src\\wiki\\wiki2",
    "language": "typescript",
    "label": "codebase-index-ts\\src\\wiki\\wiki2.ts",
    "type": "file",
    "totalTokens": 4298,
    "inDegree": 26,
    "outDegree": 13,
    "code": "import { AllowedTypes } from \"../model/consts\";\r\n\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\nconst startTime = new Date();\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\nconst projectId = \"codebase-index-ts\";\r\nconst forder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${forder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${forder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};\r\n\r\n(async () => {\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.id] = [];\r\n      return acc;\r\n    }, {});\r\n  //console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const nodePath = node.id;\r\n    const until = nodePath.lastIndexOf(\"::\");\r\n    const correspondingFile = nodePath.slice(0, until);\r\n    //console.log(\"CF: \", correspondingFile);\r\n    if (!fileToNodes[correspondingFile]) {\r\n      fileToNodes[correspondingFile] = [];\r\n    }\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.id === filePath)!; //it should always be there\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    const folderContent = folders[folderPath].join(\"\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder which are the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n",
    "importStatements": [
      "import { AllowedTypes } from \"../model/consts\";",
      "const fs2 = require(\"fs\").promises;",
      "const path2 = require(\"path\");",
      "const OpenAI2 = require(\"openai\");",
      "const { Tiktoken } = require(\"tiktoken/lite\");",
      "const cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");"
    ],
    "codeNoBody": "import { AllowedTypes } from \"../model/consts\";\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\nconst startTime = new Date();\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\nconst projectId = \"codebase-index-ts\";\r\nconst forder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${forder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${forder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};\r\n\r\n(async () => {\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.id] = [];\r\n      return acc;\r\n    }, {});\r\n  //console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}\r\n\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\n//...\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\c.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\c.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "originFile": "codebase-index-ts\\tests\\c.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\c.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\c.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath = '/my/path'",
    "originFile": "codebase-index-ts\\tests\\c.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\c.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\c.test.ts",
    "type": "file",
    "totalTokens": 2362,
    "inDegree": 2,
    "outDegree": 2,
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});\r\n",
    "importStatements": [
      "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
    ],
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\java.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\java.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "originFile": "codebase-index-ts\\tests\\java.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\java.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\java.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath = '/my/path'",
    "originFile": "codebase-index-ts\\tests\\java.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\java.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\java.test.ts",
    "type": "file",
    "totalTokens": 2014,
    "inDegree": 2,
    "outDegree": 2,
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});\r\n",
    "importStatements": [
      "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
    ],
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\javascript.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\javascript.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "originFile": "codebase-index-ts\\tests\\javascript.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\javascript.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\javascript.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath = '/my/path'",
    "originFile": "codebase-index-ts\\tests\\javascript.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\javascript.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\javascript.test.ts",
    "type": "file",
    "totalTokens": 2809,
    "inDegree": 2,
    "outDegree": 2,
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "importStatements": [
      "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
    ],
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\php.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\php.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "originFile": "codebase-index-ts\\tests\\php.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\php.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\php.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath = '/my/path'",
    "originFile": "codebase-index-ts\\tests\\php.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\php.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\php.test.ts",
    "type": "file",
    "totalTokens": 3125,
    "inDegree": 2,
    "outDegree": 2,
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});\r\n",
    "importStatements": [
      "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
    ],
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\python.test::nodeAttributes",
    "language": "typescript",
    "label": "nodeAttributes",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\python.test",
    "totalTokens": 39,
    "inDegree": 1,
    "outDegree": 1,
    "code": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": [],
    "codeNoBody": "nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "originFile": "codebase-index-ts\\tests\\python.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\python.test::rootFolderPath",
    "language": "typescript",
    "label": "rootFolderPath",
    "type": "assignment",
    "parent": "codebase-index-ts\\tests\\python.test",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 1,
    "code": "rootFolderPath = '/my/path'",
    "importStatements": [],
    "codeNoBody": "rootFolderPath = '/my/path'",
    "originFile": "codebase-index-ts\\tests\\python.test.ts"
  },
  {
    "id": "codebase-index-ts\\tests\\python.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\python.test.ts",
    "type": "file",
    "totalTokens": 2547,
    "inDegree": 2,
    "outDegree": 2,
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})\r\n",
    "importStatements": [
      "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
    ],
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\tests\\utils.test",
    "language": "typescript",
    "label": "codebase-index-ts\\tests\\utils.test.ts",
    "type": "file",
    "totalTokens": 1684,
    "inDegree": 0,
    "outDegree": 0,
    "code": "import * as utils from '../src/model/utils'\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })\r\n",
    "importStatements": [
      "import * as utils from '../src/model/utils'"
    ],
    "codeNoBody": "import * as utils from '../src/model/utils'\r\n// import Parser from 'tree-sitter'\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })",
    "originFile": ""
  },
  {
    "id": "codebase-index-ts\\wiki::improveWiki",
    "language": "typescript",
    "label": "improveWiki",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 427,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function improveWiki(wiki: string) {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. Imagine that you are a developer who is an expert in code documentation. You have been given the wiki for a project (whole repository). Based on your experience, use your expertise to improve the delivered wiki`s content. You will receive a documentation of the whole repository and its components (documentation of the folders and files) in markdown format. You will have to improve the content of the wiki page. The new documentation should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to improve the wiki page that I will give you. The wiki page I will give you corresponds to the documentation of a whole repository as a wikipedia page in markdown format. The improvements I want are the following:\\n\\n 1. Create an index of the documentation. \\n\\n 2. Clearer sections: Divide documentation into clearer and more concise sections \\n\\n 3. Include References and links: Include links to additional resources, such as documentation of the libraries used and relevant articles.\\n\\n 4. Overview a bit too general. Talk about what Wikipedia is about generic code. You should explain what the code solves.\\n\\n 5. Use paragraphs, no bullet points, just like in a wikipedia page. Concise paragraphs without loosing important information. \\n\\n The wiki page for the whole repo that I need you to improve is the following: \\n\\n${wiki} `;\r\n  contents += `This is the wiki page of the whole repository which will be used as input to improve it: \\n\\n${wiki}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function improveWiki(wiki: string) {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::buildWiki",
    "language": "typescript",
    "label": "buildWiki",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 309,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function buildWiki(finalMarkdown: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the documentation of a whole repository, you will generate a wiki page. Take into account that the whole documentation of a repository is made of the summary of files inside folders. Please be systematic and organized in your documentation and remember to give a markdown document and in prose\";\r\n\r\n  const promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files). Use prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of the whole repository that you need to convert into a wiki page is the following: \\n\\n${finalMarkdown} `;\r\n  contents += `This is the final markdown of the whole repository which will be used as input to convert it to a wiki: \\n\\n${finalMarkdown}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function buildWiki(finalMarkdown: string): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::buildFinalMarkdown",
    "language": "typescript",
    "label": "buildFinalMarkdown",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 163,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function buildFinalMarkdown(generalSummary: string): Promise<string> {\r\n  const nodes: wikiNode[] = await readNodes(\"./folderContents.json\");\r\n\r\n  let finalMarkdown = ` The following is the general documentation of the whole repository: \\n\\n ${generalSummary}\\n\\n`;\r\n  const keys = Object.keys(folderContents);\r\n  const reversedKeys = keys.reverse(); // Reverse the array of keys\r\n  for (const key of reversedKeys) {\r\n    if (key === \"root\") {\r\n      continue; // Skip the current iteration if key is \"root\"\r\n    }\r\n    const nodesInsideKey = folderContents[key];\r\n    for (const node of nodesInsideKey) {\r\n      finalMarkdown += node.summary;\r\n    }\r\n  }\r\n  //console.log(finalMarkdown);\r\n  return finalMarkdown;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function buildFinalMarkdown(generalSummary: string): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::createRepoSummary",
    "language": "typescript",
    "label": "createRepoSummary",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 615,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function createRepoSummary(allCode: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style markdown documentation for the contents of a repository. Given the code of a whole repository, you will generate a documentation and description of the whole code of the repo. Take into account that the whole code of a repository is made of code of files inside folders which is why I am going to give the whole code of the repo but the code will be separated by what the path (label) of the code file where you can find the code. Please be systematic and organized in your description and documentation and remember to give a markdown document.\";\r\n\r\n  const promptUser1 = `I need you to document the following content (code) of a repository (it is the whole code): ${allCode}. Keep in mind that a code from a repo is the collection code from files that are in that repo. Be organized and systematic, taking into account that this is for a wiki page of a repository. Don't add code to the documentation. Start by identifying the folder and then continue by documenting it. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. Also, the combined code from all files inside the repo will be given as the file path (label) and then the code of that file. The documentation should be in Markdown format and cohesive, organized and structured. Has to be precise but without loosing important information. Use prose (except when showing folder structure). The summary should be between 350 and 400 words. There should be 6-10 lines of an overview. In the overview talk  about the objective of the project (repo) and what problem does it solve and with what does it solve it. Give a bit (just a bit) of details on the purpose and functionality. Then comment on the most important parts of the repo (this should be 6-9 lines). Then comment on each of the important parts (2-6 lines each) and then finally comment on the Key algorithms and technologies the repository relies on (6 - 10 lines).`;\r\n  contents += `This is the collection of code of the whole repository which will be the input to try to summarize the repo as a whole at first: \\n\\n${allCode}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createRepoSummary(allCode: string): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::getSummaryOfAllRepoForContext",
    "language": "typescript",
    "label": "getSummaryOfAllRepoForContext",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 137,
    "inDegree": 1,
    "outDegree": 4,
    "code": "async function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string> {\r\n  //need the number of tokens\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        allCode += `\\n\\nThis file has as label (path): ${node.label} and the code in the file with that label is:\r\n        \r\n        ${node.code}\\n\\n`;\r\n      }\r\n    })\r\n  );\r\n\r\n  //console.log(\"ALLCODE: \", allCode);\r\n\r\n  const repoSummary = await createRepoSummary(allCode);\r\n  return repoSummary;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::processAllFolders",
    "language": "typescript",
    "label": "processAllFolders",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 343,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function processAllFolders(generalSummary: string): Promise<void> {\r\n  const folderPaths = Object.keys(folderContents).sort(\r\n    (a, b) => b.length - a.length\r\n  );\r\n\r\n  for (const folderPath of folderPaths) {\r\n    const folderNodes = folderContents[folderPath];\r\n    const summaries = folderNodes\r\n      .map((node) => node.summary)\r\n      .filter((summary) => summary !== undefined);\r\n    const subfolderSummaries = Object.keys(folderContents)\r\n      .filter(\r\n        (subfolder) =>\r\n          subfolder.startsWith(folderPath + \"\\\\\") && subfolder !== folderPath\r\n      )\r\n      .map((subfolder) =>\r\n        folderContents[subfolder]\r\n          .map((node) => node.summary)\r\n          .filter((summary) => summary !== undefined)\r\n          .join(\"\\n\")\r\n      );\r\n\r\n    const combinedSummary = [...summaries, ...subfolderSummaries].join(\"\\n\");\r\n\r\n    const folderSummary = await createFolderSummary(\r\n      folderPath,\r\n      combinedSummary,\r\n      generalSummary\r\n    );\r\n    let parentFolder = path.dirname(folderPath);\r\n    if (folderPath === codebasePath) {\r\n      parentFolder = \"root\";\r\n    }\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n\r\n    folderContents[parentFolder].push({\r\n      id: folderPath,\r\n      label: path.basename(folderPath),\r\n      type: \"folder\",\r\n      totalTokens: combinedSummary.length,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      code: \"\",\r\n      summary: folderSummary,\r\n    });\r\n  }\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processAllFolders(generalSummary: string): Promise<void> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::createFolderSummary",
    "language": "typescript",
    "label": "createFolderSummary",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 622,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  contents += `This is the collection of summaries of the files inside the folder ${folderPath}:\\n\\n${combinedSummary}\\n\\n`;\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a folder. Given the collection of documentations (in markdown format) of all files of a folder, you will generate a documentation of the folder taking into account that the code of a folder is made of code of files inside that folder. Please be systematic and organized in your documentation. The documentation of that folder should be in Markdown format and be between 300-400 words. Use prose and should be precise but without loosing any important information. You will receive a documentation of the whole repository to give context to the folder you are documenting.\";\r\n\r\n  const promptUser1 = `I need you to document the content of a folder. The content of this folder I want you to document will contain a collection of the documentations of all files inside that folder. This folder is part of a repository, which is why as context I am going to give you a documentation of the whole repository where the folder is. The documentation of the whole repo is the following: \\n\\n ${generalSummary}\\n\\n. Don't add code to the documentation. The contents of the folder (or the collection of documentations of the files inside that folder) you need to document in Markdown Format is:  \\n\\n${combinedSummary}\\n. The folder has as path ${folderPath}. Keep in mind that a code from a folder in this context is made up of one or more pieces of code of other files. Be organized and systematic, taking into account that this is for a wiki page of a repository. Start by identifying the folder and then continue with the documentation. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Remember it has to be between 300 and 400 words. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. The documentation should be in Markdown format. Keep in mind that the idea of this is to be a wiki page so the documentation should be like a wikipedia page in markdown format. Also, it is very important that you know that the documentation you give me for the folder should be in prose, in paragraphs 25-30 lines long.`;\r\n\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::getParentFolder",
    "language": "typescript",
    "label": "getParentFolder",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 54,
    "inDegree": 1,
    "outDegree": 2,
    "code": "function getParentFolder(node: wikiNode): string {\r\n  const nodePath = node.id;\r\n  const until = nodePath.lastIndexOf(\"\\\\\");\r\n  const parentFolder = nodePath.slice(0, until);\r\n  //console.log(parentFolder);\r\n  return parentFolder;\r\n}",
    "importStatements": [],
    "codeNoBody": "function getParentFolder(node: wikiNode): string {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::createFileSummary",
    "language": "typescript",
    "label": "createFileSummary",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 389,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a file. Given the code of a file, you will generate a documentation of the file. Please be systematic and organized in your documentation. The documentation should be like a Wikipedia page style. You will receive a documentation and overview of the whole repository to give context to the file you are documenting. The documentation you make should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to document and describe the content of a file, which is part of a repository. The repository as a whole, has a documentation which is: ${generalSummary}\\n\\n. Don't add code to the documentation. The file that I want you to document and describe about is the following: \\n\\n ${node.code}\\n\\n. Mention the file path which is: ${node.id}. Be systematic and keep in mind this is for a wiki page of a whole repository. Start by identifying the file and then continue by summarizing it. Crucial: At every opportunity you will link to other relative paths of this website. The documentation of the file should be between 330 words and 400 words. Use prose!!!! Be organized and systematic with the organization of the content. The documentation should be in Markdown format and it should be in prose.`;\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n  node.summary = completion.choices[0].message.content;\r\n  return completion.choices[0].message.content;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::processFile",
    "language": "typescript",
    "label": "processFile",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 120,
    "inDegree": 1,
    "outDegree": 5,
    "code": "async function processFile(node: wikiNode, generalSummary: string) {\r\n  const fileSummary = await createFileSummary(node, generalSummary);\r\n  if (fileSummary !== null) {\r\n    contents += `This is the summary of file ${node.label}:\\n\\n${fileSummary}\\n\\n`;\r\n    const parentFolder = getParentFolder(node);\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n    //console.log(\"I AM HEREEE\");\r\n    folderContents[parentFolder].push(node);\r\n    //console.log(folderContents);\r\n  }\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processFile(node: wikiNode, generalSummary: string) {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::processAllFiles",
    "language": "typescript",
    "label": "processAllFiles",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 96,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void> {\r\n  // Process each node and wait for all to complete\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        await processFile(node, generalSummary);\r\n      }\r\n    })\r\n  );\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}",
    "importStatements": [],
    "codeNoBody": "async function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void> {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::readNodes",
    "language": "typescript",
    "label": "readNodes",
    "type": "function",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 82,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async function readNodes(nodesFilePath: string) {\r\n  let nodes: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(nodesFilePath, \"utf8\");\r\n    nodes = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${nodesFilePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodes;\r\n}",
    "importStatements": [],
    "codeNoBody": "async function readNodes(nodesFilePath: string) {\n//...\n}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::allCode",
    "language": "typescript",
    "label": "allCode",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 4,
    "inDegree": 3,
    "outDegree": 1,
    "code": "allCode = \"\"",
    "importStatements": [],
    "codeNoBody": "allCode = \"\"",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::contents",
    "language": "typescript",
    "label": "contents",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 3,
    "inDegree": 1,
    "outDegree": 1,
    "code": "contents = \"\"",
    "importStatements": [],
    "codeNoBody": "contents = \"\"",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::folderContents",
    "language": "typescript",
    "label": "folderContents",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 15,
    "inDegree": 4,
    "outDegree": 2,
    "code": "folderContents: { [key: string]: wikiNode[] } = {}",
    "importStatements": [],
    "codeNoBody": "folderContents: { [key: string]: wikiNode[] } = {}",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::nodesFilePath",
    "language": "typescript",
    "label": "nodesFilePath",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 34,
    "inDegree": 2,
    "outDegree": 1,
    "code": "nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\"",
    "importStatements": [],
    "codeNoBody": "nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\"",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::wikiNode",
    "language": "typescript",
    "label": "wikiNode",
    "type": "type",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 60,
    "inDegree": 9,
    "outDegree": 2,
    "code": "type wikiNode = {\r\n  id: string;\r\n  label: string;\r\n  type: string;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n};",
    "importStatements": [],
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  label: string;\r\n  type: string;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n};",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::codebasePath",
    "language": "typescript",
    "label": "codebasePath",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 30,
    "inDegree": 0,
    "outDegree": 1,
    "code": "codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\\"",
    "importStatements": [],
    "codeNoBody": "codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\\"",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki::client",
    "language": "typescript",
    "label": "client",
    "type": "assignment",
    "parent": "codebase-index-ts\\wiki",
    "totalTokens": 45,
    "inDegree": 5,
    "outDegree": 1,
    "code": "client = new OpenAI({\r\n  apiKey: \"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\",\r\n})",
    "importStatements": [],
    "codeNoBody": "client = new OpenAI({\r\n  apiKey: \"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\",\r\n})",
    "originFile": "codebase-index-ts\\wiki.ts"
  },
  {
    "id": "codebase-index-ts\\wiki",
    "language": "typescript",
    "label": "codebase-index-ts\\wiki.ts",
    "type": "file",
    "totalTokens": 3837,
    "inDegree": 19,
    "outDegree": 12,
    "code": "const fs = require(\"fs\").promises;\r\nconst path = require(\"path\");\r\nconst OpenAI = require(\"openai\");\r\n\r\n//DUDAS:\r\n//-HTML O LENGUAGE NATURAL COMO OUTPUT DEL MODELO?\r\n//-Input que sea el codigo o el summary del codigo?\r\n\r\nconst client = new OpenAI({\r\n  apiKey: \"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\",\r\n});\r\nconst codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\\";\r\n\r\nexport type wikiNode = {\r\n  id: string;\r\n  label: string;\r\n  type: string;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n};\r\n\r\nconst nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\";\r\n// Dictionary to hold contents of each folder's wiki\r\nlet folderContents: { [key: string]: wikiNode[] } = {};\r\nlet contents = \"\";\r\nlet allCode = \"\";\r\n(async () => {\r\n  const nodes: wikiNode[] = await readNodes(nodesFilePath);\r\n  //console.log(nodes);\r\n  const generalSummary = await getSummaryOfAllRepoForContext(nodes);\r\n  await fs.writeFile(\"allCode.txt\", allCode);\r\n  await fs.writeFile(\"mainSummary.md\", generalSummary);\r\n  contents += `The following is the general summary of the whole repo,that will be used as context to make other summaries: \\n\\n${generalSummary} heheh\\n\\n`;\r\n  await processAllFiles(nodes, generalSummary);\r\n  //console.log(\"Folder Contents: \", folderContents);\r\n  await processAllFolders(generalSummary);\r\n  await fs.writeFile(\r\n    \"folderContents.json\",\r\n    JSON.stringify(folderContents, null, 2)\r\n  );\r\n  let final = await buildFinalMarkdown(generalSummary);\r\n  let wiki = await buildWiki(final);\r\n  wiki = await improveWiki(wiki);\r\n  await fs.writeFile(\"variablesPrompts.txt\", contents);\r\n  await fs.writeFile(\"final.md\", wiki);\r\n})();\r\n\r\nasync function readNodes(nodesFilePath: string) {\r\n  let nodes: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(nodesFilePath, \"utf8\");\r\n    nodes = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${nodesFilePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodes;\r\n}\r\n\r\nasync function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void> {\r\n  // Process each node and wait for all to complete\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        await processFile(node, generalSummary);\r\n      }\r\n    })\r\n  );\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}\r\nasync function processFile(node: wikiNode, generalSummary: string) {\r\n  const fileSummary = await createFileSummary(node, generalSummary);\r\n  if (fileSummary !== null) {\r\n    contents += `This is the summary of file ${node.label}:\\n\\n${fileSummary}\\n\\n`;\r\n    const parentFolder = getParentFolder(node);\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n    //console.log(\"I AM HEREEE\");\r\n    folderContents[parentFolder].push(node);\r\n    //console.log(folderContents);\r\n  }\r\n}\r\n\r\nasync function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a file. Given the code of a file, you will generate a documentation of the file. Please be systematic and organized in your documentation. The documentation should be like a Wikipedia page style. You will receive a documentation and overview of the whole repository to give context to the file you are documenting. The documentation you make should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to document and describe the content of a file, which is part of a repository. The repository as a whole, has a documentation which is: ${generalSummary}\\n\\n. Don't add code to the documentation. The file that I want you to document and describe about is the following: \\n\\n ${node.code}\\n\\n. Mention the file path which is: ${node.id}. Be systematic and keep in mind this is for a wiki page of a whole repository. Start by identifying the file and then continue by summarizing it. Crucial: At every opportunity you will link to other relative paths of this website. The documentation of the file should be between 330 words and 400 words. Use prose!!!! Be organized and systematic with the organization of the content. The documentation should be in Markdown format and it should be in prose.`;\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n  node.summary = completion.choices[0].message.content;\r\n  return completion.choices[0].message.content;\r\n}\r\nfunction getParentFolder(node: wikiNode): string {\r\n  const nodePath = node.id;\r\n  const until = nodePath.lastIndexOf(\"\\\\\");\r\n  const parentFolder = nodePath.slice(0, until);\r\n  //console.log(parentFolder);\r\n  return parentFolder;\r\n}\r\nasync function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string> {\r\n  contents += `This is the collection of summaries of the files inside the folder ${folderPath}:\\n\\n${combinedSummary}\\n\\n`;\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style info page documentation for the contents of a folder. Given the collection of documentations (in markdown format) of all files of a folder, you will generate a documentation of the folder taking into account that the code of a folder is made of code of files inside that folder. Please be systematic and organized in your documentation. The documentation of that folder should be in Markdown format and be between 300-400 words. Use prose and should be precise but without loosing any important information. You will receive a documentation of the whole repository to give context to the folder you are documenting.\";\r\n\r\n  const promptUser1 = `I need you to document the content of a folder. The content of this folder I want you to document will contain a collection of the documentations of all files inside that folder. This folder is part of a repository, which is why as context I am going to give you a documentation of the whole repository where the folder is. The documentation of the whole repo is the following: \\n\\n ${generalSummary}\\n\\n. Don't add code to the documentation. The contents of the folder (or the collection of documentations of the files inside that folder) you need to document in Markdown Format is:  \\n\\n${combinedSummary}\\n. The folder has as path ${folderPath}. Keep in mind that a code from a folder in this context is made up of one or more pieces of code of other files. Be organized and systematic, taking into account that this is for a wiki page of a repository. Start by identifying the folder and then continue with the documentation. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Remember it has to be between 300 and 400 words. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. The documentation should be in Markdown format. Keep in mind that the idea of this is to be a wiki page so the documentation should be like a wikipedia page in markdown format. Also, it is very important that you know that the documentation you give me for the folder should be in prose, in paragraphs 25-30 lines long.`;\r\n\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}\r\n\r\nasync function processAllFolders(generalSummary: string): Promise<void> {\r\n  const folderPaths = Object.keys(folderContents).sort(\r\n    (a, b) => b.length - a.length\r\n  );\r\n\r\n  for (const folderPath of folderPaths) {\r\n    const folderNodes = folderContents[folderPath];\r\n    const summaries = folderNodes\r\n      .map((node) => node.summary)\r\n      .filter((summary) => summary !== undefined);\r\n    const subfolderSummaries = Object.keys(folderContents)\r\n      .filter(\r\n        (subfolder) =>\r\n          subfolder.startsWith(folderPath + \"\\\\\") && subfolder !== folderPath\r\n      )\r\n      .map((subfolder) =>\r\n        folderContents[subfolder]\r\n          .map((node) => node.summary)\r\n          .filter((summary) => summary !== undefined)\r\n          .join(\"\\n\")\r\n      );\r\n\r\n    const combinedSummary = [...summaries, ...subfolderSummaries].join(\"\\n\");\r\n\r\n    const folderSummary = await createFolderSummary(\r\n      folderPath,\r\n      combinedSummary,\r\n      generalSummary\r\n    );\r\n    let parentFolder = path.dirname(folderPath);\r\n    if (folderPath === codebasePath) {\r\n      parentFolder = \"root\";\r\n    }\r\n    if (!folderContents[parentFolder]) {\r\n      folderContents[parentFolder] = [];\r\n    }\r\n\r\n    folderContents[parentFolder].push({\r\n      id: folderPath,\r\n      label: path.basename(folderPath),\r\n      type: \"folder\",\r\n      totalTokens: combinedSummary.length,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      code: \"\",\r\n      summary: folderSummary,\r\n    });\r\n  }\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n}\r\n\r\nasync function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string> {\r\n  //need the number of tokens\r\n  await Promise.all(\r\n    nodes.map(async (node) => {\r\n      // Create wiki for individual files\r\n      if (node.type === \"file\") {\r\n        allCode += `\\n\\nThis file has as label (path): ${node.label} and the code in the file with that label is:\r\n        \r\n        ${node.code}\\n\\n`;\r\n      }\r\n    })\r\n  );\r\n\r\n  //console.log(\"ALLCODE: \", allCode);\r\n\r\n  const repoSummary = await createRepoSummary(allCode);\r\n  return repoSummary;\r\n}\r\n\r\nasync function createRepoSummary(allCode: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style markdown documentation for the contents of a repository. Given the code of a whole repository, you will generate a documentation and description of the whole code of the repo. Take into account that the whole code of a repository is made of code of files inside folders which is why I am going to give the whole code of the repo but the code will be separated by what the path (label) of the code file where you can find the code. Please be systematic and organized in your description and documentation and remember to give a markdown document.\";\r\n\r\n  const promptUser1 = `I need you to document the following content (code) of a repository (it is the whole code): ${allCode}. Keep in mind that a code from a repo is the collection code from files that are in that repo. Be organized and systematic, taking into account that this is for a wiki page of a repository. Don't add code to the documentation. Start by identifying the folder and then continue by documenting it. Crucial: At every opportunity you will link to other relative paths of this website. Use new lines and paragraphs to separate different topics. Be organized and systematic with the organization of the content. Separate what each file does in the folder (only if that file is important) in different paragraphs. Just be organized and systematic. Also, the combined code from all files inside the repo will be given as the file path (label) and then the code of that file. The documentation should be in Markdown format and cohesive, organized and structured. Has to be precise but without loosing important information. Use prose (except when showing folder structure). The summary should be between 350 and 400 words. There should be 6-10 lines of an overview. In the overview talk  about the objective of the project (repo) and what problem does it solve and with what does it solve it. Give a bit (just a bit) of details on the purpose and functionality. Then comment on the most important parts of the repo (this should be 6-9 lines). Then comment on each of the important parts (2-6 lines each) and then finally comment on the Key algorithms and technologies the repository relies on (6 - 10 lines).`;\r\n  contents += `This is the collection of code of the whole repository which will be the input to try to summarize the repo as a whole at first: \\n\\n${allCode}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}\r\n\r\nasync function buildFinalMarkdown(generalSummary: string): Promise<string> {\r\n  const nodes: wikiNode[] = await readNodes(\"./folderContents.json\");\r\n\r\n  let finalMarkdown = ` The following is the general documentation of the whole repository: \\n\\n ${generalSummary}\\n\\n`;\r\n  const keys = Object.keys(folderContents);\r\n  const reversedKeys = keys.reverse(); // Reverse the array of keys\r\n  for (const key of reversedKeys) {\r\n    if (key === \"root\") {\r\n      continue; // Skip the current iteration if key is \"root\"\r\n    }\r\n    const nodesInsideKey = folderContents[key];\r\n    for (const node of nodesInsideKey) {\r\n      finalMarkdown += node.summary;\r\n    }\r\n  }\r\n  //console.log(finalMarkdown);\r\n  return finalMarkdown;\r\n}\r\n\r\nasync function buildWiki(finalMarkdown: string): Promise<string> {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the documentation of a whole repository, you will generate a wiki page. Take into account that the whole documentation of a repository is made of the summary of files inside folders. Please be systematic and organized in your documentation and remember to give a markdown document and in prose\";\r\n\r\n  const promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files). Use prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of the whole repository that you need to convert into a wiki page is the following: \\n\\n${finalMarkdown} `;\r\n  contents += `This is the final markdown of the whole repository which will be used as input to convert it to a wiki: \\n\\n${finalMarkdown}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}\r\n\r\nasync function improveWiki(wiki: string) {\r\n  const promptSystem1 =\r\n    \"You are wikiGPT. Imagine that you are a developer who is an expert in code documentation. You have been given the wiki for a project (whole repository). Based on your experience, use your expertise to improve the delivered wiki`s content. You will receive a documentation of the whole repository and its components (documentation of the folders and files) in markdown format. You will have to improve the content of the wiki page. The new documentation should be in Markdown format.\";\r\n\r\n  const promptUser1 = `I need you to improve the wiki page that I will give you. The wiki page I will give you corresponds to the documentation of a whole repository as a wikipedia page in markdown format. The improvements I want are the following:\\n\\n 1. Create an index of the documentation. \\n\\n 2. Clearer sections: Divide documentation into clearer and more concise sections \\n\\n 3. Include References and links: Include links to additional resources, such as documentation of the libraries used and relevant articles.\\n\\n 4. Overview a bit too general. Talk about what Wikipedia is about generic code. You should explain what the code solves.\\n\\n 5. Use paragraphs, no bullet points, just like in a wikipedia page. Concise paragraphs without loosing important information. \\n\\n The wiki page for the whole repo that I need you to improve is the following: \\n\\n${wiki} `;\r\n  contents += `This is the wiki page of the whole repository which will be used as input to improve it: \\n\\n${wiki}\\n\\n`;\r\n  contents +=\r\n    \"------------------------------------------------------------------------------------------------------------\\n\\n\";\r\n  const completion = await client.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: \"gpt-4o\",\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}\r\n",
    "importStatements": [
      "const fs = require(\"fs\").promises;",
      "const path = require(\"path\");",
      "const OpenAI = require(\"openai\");"
    ],
    "codeNoBody": "const fs = require(\"fs\").promises;\r\nconst path = require(\"path\");\r\nconst OpenAI = require(\"openai\");\r\n//DUDAS:\r\n//-HTML O LENGUAGE NATURAL COMO OUTPUT DEL MODELO?\r\n//-Input que sea el codigo o el summary del codigo?\r\n\r\nconst client = new OpenAI({\r\n  apiKey: \"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\",\r\n});\r\nconst codebasePath =\r\n  \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\\";\r\n\r\nexport type wikiNode = {\r\n  id: string;\r\n  label: string;\r\n  type: string;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n};\r\n\r\nconst nodesFilePath: string =\r\n  \"C:/Users/gmasc/OneDrive/Documentos/CodeGPT/Graphs/codebase-index-ts/nodes.json\";\r\n// Dictionary to hold contents of each folder's wiki\r\nlet folderContents: { [key: string]: wikiNode[] } = {};\r\nlet contents = \"\";\r\nlet allCode = \"\";\r\n(async () => {\r\n  const nodes: wikiNode[] = await readNodes(nodesFilePath);\r\n  //console.log(nodes);\r\n  const generalSummary = await getSummaryOfAllRepoForContext(nodes);\r\n  await fs.writeFile(\"allCode.txt\", allCode);\r\n  await fs.writeFile(\"mainSummary.md\", generalSummary);\r\n  contents += `The following is the general summary of the whole repo,that will be used as context to make other summaries: \\n\\n${generalSummary} heheh\\n\\n`;\r\n  await processAllFiles(nodes, generalSummary);\r\n  //console.log(\"Folder Contents: \", folderContents);\r\n  await processAllFolders(generalSummary);\r\n  await fs.writeFile(\r\n    \"folderContents.json\",\r\n    JSON.stringify(folderContents, null, 2)\r\n  );\r\n  let final = await buildFinalMarkdown(generalSummary);\r\n  let wiki = await buildWiki(final);\r\n  wiki = await improveWiki(wiki);\r\n  await fs.writeFile(\"variablesPrompts.txt\", contents);\r\n  await fs.writeFile(\"final.md\", wiki);\r\n})();\r\n\r\nasync function readNodes(nodesFilePath: string) {\n//...\n}\r\n\r\nasync function processAllFiles(\r\n  nodes: wikiNode[],\r\n  generalSummary: string\r\n): Promise<void> {\n//...\n}\r\nasync function processFile(node: wikiNode, generalSummary: string) {\n//...\n}\r\n\r\nasync function createFileSummary(\r\n  node: wikiNode,\r\n  generalSummary: string\r\n): Promise<string> {\n//...\n}\r\nfunction getParentFolder(node: wikiNode): string {\n//...\n}\r\nasync function createFolderSummary(\r\n  folderPath: string,\r\n  combinedSummary: string,\r\n  generalSummary: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function processAllFolders(generalSummary: string): Promise<void> {\n//...\n}\r\n\r\nasync function getSummaryOfAllRepoForContext(\r\n  nodes: wikiNode[]\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function createRepoSummary(allCode: string): Promise<string> {\n//...\n}\r\n\r\nasync function buildFinalMarkdown(generalSummary: string): Promise<string> {\n//...\n}\r\n\r\nasync function buildWiki(finalMarkdown: string): Promise<string> {\n//...\n}\r\n\r\nasync function improveWiki(wiki: string) {\n//...\n}",
    "originFile": ""
  }
]