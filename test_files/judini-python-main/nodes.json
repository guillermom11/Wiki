[
  {
    "id": "\\CHANGELOG",
    "language": "markdown",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\CHANGELOG.md",
    "type": "file",
    "totalTokens": 463,
    "inDegree": 0,
    "outDegree": 0,
    "code": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.1.12] - 19-03-2024\n### Changed\n- Fix problem with `stream=True`\n- Remove `format` parameter: Now it will be always `text`. \n\n## [0.1.11] - 01-03-2024\n### Changed\n- Remove unused packages\n- Set minimum package version\n\n\n## [0.1.10] - 16-02-2024\n### Changed\n- Updated to new API version\n\n## [0.0.24] - 12-20-2023\n\n### Changed\n+ Fix errors\n\n## [0.0.23] - 12-15-2023\n\n### Changed\n+ Fix errors\n\n## [0.0.22] - 12-15-2023\n\n### Changed\n+ Updates completion\n\n## [0.0.21] - 12-11-2023\n\n### Changed\n+ Updates methods\n+ Changes in modules\n+ Update Readme with Examples\n\n\n## [0.0.17] - 09-20-2023\n\n### Changed\n- Updates completion\n\n## [0.0.17] - 09-20-2023\n\n### Changed\n- The agent's response has been updated in case the return is with functions.\n\n## [0.0.16] - 09-08-2023\n### Added\n\n- Added the Examples.\n\n### Changed\n- fix agent file\n- fix stream and async functions\n\n\n## [0.0.13] - 08-26-2023\n\n### Added\n\n- Added the CHANGELOG file.\n\n### Changed\n\n- Fix test file\n- Fix Agent Class code\n- Change struct internal\n\n## [0.0.1] - [0.0.12] - before 08-2023\n\n### Changed\n\n- Initial changes were made without documentation in the CHANGELOG.\n",
    "importStatements": [],
    "codeNoBody": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.1.12] - 19-03-2024\n### Changed\n- Fix problem with `stream=True`\n- Remove `format` parameter: Now it will be always `text`. \n\n## [0.1.11] - 01-03-2024\n### Changed\n- Remove unused packages\n- Set minimum package version\n\n\n## [0.1.10] - 16-02-2024\n### Changed\n- Updated to new API version\n\n## [0.0.24] - 12-20-2023\n\n### Changed\n+ Fix errors\n\n## [0.0.23] - 12-15-2023\n\n### Changed\n+ Fix errors\n\n## [0.0.22] - 12-15-2023\n\n### Changed\n+ Updates completion\n\n## [0.0.21] - 12-11-2023\n\n### Changed\n+ Updates methods\n+ Changes in modules\n+ Update Readme with Examples\n\n\n## [0.0.17] - 09-20-2023\n\n### Changed\n- Updates completion\n\n## [0.0.17] - 09-20-2023\n\n### Changed\n- The agent's response has been updated in case the return is with functions.\n\n## [0.0.16] - 09-08-2023\n### Added\n\n- Added the Examples.\n\n### Changed\n- fix agent file\n- fix stream and async functions\n\n\n## [0.0.13] - 08-26-2023\n\n### Added\n\n- Added the CHANGELOG file.\n\n### Changed\n\n- Fix test file\n- Fix Agent Class code\n- Change struct internal\n\n## [0.0.1] - [0.0.12] - before 08-2023\n\n### Changed\n\n- Initial changes were made without documentation in the CHANGELOG.",
    "originFile": "\\CHANGELOG.md"
  },
  {
    "id": "\\README",
    "language": "markdown",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\README.md",
    "type": "file",
    "totalTokens": 1489,
    "inDegree": 0,
    "outDegree": 0,
    "code": "# Judini Python Package\nThe Judini Python library provides convenient access to CodeGPT's Judini REST API from any Python 3.7+ application. The library includes type definitions for all requests parameters and response fields, and offers synchronous and asynchronous clients.\n\n## Documentation\nThe API documentation can be found [Here](https://developers.codegpt.co).\n\n## Install\nTo install the package, simply run the following command:\n\n```bash\npip install judini\n```\n\n## How to get your keys\n1. Create an account at https://app.codegpt.co\n2. Get your **CodeGPT Api Key** and **Org ID** from the [Apikeys menu](https://app.codegpt.co/en/apikeys)\n  \n## How to use\n\n### Chat Completion\n\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\n\nAGENT_ID = \"0000000-0000-0000-0000-000000000000\"\nmessages = [{\"role\": \"user\", \"content\": \"What is the meaning of life?\"}]\n\n# No streaming\nchat = codegpt.chat_completion(agent_id=AGENT_ID,\n                               messages=messages)\nprint(chat)\n\n# Streaming\nfor chunk in codegpt.chat_completion(agent_id=AGENT_ID,\n...                                  messages=messages,\n...                                  stream=True):\n    print(chunk, end=\"\")\n```\n\n### Agents\n#### List all agents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.get_agents()\n>> [Agent(id='0000000-0000-0000-0000-000000000000', ...),\n>>  Agent(id='0000000-0000-0000-0000-000000000001', ...)]\n```\n\n#### Get agent by ID\n```python  \nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\nagent = codegpt.get_agent(agent_id='0000000-0000-0000-0000-000000000000')\nagent\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name', model='gpt-3.5-turbo',\n>>       prompt='You are a helpful assistant.',\n>>       welcome='Hello, how can I help you?',\n>>       ...)\n```\n\n#### Create Agent\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.create_agent(name='Agent name', model='gpt-3.5-turbo',\n...                  prompt='You are a helpful assistant.',\n...                  welcome='Hello, how can I help you?')\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name', model='gpt-3.5-turbo', ...)\n```\n\n#### Update Agent info\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_agent(agent_id='0000000-0000-0000-0000-000000000000',\n...                  name='Agent name updated',\n...                  model='gpt-4-turbo-preview')\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name updated', model='gpt-3.5-turbo', ...)                    \n```\n\n#### Update Agent documents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_agent_documents(agent_id='0000000-0000-0000-0000-000000000000',\n...                            document_ids=[DOCUMENT_ID_1, DOCUMENT_ID_2])\n>> \"Agent documents updated successfully\"\n```\n\n#### Delete Agent\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.delete_agent('0000000-0000-0000-0000-000000000000')\n>> \"Agent deleted successfully\"\n```\n\n\n### Documents\n#### List all documents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.get_documents()\n>> [Document(id='0000000-0000-0000-0000-000000000000', ...),\n>>  Document(id='0000000-0000-0000-0000-000000000001', ...)]\n```\n\n#### Get document by ID\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ndocument = codegpt.get_document_by_id('0000000-0000-0000-0000-000000000000')\ndocument\n>> Document(id='0000000-0000-0000-0000-000000000000',\n>>          user_id='...',\n>>          name='My Document',\n>>          metadata='...',\n>>          content='Document content', ...)\n```\n\n#### Upload a document\n**Currently, only text documents are supported**\n```python\t\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.upload_document('path/to/file.txt', generate_metadata=False)\n>> {'id': '0000000-0000-0000-0000-000000000000'}\n```\n\n#### Update document metadata\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_document_metadata(id='0000000-0000-0000-0000-000000000000',\n...                              title='My Document Updated',)\n>> \"Document metadata updated successfully\"\n```\n\n#### Delete a document\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.delete_document('0000000-0000-0000-0000-000000000000')\n>> \"Document deleted successfully\"\n```\n\n## MORE EXAMPLES\nYou can review more examples in our [Cookbook Repository](https://github.com/judinilabs/cookbook/)\n\n## Changelog\n[Changelog](https://github.com/JudiniLabs/judini-python/blob/main/CHANGELOG.md)",
    "importStatements": [],
    "codeNoBody": "# Judini Python Package\nThe Judini Python library provides convenient access to CodeGPT's Judini REST API from any Python 3.7+ application. The library includes type definitions for all requests parameters and response fields, and offers synchronous and asynchronous clients.\n## Documentation\nThe API documentation can be found [Here](https://developers.codegpt.co).\n\n## Install\nTo install the package, simply run the following command:\n\n```bash\npip install judini\n```\n\n## How to get your keys\n1. Create an account at https://app.codegpt.co\n2. Get your **CodeGPT Api Key** and **Org ID** from the [Apikeys menu](https://app.codegpt.co/en/apikeys)\n  \n## How to use\n\n### Chat Completion\n\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\n\nAGENT_ID = \"0000000-0000-0000-0000-000000000000\"\nmessages = [{\"role\": \"user\", \"content\": \"What is the meaning of life?\"}]\n\n# No streaming\nchat = codegpt.chat_completion(agent_id=AGENT_ID,\n                               messages=messages)\nprint(chat)\n\n# Streaming\nfor chunk in codegpt.chat_completion(agent_id=AGENT_ID,\n...                                  messages=messages,\n...                                  stream=True):\n    print(chunk, end=\"\")\n```\n\n### Agents\n#### List all agents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.get_agents()\n>> [Agent(id='0000000-0000-0000-0000-000000000000', ...),\n>>  Agent(id='0000000-0000-0000-0000-000000000001', ...)]\n```\n\n#### Get agent by ID\n```python  \nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\nagent = codegpt.get_agent(agent_id='0000000-0000-0000-0000-000000000000')\nagent\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name', model='gpt-3.5-turbo',\n>>       prompt='You are a helpful assistant.',\n>>       welcome='Hello, how can I help you?',\n>>       ...)\n```\n\n#### Create Agent\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.create_agent(name='Agent name', model='gpt-3.5-turbo',\n...                  prompt='You are a helpful assistant.',\n...                  welcome='Hello, how can I help you?')\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name', model='gpt-3.5-turbo', ...)\n```\n\n#### Update Agent info\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_agent(agent_id='0000000-0000-0000-0000-000000000000',\n...                  name='Agent name updated',\n...                  model='gpt-4-turbo-preview')\n>> Agent(id='0000000-0000-0000-0000-000000000000',\n>>       name='Agent name updated', model='gpt-3.5-turbo', ...)                    \n```\n\n#### Update Agent documents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_agent_documents(agent_id='0000000-0000-0000-0000-000000000000',\n...                            document_ids=[DOCUMENT_ID_1, DOCUMENT_ID_2])\n>> \"Agent documents updated successfully\"\n```\n\n#### Delete Agent\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.delete_agent('0000000-0000-0000-0000-000000000000')\n>> \"Agent deleted successfully\"\n```\n\n\n### Documents\n#### List all documents\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.get_documents()\n>> [Document(id='0000000-0000-0000-0000-000000000000', ...),\n>>  Document(id='0000000-0000-0000-0000-000000000001', ...)]\n```\n\n#### Get document by ID\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ndocument = codegpt.get_document_by_id('0000000-0000-0000-0000-000000000000')\ndocument\n>> Document(id='0000000-0000-0000-0000-000000000000',\n>>          user_id='...',\n>>          name='My Document',\n>>          metadata='...',\n>>          content='Document content', ...)\n```\n\n#### Upload a document\n**Currently, only text documents are supported**\n```python\t\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.upload_document('path/to/file.txt', generate_metadata=False)\n>> {'id': '0000000-0000-0000-0000-000000000000'}\n```\n\n#### Update document metadata\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.update_document_metadata(id='0000000-0000-0000-0000-000000000000',\n...                              title='My Document Updated',)\n>> \"Document metadata updated successfully\"\n```\n\n#### Delete a document\n```python\nfrom judini import CodeGPTPlus\ncodegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=ORG_ID)\ncodegpt.delete_document('0000000-0000-0000-0000-000000000000')\n>> \"Document deleted successfully\"\n```\n\n## MORE EXAMPLES\nYou can review more examples in our [Cookbook Repository](https://github.com/judinilabs/cookbook/)\n\n## Changelog\n[Changelog](https://github.com/JudiniLabs/judini-python/blob/main/CHANGELOG.md)",
    "originFile": "\\README.md"
  },
  {
    "id": "\\examples\\chat_completion::chat_example",
    "language": "python",
    "label": "chat_example",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\examples\\chat_completion",
    "totalTokens": 166,
    "inDegree": 2,
    "outDegree": 0,
    "code": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    CODEGPT_API_KEY = os.getenv(\"CODEGPT_API_KEY\")\n    CODEGPT_ORG_ID = os.getenv(\"CODEGPT_ORG_ID\")\n    CODEGPT_AGENT_ID = os.getenv(\"CODEGPT_AGENT_ID\")\n    # Create an instance of the CodeGPTPlus class\n    codegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=CODEGPT_ORG_ID)\n\n    # Use a loop to interact with the agent and get responses\n    for chunk in codegpt.chat_completion(agent_id=CODEGPT_AGENT_ID, messages=messages, stream=True):\n        print(chunk, end=\"\")  # Print the responses obtained from the agent",
    "importStatements": [],
    "codeNoBody": "def chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    ...",
    "originFile": "\\examples\\chat_completion.py"
  },
  {
    "id": "\\examples\\chat_completion",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\examples\\chat_completion.py",
    "type": "file",
    "totalTokens": 288,
    "inDegree": 0,
    "outDegree": 2,
    "code": "# Import necessary modules and libraries\nimport os\nfrom judini import CodeGPTPlus\nfrom dotenv import load_dotenv\n\n# Load environment variables from a .env file if available\nload_dotenv()\n\n\n# Define a function to demonstrate a chat interaction with a CodeGPT agent\n\ndef chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    CODEGPT_API_KEY = os.getenv(\"CODEGPT_API_KEY\")\n    CODEGPT_ORG_ID = os.getenv(\"CODEGPT_ORG_ID\")\n    CODEGPT_AGENT_ID = os.getenv(\"CODEGPT_AGENT_ID\")\n    # Create an instance of the CodeGPTPlus class\n    codegpt = CodeGPTPlus(api_key=CODEGPT_API_KEY, org_id=CODEGPT_ORG_ID)\n\n    # Use a loop to interact with the agent and get responses\n    for chunk in codegpt.chat_completion(agent_id=CODEGPT_AGENT_ID, messages=messages, stream=True):\n        print(chunk, end=\"\")  # Print the responses obtained from the agent\n\n# Entry point of the script\nif __name__ == \"__main__\":\n    text = \"First President of USA?\"  # Define a user message for the conversation\n    message = {\"role\": \"user\", \"content\": text}  # Create a message for the user\n    chat_example([message])",
    "importStatements": [
      "import os",
      "from judini import CodeGPTPlus",
      "from dotenv import load_dotenv"
    ],
    "codeNoBody": "# Import necessary modules and libraries\nimport os\nfrom judini import CodeGPTPlus\nfrom dotenv import load_dotenv\n# Load environment variables from a .env file if available\nload_dotenv()\n\n\n# Define a function to demonstrate a chat interaction with a CodeGPT agent\n\ndef chat_example(messages: list):\n    # Retrieve the CodeGPT API key from environment variables\n    ...\n\n# Entry point of the script\nif __name__ == \"__main__\":\n    text = \"First President of USA?\"  # Define a user message for the conversation\n    message = {\"role\": \"user\", \"content\": text}  # Create a message for the user\n    chat_example([message])",
    "originFile": "\\examples\\chat_completion.py"
  },
  {
    "id": "\\setup",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\setup.py",
    "type": "file",
    "totalTokens": 221,
    "inDegree": 0,
    "outDegree": 0,
    "code": "import setuptools\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"judini\",\n    version=\"0.1.12\",\n    author=\"Judini Inc.\",\n    author_email=\"daniel@judini.ai\",\n    description=\"CodeGPT python package\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/JudiniLabs/judini-python\",\n    packages=setuptools.find_packages(),\n    package_data={\"judini\": [\"VERSION\"]},\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Operating System :: OS Independent\",\n    ],\n    python_requires=\">=3.7\",\n    install_requires=[\n        \"requests>=2.31.0\", \"python-dotenv>=1.0.0\", \"pydantic>=2.5.2\"\n    ],\n)",
    "importStatements": [
      "import setuptools"
    ],
    "codeNoBody": "import setuptools\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"judini\",\n    version=\"0.1.12\",\n    author=\"Judini Inc.\",\n    author_email=\"daniel@judini.ai\",\n    description=\"CodeGPT python package\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/JudiniLabs/judini-python\",\n    packages=setuptools.find_packages(),\n    package_data={\"judini\": [\"VERSION\"]},\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Operating System :: OS Independent\",\n    ],\n    python_requires=\">=3.7\",\n    install_requires=[\n        \"requests>=2.31.0\", \"python-dotenv>=1.0.0\", \"pydantic>=2.5.2\"\n    ],\n)",
    "originFile": "\\setup.py"
  },
  {
    "id": "\\src\\judini\\__init__",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\__init__.py",
    "type": "file",
    "totalTokens": 10,
    "inDegree": 0,
    "outDegree": 0,
    "code": "from .codegpt import CodeGPTPlus",
    "importStatements": [
      "from .codegpt import CodeGPTPlus"
    ],
    "codeNoBody": "from .codegpt import CodeGPTPlus",
    "originFile": "\\src\\judini\\__init__.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.delete_document",
    "language": "python",
    "label": "CodeGPTPlus.delete_document",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    ...\n        \n        \n    def delete_document(self, document_id: str) -> None:\n        \n\n        response = requests.delete(f\"{self.base_url}/document/{document_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Document deleted successfully')\n        return",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def delete_document(self, document_id: str) -> None:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.upload_document",
    "language": "python",
    "label": "CodeGPTPlus.upload_document",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 264,
    "inDegree": 1,
    "outDegree": 4,
    "code": "class CodeGPTPlus:\n\n\n\n    def upload_document(self, file_path: str,\n                        generate_metadata: bool = False) -> Dict[str, str]:\n        \n        \n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n        \n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_id = response.json()['documentId']\n        if generate_metadata:\n            try:\n                document_metadata = self._generate_document_metadata(file_path)\n                self.update_document_metadata(document_id,\n                                              **document_metadata.model_dump())\n                return {'id' : document_id}\n            except:\n                print('Failed to generate document metadata.')\n                return {'id' : document_id}\n\n        return {'id' : document_id}\n        \n        \n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def upload_document(self, file_path: str,\n                        generate_metadata: bool = False) -> Dict[str, str]:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus._generate_document_metadata",
    "language": "python",
    "label": "CodeGPTPlus._generate_document_metadata",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 183,
    "inDegree": 2,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def _generate_document_metadata(self, file_path: str) -> DocumentMetadata:\n        \n\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n\n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document/metadata\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n            \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return DocumentMetadata(**response.json()[\"metadata\"])\n\n        \n        \n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def _generate_document_metadata(self, file_path: str) -> DocumentMetadata:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.update_document_metadata",
    "language": "python",
    "label": "CodeGPTPlus.update_document_metadata",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 223,
    "inDegree": 2,
    "outDegree": 3,
    "code": "class CodeGPTPlus:\n\n\n\n    def update_document_metadata(self,\n                                 document_id: str,\n                                 title: Optional[str] = None,\n                                 description: Optional[str] = None,\n                                 summary: Optional[str] = None,\n                                 keywords: Optional[str] = None,\n                                 language: Optional[str] = None):\n        \n        document_metadata = (self.get_document(document_id).metadata or\n                             DocumentMetadata())\n        if title:\n            document_metadata.title = title\n        if description:\n            document_metadata.description = description\n        if summary:\n            document_metadata.summary = summary\n        if keywords:\n            document_metadata.keywords = keywords\n        if language:\n            document_metadata.language = language\n\n        payload = json.dumps(document_metadata.model_dump())\n\n        response = requests.patch(f\"{self.base_url}/document/{document_id}/metadata\",\n                                  headers=self.headers,\n                                  data=payload)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print(\"Document metadata updated successfully\")\n        return\n    \n\n        \n        \n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def update_document_metadata(self,\n                                 document_id: str,\n                                 title: Optional[str] = None,\n                                 description: Optional[str] = None,\n                                 summary: Optional[str] = None,\n                                 keywords: Optional[str] = None,\n                                 language: Optional[str] = None):\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.get_document",
    "language": "python",
    "label": "CodeGPTPlus.get_document",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 86,
    "inDegree": 2,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def get_document(self, document_id: str) -> Document:\n        \n\n        response = requests.get(f\"{self.base_url}/document/{document_id}\",\n                                headers=self.headers)\n\n        if response.status_code != 200:\n           raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Document(**response.json())\n    \n    \n\n        \n        \n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def get_document(self, document_id: str) -> Document:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.get_documents",
    "language": "python",
    "label": "CodeGPTPlus.get_documents",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 94,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def get_documents(self) -> List[Document]:\n        \n\n        response = requests.get(f\"{self.base_url}/document\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_lists = response.json()\n        return [Document(**document_dict) for document_dict in document_lists]\n    \n    \n    \n\n        \n        \n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def get_documents(self) -> List[Document]:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.update_agent_documents",
    "language": "python",
    "label": "CodeGPTPlus.update_agent_documents",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 117,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def update_agent_documents(self, agent_id: str, document_ids: List[str]) -> None:\n        \n        payload = json.dumps({ \"agent_documents\": document_ids})\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}/documents\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent documents updated successfully')\n        return \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def update_agent_documents(self, agent_id: str, document_ids: List[str]) -> None:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.delete_agent",
    "language": "python",
    "label": "CodeGPTPlus.delete_agent",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 89,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def delete_agent(self, agent_id: str) -> None:\n        \n\n        response = requests.delete(f\"{self.base_url}/agent/{agent_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent deleted successfully')\n        return\n     \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def delete_agent(self, agent_id: str) -> None:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.update_agent",
    "language": "python",
    "label": "CodeGPTPlus.update_agent",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 331,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def update_agent(self,\n                     agent_id: str,\n                     name: Optional[str] = None,\n                     model: Optional[str] = None,\n                     prompt: Optional[str] = None,\n                     welcome: Optional[str] = None,\n                     topk: Optional[int] = None,\n                     temperature: Optional[int] = None,\n                     is_public: Optional[bool] = None,\n                     pincode: Optional[str] = None\n                     ) -> Agent:\n        \n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n        payload = {}\n        if name:\n            payload['name'] = name\n        if model:\n            payload['model'] = model\n        if prompt:\n            payload['prompt'] = prompt\n        if welcome:\n            payload['welcome'] = welcome\n        if topk:\n            payload['topk'] = topk\n        if temperature:\n            payload['temperature'] = temperature\n        if is_public:\n            payload['is_public'] = is_public\n        if pincode:\n            payload['pincode'] = pincode\n\n        if not payload:\n            raise ValueError('JUDINI: At least one parameter must be provided')\n        \n        payload = json.dumps(payload)\n\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n\n     \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def update_agent(self,\n                     agent_id: str,\n                     name: Optional[str] = None,\n                     model: Optional[str] = None,\n                     prompt: Optional[str] = None,\n                     welcome: Optional[str] = None,\n                     topk: Optional[int] = None,\n                     temperature: Optional[int] = None,\n                     is_public: Optional[bool] = None,\n                     pincode: Optional[str] = None\n                     ) -> Agent:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.create_agent",
    "language": "python",
    "label": "CodeGPTPlus.create_agent",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 195,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def create_agent(self,\n                     name: str,\n                     model: str=\"gpt-3.5-turbo\",\n                     prompt: str = \"You are a helpful assistant.\",\n                     welcome: str = \"Hello, how can I help you today?\",\n                     topk: int=3,\n                     temperature: int=0.7,\n                     ) -> Agent:\n        \n\n        payload = json.dumps({\n            \"name\": name,\n            \"model\": model,\n            \"prompt\": prompt,\n            \"welcome\": welcome,\n            \"topk\": topk,\n            \"temperature\": temperature\n        })\n        response = requests.post(f\"{self.base_url}/agent\", headers=self.headers,\n                                 data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    \n\n     \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def create_agent(self,\n                     name: str,\n                     model: str=\"gpt-3.5-turbo\",\n                     prompt: str = \"You are a helpful assistant.\",\n                     welcome: str = \"Hello, how can I help you today?\",\n                     topk: int=3,\n                     temperature: int=0.7,\n                     ) -> Agent:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.get_agent",
    "language": "python",
    "label": "CodeGPTPlus.get_agent",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 91,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def get_agent(self, agent_id: str) -> Agent:\n        \n\n        response = requests.get(f\"{self.base_url}/agent/{agent_id}?populate=agent_documents\",\n                                 headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    \n    \n\n     \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def get_agent(self, agent_id: str) -> Agent:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.get_agents",
    "language": "python",
    "label": "CodeGPTPlus.get_agents",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 94,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def get_agents(self) -> List[Agent]:\n        \n\n        response = requests.get(f\"{self.base_url}/agent\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        agent_lists = response.json()\n        return [Agent(**agent_dict) for agent_dict in agent_lists]\n    \n    \n    \n    \n\n     \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def get_agents(self) -> List[Agent]:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.chat_completion",
    "language": "python",
    "label": "CodeGPTPlus.chat_completion",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 224,
    "inDegree": 1,
    "outDegree": 2,
    "code": "class CodeGPTPlus:\n\n\n\n    def chat_completion(self, agent_id: str, messages: List[Dict[str, str]], \n               stream: bool = False) -> str:\n        \n        \n        if len(messages) == 0:\n            raise ValueError('JUDINI: messages array should not be empty')\n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n\n        headers = self.headers.copy()\n        headers['accept'] = 'text/event-stream'\n\n        payload = json.dumps({\n            \"agentId\": agent_id,\n            \"messages\": messages,\n            \"stream\": stream,\n            \"format\": \"text\"\n        })\n\n        response = requests.post(f\"{self.base_url}/chat/completions\",\n                                 headers=headers, data=payload,\n                                 stream=stream)\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        if stream:\n            return handle_stream(response)\n        else:\n            return handle_non_stream(response)\n        \n\n    ...",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def chat_completion(self, agent_id: str, messages: List[Dict[str, str]], \n               stream: bool = False) -> str:\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus.__init__",
    "language": "python",
    "label": "CodeGPTPlus.__init__",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt::CodeGPTPlus",
    "totalTokens": 260,
    "inDegree": 14,
    "outDegree": 1,
    "code": "class CodeGPTPlus:\n    def __init__(self,\n                 api_key: Optional[str] = None,\n                 org_id: Optional[str] = None,\n                 base_url: str = base_url):\n\n        if not api_key:\n            api_key = os.getenv(\"CODEGPT_API_KEY\")\n            if not api_key:\n                raise Exception('JUDINI: API key not found. Please set'\n                                + ' the CODEGPT_API_KEY environment variable'\n                                + ' or pass it as an argument.\\nYou can get'\n                                + ' your API key from: ' + PLAYGROUND_KEYS_URL)\n        self.headers = {\n            'Content-Type': 'application/json',\n            'Channel' : 'SDK_PYTHON',\n            'Authorization': 'Bearer ' + api_key\n        }\n        if not org_id:\n            org_id = os.getenv(\"CODEGPT_ORG_ID\")\n\n        if org_id:\n            self.headers['CodeGPT-Org-Id'] = org_id\n        else:\n            warnings.warn('\\nJUDINI: Org ID not found. This could lead to'\n                          + ' unexpected behavior.\\nYou can get your org ID'\n                          + ' from: ' + PLAYGROUND_KEYS_URL)\n        \n        self.is_streaming = False\n        self.base_url = base_url\n\n\n\n    ",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    ...\n    def __init__(self,\n                 api_key: Optional[str] = None,\n                 org_id: Optional[str] = None,\n                 base_url: str = base_url):\n            ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::CodeGPTPlus",
    "language": "python",
    "label": "CodeGPTPlus",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 4095,
    "inDegree": 1,
    "outDegree": 15,
    "code": "class CodeGPTPlus:\n    def __init__(self,\n                 api_key: Optional[str] = None,\n                 org_id: Optional[str] = None,\n                 base_url: str = base_url):\n\n        if not api_key:\n            api_key = os.getenv(\"CODEGPT_API_KEY\")\n            if not api_key:\n                raise Exception('JUDINI: API key not found. Please set'\n                                + ' the CODEGPT_API_KEY environment variable'\n                                + ' or pass it as an argument.\\nYou can get'\n                                + ' your API key from: ' + PLAYGROUND_KEYS_URL)\n        self.headers = {\n            'Content-Type': 'application/json',\n            'Channel' : 'SDK_PYTHON',\n            'Authorization': 'Bearer ' + api_key\n        }\n        if not org_id:\n            org_id = os.getenv(\"CODEGPT_ORG_ID\")\n\n        if org_id:\n            self.headers['CodeGPT-Org-Id'] = org_id\n        else:\n            warnings.warn('\\nJUDINI: Org ID not found. This could lead to'\n                          + ' unexpected behavior.\\nYou can get your org ID'\n                          + ' from: ' + PLAYGROUND_KEYS_URL)\n        \n        self.is_streaming = False\n        self.base_url = base_url\n\n\n\n    #######################\n    ### CHAT COMPLETION ###\n    #######################\n        \n    def chat_completion(self, agent_id: str, messages: List[Dict[str, str]], \n               stream: bool = False) -> str:\n        \"\"\"\n        Initiates a chat with the specified agent and handles the streaming of\n        responses.\n\n        Parameters\n        ----------\n\n        agent_id: The ID of the agent to chat with.\n        messages: An array of message objects to be sent to the agent. Each\n                  object should have a `role` (which can be 'system', 'user',\n                  or 'assistant') and `content` which is the actual message.\n        stream: Whether to stream the response or not.\n\n        Example:\n        >>> from judini import CodeGPTPlus\n        >>> codegpt = CodeGPTPlus(api_key, org_id)\n        >>> agent_id = '00000000-0000-0000-0000-000000000000'\n        >>> messages = [{'role': 'user', 'content': 'Hello, World!'}]\n        >>> codegpt.chat_completion(agent_id, messages, stream=True)\n        'Hello, World!'\n        \"\"\"\n        \n        if len(messages) == 0:\n            raise ValueError('JUDINI: messages array should not be empty')\n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n\n        headers = self.headers.copy()\n        headers['accept'] = 'text/event-stream'\n\n        payload = json.dumps({\n            \"agentId\": agent_id,\n            \"messages\": messages,\n            \"stream\": stream,\n            \"format\": \"text\"\n        })\n\n        response = requests.post(f\"{self.base_url}/chat/completions\",\n                                 headers=headers, data=payload,\n                                 stream=stream)\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        if stream:\n            return handle_stream(response)\n        else:\n            return handle_non_stream(response)\n        \n\n    ##############\n    ### AGENTS ###\n    ##############\n\n    def get_agents(self) -> List[Agent]:\n        \"\"\"\n        Retrieves a list of all the agents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing agents with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                    associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/agent\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        agent_lists = response.json()\n        return [Agent(**agent_dict) for agent_dict in agent_lists]\n    \n    def get_agent(self, agent_id: str) -> Agent:\n        \"\"\"\n        Retrieves a specific agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to retrieve.\n\n        Returns a json object representing the agent with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/agent/{agent_id}?populate=agent_documents\",\n                                 headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    def create_agent(self,\n                     name: str,\n                     model: str=\"gpt-3.5-turbo\",\n                     prompt: str = \"You are a helpful assistant.\",\n                     welcome: str = \"Hello, how can I help you today?\",\n                     topk: int=3,\n                     temperature: int=0.7,\n                     ) -> Agent:\n        \"\"\"\n        Creates a new agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        name: The name of the agent.\n        model: The model to be used by the agent. For example, 'gpt-3.5-turbo'.\n        prompt: The prompt of the agent.\n        welcome: The welcome message of the agent.\n        topk: The number of elements to retrieve from the documents\n        temperature: The temperature of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        payload = json.dumps({\n            \"name\": name,\n            \"model\": model,\n            \"prompt\": prompt,\n            \"welcome\": welcome,\n            \"topk\": topk,\n            \"temperature\": temperature\n        })\n        response = requests.post(f\"{self.base_url}/agent\", headers=self.headers,\n                                 data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    def update_agent(self,\n                     agent_id: str,\n                     name: Optional[str] = None,\n                     model: Optional[str] = None,\n                     prompt: Optional[str] = None,\n                     welcome: Optional[str] = None,\n                     topk: Optional[int] = None,\n                     temperature: Optional[int] = None,\n                     is_public: Optional[bool] = None,\n                     pincode: Optional[str] = None\n                     ) -> Agent:\n        \"\"\"\n        Updates an existing agent in the CodeGPTPlus API.\n        Apart from the agent ID, at least one parameter is required.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        name: (optional) The updated name of the agent.\n        model: (optional) The updated model to be used by the agent.\n        prompt: (optional) The updated prompt of the agent.\n        welcome: (optional) The updated welcome message of the agent.\n        topk: (optional) The updated number of elements to retrieve from the\n                         documents\n        temperature: (optional) The updated temperature of the agent.\n        is_public: (optional) The updated visibility of the agent.\n        pincode: (optional) The updated pincode of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n        payload = {}\n        if name:\n            payload['name'] = name\n        if model:\n            payload['model'] = model\n        if prompt:\n            payload['prompt'] = prompt\n        if welcome:\n            payload['welcome'] = welcome\n        if topk:\n            payload['topk'] = topk\n        if temperature:\n            payload['temperature'] = temperature\n        if is_public:\n            payload['is_public'] = is_public\n        if pincode:\n            payload['pincode'] = pincode\n\n        if not payload:\n            raise ValueError('JUDINI: At least one parameter must be provided')\n        \n        payload = json.dumps(payload)\n\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n\n    def delete_agent(self, agent_id: str) -> None:\n        \"\"\"\n        Deletes an agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to delete.\n        \"\"\"\n\n        response = requests.delete(f\"{self.base_url}/agent/{agent_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent deleted successfully')\n        return\n    \n    def update_agent_documents(self, agent_id: str, document_ids: List[str]) -> None:\n        \"\"\"\n        Updates the documents associated with an agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        document_ids: The IDs of the documents to associate with the agent.\n        \"\"\"\n        payload = json.dumps({ \"agent_documents\": document_ids})\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}/documents\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent documents updated successfully')\n        return \n\n    #################\n    ### DOCUMENTS ###\n    #################\n\n    def get_documents(self) -> List[Document]:\n        \"\"\"\n        Retrieves a list of all the documents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing documents with the\n        following properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/document\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_lists = response.json()\n        return [Document(**document_dict) for document_dict in document_lists]\n    \n    def get_document(self, document_id: str) -> Document:\n        \"\"\"\n        Retrieves a specific document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to retrieve.\n\n        Returns a json object representing the document with the following\n        properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/document/{document_id}\",\n                                headers=self.headers)\n\n        if response.status_code != 200:\n           raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Document(**response.json())\n    \n    def update_document_metadata(self,\n                                 document_id: str,\n                                 title: Optional[str] = None,\n                                 description: Optional[str] = None,\n                                 summary: Optional[str] = None,\n                                 keywords: Optional[str] = None,\n                                 language: Optional[str] = None):\n        \"\"\"\n        Updates the metadata of a document in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to update.\n        title: (optional) The updated title of the document.\n        description: (optional) The updated description of the document.\n        summary: (optional) The updated summary of the document.\n        keywords: (optional) The updated keywords of the document.\n        language: (optional) The updated language of the document.\n\n        \"\"\"\n        document_metadata = (self.get_document(document_id).metadata or\n                             DocumentMetadata())\n        if title:\n            document_metadata.title = title\n        if description:\n            document_metadata.description = description\n        if summary:\n            document_metadata.summary = summary\n        if keywords:\n            document_metadata.keywords = keywords\n        if language:\n            document_metadata.language = language\n\n        payload = json.dumps(document_metadata.model_dump())\n\n        response = requests.patch(f\"{self.base_url}/document/{document_id}/metadata\",\n                                  headers=self.headers,\n                                  data=payload)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print(\"Document metadata updated successfully\")\n        return\n    \n    def _generate_document_metadata(self, file_path: str) -> DocumentMetadata:\n        \"\"\"\n        Generates metadata for a document using the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to generate metadata for.\n\n        Returns\n        -------\n        metadata: A DocumentMetadata object containing the metadata generated\n        by the CodeGPTPlus API.\n        \"\"\"\n\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n\n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document/metadata\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n            \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return DocumentMetadata(**response.json()[\"metadata\"])\n\n    def upload_document(self, file_path: str,\n                        generate_metadata: bool = False) -> Dict[str, str]:\n        \"\"\"\n        Uploads a document to the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to upload.\n        generate_metadata: (optional) Whether to extract metadata from the\n                                      uploaded document.\n\n        Returns\n        -------\n        response_json: A dictionary containing the document ID of the uploaded\n                       document.\n        \"\"\"\n        \n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n        \n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_id = response.json()['documentId']\n        if generate_metadata:\n            try:\n                document_metadata = self._generate_document_metadata(file_path)\n                self.update_document_metadata(document_id,\n                                              **document_metadata.model_dump())\n                return {'id' : document_id}\n            except:\n                print('Failed to generate document metadata.')\n                return {'id' : document_id}\n\n        return {'id' : document_id}\n        \n        \n    def delete_document(self, document_id: str) -> None:\n        \"\"\"\n        Deletes a document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to delete.\n        \"\"\"\n\n        response = requests.delete(f\"{self.base_url}/document/{document_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Document deleted successfully')\n        return",
    "importStatements": [],
    "codeNoBody": "class CodeGPTPlus:\n    def __init__(self,\n                 api_key: Optional[str] = None,\n                 org_id: Optional[str] = None,\n                 base_url: str = base_url):\n        if not api_key:\n            api_key = os.getenv(\"CODEGPT_API_KEY\")\n            if not api_key:\n                raise Exception('JUDINI: API key not found. Please set'\n                                + ' the CODEGPT_API_KEY environment variable'\n                                + ' or pass it as an argument.\\nYou can get'\n                                + ' your API key from: ' + PLAYGROUND_KEYS_URL)\n        self.headers = {\n            'Content-Type': 'application/json',\n            'Channel' : 'SDK_PYTHON',\n            'Authorization': 'Bearer ' + api_key\n        }\n        if not org_id:\n            org_id = os.getenv(\"CODEGPT_ORG_ID\")\n\n        if org_id:\n            self.headers['CodeGPT-Org-Id'] = org_id\n        else:\n            warnings.warn('\\nJUDINI: Org ID not found. This could lead to'\n                          + ' unexpected behavior.\\nYou can get your org ID'\n                          + ' from: ' + PLAYGROUND_KEYS_URL)\n        \n        self.is_streaming = False\n        self.base_url = base_url\n\n\n\n    #######################\n    ### CHAT COMPLETION ###\n    #######################\n        \n    def chat_completion(self, agent_id: str, messages: List[Dict[str, str]], \n               stream: bool = False) -> str:\n        \"\"\"\n        Initiates a chat with the specified agent and handles the streaming of\n        responses.\n\n        Parameters\n        ----------\n\n        agent_id: The ID of the agent to chat with.\n        messages: An array of message objects to be sent to the agent. Each\n                  object should have a `role` (which can be 'system', 'user',\n                  or 'assistant') and `content` which is the actual message.\n        stream: Whether to stream the response or not.\n\n        Example:\n        >>> from judini import CodeGPTPlus\n        >>> codegpt = CodeGPTPlus(api_key, org_id)\n        >>> agent_id = '00000000-0000-0000-0000-000000000000'\n        >>> messages = [{'role': 'user', 'content': 'Hello, World!'}]\n        >>> codegpt.chat_completion(agent_id, messages, stream=True)\n        'Hello, World!'\n        \"\"\"\n        ...\n        \n\n    ##############\n    ### AGENTS ###\n    ##############\n\n    def get_agents(self) -> List[Agent]:\n        \"\"\"\n        Retrieves a list of all the agents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing agents with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                    associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        ...\n    \n    def get_agent(self, agent_id: str) -> Agent:\n        \"\"\"\n        Retrieves a specific agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to retrieve.\n\n        Returns a json object representing the agent with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        ...\n    \n    def create_agent(self,\n                     name: str,\n                     model: str=\"gpt-3.5-turbo\",\n                     prompt: str = \"You are a helpful assistant.\",\n                     welcome: str = \"Hello, how can I help you today?\",\n                     topk: int=3,\n                     temperature: int=0.7,\n                     ) -> Agent:\n        \"\"\"\n        Creates a new agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        name: The name of the agent.\n        model: The model to be used by the agent. For example, 'gpt-3.5-turbo'.\n        prompt: The prompt of the agent.\n        welcome: The welcome message of the agent.\n        topk: The number of elements to retrieve from the documents\n        temperature: The temperature of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        ...\n    \n    def update_agent(self,\n                     agent_id: str,\n                     name: Optional[str] = None,\n                     model: Optional[str] = None,\n                     prompt: Optional[str] = None,\n                     welcome: Optional[str] = None,\n                     topk: Optional[int] = None,\n                     temperature: Optional[int] = None,\n                     is_public: Optional[bool] = None,\n                     pincode: Optional[str] = None\n                     ) -> Agent:\n        \"\"\"\n        Updates an existing agent in the CodeGPTPlus API.\n        Apart from the agent ID, at least one parameter is required.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        name: (optional) The updated name of the agent.\n        model: (optional) The updated model to be used by the agent.\n        prompt: (optional) The updated prompt of the agent.\n        welcome: (optional) The updated welcome message of the agent.\n        topk: (optional) The updated number of elements to retrieve from the\n                         documents\n        temperature: (optional) The updated temperature of the agent.\n        is_public: (optional) The updated visibility of the agent.\n        pincode: (optional) The updated pincode of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        ...\n    \n\n    def delete_agent(self, agent_id: str) -> None:\n        \"\"\"\n        Deletes an agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to delete.\n        \"\"\"\n        ...\n    \n    def update_agent_documents(self, agent_id: str, document_ids: List[str]) -> None:\n        \"\"\"\n        Updates the documents associated with an agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        document_ids: The IDs of the documents to associate with the agent.\n        \"\"\"\n        ... \n\n    #################\n    ### DOCUMENTS ###\n    #################\n\n    def get_documents(self) -> List[Document]:\n        \"\"\"\n        Retrieves a list of all the documents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing documents with the\n        following properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n        ...\n    \n    def get_document(self, document_id: str) -> Document:\n        \"\"\"\n        Retrieves a specific document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to retrieve.\n\n        Returns a json object representing the document with the following\n        properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n        ...\n    \n    def update_document_metadata(self,\n                                 document_id: str,\n                                 title: Optional[str] = None,\n                                 description: Optional[str] = None,\n                                 summary: Optional[str] = None,\n                                 keywords: Optional[str] = None,\n                                 language: Optional[str] = None):\n        \"\"\"\n        Updates the metadata of a document in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to update.\n        title: (optional) The updated title of the document.\n        description: (optional) The updated description of the document.\n        summary: (optional) The updated summary of the document.\n        keywords: (optional) The updated keywords of the document.\n        language: (optional) The updated language of the document.\n\n        \"\"\"\n        ...\n    \n    def _generate_document_metadata(self, file_path: str) -> DocumentMetadata:\n        \"\"\"\n        Generates metadata for a document using the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to generate metadata for.\n\n        Returns\n        -------\n        metadata: A DocumentMetadata object containing the metadata generated\n        by the CodeGPTPlus API.\n        \"\"\"\n        ...\n\n    def upload_document(self, file_path: str,\n                        generate_metadata: bool = False) -> Dict[str, str]:\n        \"\"\"\n        Uploads a document to the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to upload.\n        generate_metadata: (optional) Whether to extract metadata from the\n                                      uploaded document.\n\n        Returns\n        -------\n        response_json: A dictionary containing the document ID of the uploaded\n                       document.\n        \"\"\"\n        ...\n        \n        \n    def delete_document(self, document_id: str) -> None:\n        \"\"\"\n        Deletes a document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to delete.\n        \"\"\"\n        ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::PLAYGROUND_KEYS_URL",
    "language": "python",
    "label": "PLAYGROUND_KEYS_URL",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 17,
    "inDegree": 1,
    "outDegree": 0,
    "code": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
    "importStatements": [],
    "codeNoBody": "PLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys'",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::JUDINI_TUTORIAL",
    "language": "python",
    "label": "JUDINI_TUTORIAL",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 14,
    "inDegree": 14,
    "outDegree": 1,
    "code": "JUDINI_TUTORIAL = f'{base_url}/docs'",
    "importStatements": [],
    "codeNoBody": "JUDINI_TUTORIAL = f'{base_url}/docs'",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt::base_url",
    "language": "python",
    "label": "base_url",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt",
    "totalTokens": 16,
    "inDegree": 5,
    "outDegree": 0,
    "code": "base_url = 'https://api-beta.codegpt.co/api/v1'",
    "importStatements": [],
    "codeNoBody": "base_url = 'https://api-beta.codegpt.co/api/v1'",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\codegpt",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\codegpt.py",
    "type": "file",
    "totalTokens": 4192,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import os\nimport mimetypes\nimport warnings\nimport json\nimport requests\nfrom typing import List, Dict, Literal, Optional\nfrom .utils import handle_non_stream, handle_stream\nfrom .types import Agent, Document, DocumentMetadata\n\nbase_url = 'https://api-beta.codegpt.co/api/v1'\nJUDINI_TUTORIAL = f'{base_url}/docs'\nPLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys' \n\nclass CodeGPTPlus:\n    def __init__(self,\n                 api_key: Optional[str] = None,\n                 org_id: Optional[str] = None,\n                 base_url: str = base_url):\n\n        if not api_key:\n            api_key = os.getenv(\"CODEGPT_API_KEY\")\n            if not api_key:\n                raise Exception('JUDINI: API key not found. Please set'\n                                + ' the CODEGPT_API_KEY environment variable'\n                                + ' or pass it as an argument.\\nYou can get'\n                                + ' your API key from: ' + PLAYGROUND_KEYS_URL)\n        self.headers = {\n            'Content-Type': 'application/json',\n            'Channel' : 'SDK_PYTHON',\n            'Authorization': 'Bearer ' + api_key\n        }\n        if not org_id:\n            org_id = os.getenv(\"CODEGPT_ORG_ID\")\n\n        if org_id:\n            self.headers['CodeGPT-Org-Id'] = org_id\n        else:\n            warnings.warn('\\nJUDINI: Org ID not found. This could lead to'\n                          + ' unexpected behavior.\\nYou can get your org ID'\n                          + ' from: ' + PLAYGROUND_KEYS_URL)\n        \n        self.is_streaming = False\n        self.base_url = base_url\n\n\n\n    #######################\n    ### CHAT COMPLETION ###\n    #######################\n        \n    def chat_completion(self, agent_id: str, messages: List[Dict[str, str]], \n               stream: bool = False) -> str:\n        \"\"\"\n        Initiates a chat with the specified agent and handles the streaming of\n        responses.\n\n        Parameters\n        ----------\n\n        agent_id: The ID of the agent to chat with.\n        messages: An array of message objects to be sent to the agent. Each\n                  object should have a `role` (which can be 'system', 'user',\n                  or 'assistant') and `content` which is the actual message.\n        stream: Whether to stream the response or not.\n\n        Example:\n        >>> from judini import CodeGPTPlus\n        >>> codegpt = CodeGPTPlus(api_key, org_id)\n        >>> agent_id = '00000000-0000-0000-0000-000000000000'\n        >>> messages = [{'role': 'user', 'content': 'Hello, World!'}]\n        >>> codegpt.chat_completion(agent_id, messages, stream=True)\n        'Hello, World!'\n        \"\"\"\n        \n        if len(messages) == 0:\n            raise ValueError('JUDINI: messages array should not be empty')\n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n\n        headers = self.headers.copy()\n        headers['accept'] = 'text/event-stream'\n\n        payload = json.dumps({\n            \"agentId\": agent_id,\n            \"messages\": messages,\n            \"stream\": stream,\n            \"format\": \"text\"\n        })\n\n        response = requests.post(f\"{self.base_url}/chat/completions\",\n                                 headers=headers, data=payload,\n                                 stream=stream)\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        if stream:\n            return handle_stream(response)\n        else:\n            return handle_non_stream(response)\n        \n\n    ##############\n    ### AGENTS ###\n    ##############\n\n    def get_agents(self) -> List[Agent]:\n        \"\"\"\n        Retrieves a list of all the agents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing agents with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                    associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/agent\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        agent_lists = response.json()\n        return [Agent(**agent_dict) for agent_dict in agent_lists]\n    \n    def get_agent(self, agent_id: str) -> Agent:\n        \"\"\"\n        Retrieves a specific agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to retrieve.\n\n        Returns a json object representing the agent with the following\n        properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/agent/{agent_id}?populate=agent_documents\",\n                                 headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    def create_agent(self,\n                     name: str,\n                     model: str=\"gpt-3.5-turbo\",\n                     prompt: str = \"You are a helpful assistant.\",\n                     welcome: str = \"Hello, how can I help you today?\",\n                     topk: int=3,\n                     temperature: int=0.7,\n                     ) -> Agent:\n        \"\"\"\n        Creates a new agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        name: The name of the agent.\n        model: The model to be used by the agent. For example, 'gpt-3.5-turbo'.\n        prompt: The prompt of the agent.\n        welcome: The welcome message of the agent.\n        topk: The number of elements to retrieve from the documents\n        temperature: The temperature of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n\n        payload = json.dumps({\n            \"name\": name,\n            \"model\": model,\n            \"prompt\": prompt,\n            \"welcome\": welcome,\n            \"topk\": topk,\n            \"temperature\": temperature\n        })\n        response = requests.post(f\"{self.base_url}/agent\", headers=self.headers,\n                                 data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n    def update_agent(self,\n                     agent_id: str,\n                     name: Optional[str] = None,\n                     model: Optional[str] = None,\n                     prompt: Optional[str] = None,\n                     welcome: Optional[str] = None,\n                     topk: Optional[int] = None,\n                     temperature: Optional[int] = None,\n                     is_public: Optional[bool] = None,\n                     pincode: Optional[str] = None\n                     ) -> Agent:\n        \"\"\"\n        Updates an existing agent in the CodeGPTPlus API.\n        Apart from the agent ID, at least one parameter is required.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        name: (optional) The updated name of the agent.\n        model: (optional) The updated model to be used by the agent.\n        prompt: (optional) The updated prompt of the agent.\n        welcome: (optional) The updated welcome message of the agent.\n        topk: (optional) The updated number of elements to retrieve from the\n                         documents\n        temperature: (optional) The updated temperature of the agent.\n        is_public: (optional) The updated visibility of the agent.\n        pincode: (optional) The updated pincode of the agent.\n\n         Returns a json object representing the agent with the following\n         properties:\n            id: str = The ID of the agent\n            name: str = The name of the agent\n            prompt: str = The prompt of the agent\n            model: str = The model of the agent\n            agent_documents: Optional[List[str]] = The list of documents\n                                                   associated with the agent\n            welcome: str = The welcome message of the agent\n            pincode: Optional[str] = The pincode of the agent\n            is_public: bool = Whether the agent is public or not\n            agent_type: str = The type of the agent\n        \"\"\"\n        \n        if not agent_id:\n            raise ValueError('JUDINI: agent_id should not be empty')\n        \n        payload = {}\n        if name:\n            payload['name'] = name\n        if model:\n            payload['model'] = model\n        if prompt:\n            payload['prompt'] = prompt\n        if welcome:\n            payload['welcome'] = welcome\n        if topk:\n            payload['topk'] = topk\n        if temperature:\n            payload['temperature'] = temperature\n        if is_public:\n            payload['is_public'] = is_public\n        if pincode:\n            payload['pincode'] = pincode\n\n        if not payload:\n            raise ValueError('JUDINI: At least one parameter must be provided')\n        \n        payload = json.dumps(payload)\n\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Agent(**response.json())\n    \n\n    def delete_agent(self, agent_id: str) -> None:\n        \"\"\"\n        Deletes an agent from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to delete.\n        \"\"\"\n\n        response = requests.delete(f\"{self.base_url}/agent/{agent_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent deleted successfully')\n        return\n    \n    def update_agent_documents(self, agent_id: str, document_ids: List[str]) -> None:\n        \"\"\"\n        Updates the documents associated with an agent in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        agent_id: The ID of the agent to update.\n        document_ids: The IDs of the documents to associate with the agent.\n        \"\"\"\n        payload = json.dumps({ \"agent_documents\": document_ids})\n        response = requests.patch(f\"{self.base_url}/agent/{agent_id}/documents\",\n                                  headers=self.headers,\n                                  data=payload)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Agent documents updated successfully')\n        return \n\n    #################\n    ### DOCUMENTS ###\n    #################\n\n    def get_documents(self) -> List[Document]:\n        \"\"\"\n        Retrieves a list of all the documents from the CodeGPTPlus API.\n\n        Returns an array of json objects representing documents with the\n        following properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/document\", headers=self.headers)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_lists = response.json()\n        return [Document(**document_dict) for document_dict in document_lists]\n    \n    def get_document(self, document_id: str) -> Document:\n        \"\"\"\n        Retrieves a specific document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to retrieve.\n\n        Returns a json object representing the document with the following\n        properties:\n            id: str = The ID of the document\n            user_id: str = The ID of the user who created the document\n            name: str = The name of the document\n            content: str = The content of the document\n            file_type: str = The type of the document\n            metadata: Optional[DocumentMetadata] = The metadata of the document\n            tokens: int = The number of tokens in the document\n            chunks_count: int = The number of chunks the document was split into\n        \"\"\"\n\n        response = requests.get(f\"{self.base_url}/document/{document_id}\",\n                                headers=self.headers)\n\n        if response.status_code != 200:\n           raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return Document(**response.json())\n    \n    def update_document_metadata(self,\n                                 document_id: str,\n                                 title: Optional[str] = None,\n                                 description: Optional[str] = None,\n                                 summary: Optional[str] = None,\n                                 keywords: Optional[str] = None,\n                                 language: Optional[str] = None):\n        \"\"\"\n        Updates the metadata of a document in the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to update.\n        title: (optional) The updated title of the document.\n        description: (optional) The updated description of the document.\n        summary: (optional) The updated summary of the document.\n        keywords: (optional) The updated keywords of the document.\n        language: (optional) The updated language of the document.\n\n        \"\"\"\n        document_metadata = (self.get_document(document_id).metadata or\n                             DocumentMetadata())\n        if title:\n            document_metadata.title = title\n        if description:\n            document_metadata.description = description\n        if summary:\n            document_metadata.summary = summary\n        if keywords:\n            document_metadata.keywords = keywords\n        if language:\n            document_metadata.language = language\n\n        payload = json.dumps(document_metadata.model_dump())\n\n        response = requests.patch(f\"{self.base_url}/document/{document_id}/metadata\",\n                                  headers=self.headers,\n                                  data=payload)\n\n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print(\"Document metadata updated successfully\")\n        return\n    \n    def _generate_document_metadata(self, file_path: str) -> DocumentMetadata:\n        \"\"\"\n        Generates metadata for a document using the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to generate metadata for.\n\n        Returns\n        -------\n        metadata: A DocumentMetadata object containing the metadata generated\n        by the CodeGPTPlus API.\n        \"\"\"\n\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n\n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document/metadata\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n            \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        return DocumentMetadata(**response.json()[\"metadata\"])\n\n    def upload_document(self, file_path: str,\n                        generate_metadata: bool = False) -> Dict[str, str]:\n        \"\"\"\n        Uploads a document to the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        file_path: The path to the file to upload.\n        generate_metadata: (optional) Whether to extract metadata from the\n                                      uploaded document.\n\n        Returns\n        -------\n        response_json: A dictionary containing the document ID of the uploaded\n                       document.\n        \"\"\"\n        \n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f'JUDINI: File not found: {file_path}')\n        \n        file_type = mimetypes.guess_type(file_path)[0]\n        \n        headers = self.headers.copy()\n        del headers['Content-Type']\n        \n        with open(file_path, 'rb') as file:\n            file_tuple = (os.path.basename(file_path), file, file_type)\n            response = requests.post(f\"{self.base_url}/document\",\n                                     headers=headers,\n                                     files={'file': file_tuple})\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        document_id = response.json()['documentId']\n        if generate_metadata:\n            try:\n                document_metadata = self._generate_document_metadata(file_path)\n                self.update_document_metadata(document_id,\n                                              **document_metadata.model_dump())\n                return {'id' : document_id}\n            except:\n                print('Failed to generate document metadata.')\n                return {'id' : document_id}\n\n        return {'id' : document_id}\n        \n        \n    def delete_document(self, document_id: str) -> None:\n        \"\"\"\n        Deletes a document from the CodeGPTPlus API.\n\n        Parameters\n        ----------\n        document_id: The ID of the document to delete.\n        \"\"\"\n\n        response = requests.delete(f\"{self.base_url}/document/{document_id}\",\n                                   headers=self.headers)\n        \n        if response.status_code != 200:\n            raise Exception(f'JUDINI: API Response was: {response.status_code}'\n                            + f' {response.text} {JUDINI_TUTORIAL}')\n        \n        print('Document deleted successfully')\n        return",
    "importStatements": [
      "import os",
      "import mimetypes",
      "import warnings",
      "import json",
      "import requests",
      "from typing import List, Dict, Literal, Optional",
      "from .utils import handle_non_stream, handle_stream",
      "from .types import Agent, Document, DocumentMetadata"
    ],
    "codeNoBody": "import os\nimport mimetypes\nimport warnings\nimport json\nimport requests\nfrom typing import List, Dict, Literal, Optional\nfrom .utils import handle_non_stream, handle_stream\nfrom .types import Agent, Document, DocumentMetadata\nbase_url = 'https://api-beta.codegpt.co/api/v1'\nJUDINI_TUTORIAL = f'{base_url}/docs'\nPLAYGROUND_KEYS_URL = 'https://app.codegpt.co/en/apikeys' \n\nclass CodeGPTPlus:\n    ...",
    "originFile": "\\src\\judini\\codegpt.py"
  },
  {
    "id": "\\src\\judini\\types::Document.json_loads",
    "language": "python",
    "label": "Document.json_loads",
    "type": "method",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\types::Document",
    "totalTokens": 41,
    "inDegree": 1,
    "outDegree": 0,
    "code": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
    "importStatements": [],
    "codeNoBody": "class Document(BaseModel):\n    ...\n    @field_validator(\"metadata\", mode=\"before\")\ndef json_loads(cls, v):\n            ...",
    "originFile": "\\src\\judini\\types.py"
  },
  {
    "id": "\\src\\judini\\types::Document",
    "language": "python",
    "label": "Document",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\types",
    "totalTokens": 179,
    "inDegree": 1,
    "outDegree": 1,
    "code": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
    "importStatements": [],
    "codeNoBody": "class Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        \n        ...",
    "originFile": "\\src\\judini\\types.py"
  },
  {
    "id": "\\src\\judini\\types::DocumentMetadata",
    "language": "python",
    "label": "DocumentMetadata",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\types",
    "totalTokens": 90,
    "inDegree": 1,
    "outDegree": 0,
    "code": "class DocumentMetadata(BaseModel):\n    title: Optional[str] = \"\"\n    \"\"\"The title of the document\"\"\"\n    description: Optional[str] = \"\"\n    \"\"\"The description of the document\"\"\"\n    summary: Optional[str] = \"\"\n    \"\"\"The summary of the document\"\"\"\n    keywords: Optional[str] = \"\"\n    \"\"\"The keywords of the document, separated by commas\"\"\"\n    language: Optional[str] = \"\"\n    \"\"\"The language of the document\"\"\"",
    "importStatements": [],
    "codeNoBody": "class DocumentMetadata(BaseModel):\n    ...",
    "originFile": "\\src\\judini\\types.py"
  },
  {
    "id": "\\src\\judini\\types::Agent",
    "language": "python",
    "label": "Agent",
    "type": "class",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\types",
    "totalTokens": 142,
    "inDegree": 1,
    "outDegree": 0,
    "code": "class Agent(BaseModel):\n    id: str\n    \"\"\"The ID of the agent\"\"\"\n    name: str\n    \"\"\"The name of the agent\"\"\"\n    prompt: str\n    \"\"\"The prompt of the agent\"\"\"\n    model: str\n    \"\"\"The model of the agent\"\"\"\n    agent_documents: Optional[List[str]] = None\n    \"\"\"The list of documents associated with the agent\"\"\"\n    welcome: str\n    \"\"\"The welcome message of the agent\"\"\"\n    pincode: Optional[str] = None\n    \"\"\"The pincode of the agent\"\"\"\n    is_public: bool\n    \"\"\"Whether the agent is public or not\"\"\"\n    agent_type: str\n    \"\"\"The type of the agent\"\"\"",
    "importStatements": [],
    "codeNoBody": "class Agent(BaseModel):\n    ...",
    "originFile": "\\src\\judini\\types.py"
  },
  {
    "id": "\\src\\judini\\types",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\types.py",
    "type": "file",
    "totalTokens": 431,
    "inDegree": 0,
    "outDegree": 3,
    "code": "from pydantic import BaseModel, field_validator\nfrom typing import Optional, List\nimport json\n\nclass Agent(BaseModel):\n    id: str\n    \"\"\"The ID of the agent\"\"\"\n    name: str\n    \"\"\"The name of the agent\"\"\"\n    prompt: str\n    \"\"\"The prompt of the agent\"\"\"\n    model: str\n    \"\"\"The model of the agent\"\"\"\n    agent_documents: Optional[List[str]] = None\n    \"\"\"The list of documents associated with the agent\"\"\"\n    welcome: str\n    \"\"\"The welcome message of the agent\"\"\"\n    pincode: Optional[str] = None\n    \"\"\"The pincode of the agent\"\"\"\n    is_public: bool\n    \"\"\"Whether the agent is public or not\"\"\"\n    agent_type: str\n    \"\"\"The type of the agent\"\"\"\n\nclass DocumentMetadata(BaseModel):\n    title: Optional[str] = \"\"\n    \"\"\"The title of the document\"\"\"\n    description: Optional[str] = \"\"\n    \"\"\"The description of the document\"\"\"\n    summary: Optional[str] = \"\"\n    \"\"\"The summary of the document\"\"\"\n    keywords: Optional[str] = \"\"\n    \"\"\"The keywords of the document, separated by commas\"\"\"\n    language: Optional[str] = \"\"\n    \"\"\"The language of the document\"\"\"\n\n\nclass Document(BaseModel):\n    id: str\n    \"\"\"The ID of the document\"\"\"\n    user_id: str\n    \"\"\"The ID of the user who created the document\"\"\"\n    name: str\n    \"\"\"The name of the document\"\"\"\n    file_type: str\n    \"\"\"The type of the document\"\"\"\n    metadata: Optional[DocumentMetadata] = None\n    \"\"\"The metadata of the document\"\"\"\n    tokens: int\n    \"\"\"The number of tokens in the document\"\"\"\n    chunks_count: Optional[int] = None\n    \"\"\"The number of chunks the document was split into\"\"\"\n    content: Optional[str] = None\n    \"\"\"The content of the document\"\"\"\n\n    @field_validator(\"metadata\", mode=\"before\")\n    def json_loads(cls, v):\n        if v:\n            if isinstance(v, str):\n                return json.loads(v)\n            else:\n                return v",
    "importStatements": [
      "from pydantic import BaseModel, field_validator",
      "from typing import Optional, List",
      "import json"
    ],
    "codeNoBody": "from pydantic import BaseModel, field_validator\nfrom typing import Optional, List\nimport json\nclass Agent(BaseModel):\n    ...\n\nclass DocumentMetadata(BaseModel):\n    ...\n\n\nclass Document(BaseModel):\n    ...",
    "originFile": "\\src\\judini\\types.py"
  },
  {
    "id": "\\src\\judini\\utils::handle_non_stream",
    "language": "python",
    "label": "handle_non_stream",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\utils",
    "totalTokens": 48,
    "inDegree": 1,
    "outDegree": 0,
    "code": "def handle_non_stream(response: requests.Response) -> str:\n    try:\n        text = response.json()\n        return text\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n    finally:\n        response.close()",
    "importStatements": [],
    "codeNoBody": "def handle_non_stream(response: requests.Response) -> str:\n    ...",
    "originFile": "\\src\\judini\\utils.py"
  },
  {
    "id": "\\src\\judini\\utils::handle_stream",
    "language": "python",
    "label": "handle_stream",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\utils",
    "totalTokens": 68,
    "inDegree": 1,
    "outDegree": 0,
    "code": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    try:\n        for chunk in response.iter_content(chunk_size=64, decode_unicode=True):\n            if chunk:\n                yield chunk\n    except Exception as e:\n        print(f\"Error occurred: {e}\", chunk)\n    finally:\n        response.close()",
    "importStatements": [],
    "codeNoBody": "def handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    ...",
    "originFile": "\\src\\judini\\utils.py"
  },
  {
    "id": "\\src\\judini\\utils",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\src\\judini\\utils.py",
    "type": "file",
    "totalTokens": 136,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import json\nfrom typing import List, Dict, Literal, Generator, Any\nimport requests\n\ndef handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    try:\n        for chunk in response.iter_content(chunk_size=64, decode_unicode=True):\n            if chunk:\n                yield chunk\n    except Exception as e:\n        print(f\"Error occurred: {e}\", chunk)\n    finally:\n        response.close()\n\ndef handle_non_stream(response: requests.Response) -> str:\n    try:\n        text = response.json()\n        return text\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n    finally:\n        response.close()\n    ",
    "importStatements": [
      "import json",
      "from typing import List, Dict, Literal, Generator, Any",
      "import requests"
    ],
    "codeNoBody": "import json\nfrom typing import List, Dict, Literal, Generator, Any\nimport requests\ndef handle_stream(response: requests.Response) -> Generator[Any, Any, Any]:\n    ...\n\ndef handle_non_stream(response: requests.Response) -> str:\n    ...",
    "originFile": "\\src\\judini\\utils.py"
  },
  {
    "id": "\\streamlit::completion",
    "language": "python",
    "label": "completion",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\streamlit",
    "totalTokens": 12,
    "inDegree": 1,
    "outDegree": 1,
    "code": "completion = Completion(api_key=CODEGPT_API_KEY)",
    "importStatements": [],
    "codeNoBody": "completion = Completion(api_key=CODEGPT_API_KEY)",
    "originFile": "\\streamlit.py"
  },
  {
    "id": "\\streamlit::enable_stream",
    "language": "python",
    "label": "enable_stream",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\streamlit",
    "totalTokens": 13,
    "inDegree": 1,
    "outDegree": 0,
    "code": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
    "importStatements": [],
    "codeNoBody": "enable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)",
    "originFile": "\\streamlit.py"
  },
  {
    "id": "\\streamlit::AGENT_ID",
    "language": "python",
    "label": "AGENT_ID",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\streamlit",
    "totalTokens": 21,
    "inDegree": 1,
    "outDegree": 0,
    "code": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
    "importStatements": [],
    "codeNoBody": "AGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))",
    "originFile": "\\streamlit.py"
  },
  {
    "id": "\\streamlit::CODEGPT_API_KEY",
    "language": "python",
    "label": "CODEGPT_API_KEY",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\streamlit",
    "totalTokens": 34,
    "inDegree": 2,
    "outDegree": 0,
    "code": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
    "importStatements": [],
    "codeNoBody": "CODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))",
    "originFile": "\\streamlit.py"
  },
  {
    "id": "\\streamlit",
    "language": "python",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\judini-python-main\\judini-python-main\\streamlit.py",
    "type": "file",
    "totalTokens": 461,
    "inDegree": 0,
    "outDegree": 4,
    "code": "from judini.codegpt.chat import Completion\nimport streamlit as st\n\n\nst.set_page_config(page_title=\"CodeGPT Chat\", layout=\"wide\")\nst.title(\"CodeGPT Chat\")\n\nif \"codegpt_api_key\" not in st.session_state:\n    st.session_state[\"openai_api_key\"] = None\n\nif \"agent_id\" not in st.session_state:\n    st.session_state[\"agent_id\"] = None\n\nif \"messages\" not in st.session_state:\n    st.session_state[\"messages\"] = []\n\nCODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))\nif not CODEGPT_API_KEY:\n    st.sidebar.info(\"Please enter your CodeGPT API key.\")\n    st.stop()\nAGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))\nif not AGENT_ID:\n    st.sidebar.info(\"Please enter an Agent ID.\")\n    st.stop()\nenable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)\nif st.sidebar.button(\"Clear message history\"):\n    st.session_state[\"messages\"] = []\n    st.rerun()\n\ncompletion = Completion(api_key=CODEGPT_API_KEY)\n\n\nfor msg in st.session_state[\"messages\"]:\n    st.chat_message(msg[\"role\"]).write(msg[\"content\"])\n\nif user_query := st.chat_input(\"How can I help you?\"):\n    st.chat_message(\"user\").write(user_query)\n\n    with st.chat_message(\"assistant\"):\n        st.session_state[\"messages\"].append({\"role\": \"user\", \"content\": user_query})\n        msgs = st.session_state[\"messages\"]\n        ai_response = \"\"\n        if enable_stream:\n            message_placeholder = st.empty()\n            with st.spinner(\"Wait for it...\"):\n                response = completion.create(AGENT_ID, msgs, stream=True)\n            for chunk in response:\n                ai_response += chunk\n                message_placeholder.markdown(ai_response)\n                \n        else:\n            with st.spinner(\"Wait for it...\"):\n                ai_response = completion.create(AGENT_ID, msgs, stream=False)\n                st.markdown(ai_response)\n        st.session_state[\"messages\"].append({\"role\": \"assistant\", \"content\": ai_response})",
    "importStatements": [
      "from judini.codegpt.chat import Completion",
      "import streamlit as st"
    ],
    "codeNoBody": "from judini.codegpt.chat import Completion\nimport streamlit as st\nst.set_page_config(page_title=\"CodeGPT Chat\", layout=\"wide\")\nst.title(\"CodeGPT Chat\")\n\nif \"codegpt_api_key\" not in st.session_state:\n    st.session_state[\"openai_api_key\"] = None\n\nif \"agent_id\" not in st.session_state:\n    st.session_state[\"agent_id\"] = None\n\nif \"messages\" not in st.session_state:\n    st.session_state[\"messages\"] = []\n\nCODEGPT_API_KEY = st.sidebar.text_input(\"CodeGPT API Key\", type=\"password\", value=st.session_state.get(\"codegpt_api_key\"))\nif not CODEGPT_API_KEY:\n    st.sidebar.info(\"Please enter your CodeGPT API key.\")\n    st.stop()\nAGENT_ID = st.sidebar.text_input(\"Agent ID\", value=st.session_state.get(\"agent_id\"))\nif not AGENT_ID:\n    st.sidebar.info(\"Please enter an Agent ID.\")\n    st.stop()\nenable_stream = st.sidebar.checkbox(\"Enable Stream\", value=True)\nif st.sidebar.button(\"Clear message history\"):\n    st.session_state[\"messages\"] = []\n    st.rerun()\n\ncompletion = Completion(api_key=CODEGPT_API_KEY)\n\n\nfor msg in st.session_state[\"messages\"]:\n    st.chat_message(msg[\"role\"]).write(msg[\"content\"])\n\nif user_query := st.chat_input(\"How can I help you?\"):\n    st.chat_message(\"user\").write(user_query)\n\n    with st.chat_message(\"assistant\"):\n        st.session_state[\"messages\"].append({\"role\": \"user\", \"content\": user_query})\n        msgs = st.session_state[\"messages\"]\n        ai_response = \"\"\n        if enable_stream:\n            message_placeholder = st.empty()\n            with st.spinner(\"Wait for it...\"):\n                response = completion.create(AGENT_ID, msgs, stream=True)\n            for chunk in response:\n                ai_response += chunk\n                message_placeholder.markdown(ai_response)\n                \n        else:\n            with st.spinner(\"Wait for it...\"):\n                ai_response = completion.create(AGENT_ID, msgs, stream=False)\n                st.markdown(ai_response)\n        st.session_state[\"messages\"].append({\"role\": \"assistant\", \"content\": ai_response})",
    "originFile": "\\streamlit.py"
  }
]