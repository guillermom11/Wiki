[
  {
    "id": "\\README",
    "language": "markdown",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\README.md",
    "type": "file",
    "totalTokens": 9,
    "inDegree": 0,
    "outDegree": 0,
    "code": "```\ndeno task dev\n```\n",
    "importStatements": [],
    "codeNoBody": "```\ndeno task dev\n```",
    "originFile": "\\README.md"
  },
  {
    "id": "\\crons\\usage-rds::getCurrentDateFormatted",
    "language": "typescript",
    "label": "getCurrentDateFormatted",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\crons\\usage-rds",
    "totalTokens": 158,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function getCurrentDateFormatted() {\n  const date = new Date()\n\n  const year = date.getUTCFullYear()\n  const month = ('0' + (date.getUTCMonth() + 1)).slice(-2) // Months are 0 based so +1 and pad with leading 0\n  const day = ('0' + date.getUTCDate()).slice(-2) // Pad with leading 0\n\n  // Set time to 00:00:00.000\n  const hours = '00'\n  const minutes = '00'\n  const seconds = '00'\n  const milliseconds = '000'\n\n  const formattedDate =\n    `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}+00`\n\n  return formattedDate\n}",
    "importStatements": [],
    "codeNoBody": "function getCurrentDateFormatted() {\n//...\n}",
    "originFile": "\\crons\\usage-rds.ts"
  },
  {
    "id": "\\crons\\usage-rds",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\crons\\usage-rds.ts",
    "type": "file",
    "totalTokens": 395,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { getEnv } from '@/lib/env.ts'\n\nDeno.cron('Run every day at 3am', '0 3 * * *', async () => {\n  const isDenoDeploy = Deno.env.get('DENO_DEPLOYMENT_ID') !== undefined\n  if (!isDenoDeploy) return\n\n  const date = getCurrentDateFormatted()\n  console.log('Migrating data to AMAZON RDS before', date)\n\n  try {\n    const res = await fetch(`${getEnv('PLAYGROUND_URL')}/api/rds/usage`, {\n      headers: {\n        'Content-Type': 'application/json',\n        'secret-key': getEnv('PLAYGROUND_SECRET_KEY'),\n      },\n    })\n\n    if (!res.ok) {\n      console.log('Error migrating usage to AMAZON RDS before', date)\n      const data = await res.json()\n      console.log('Error =>', data)\n      return\n    }\n\n    const data = await res.json()\n\n    console.log(data)\n    console.log('Data migrated successfully to AMAZON RDS before', date)\n  } catch (error) {\n    console.log(error)\n  }\n})\n\nfunction getCurrentDateFormatted() {\n  const date = new Date()\n\n  const year = date.getUTCFullYear()\n  const month = ('0' + (date.getUTCMonth() + 1)).slice(-2) // Months are 0 based so +1 and pad with leading 0\n  const day = ('0' + date.getUTCDate()).slice(-2) // Pad with leading 0\n\n  // Set time to 00:00:00.000\n  const hours = '00'\n  const minutes = '00'\n  const seconds = '00'\n  const milliseconds = '000'\n\n  const formattedDate =\n    `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}+00`\n\n  return formattedDate\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nDeno.cron('Run every day at 3am', '0 3 * * *', async () => {\n  const isDenoDeploy = Deno.env.get('DENO_DEPLOYMENT_ID') !== undefined\n  if (!isDenoDeploy) return\n\n  const date = getCurrentDateFormatted()\n  console.log('Migrating data to AMAZON RDS before', date)\n\n  try {\n    const res = await fetch(`${getEnv('PLAYGROUND_URL')}/api/rds/usage`, {\n      headers: {\n        'Content-Type': 'application/json',\n        'secret-key': getEnv('PLAYGROUND_SECRET_KEY'),\n      },\n    })\n\n    if (!res.ok) {\n      console.log('Error migrating usage to AMAZON RDS before', date)\n      const data = await res.json()\n      console.log('Error =>', data)\n      return\n    }\n\n    const data = await res.json()\n\n    console.log(data)\n    console.log('Data migrated successfully to AMAZON RDS before', date)\n  } catch (error) {\n    console.log(error)\n  }\n})\n\nfunction getCurrentDateFormatted() {\n//...\n}",
    "originFile": "\\crons\\usage-rds.ts"
  },
  {
    "id": "\\gen-env::envExample",
    "language": "typescript",
    "label": "envExample",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env",
    "totalTokens": 5,
    "inDegree": 2,
    "outDegree": 0,
    "code": "let envExample = ''",
    "importStatements": [],
    "codeNoBody": "let envExample = ''",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\gen-env::envText",
    "language": "typescript",
    "label": "envText",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env",
    "totalTokens": 10,
    "inDegree": 2,
    "outDegree": 0,
    "code": "let envText = `export interface Env {`",
    "importStatements": [],
    "codeNoBody": "let envText = `export interface Env {`",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\gen-env::keys",
    "language": "typescript",
    "label": "keys",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env",
    "totalTokens": 42,
    "inDegree": 1,
    "outDegree": 1,
    "code": "const keys = envs\n  .map((env) => env.split('=')[0].trim())\n  .filter((val) => {\n    return !val.startsWith('#') &&\n      val\n  })",
    "importStatements": [],
    "codeNoBody": "const keys = envs\n  .map((env) => env.split('=')[0].trim())\n  .filter((val) => {\n    return !val.startsWith('#') &&\n      val\n  })",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\gen-env::envs",
    "language": "typescript",
    "label": "envs",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env",
    "totalTokens": 10,
    "inDegree": 2,
    "outDegree": 1,
    "code": "const envs = file.split('\"\\n')",
    "importStatements": [],
    "codeNoBody": "const envs = file.split('\"\\n')",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\gen-env::file",
    "language": "typescript",
    "label": "file",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const file = await Deno.readTextFile('./.env')",
    "importStatements": [],
    "codeNoBody": "const file = await Deno.readTextFile('./.env')",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\gen-env",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\gen-env.ts",
    "type": "file",
    "totalTokens": 158,
    "inDegree": 0,
    "outDegree": 7,
    "code": "const file = await Deno.readTextFile('./.env')\nconst envs = file.split('\"\\n')\n\nconst keys = envs\n  .map((env) => env.split('=')[0].trim())\n  .filter((val) => {\n    return !val.startsWith('#') &&\n      val\n  })\n\nlet envText = `export interface Env {`\nlet envExample = ''\n\nfor (const key of keys) {\n  envText += `\\n  ${key}: string`\n  envExample += `${key}=\"\"\\n`\n}\n\nenvText += `\\n}`\n\nawait Promise.all([\n  Deno.writeFile('./types/env.ts', new TextEncoder().encode(envText)),\n  Deno.writeFile('./.env.example', new TextEncoder().encode(envExample)),\n])\n",
    "importStatements": [],
    "codeNoBody": "const file = await Deno.readTextFile('./.env')\nconst envs = file.split('\"\\n')\nconst keys = envs\n  .map((env) => env.split('=')[0].trim())\n  .filter((val) => {\n    return !val.startsWith('#') &&\n      val\n  })\n\nlet envText = `export interface Env {`\nlet envExample = ''\n\nfor (const key of keys) {\n  envText += `\\n  ${key}: string`\n  envExample += `${key}=\"\"\\n`\n}\n\nenvText += `\\n}`\n\nawait Promise.all([\n  Deno.writeFile('./types/env.ts', new TextEncoder().encode(envText)),\n  Deno.writeFile('./.env.example', new TextEncoder().encode(envExample)),\n])",
    "originFile": "\\gen-env.ts"
  },
  {
    "id": "\\lib\\ai\\metadata::generateMetadata",
    "language": "typescript",
    "label": "generateMetadata",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\metadata",
    "totalTokens": 188,
    "inDegree": 3,
    "outDegree": 3,
    "code": "async function generateMetadata(content: string) {\n  if (!content) {\n    throw new Error('Missing content')\n  }\n\n  const model = 'gpt-3.5-turbo'\n\n  const options: [string, ChatRequestMessage[], GetChatCompletionsOptions] = [\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].model,\n    [{ role: 'user', content: content.slice(0, 1024) }],\n    {\n      tools: [\n        {\n          type: 'function',\n          function: extractionFunctionSchema,\n        },\n      ],\n    },\n  ]\n  const response = await openaiClient().getChatCompletions(\n    ...options,\n  )\n  const result = response.choices[0].message\n\n  if (!result) {\n    throw new Error('No result')\n  }\n  return JSON.parse(result.toolCalls[0].function.arguments)\n}",
    "importStatements": [],
    "codeNoBody": "async function generateMetadata(content: string) {\n       //...\n       }",
    "originFile": "\\lib\\ai\\metadata.ts"
  },
  {
    "id": "\\lib\\ai\\metadata",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\metadata.ts",
    "type": "file",
    "totalTokens": 271,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { openaiClient } from '@/services/ai/azure/index.ts'\nimport {\n  ChatRequestMessage,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\nimport { extractionFunctionSchema } from '@/schemas/metadata.ts'\n\nexport async function generateMetadata(content: string) {\n  if (!content) {\n    throw new Error('Missing content')\n  }\n\n  const model = 'gpt-3.5-turbo'\n\n  const options: [string, ChatRequestMessage[], GetChatCompletionsOptions] = [\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].model,\n    [{ role: 'user', content: content.slice(0, 1024) }],\n    {\n      tools: [\n        {\n          type: 'function',\n          function: extractionFunctionSchema,\n        },\n      ],\n    },\n  ]\n  const response = await openaiClient().getChatCompletions(\n    ...options,\n  )\n  const result = response.choices[0].message\n\n  if (!result) {\n    throw new Error('No result')\n  }\n  return JSON.parse(result.toolCalls[0].function.arguments)\n}\n",
    "importStatements": [
      "import { openaiClient } from '@/services/ai/azure/index.ts'",
      "import {\n  ChatRequestMessage,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'",
      "import { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'",
      "import { extractionFunctionSchema } from '@/schemas/metadata.ts'"
    ],
    "codeNoBody": "import { openaiClient } from '@/services/ai/azure/index.ts'\nimport {\n  ChatRequestMessage,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\nimport { extractionFunctionSchema } from '@/schemas/metadata.ts'\nexport async function generateMetadata(content: string) {\n       //...\n       }",
    "originFile": "\\lib\\ai\\metadata.ts"
  },
  {
    "id": "\\lib\\ai\\question-generator::anthropicFunction",
    "language": "typescript",
    "label": "anthropicFunction",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\question-generator::questionGenerator",
    "totalTokens": 173,
    "inDegree": 2,
    "outDegree": 1,
    "code": "const anthropicFunction = async () => {\n    const model = new ChatAnthropic({\n      anthropicApiKey: getEnv('ANTHROPIC_API_KEY'),\n      temperature: 0,\n      modelName: 'claude-2',\n      maxTokensToSample: 32,\n      streaming: false,\n      verbose: false,\n      stopSequences: ['\\n\\nHuman:'],\n    })\n\n    // Inspired on the 'User Message'. If the User Message has no related to the Content, suggest a better question related to the Content.\n    // The Search Query Question must to be relevant, concise and precise.\n\n    const search = await model.invoke(anthropicPrompt)\n\n    console.log('\\nAuto Generated Search Query Question:\\n', search.content)\n    if (search.content === ' Q:') return ''\n\n    return search.content as string\n  }",
    "importStatements": [],
    "codeNoBody": "const anthropicFunction = async () => {\n  //...\n  }",
    "originFile": "\\lib\\ai\\question-generator.ts"
  },
  {
    "id": "\\lib\\ai\\question-generator::questionGenerator",
    "language": "typescript",
    "label": "questionGenerator",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\question-generator",
    "totalTokens": 1657,
    "inDegree": 1,
    "outDegree": 3,
    "code": "function questionGenerator(\n  message: string,\n  documents?: ({\n    title: string | null\n    description: string | null\n    summary: string | null\n  } | null)[],\n) {\n  /*\n  title.forEach((t: any, index: number) => {\n    const d = description[index]\n    const s = summary[index]\n    document.concat(`\n      Document ${index}:\n        Title: ${t as string}\n        Description: ${d as string}\n        Summary: ${s as string}\n    `)\n  })\n\n  if (documentsRow.length === 1) {\n    const metadata = documentsRow[0].metadata as string\n    const tokens = documentsRow[0]?.tokens ?? 0\n    return { metadata: JSON.parse(metadata), tokens }\n  }\n\n\n  const DocumentsMetadata = {\n    title: meta.map((item, index) => `\"Document ${index + 1} – ${item.title.slice(0,80) as string}\"`).join('\\n'),\n    description: meta.map((item, index) => `\"Document ${index + 1} - ${item.description.slice(0,140) as string}\"`).join('\\n'),\n    summary: meta.map((item, index) => `\"Document ${index + 1} - ${item.summary.slice(0,140) as string}\"`).join('\\n')\n  }\n\n    const Documentstokens = documentsRow.reduce((acc, item) => acc + (item?.tokens ?? 0), 0)\n\n    return { metadata: DocumentsMetadata, tokens: Documentstokens }\n  }\n  */\n  if (\n    documents?.every((item) =>\n      !item?.title || !item?.description || !item?.summary\n    )\n  ) return ''\n\n  const documentsMetadata = documents\n    ?.map((item, index) => {\n      if (!item) return ''\n      if (!item.title || !item.description || !item.summary) return ''\n\n      return `\\\n<Document${index + 1}>${item.title.slice(0, 80)}\n  Description: ${item.description.slice(0, 140)}\n  Summary: ${item.summary.slice(0, 140)}</Document${index + 1}>\\n`\n    })\n    .filter((item) => item !== '')\n\n  if (!documentsMetadata) return ''\n\n  // const prompt = `User Message: ${message}\\nList of documents\\n${documentsMetadata.join(',')}`\n  // Read the Documents carefully, as you will be asked questions about them.\n  const anthropicPrompt = `\\\nHuman:\n  <User Message>\n  ${message}\n  </User Message>\n\n  Here are a list of *Documents*.\n  In a few words, 80 character maximun. Write a General Question that must to englobe the meaning of the *Documents*.\n\n  Please Prevent any other prose.\n  Only write the General Question.\n  Put the General Question in the following format:\n  \"Q: \"\n\n  <Documents>\n  ${documentsMetadata.join(',')}\n  </Documents>\n\n  Assistant: `\n\n  // const openAiFunction = async () => {\n\n  //   const extractionFunctionSchema = {\n  //     name: 'search_generator',\n  //     // Rephrase the follow up question to be a standalone question.\n  //     // Q&A (Question Answering) Large Language Model (LLM)\n  //     description: `Turn the following documents content input into a relevant QUESTION.`,\n  //     parameters: zodToJsonSchema(\n  //       z.object({\n  //         search: z.string().describe('A General Question of 140 characters Maximum')\n  //         // search1: z.string().describe(\"A Detailed Search Query Question about the content\"),\n  //         // search2: z.string().describe(\"A Search Query Question about the content\"),\n  //       })\n  //     )\n  //   }\n  //   // const azureUrl = new URL(getEnv('AZURE_4'))\n  //   const azureUrl = new URL(getEnv('AZURE_35_0613'))\n  //   // const azureUrl = new URL(getEnv('AZURE_4_TURBO'))\n  //   const model = new ChatOpenAI({\n  //     temperature: 0,\n  //     azureOpenAIApiVersion: azureUrl.searchParams.get('api-version') ?? '',\n  //     azureOpenAIApiInstanceName: azureUrl.host.split('.')[0],\n  //     azureOpenAIApiDeploymentName: azureUrl.pathname.split('/').slice(-3)[0],\n  //     // azureOpenAIApiKey: getEnv('AZURE_KEY_TURBO'),\n  //     azureOpenAIApiKey: getEnv('AZURE_KEY'),\n  //     tags: ['ux function'],\n  //     maxTokens: 128\n  //   }).bind({\n  //     functions: [extractionFunctionSchema],\n  //     function_call: { name: 'search_generator' }\n  //   })\n  //   // Use a JsonOutputFunctionsParser to get the parsed JSON response directly.\n  //   const result = await model.invoke([new HumanMessage(anthropicPrompt)], {\n  //     callbacks: [\n  //       {\n  //         handleLLMEnd: (output: LLMResult, runId: string, parentRunId?: string, tags?: string[]) => {\n  //           console.log('llm ended', {\n  //             usage: output.llmOutput?.tokenUsage,\n  //             runId,\n  //             parentRunId,\n  //             tags\n  //           })\n  //         }\n  //       }\n  //     ]\n  //   })\n  //   if (!result) {\n  //     return null\n  //   }\n  //   // console.log('result', result)\n  //   const search = JSON.parse(result.lc_kwargs.additional_kwargs.function_call.arguments).search\n\n  //   console.log('Auto Generated Search Query Question:\\n', search)\n\n  //   return search\n  // }\n\n  // const hfFunction = async () => {\n  //   const model = new HuggingFaceInference({\n  //     // model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n  //     model: 'mistralai/Mistral-7B-Instruct-v0.1',\n  //     apiKey: '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',\n  //     maxTokens: 32,\n  //     temperature: 0.01\n  //   })\n\n  //   const res = await model.call(\n  //     `<s> [INST] ${document} [/INST] Only content subject Related Question: Model answer\\n</s> [INST] Inspired on the 'User Message' Generate in a maximun 5 words ONE Detailed Search Question ONLY ABOUT the the Content\\nQuestion: [/INST]`\n  //   )\n  //   console.log('HF', res)\n  //   return res\n  // }\n\n  const anthropicFunction = async () => {\n    const model = new ChatAnthropic({\n      anthropicApiKey: getEnv('ANTHROPIC_API_KEY'),\n      temperature: 0,\n      modelName: 'claude-2',\n      maxTokensToSample: 32,\n      streaming: false,\n      verbose: false,\n      stopSequences: ['\\n\\nHuman:'],\n    })\n\n    // Inspired on the 'User Message'. If the User Message has no related to the Content, suggest a better question related to the Content.\n    // The Search Query Question must to be relevant, concise and precise.\n\n    const search = await model.invoke(anthropicPrompt)\n\n    console.log('\\nAuto Generated Search Query Question:\\n', search.content)\n    if (search.content === ' Q:') return ''\n\n    return search.content as string\n  }\n\n  // return await openAiFunction()\n  return anthropicFunction()\n  // return await hfFunction()\n}",
    "importStatements": [],
    "codeNoBody": "function questionGenerator(\n  message: string,\n  documents?: ({\n    title: string | null\n    description: string | null\n    summary: string | null\n  } | null)[],\n) {\n  /*\n  title.forEach((t: any, index: number) => {\n    const d = description[index]\n    const s = summary[index]\n    document.concat(`\n      Document ${index}:\n        Title: ${t as string}\n        Description: ${d as string}\n        Summary: ${s as string}\n    `)\n  })\n  if (documentsRow.length === 1) {\n    const metadata = documentsRow[0].metadata as string\n    const tokens = documentsRow[0]?.tokens ?? 0\n    return { metadata: JSON.parse(metadata), tokens }\n  }\n\n\n  const DocumentsMetadata = {\n    title: meta.map((item, index) => `\"Document ${index + 1} – ${item.title.slice(0,80) as string}\"`).join('\\n'),\n    description: meta.map((item, index) => `\"Document ${index + 1} - ${item.description.slice(0,140) as string}\"`).join('\\n'),\n    summary: meta.map((item, index) => `\"Document ${index + 1} - ${item.summary.slice(0,140) as string}\"`).join('\\n')\n  }\n\n    const Documentstokens = documentsRow.reduce((acc, item) => acc + (item?.tokens ?? 0), 0)\n\n    return { metadata: DocumentsMetadata, tokens: Documentstokens }\n  }\n  */\n  if (\n    documents?.every((item) =>\n      !item?.title || !item?.description || !item?.summary\n    )\n  ) return ''\n\n  const documentsMetadata = documents\n    ?.map((item, index) => {\n      if (!item) return ''\n      if (!item.title || !item.description || !item.summary) return ''\n\n      return `\\\n<Document${index + 1}>${item.title.slice(0, 80)}\n  Description: ${item.description.slice(0, 140)}\n  Summary: ${item.summary.slice(0, 140)}</Document${index + 1}>\\n`\n    })\n    .filter((item) => item !== '')\n\n  if (!documentsMetadata) return ''\n\n  // const prompt = `User Message: ${message}\\nList of documents\\n${documentsMetadata.join(',')}`\n  // Read the Documents carefully, as you will be asked questions about them.\n  const anthropicPrompt = `\\\nHuman:\n  <User Message>\n  ${message}\n  </User Message>\n\n  Here are a list of *Documents*.\n  In a few words, 80 character maximun. Write a General Question that must to englobe the meaning of the *Documents*.\n\n  Please Prevent any other prose.\n  Only write the General Question.\n  Put the General Question in the following format:\n  \"Q: \"\n\n  <Documents>\n  ${documentsMetadata.join(',')}\n  </Documents>\n\n  Assistant: `\n\n  // const openAiFunction = async () => {\n\n  //   const extractionFunctionSchema = {\n  //     name: 'search_generator',\n  //     // Rephrase the follow up question to be a standalone question.\n  //     // Q&A (Question Answering) Large Language Model (LLM)\n  //     description: `Turn the following documents content input into a relevant QUESTION.`,\n  //     parameters: zodToJsonSchema(\n  //       z.object({\n  //         search: z.string().describe('A General Question of 140 characters Maximum')\n  //         // search1: z.string().describe(\"A Detailed Search Query Question about the content\"),\n  //         // search2: z.string().describe(\"A Search Query Question about the content\"),\n  //       })\n  //     )\n  //   }\n  //   // const azureUrl = new URL(getEnv('AZURE_4'))\n  //   const azureUrl = new URL(getEnv('AZURE_35_0613'))\n  //   // const azureUrl = new URL(getEnv('AZURE_4_TURBO'))\n  //   const model = new ChatOpenAI({\n  //     temperature: 0,\n  //     azureOpenAIApiVersion: azureUrl.searchParams.get('api-version') ?? '',\n  //     azureOpenAIApiInstanceName: azureUrl.host.split('.')[0],\n  //     azureOpenAIApiDeploymentName: azureUrl.pathname.split('/').slice(-3)[0],\n  //     // azureOpenAIApiKey: getEnv('AZURE_KEY_TURBO'),\n  //     azureOpenAIApiKey: getEnv('AZURE_KEY'),\n  //     tags: ['ux function'],\n  //     maxTokens: 128\n  //   }).bind({\n  //     functions: [extractionFunctionSchema],\n  //     function_call: { name: 'search_generator' }\n  //   })\n  //   // Use a JsonOutputFunctionsParser to get the parsed JSON response directly.\n  //   const result = await model.invoke([new HumanMessage(anthropicPrompt)], {\n  //     callbacks: [\n  //       {\n  //         handleLLMEnd: (output: LLMResult, runId: string, parentRunId?: string, tags?: string[]) => {\n  //           console.log('llm ended', {\n  //             usage: output.llmOutput?.tokenUsage,\n  //             runId,\n  //             parentRunId,\n  //             tags\n  //           })\n  //         }\n  //       }\n  //     ]\n  //   })\n  //   if (!result) {\n  //     return null\n  //   }\n  //   // console.log('result', result)\n  //   const search = JSON.parse(result.lc_kwargs.additional_kwargs.function_call.arguments).search\n\n  //   console.log('Auto Generated Search Query Question:\\n', search)\n\n  //   return search\n  // }\n\n  // const hfFunction = async () => {\n  //   const model = new HuggingFaceInference({\n  //     // model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n  //     model: 'mistralai/Mistral-7B-Instruct-v0.1',\n  //     apiKey: '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',\n  //     maxTokens: 32,\n  //     temperature: 0.01\n  //   })\n\n  //   const res = await model.call(\n  //     `<s> [INST] ${document} [/INST] Only content subject Related Question: Model answer\\n</s> [INST] Inspired on the 'User Message' Generate in a maximun 5 words ONE Detailed Search Question ONLY ABOUT the the Content\\nQuestion: [/INST]`\n  //   )\n  //   console.log('HF', res)\n  //   return res\n  // }\n\n  const anthropicFunction = async () => {\n    const model = new ChatAnthropic({\n      anthropicApiKey: getEnv('ANTHROPIC_API_KEY'),\n      temperature: 0,\n      modelName: 'claude-2',\n      maxTokensToSample: 32,\n      streaming: false,\n      verbose: false,\n      stopSequences: ['\\n\\nHuman:'],\n    })\n\n    // Inspired on the 'User Message'. If the User Message has no related to the Content, suggest a better question related to the Content.\n    // The Search Query Question must to be relevant, concise and precise.\n\n    const search = await model.invoke(anthropicPrompt)\n\n    console.log('\\nAuto Generated Search Query Question:\\n', search.content)\n    if (search.content === ' Q:') return ''\n\n    return search.content as string\n  }\n\n  // return await openAiFunction()\n  return anthropicFunction()\n  // return await hfFunction()\n}",
    "originFile": "\\lib\\ai\\question-generator.ts"
  },
  {
    "id": "\\lib\\ai\\question-generator::runtime",
    "language": "typescript",
    "label": "runtime",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\question-generator",
    "totalTokens": 7,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const runtime = 'edge'",
    "importStatements": [],
    "codeNoBody": "export const runtime = 'edge'",
    "originFile": "\\lib\\ai\\question-generator.ts"
  },
  {
    "id": "\\lib\\ai\\question-generator",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ai\\question-generator.ts",
    "type": "file",
    "totalTokens": 1690,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import { getEnv } from '@/lib/env.ts'\nimport { ChatAnthropic } from '@langchain/anthropic'\n\nexport const runtime = 'edge'\n\nexport function questionGenerator(\n  message: string,\n  documents?: ({\n    title: string | null\n    description: string | null\n    summary: string | null\n  } | null)[],\n) {\n  /*\n  title.forEach((t: any, index: number) => {\n    const d = description[index]\n    const s = summary[index]\n    document.concat(`\n      Document ${index}:\n        Title: ${t as string}\n        Description: ${d as string}\n        Summary: ${s as string}\n    `)\n  })\n\n  if (documentsRow.length === 1) {\n    const metadata = documentsRow[0].metadata as string\n    const tokens = documentsRow[0]?.tokens ?? 0\n    return { metadata: JSON.parse(metadata), tokens }\n  }\n\n\n  const DocumentsMetadata = {\n    title: meta.map((item, index) => `\"Document ${index + 1} – ${item.title.slice(0,80) as string}\"`).join('\\n'),\n    description: meta.map((item, index) => `\"Document ${index + 1} - ${item.description.slice(0,140) as string}\"`).join('\\n'),\n    summary: meta.map((item, index) => `\"Document ${index + 1} - ${item.summary.slice(0,140) as string}\"`).join('\\n')\n  }\n\n    const Documentstokens = documentsRow.reduce((acc, item) => acc + (item?.tokens ?? 0), 0)\n\n    return { metadata: DocumentsMetadata, tokens: Documentstokens }\n  }\n  */\n  if (\n    documents?.every((item) =>\n      !item?.title || !item?.description || !item?.summary\n    )\n  ) return ''\n\n  const documentsMetadata = documents\n    ?.map((item, index) => {\n      if (!item) return ''\n      if (!item.title || !item.description || !item.summary) return ''\n\n      return `\\\n<Document${index + 1}>${item.title.slice(0, 80)}\n  Description: ${item.description.slice(0, 140)}\n  Summary: ${item.summary.slice(0, 140)}</Document${index + 1}>\\n`\n    })\n    .filter((item) => item !== '')\n\n  if (!documentsMetadata) return ''\n\n  // const prompt = `User Message: ${message}\\nList of documents\\n${documentsMetadata.join(',')}`\n  // Read the Documents carefully, as you will be asked questions about them.\n  const anthropicPrompt = `\\\nHuman:\n  <User Message>\n  ${message}\n  </User Message>\n\n  Here are a list of *Documents*.\n  In a few words, 80 character maximun. Write a General Question that must to englobe the meaning of the *Documents*.\n\n  Please Prevent any other prose.\n  Only write the General Question.\n  Put the General Question in the following format:\n  \"Q: \"\n\n  <Documents>\n  ${documentsMetadata.join(',')}\n  </Documents>\n\n  Assistant: `\n\n  // const openAiFunction = async () => {\n\n  //   const extractionFunctionSchema = {\n  //     name: 'search_generator',\n  //     // Rephrase the follow up question to be a standalone question.\n  //     // Q&A (Question Answering) Large Language Model (LLM)\n  //     description: `Turn the following documents content input into a relevant QUESTION.`,\n  //     parameters: zodToJsonSchema(\n  //       z.object({\n  //         search: z.string().describe('A General Question of 140 characters Maximum')\n  //         // search1: z.string().describe(\"A Detailed Search Query Question about the content\"),\n  //         // search2: z.string().describe(\"A Search Query Question about the content\"),\n  //       })\n  //     )\n  //   }\n  //   // const azureUrl = new URL(getEnv('AZURE_4'))\n  //   const azureUrl = new URL(getEnv('AZURE_35_0613'))\n  //   // const azureUrl = new URL(getEnv('AZURE_4_TURBO'))\n  //   const model = new ChatOpenAI({\n  //     temperature: 0,\n  //     azureOpenAIApiVersion: azureUrl.searchParams.get('api-version') ?? '',\n  //     azureOpenAIApiInstanceName: azureUrl.host.split('.')[0],\n  //     azureOpenAIApiDeploymentName: azureUrl.pathname.split('/').slice(-3)[0],\n  //     // azureOpenAIApiKey: getEnv('AZURE_KEY_TURBO'),\n  //     azureOpenAIApiKey: getEnv('AZURE_KEY'),\n  //     tags: ['ux function'],\n  //     maxTokens: 128\n  //   }).bind({\n  //     functions: [extractionFunctionSchema],\n  //     function_call: { name: 'search_generator' }\n  //   })\n  //   // Use a JsonOutputFunctionsParser to get the parsed JSON response directly.\n  //   const result = await model.invoke([new HumanMessage(anthropicPrompt)], {\n  //     callbacks: [\n  //       {\n  //         handleLLMEnd: (output: LLMResult, runId: string, parentRunId?: string, tags?: string[]) => {\n  //           console.log('llm ended', {\n  //             usage: output.llmOutput?.tokenUsage,\n  //             runId,\n  //             parentRunId,\n  //             tags\n  //           })\n  //         }\n  //       }\n  //     ]\n  //   })\n  //   if (!result) {\n  //     return null\n  //   }\n  //   // console.log('result', result)\n  //   const search = JSON.parse(result.lc_kwargs.additional_kwargs.function_call.arguments).search\n\n  //   console.log('Auto Generated Search Query Question:\\n', search)\n\n  //   return search\n  // }\n\n  // const hfFunction = async () => {\n  //   const model = new HuggingFaceInference({\n  //     // model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n  //     model: 'mistralai/Mistral-7B-Instruct-v0.1',\n  //     apiKey: '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',\n  //     maxTokens: 32,\n  //     temperature: 0.01\n  //   })\n\n  //   const res = await model.call(\n  //     `<s> [INST] ${document} [/INST] Only content subject Related Question: Model answer\\n</s> [INST] Inspired on the 'User Message' Generate in a maximun 5 words ONE Detailed Search Question ONLY ABOUT the the Content\\nQuestion: [/INST]`\n  //   )\n  //   console.log('HF', res)\n  //   return res\n  // }\n\n  const anthropicFunction = async () => {\n    const model = new ChatAnthropic({\n      anthropicApiKey: getEnv('ANTHROPIC_API_KEY'),\n      temperature: 0,\n      modelName: 'claude-2',\n      maxTokensToSample: 32,\n      streaming: false,\n      verbose: false,\n      stopSequences: ['\\n\\nHuman:'],\n    })\n\n    // Inspired on the 'User Message'. If the User Message has no related to the Content, suggest a better question related to the Content.\n    // The Search Query Question must to be relevant, concise and precise.\n\n    const search = await model.invoke(anthropicPrompt)\n\n    console.log('\\nAuto Generated Search Query Question:\\n', search.content)\n    if (search.content === ' Q:') return ''\n\n    return search.content as string\n  }\n\n  // return await openAiFunction()\n  return anthropicFunction()\n  // return await hfFunction()\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { ChatAnthropic } from '@langchain/anthropic'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nimport { ChatAnthropic } from '@langchain/anthropic'\nexport const runtime = 'edge'\n\nexport function questionGenerator(\n  message: string,\n  documents?: ({\n    title: string | null\n    description: string | null\n    summary: string | null\n  } | null)[],\n) {\n       //...\n       }",
    "originFile": "\\lib\\ai\\question-generator.ts"
  },
  {
    "id": "\\lib\\bugsnag::reportError",
    "language": "typescript",
    "label": "reportError",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\bugsnag",
    "totalTokens": 325,
    "inDegree": 21,
    "outDegree": 2,
    "code": "function reportError(error: any, userId?: string, userEmail?: string) {\n  const apiKey = getEnv('BUGSNAG_APIKEY')\n\n  if (!apiKey) return\n\n  const bg = Bugsnag as unknown as Bugsnag\n\n  if (!bg.isStarted()) {\n    bg.start({\n      apiKey,\n      plugins: [],\n      autoTrackSessions: true,\n      collectUserIp: false,\n      enabledBreadcrumbTypes: ['error', 'log', 'request', 'state'],\n      maxBreadcrumbs: 3,\n    })\n  }\n\n  try {\n    bg.notify(error, (event) => {\n      if (!!userId || !!userEmail) {\n        event.setUser(userId, userEmail)\n      }\n    })\n    console.log('Error reported to bugsnag')\n  } catch (error) {\n    console.log(error)\n  }\n\n  // TODO: Preguntar si se va a cambiar el hook de make\n\n  // if (process.env.NODE_ENV === 'production') {\n  //   fetch('https://hook.us1.make.com/1b3sfpccrkqbd8ozum57uilncq9556o1', {\n  //     method: 'POST',\n  //     body: JSON.stringify({\n  //       error: error?.message ?? error,\n  //       stack: error?.stack ?? '',\n  //       cause: error?.cause ?? '',\n  //       name: error?.name ?? '',\n  //       userId,\n  //       userEmail\n  //     })\n  //   }).catch((err) => console.error(err))\n  // }\n}",
    "importStatements": [],
    "codeNoBody": "function reportError(error: any, userId?: string, userEmail?: string) {\n       //...\n       }",
    "originFile": "\\lib\\bugsnag.ts"
  },
  {
    "id": "\\lib\\bugsnag::Bugsnag",
    "language": "typescript",
    "label": "Bugsnag",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\bugsnag",
    "totalTokens": 38,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Bugsnag {\n  notify(error: any, cb: (event: any) => void): void\n  start(options: any): void\n  isStarted(): boolean\n}",
    "importStatements": [],
    "codeNoBody": "interface Bugsnag {\n//...\n}",
    "originFile": "\\lib\\bugsnag.ts"
  },
  {
    "id": "\\lib\\bugsnag",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\bugsnag.ts",
    "type": "file",
    "totalTokens": 402,
    "inDegree": 0,
    "outDegree": 3,
    "code": "// deno-lint-ignore-file\nimport { getEnv } from '@/lib/env.ts'\nimport Bugsnag from 'npm:@bugsnag/js@7.22.4'\n\ninterface Bugsnag {\n  notify(error: any, cb: (event: any) => void): void\n  start(options: any): void\n  isStarted(): boolean\n}\n\nexport function reportError(error: any, userId?: string, userEmail?: string) {\n  const apiKey = getEnv('BUGSNAG_APIKEY')\n\n  if (!apiKey) return\n\n  const bg = Bugsnag as unknown as Bugsnag\n\n  if (!bg.isStarted()) {\n    bg.start({\n      apiKey,\n      plugins: [],\n      autoTrackSessions: true,\n      collectUserIp: false,\n      enabledBreadcrumbTypes: ['error', 'log', 'request', 'state'],\n      maxBreadcrumbs: 3,\n    })\n  }\n\n  try {\n    bg.notify(error, (event) => {\n      if (!!userId || !!userEmail) {\n        event.setUser(userId, userEmail)\n      }\n    })\n    console.log('Error reported to bugsnag')\n  } catch (error) {\n    console.log(error)\n  }\n\n  // TODO: Preguntar si se va a cambiar el hook de make\n\n  // if (process.env.NODE_ENV === 'production') {\n  //   fetch('https://hook.us1.make.com/1b3sfpccrkqbd8ozum57uilncq9556o1', {\n  //     method: 'POST',\n  //     body: JSON.stringify({\n  //       error: error?.message ?? error,\n  //       stack: error?.stack ?? '',\n  //       cause: error?.cause ?? '',\n  //       name: error?.name ?? '',\n  //       userId,\n  //       userEmail\n  //     })\n  //   }).catch((err) => console.error(err))\n  // }\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import Bugsnag from 'npm:@bugsnag/js@7.22.4'"
    ],
    "codeNoBody": "// deno-lint-ignore-file\nimport { getEnv } from '@/lib/env.ts'\nimport Bugsnag from 'npm:@bugsnag/js@7.22.4'\ninterface Bugsnag {\n//...\n}\n\nexport function reportError(error: any, userId?: string, userEmail?: string) {\n       //...\n       }",
    "originFile": "\\lib\\bugsnag.ts"
  },
  {
    "id": "\\lib\\chat\\stream-reader",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\stream-reader.ts",
    "type": "file",
    "totalTokens": 76,
    "inDegree": 0,
    "outDegree": 0,
    "code": "export async function* streamReader(readableStream: ReadableStream) {\n  const reader = readableStream.getReader()\n  const decoder = new TextDecoder()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n    const content = decoder.decode(value)\n    yield content\n  }\n}\n",
    "importStatements": [],
    "codeNoBody": "export async function* streamReader(readableStream: ReadableStream) {\n  const reader = readableStream.getReader()\n  const decoder = new TextDecoder()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n    const content = decoder.decode(value)\n    yield content\n  }\n}",
    "originFile": "\\lib\\chat\\stream-reader.ts"
  },
  {
    "id": "\\lib\\chat\\streaming::onFinal",
    "language": "typescript",
    "label": "onFinal",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\streaming::createResponse",
    "totalTokens": 990,
    "inDegree": 2,
    "outDegree": 9,
    "code": "const onFinal = async ({ completion, tokens }: {\n    completion: string\n    tokens?: {\n      promptTokens: number\n      completionTokens: number\n    }\n  }) => {\n    const endTime = new Date(Date.now()).toISOString()\n\n    const chatLog: ChatLogInsert = {\n      model: agent.model,\n      org_id: orgId,\n      agent_id: agent.id,\n      user_id: userId,\n      completion_tokens: completionTokens,\n      prompt_tokens: promptTokens,\n      embbedding_tokens: lastMessageTokens,\n      session_id: sessionId,\n      start_time: startTime,\n      end_time: endTime,\n      message_embedding: lastMessageEmbedding.length < 1\n        ? null\n        : lastMessageEmbedding as unknown as string,\n      tags,\n      system_prompt: systemPrompt,\n      agent_documents_verification_time: agentDocumentsVerificationTime,\n      embedding_time: embeddingTime,\n      first_token_response_time: stream ? firstTokenResponseTime : 0,\n      plan_agent_time: planAndAgentTime,\n      semantic_search_time: semanticSearchTime,\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'SEMANTIC_SEARCH',\n      channel,\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: planName,\n      embeddings_tokens: lastMessageTokens,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      prompt_token: 0,\n      completion_token: 0,\n      org_id: orgId,\n      session_id: sessionId,\n    }, {\n      type: 'CHAT',\n      channel,\n      source: 'API',\n      model: agent.model,\n      plan_name: planName,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      org_id: orgId,\n      embeddings_tokens: 0,\n      prompt_token: tokens ? tokens.promptTokens : promptTokens,\n      completion_token: tokens ? tokens.completionTokens : completionTokens,\n      session_id: sessionId,\n    }]\n\n    const messageCreationTime = new Date(Date.now()).getTime()\n\n    const promises = [\n      saveChatLog({\n        log: chatLog,\n        messages: [\n          ...messages.map((m, i) => ({\n            role: m.role,\n            content: m.content,\n            created_at: new Date(messageCreationTime + 100 * i).toISOString(),\n          })),\n          {\n            role: 'assistant',\n            content: completion,\n            created_at: new Date(messageCreationTime + 100 * messages.length)\n              .toISOString(),\n          },\n        ],\n        chunks: knowledge.chunks,\n      }),\n      saveUsage(usage),\n    ]\n\n    if (userOrgId) {\n      promises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: usage[1].prompt_token ?? 0,\n          outputTokens: usage[1].completion_token ?? 0,\n          model: agent.model as ModelsEnum,\n        }),\n      )\n    }\n\n    if (body && body.length > 0) {\n      for (const item of body) {\n        if (\n          ['playgroundChat', 'completion', 'Chat', 'sharedChat', 'widgetChat']\n            .includes(item.event)\n        ) {\n          item.properties = {\n            ...item.properties,\n            prompt_tokens: usage[1].prompt_token,\n            completion_tokens: usage[1].completion_token,\n            embeddings_tokens: lastMessageTokens,\n          }\n        }\n\n        if (['completion2', 'completion2consumer'].includes(item.event)) {\n          const promptTokens = usage[1].prompt_token ?? 0\n          const completionTokens = usage[1].completion_token ?? 0\n\n          item.properties = {\n            ...item.properties,\n            tokens_total: promptTokens + completionTokens + lastMessageTokens,\n            tokens_completion: completionTokens,\n            tokens_prompt: promptTokens,\n            tokens_embedding: lastMessageTokens,\n          }\n        }\n      }\n\n      promises.push(mixpanel({ body }))\n    }\n\n    if (saveMessages) {\n      const timestamp = Date.now()\n      const content = completion\n      const lastTwoMessages:\n        Database['public']['Tables']['messages']['Insert'][] = [\n          {\n            role: 'user',\n            content: messages[messages.length - 1].content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp).toISOString(),\n          },\n          {\n            role: 'assistant',\n            content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp + 100).toISOString(),\n          },\n        ]\n\n      const messageRecording = isReload\n        ? updateLastAssistantMessage(agent.id, content)\n        : saveSupabaseMessages(lastTwoMessages)\n\n      promises.push(messageRecording)\n    }\n    await Promise.all(promises)\n  }",
    "importStatements": [],
    "codeNoBody": "const onFinal = async ({ completion, tokens }: {\n    completion: string\n    tokens?: {\n      promptTokens: number\n      completionTokens: number\n    }\n  }) => {\n  //...\n  }",
    "originFile": "\\lib\\chat\\streaming.ts"
  },
  {
    "id": "\\lib\\chat\\streaming::onToken",
    "language": "typescript",
    "label": "onToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\streaming::createResponse",
    "totalTokens": 161,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const onToken = () => {\n    if (completionTokens === 0) {\n      firstTokenResponseTime = Date.now() - firstTokenResponseTime\n\n      if (statusId) {\n        const channel = new BroadcastChannel(`chat-status-${statusId}`)\n        channel.postMessage({ message: 'Model start streaming', done: true })\n        setTimeout(() => {\n          channel.close()\n        }, 5)\n      }\n    }\n    completionTokens += 1\n\n    const currentCost = outputCost.times(completionTokens).plus(cost)\n    if (\n      dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n      currentCost.gte(dailyMaxUsage)\n    ) {\n      controller.abort()\n      throw new HTTPException(400, { message: 'Daily max usage reached' })\n    }\n  }",
    "importStatements": [],
    "codeNoBody": "const onToken = () => {\n  //...\n  }",
    "originFile": "\\lib\\chat\\streaming.ts"
  },
  {
    "id": "\\lib\\chat\\streaming::createResponse",
    "language": "typescript",
    "label": "createResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\streaming",
    "totalTokens": 1766,
    "inDegree": 17,
    "outDegree": 18,
    "code": "async function createResponse(\n  {\n    messages: userMessages,\n    stream = true,\n    format = 'text',\n    agent,\n    lastMessageTokens,\n    lastMessageEmbedding,\n    dailyUsage,\n    dailyMaxUsage: dailyMaxUsageNumber,\n    knowledge,\n    sessionId,\n    userId,\n    channel,\n    orgId,\n    planName,\n    userOrgId,\n    body,\n    saveMessages = false,\n    isReload,\n    c,\n    tags,\n    agentDocumentsVerificationTime,\n    embeddingTime,\n    semanticSearchTime,\n    planAndAgentTime,\n    statusId,\n    functions,\n    function_call,\n  }: Props,\n) {\n  const messages = userMessages.slice(-agent.memory)\n\n  const systemPrompt = createSystemPrompt({\n    knowledge: knowledge.content,\n    agent: {\n      model: agent.model,\n      name: agent.name,\n      prompt: agent.prompt,\n    },\n  })\n\n  const { tokens: promptTokens } = await getModelTokens({\n    model: agent.model,\n    messages,\n    text: systemPrompt,\n  })\n\n  const [modelCost, modelAdaCost] = await Promise.all([\n    redis.get<{ input: number; output: number }>(\n      `modelCost-${agent.model}`,\n    ),\n    redis.get<{ input: number; output: number }>(\n      `modelCost-text-embedding-ada-002`,\n    ),\n  ])\n\n  const embeddingCost = new Decimal(modelAdaCost?.input ?? 0).dividedBy(1000)\n    .times(lastMessageTokens)\n\n  const promptTokenCost = new Decimal(modelCost?.input ?? 0).dividedBy(1000)\n    .times(\n      promptTokens,\n    )\n\n  const cost = embeddingCost.plus(promptTokenCost).plus(\n    new Decimal(dailyUsage),\n  )\n\n  const dailyMaxUsage = new Decimal(dailyMaxUsageNumber)\n\n  if (\n    dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n    cost.gte(dailyMaxUsage)\n  ) {\n    throw new HTTPException(400, { message: 'Daily max usage reached' })\n  }\n\n  let completionTokens = 0\n\n  const outputCost = new Decimal(modelCost?.output ?? 0).dividedBy(1000)\n\n  const controller = new AbortController()\n\n  let firstTokenResponseTime = Date.now()\n\n  const onToken = () => {\n    if (completionTokens === 0) {\n      firstTokenResponseTime = Date.now() - firstTokenResponseTime\n\n      if (statusId) {\n        const channel = new BroadcastChannel(`chat-status-${statusId}`)\n        channel.postMessage({ message: 'Model start streaming', done: true })\n        setTimeout(() => {\n          channel.close()\n        }, 5)\n      }\n    }\n    completionTokens += 1\n\n    const currentCost = outputCost.times(completionTokens).plus(cost)\n    if (\n      dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n      currentCost.gte(dailyMaxUsage)\n    ) {\n      controller.abort()\n      throw new HTTPException(400, { message: 'Daily max usage reached' })\n    }\n  }\n\n  const startTime = new Date(Date.now()).toISOString()\n\n  const onFinal = async ({ completion, tokens }: {\n    completion: string\n    tokens?: {\n      promptTokens: number\n      completionTokens: number\n    }\n  }) => {\n    const endTime = new Date(Date.now()).toISOString()\n\n    const chatLog: ChatLogInsert = {\n      model: agent.model,\n      org_id: orgId,\n      agent_id: agent.id,\n      user_id: userId,\n      completion_tokens: completionTokens,\n      prompt_tokens: promptTokens,\n      embbedding_tokens: lastMessageTokens,\n      session_id: sessionId,\n      start_time: startTime,\n      end_time: endTime,\n      message_embedding: lastMessageEmbedding.length < 1\n        ? null\n        : lastMessageEmbedding as unknown as string,\n      tags,\n      system_prompt: systemPrompt,\n      agent_documents_verification_time: agentDocumentsVerificationTime,\n      embedding_time: embeddingTime,\n      first_token_response_time: stream ? firstTokenResponseTime : 0,\n      plan_agent_time: planAndAgentTime,\n      semantic_search_time: semanticSearchTime,\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'SEMANTIC_SEARCH',\n      channel,\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: planName,\n      embeddings_tokens: lastMessageTokens,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      prompt_token: 0,\n      completion_token: 0,\n      org_id: orgId,\n      session_id: sessionId,\n    }, {\n      type: 'CHAT',\n      channel,\n      source: 'API',\n      model: agent.model,\n      plan_name: planName,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      org_id: orgId,\n      embeddings_tokens: 0,\n      prompt_token: tokens ? tokens.promptTokens : promptTokens,\n      completion_token: tokens ? tokens.completionTokens : completionTokens,\n      session_id: sessionId,\n    }]\n\n    const messageCreationTime = new Date(Date.now()).getTime()\n\n    const promises = [\n      saveChatLog({\n        log: chatLog,\n        messages: [\n          ...messages.map((m, i) => ({\n            role: m.role,\n            content: m.content,\n            created_at: new Date(messageCreationTime + 100 * i).toISOString(),\n          })),\n          {\n            role: 'assistant',\n            content: completion,\n            created_at: new Date(messageCreationTime + 100 * messages.length)\n              .toISOString(),\n          },\n        ],\n        chunks: knowledge.chunks,\n      }),\n      saveUsage(usage),\n    ]\n\n    if (userOrgId) {\n      promises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: usage[1].prompt_token ?? 0,\n          outputTokens: usage[1].completion_token ?? 0,\n          model: agent.model as ModelsEnum,\n        }),\n      )\n    }\n\n    if (body && body.length > 0) {\n      for (const item of body) {\n        if (\n          ['playgroundChat', 'completion', 'Chat', 'sharedChat', 'widgetChat']\n            .includes(item.event)\n        ) {\n          item.properties = {\n            ...item.properties,\n            prompt_tokens: usage[1].prompt_token,\n            completion_tokens: usage[1].completion_token,\n            embeddings_tokens: lastMessageTokens,\n          }\n        }\n\n        if (['completion2', 'completion2consumer'].includes(item.event)) {\n          const promptTokens = usage[1].prompt_token ?? 0\n          const completionTokens = usage[1].completion_token ?? 0\n\n          item.properties = {\n            ...item.properties,\n            tokens_total: promptTokens + completionTokens + lastMessageTokens,\n            tokens_completion: completionTokens,\n            tokens_prompt: promptTokens,\n            tokens_embedding: lastMessageTokens,\n          }\n        }\n      }\n\n      promises.push(mixpanel({ body }))\n    }\n\n    if (saveMessages) {\n      const timestamp = Date.now()\n      const content = completion\n      const lastTwoMessages:\n        Database['public']['Tables']['messages']['Insert'][] = [\n          {\n            role: 'user',\n            content: messages[messages.length - 1].content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp).toISOString(),\n          },\n          {\n            role: 'assistant',\n            content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp + 100).toISOString(),\n          },\n        ]\n\n      const messageRecording = isReload\n        ? updateLastAssistantMessage(agent.id, content)\n        : saveSupabaseMessages(lastTwoMessages)\n\n      promises.push(messageRecording)\n    }\n    await Promise.all(promises)\n  }\n\n  if (statusId) {\n    const channel = new BroadcastChannel(`chat-status-${statusId}`)\n    channel.postMessage({ message: 'Calling AI model', done: false })\n    setTimeout(() => {\n      channel.close()\n    }, 5)\n  }\n\n  const response = await createModelResponse({\n    agentName: agent.name,\n    model: agent.model,\n    temperature: agent.temperature,\n    messages,\n    stream,\n    format,\n    systemPrompt,\n    abortSignal: controller.signal,\n    c,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  })\n\n  return response\n}",
    "importStatements": [],
    "codeNoBody": "async function createResponse(\n  {\n    messages: userMessages,\n    stream = true,\n    format = 'text',\n    agent,\n    lastMessageTokens,\n    lastMessageEmbedding,\n    dailyUsage,\n    dailyMaxUsage: dailyMaxUsageNumber,\n    knowledge,\n    sessionId,\n    userId,\n    channel,\n    orgId,\n    planName,\n    userOrgId,\n    body,\n    saveMessages = false,\n    isReload,\n    c,\n    tags,\n    agentDocumentsVerificationTime,\n    embeddingTime,\n    semanticSearchTime,\n    planAndAgentTime,\n    statusId,\n    functions,\n    function_call,\n  }: Props,\n) {\n  const messages = userMessages.slice(-agent.memory)\n  const systemPrompt = createSystemPrompt({\n    knowledge: knowledge.content,\n    agent: {\n      model: agent.model,\n      name: agent.name,\n      prompt: agent.prompt,\n    },\n  })\n\n  const { tokens: promptTokens } = await getModelTokens({\n    model: agent.model,\n    messages,\n    text: systemPrompt,\n  })\n\n  const [modelCost, modelAdaCost] = await Promise.all([\n    redis.get<{ input: number; output: number }>(\n      `modelCost-${agent.model}`,\n    ),\n    redis.get<{ input: number; output: number }>(\n      `modelCost-text-embedding-ada-002`,\n    ),\n  ])\n\n  const embeddingCost = new Decimal(modelAdaCost?.input ?? 0).dividedBy(1000)\n    .times(lastMessageTokens)\n\n  const promptTokenCost = new Decimal(modelCost?.input ?? 0).dividedBy(1000)\n    .times(\n      promptTokens,\n    )\n\n  const cost = embeddingCost.plus(promptTokenCost).plus(\n    new Decimal(dailyUsage),\n  )\n\n  const dailyMaxUsage = new Decimal(dailyMaxUsageNumber)\n\n  if (\n    dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n    cost.gte(dailyMaxUsage)\n  ) {\n    throw new HTTPException(400, { message: 'Daily max usage reached' })\n  }\n\n  let completionTokens = 0\n\n  const outputCost = new Decimal(modelCost?.output ?? 0).dividedBy(1000)\n\n  const controller = new AbortController()\n\n  let firstTokenResponseTime = Date.now()\n\n  const onToken = () => {\n    if (completionTokens === 0) {\n      firstTokenResponseTime = Date.now() - firstTokenResponseTime\n\n      if (statusId) {\n        const channel = new BroadcastChannel(`chat-status-${statusId}`)\n        channel.postMessage({ message: 'Model start streaming', done: true })\n        setTimeout(() => {\n          channel.close()\n        }, 5)\n      }\n    }\n    completionTokens += 1\n\n    const currentCost = outputCost.times(completionTokens).plus(cost)\n    if (\n      dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n      currentCost.gte(dailyMaxUsage)\n    ) {\n      controller.abort()\n      throw new HTTPException(400, { message: 'Daily max usage reached' })\n    }\n  }\n\n  const startTime = new Date(Date.now()).toISOString()\n\n  const onFinal = async ({ completion, tokens }: {\n    completion: string\n    tokens?: {\n      promptTokens: number\n      completionTokens: number\n    }\n  }) => {\n    const endTime = new Date(Date.now()).toISOString()\n\n    const chatLog: ChatLogInsert = {\n      model: agent.model,\n      org_id: orgId,\n      agent_id: agent.id,\n      user_id: userId,\n      completion_tokens: completionTokens,\n      prompt_tokens: promptTokens,\n      embbedding_tokens: lastMessageTokens,\n      session_id: sessionId,\n      start_time: startTime,\n      end_time: endTime,\n      message_embedding: lastMessageEmbedding.length < 1\n        ? null\n        : lastMessageEmbedding as unknown as string,\n      tags,\n      system_prompt: systemPrompt,\n      agent_documents_verification_time: agentDocumentsVerificationTime,\n      embedding_time: embeddingTime,\n      first_token_response_time: stream ? firstTokenResponseTime : 0,\n      plan_agent_time: planAndAgentTime,\n      semantic_search_time: semanticSearchTime,\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'SEMANTIC_SEARCH',\n      channel,\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: planName,\n      embeddings_tokens: lastMessageTokens,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      prompt_token: 0,\n      completion_token: 0,\n      org_id: orgId,\n      session_id: sessionId,\n    }, {\n      type: 'CHAT',\n      channel,\n      source: 'API',\n      model: agent.model,\n      plan_name: planName,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      org_id: orgId,\n      embeddings_tokens: 0,\n      prompt_token: tokens ? tokens.promptTokens : promptTokens,\n      completion_token: tokens ? tokens.completionTokens : completionTokens,\n      session_id: sessionId,\n    }]\n\n    const messageCreationTime = new Date(Date.now()).getTime()\n\n    const promises = [\n      saveChatLog({\n        log: chatLog,\n        messages: [\n          ...messages.map((m, i) => ({\n            role: m.role,\n            content: m.content,\n            created_at: new Date(messageCreationTime + 100 * i).toISOString(),\n          })),\n          {\n            role: 'assistant',\n            content: completion,\n            created_at: new Date(messageCreationTime + 100 * messages.length)\n              .toISOString(),\n          },\n        ],\n        chunks: knowledge.chunks,\n      }),\n      saveUsage(usage),\n    ]\n\n    if (userOrgId) {\n      promises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: usage[1].prompt_token ?? 0,\n          outputTokens: usage[1].completion_token ?? 0,\n          model: agent.model as ModelsEnum,\n        }),\n      )\n    }\n\n    if (body && body.length > 0) {\n      for (const item of body) {\n        if (\n          ['playgroundChat', 'completion', 'Chat', 'sharedChat', 'widgetChat']\n            .includes(item.event)\n        ) {\n          item.properties = {\n            ...item.properties,\n            prompt_tokens: usage[1].prompt_token,\n            completion_tokens: usage[1].completion_token,\n            embeddings_tokens: lastMessageTokens,\n          }\n        }\n\n        if (['completion2', 'completion2consumer'].includes(item.event)) {\n          const promptTokens = usage[1].prompt_token ?? 0\n          const completionTokens = usage[1].completion_token ?? 0\n\n          item.properties = {\n            ...item.properties,\n            tokens_total: promptTokens + completionTokens + lastMessageTokens,\n            tokens_completion: completionTokens,\n            tokens_prompt: promptTokens,\n            tokens_embedding: lastMessageTokens,\n          }\n        }\n      }\n\n      promises.push(mixpanel({ body }))\n    }\n\n    if (saveMessages) {\n      const timestamp = Date.now()\n      const content = completion\n      const lastTwoMessages:\n        Database['public']['Tables']['messages']['Insert'][] = [\n          {\n            role: 'user',\n            content: messages[messages.length - 1].content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp).toISOString(),\n          },\n          {\n            role: 'assistant',\n            content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp + 100).toISOString(),\n          },\n        ]\n\n      const messageRecording = isReload\n        ? updateLastAssistantMessage(agent.id, content)\n        : saveSupabaseMessages(lastTwoMessages)\n\n      promises.push(messageRecording)\n    }\n    await Promise.all(promises)\n  }\n\n  if (statusId) {\n    const channel = new BroadcastChannel(`chat-status-${statusId}`)\n    channel.postMessage({ message: 'Calling AI model', done: false })\n    setTimeout(() => {\n      channel.close()\n    }, 5)\n  }\n\n  const response = await createModelResponse({\n    agentName: agent.name,\n    model: agent.model,\n    temperature: agent.temperature,\n    messages,\n    stream,\n    format,\n    systemPrompt,\n    abortSignal: controller.signal,\n    c,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  })\n\n  return response\n}",
    "originFile": "\\lib\\chat\\streaming.ts"
  },
  {
    "id": "\\lib\\chat\\streaming::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\streaming",
    "totalTokens": 233,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Props {\n  c: Context\n  messages: any[]\n  stream?: boolean\n  format?: 'text' | 'json'\n  messageLimit?: number\n  agent: {\n    id: string\n    model: string\n    name: string\n    prompt: string\n    temperature: number\n    memory: number\n  }\n  sessionId?: string\n  userId?: string\n  lastMessageTokens: number\n  lastMessageEmbedding: number[]\n  dailyMaxUsage: number\n  dailyUsage: number\n  knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  }\n  channel: string\n  planName: string\n  orgId: string\n  userOrgId?: string\n  body?: any\n  saveMessages?: boolean\n  isReload?: string | null\n  tags: string[]\n  agentDocumentsVerificationTime: number\n  embeddingTime: number\n  semanticSearchTime: number\n  planAndAgentTime: number\n  statusId?: string\n  functions?: FunctionDefinition[]\n  function_call?: any\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\lib\\chat\\streaming.ts"
  },
  {
    "id": "\\lib\\chat\\streaming",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\streaming.ts",
    "type": "file",
    "totalTokens": 2272,
    "inDegree": 0,
    "outDegree": 3,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport type { ModelsEnum } from '@/types/index.ts'\nimport { redis } from '@/lib/redis.ts'\n\nimport { Decimal } from 'npm:decimal.js@10.4.3'\nimport { UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { HTTPException } from 'hono/http-exception'\nimport { createModelResponse } from '@/services/ai/index.ts'\nimport { Context } from 'hono'\nimport { createSystemPrompt } from '@/lib/chat/system-prompt.ts'\nimport { getModelTokens } from '@/lib/chat/tokens.ts'\nimport { saveUsage, type UsageInsert } from '@/services/supabase/usage.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Database } from '@/types/supabase.ts'\nimport {\n  saveMessages as saveSupabaseMessages,\n  updateLastAssistantMessage,\n} from '@/services/supabase/messages.ts'\nimport {\n  type ChatLogInsert,\n  saveChatLog,\n} from '@/services/supabase/chat-log.ts'\nimport type { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.12'\n\ninterface Props {\n  c: Context\n  messages: any[]\n  stream?: boolean\n  format?: 'text' | 'json'\n  messageLimit?: number\n  agent: {\n    id: string\n    model: string\n    name: string\n    prompt: string\n    temperature: number\n    memory: number\n  }\n  sessionId?: string\n  userId?: string\n  lastMessageTokens: number\n  lastMessageEmbedding: number[]\n  dailyMaxUsage: number\n  dailyUsage: number\n  knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  }\n  channel: string\n  planName: string\n  orgId: string\n  userOrgId?: string\n  body?: any\n  saveMessages?: boolean\n  isReload?: string | null\n  tags: string[]\n  agentDocumentsVerificationTime: number\n  embeddingTime: number\n  semanticSearchTime: number\n  planAndAgentTime: number\n  statusId?: string\n  functions?: FunctionDefinition[]\n  function_call?: any\n}\n\nexport async function createResponse(\n  {\n    messages: userMessages,\n    stream = true,\n    format = 'text',\n    agent,\n    lastMessageTokens,\n    lastMessageEmbedding,\n    dailyUsage,\n    dailyMaxUsage: dailyMaxUsageNumber,\n    knowledge,\n    sessionId,\n    userId,\n    channel,\n    orgId,\n    planName,\n    userOrgId,\n    body,\n    saveMessages = false,\n    isReload,\n    c,\n    tags,\n    agentDocumentsVerificationTime,\n    embeddingTime,\n    semanticSearchTime,\n    planAndAgentTime,\n    statusId,\n    functions,\n    function_call,\n  }: Props,\n) {\n  const messages = userMessages.slice(-agent.memory)\n\n  const systemPrompt = createSystemPrompt({\n    knowledge: knowledge.content,\n    agent: {\n      model: agent.model,\n      name: agent.name,\n      prompt: agent.prompt,\n    },\n  })\n\n  const { tokens: promptTokens } = await getModelTokens({\n    model: agent.model,\n    messages,\n    text: systemPrompt,\n  })\n\n  const [modelCost, modelAdaCost] = await Promise.all([\n    redis.get<{ input: number; output: number }>(\n      `modelCost-${agent.model}`,\n    ),\n    redis.get<{ input: number; output: number }>(\n      `modelCost-text-embedding-ada-002`,\n    ),\n  ])\n\n  const embeddingCost = new Decimal(modelAdaCost?.input ?? 0).dividedBy(1000)\n    .times(lastMessageTokens)\n\n  const promptTokenCost = new Decimal(modelCost?.input ?? 0).dividedBy(1000)\n    .times(\n      promptTokens,\n    )\n\n  const cost = embeddingCost.plus(promptTokenCost).plus(\n    new Decimal(dailyUsage),\n  )\n\n  const dailyMaxUsage = new Decimal(dailyMaxUsageNumber)\n\n  if (\n    dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n    cost.gte(dailyMaxUsage)\n  ) {\n    throw new HTTPException(400, { message: 'Daily max usage reached' })\n  }\n\n  let completionTokens = 0\n\n  const outputCost = new Decimal(modelCost?.output ?? 0).dividedBy(1000)\n\n  const controller = new AbortController()\n\n  let firstTokenResponseTime = Date.now()\n\n  const onToken = () => {\n    if (completionTokens === 0) {\n      firstTokenResponseTime = Date.now() - firstTokenResponseTime\n\n      if (statusId) {\n        const channel = new BroadcastChannel(`chat-status-${statusId}`)\n        channel.postMessage({ message: 'Model start streaming', done: true })\n        setTimeout(() => {\n          channel.close()\n        }, 5)\n      }\n    }\n    completionTokens += 1\n\n    const currentCost = outputCost.times(completionTokens).plus(cost)\n    if (\n      dailyMaxUsageNumber !== UNLIMITED_MAX_USAGE &&\n      currentCost.gte(dailyMaxUsage)\n    ) {\n      controller.abort()\n      throw new HTTPException(400, { message: 'Daily max usage reached' })\n    }\n  }\n\n  const startTime = new Date(Date.now()).toISOString()\n\n  const onFinal = async ({ completion, tokens }: {\n    completion: string\n    tokens?: {\n      promptTokens: number\n      completionTokens: number\n    }\n  }) => {\n    const endTime = new Date(Date.now()).toISOString()\n\n    const chatLog: ChatLogInsert = {\n      model: agent.model,\n      org_id: orgId,\n      agent_id: agent.id,\n      user_id: userId,\n      completion_tokens: completionTokens,\n      prompt_tokens: promptTokens,\n      embbedding_tokens: lastMessageTokens,\n      session_id: sessionId,\n      start_time: startTime,\n      end_time: endTime,\n      message_embedding: lastMessageEmbedding.length < 1\n        ? null\n        : lastMessageEmbedding as unknown as string,\n      tags,\n      system_prompt: systemPrompt,\n      agent_documents_verification_time: agentDocumentsVerificationTime,\n      embedding_time: embeddingTime,\n      first_token_response_time: stream ? firstTokenResponseTime : 0,\n      plan_agent_time: planAndAgentTime,\n      semantic_search_time: semanticSearchTime,\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'SEMANTIC_SEARCH',\n      channel,\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: planName,\n      embeddings_tokens: lastMessageTokens,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      prompt_token: 0,\n      completion_token: 0,\n      org_id: orgId,\n      session_id: sessionId,\n    }, {\n      type: 'CHAT',\n      channel,\n      source: 'API',\n      model: agent.model,\n      plan_name: planName,\n      agent_id: agent.id,\n      user_id: userId ?? null,\n      org_id: orgId,\n      embeddings_tokens: 0,\n      prompt_token: tokens ? tokens.promptTokens : promptTokens,\n      completion_token: tokens ? tokens.completionTokens : completionTokens,\n      session_id: sessionId,\n    }]\n\n    const messageCreationTime = new Date(Date.now()).getTime()\n\n    const promises = [\n      saveChatLog({\n        log: chatLog,\n        messages: [\n          ...messages.map((m, i) => ({\n            role: m.role,\n            content: m.content,\n            created_at: new Date(messageCreationTime + 100 * i).toISOString(),\n          })),\n          {\n            role: 'assistant',\n            content: completion,\n            created_at: new Date(messageCreationTime + 100 * messages.length)\n              .toISOString(),\n          },\n        ],\n        chunks: knowledge.chunks,\n      }),\n      saveUsage(usage),\n    ]\n\n    if (userOrgId) {\n      promises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: usage[1].prompt_token ?? 0,\n          outputTokens: usage[1].completion_token ?? 0,\n          model: agent.model as ModelsEnum,\n        }),\n      )\n    }\n\n    if (body && body.length > 0) {\n      for (const item of body) {\n        if (\n          ['playgroundChat', 'completion', 'Chat', 'sharedChat', 'widgetChat']\n            .includes(item.event)\n        ) {\n          item.properties = {\n            ...item.properties,\n            prompt_tokens: usage[1].prompt_token,\n            completion_tokens: usage[1].completion_token,\n            embeddings_tokens: lastMessageTokens,\n          }\n        }\n\n        if (['completion2', 'completion2consumer'].includes(item.event)) {\n          const promptTokens = usage[1].prompt_token ?? 0\n          const completionTokens = usage[1].completion_token ?? 0\n\n          item.properties = {\n            ...item.properties,\n            tokens_total: promptTokens + completionTokens + lastMessageTokens,\n            tokens_completion: completionTokens,\n            tokens_prompt: promptTokens,\n            tokens_embedding: lastMessageTokens,\n          }\n        }\n      }\n\n      promises.push(mixpanel({ body }))\n    }\n\n    if (saveMessages) {\n      const timestamp = Date.now()\n      const content = completion\n      const lastTwoMessages:\n        Database['public']['Tables']['messages']['Insert'][] = [\n          {\n            role: 'user',\n            content: messages[messages.length - 1].content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp).toISOString(),\n          },\n          {\n            role: 'assistant',\n            content,\n            agent_id: agent.id,\n            user_id: userId,\n            created_at: new Date(timestamp + 100).toISOString(),\n          },\n        ]\n\n      const messageRecording = isReload\n        ? updateLastAssistantMessage(agent.id, content)\n        : saveSupabaseMessages(lastTwoMessages)\n\n      promises.push(messageRecording)\n    }\n    await Promise.all(promises)\n  }\n\n  if (statusId) {\n    const channel = new BroadcastChannel(`chat-status-${statusId}`)\n    channel.postMessage({ message: 'Calling AI model', done: false })\n    setTimeout(() => {\n      channel.close()\n    }, 5)\n  }\n\n  const response = await createModelResponse({\n    agentName: agent.name,\n    model: agent.model,\n    temperature: agent.temperature,\n    messages,\n    stream,\n    format,\n    systemPrompt,\n    abortSignal: controller.signal,\n    c,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  })\n\n  return response\n}\n",
    "importStatements": [
      "import type { ModelsEnum } from '@/types/index.ts'",
      "import { redis } from '@/lib/redis.ts'",
      "import { Decimal } from 'npm:decimal.js@10.4.3'",
      "import { UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'",
      "import { HTTPException } from 'hono/http-exception'",
      "import { createModelResponse } from '@/services/ai/index.ts'",
      "import { Context } from 'hono'",
      "import { createSystemPrompt } from '@/lib/chat/system-prompt.ts'",
      "import { getModelTokens } from '@/lib/chat/tokens.ts'",
      "import { saveUsage, type UsageInsert } from '@/services/supabase/usage.ts'",
      "import { addOrgDailyTokens } from '@/services/supabase/organizations.ts'",
      "import { mixpanel } from '@/lib/mixpanel.ts'",
      "import { Database } from '@/types/supabase.ts'",
      "import {\n  saveMessages as saveSupabaseMessages,\n  updateLastAssistantMessage,\n} from '@/services/supabase/messages.ts'",
      "import {\n  type ChatLogInsert,\n  saveChatLog,\n} from '@/services/supabase/chat-log.ts'",
      "import type { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.12'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport type { ModelsEnum } from '@/types/index.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { Decimal } from 'npm:decimal.js@10.4.3'\nimport { UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { HTTPException } from 'hono/http-exception'\nimport { createModelResponse } from '@/services/ai/index.ts'\nimport { Context } from 'hono'\nimport { createSystemPrompt } from '@/lib/chat/system-prompt.ts'\nimport { getModelTokens } from '@/lib/chat/tokens.ts'\nimport { saveUsage, type UsageInsert } from '@/services/supabase/usage.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Database } from '@/types/supabase.ts'\nimport {\n  saveMessages as saveSupabaseMessages,\n  updateLastAssistantMessage,\n} from '@/services/supabase/messages.ts'\nimport {\n  type ChatLogInsert,\n  saveChatLog,\n} from '@/services/supabase/chat-log.ts'\nimport type { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.12'\n\ninterface Props {\n//...\n}\n\nexport async function createResponse(\n  {\n    messages: userMessages,\n    stream = true,\n    format = 'text',\n    agent,\n    lastMessageTokens,\n    lastMessageEmbedding,\n    dailyUsage,\n    dailyMaxUsage: dailyMaxUsageNumber,\n    knowledge,\n    sessionId,\n    userId,\n    channel,\n    orgId,\n    planName,\n    userOrgId,\n    body,\n    saveMessages = false,\n    isReload,\n    c,\n    tags,\n    agentDocumentsVerificationTime,\n    embeddingTime,\n    semanticSearchTime,\n    planAndAgentTime,\n    statusId,\n    functions,\n    function_call,\n  }: Props,\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\streaming.ts"
  },
  {
    "id": "\\lib\\chat\\system-prompt::createSystemPrompt",
    "language": "typescript",
    "label": "createSystemPrompt",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\system-prompt",
    "totalTokens": 173,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function createSystemPrompt(\n  { knowledge, agent }: {\n    knowledge: string\n    agent: {\n      name: string\n      prompt: string\n      model: string\n    }\n  },\n) {\n  const documentsKnowledge = knowledge\n    ? `You are an assistant for question-answering tasks. Use the following pieces of retrieved context (Knowledge) to answer the question. If you don't know the answer, just say that you don't know. Read these Knowledge carefully, as you will be asked questions about them. Keep the answer concise. Always answer related to the Knowledge.\n  \n    ---\n    \n    # KNOWLEDGE:\n    \n    <Documents>\n    ${knowledge}\n    </Documents>`\n    : ''\n\n  return `Agent Name: ${agent.name}\n\n  ${documentsKnowledge}\n\n  # INSTRUCTIONS:\n\n  ${agent.prompt}`\n}",
    "importStatements": [],
    "codeNoBody": "function createSystemPrompt(\n  { knowledge, agent }: {\n    knowledge: string\n    agent: {\n      name: string\n      prompt: string\n      model: string\n    }\n  },\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\system-prompt.ts"
  },
  {
    "id": "\\lib\\chat\\system-prompt",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\system-prompt.ts",
    "type": "file",
    "totalTokens": 174,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export function createSystemPrompt(\n  { knowledge, agent }: {\n    knowledge: string\n    agent: {\n      name: string\n      prompt: string\n      model: string\n    }\n  },\n) {\n  const documentsKnowledge = knowledge\n    ? `You are an assistant for question-answering tasks. Use the following pieces of retrieved context (Knowledge) to answer the question. If you don't know the answer, just say that you don't know. Read these Knowledge carefully, as you will be asked questions about them. Keep the answer concise. Always answer related to the Knowledge.\n  \n    ---\n    \n    # KNOWLEDGE:\n    \n    <Documents>\n    ${knowledge}\n    </Documents>`\n    : ''\n\n  return `Agent Name: ${agent.name}\n\n  ${documentsKnowledge}\n\n  # INSTRUCTIONS:\n\n  ${agent.prompt}`\n}\n",
    "importStatements": [],
    "codeNoBody": "export function createSystemPrompt(\n  { knowledge, agent }: {\n    knowledge: string\n    agent: {\n      name: string\n      prompt: string\n      model: string\n    }\n  },\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\system-prompt.ts"
  },
  {
    "id": "\\lib\\chat\\tokens::getModelTokens",
    "language": "typescript",
    "label": "getModelTokens",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tokens",
    "totalTokens": 267,
    "inDegree": 2,
    "outDegree": 6,
    "code": "async function getModelTokens(\n  { model, messages = [], text = '' }: Props,\n) {\n  let tokens = 0\n\n  const content = messages\n    .map((message) => message.content).join('') + text\n\n  if (model.includes('gpt')) {\n    const tokenizerModel = ['gpt-4-turbo', 'gpt-4o'].includes(model)\n      ? 'gpt-4'\n      : model as TiktokenModel\n    tokens = tokenizer(\n      content,\n      tokenizerModel,\n    )\n  }\n\n  if (model.includes('claude')) {\n    tokens = countTokens(content)\n  }\n\n  if (model.includes('gemini')) {\n    const { totalTokens } = await vertexAI.getGenerativeModel({\n      model: VERTEX_MODELS_MAP[model as keyof typeof VERTEX_MODELS_MAP],\n    }).countTokens({ contents: [{ role: 'USER', parts: [{ text: content }] }] })\n\n    tokens = totalTokens\n  }\n\n  if (['codestral'].includes(model)) {\n    tokens = mistralTokenizer.encode(content).length ?? 0\n  }\n\n  if (model.includes('llama')) {\n    tokens = llama3Tokenizer.encode(content).length ?? 0\n  }\n\n  return { tokens }\n}",
    "importStatements": [],
    "codeNoBody": "async function getModelTokens(\n  { model, messages = [], text = '' }: Props,\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\tokens.ts"
  },
  {
    "id": "\\lib\\chat\\tokens::mistralTokenizer",
    "language": "typescript",
    "label": "mistralTokenizer",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tokens",
    "totalTokens": 10,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const mistralTokenizer = new MistralTokenizer()",
    "importStatements": [],
    "codeNoBody": "const mistralTokenizer = new MistralTokenizer()",
    "originFile": "\\lib\\chat\\tokens.ts"
  },
  {
    "id": "\\lib\\chat\\tokens::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tokens",
    "totalTokens": 20,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  model: string\n  messages?: ChatMessage[]\n  text?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\lib\\chat\\tokens.ts"
  },
  {
    "id": "\\lib\\chat\\tokens",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tokens.ts",
    "type": "file",
    "totalTokens": 427,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'\nimport type { ChatMessage } from '@/types/index.ts'\nimport { countTokens } from 'npm:@anthropic-ai/tokenizer@0.0.4'\nimport { vertexAI } from '@/services/ai/google/vertex/index.ts'\nimport { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'\nimport { MistralTokenizer } from 'npm:mistral-tokenizer-ts@1.2.0'\nimport llama3Tokenizer from 'npm:llama3-tokenizer-js@1.1.3'\n\ninterface Props {\n  model: string\n  messages?: ChatMessage[]\n  text?: string\n}\n\nconst mistralTokenizer = new MistralTokenizer()\n\nexport async function getModelTokens(\n  { model, messages = [], text = '' }: Props,\n) {\n  let tokens = 0\n\n  const content = messages\n    .map((message) => message.content).join('') + text\n\n  if (model.includes('gpt')) {\n    const tokenizerModel = ['gpt-4-turbo', 'gpt-4o'].includes(model)\n      ? 'gpt-4'\n      : model as TiktokenModel\n    tokens = tokenizer(\n      content,\n      tokenizerModel,\n    )\n  }\n\n  if (model.includes('claude')) {\n    tokens = countTokens(content)\n  }\n\n  if (model.includes('gemini')) {\n    const { totalTokens } = await vertexAI.getGenerativeModel({\n      model: VERTEX_MODELS_MAP[model as keyof typeof VERTEX_MODELS_MAP],\n    }).countTokens({ contents: [{ role: 'USER', parts: [{ text: content }] }] })\n\n    tokens = totalTokens\n  }\n\n  if (['codestral'].includes(model)) {\n    tokens = mistralTokenizer.encode(content).length ?? 0\n  }\n\n  if (model.includes('llama')) {\n    tokens = llama3Tokenizer.encode(content).length ?? 0\n  }\n\n  return { tokens }\n}\n",
    "importStatements": [
      "import { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'",
      "import type { ChatMessage } from '@/types/index.ts'",
      "import { countTokens } from 'npm:@anthropic-ai/tokenizer@0.0.4'",
      "import { vertexAI } from '@/services/ai/google/vertex/index.ts'",
      "import { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'",
      "import { MistralTokenizer } from 'npm:mistral-tokenizer-ts@1.2.0'",
      "import llama3Tokenizer from 'npm:llama3-tokenizer-js@1.1.3'"
    ],
    "codeNoBody": "import { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'\nimport type { ChatMessage } from '@/types/index.ts'\nimport { countTokens } from 'npm:@anthropic-ai/tokenizer@0.0.4'\nimport { vertexAI } from '@/services/ai/google/vertex/index.ts'\nimport { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'\nimport { MistralTokenizer } from 'npm:mistral-tokenizer-ts@1.2.0'\nimport llama3Tokenizer from 'npm:llama3-tokenizer-js@1.1.3'\ninterface Props {\n//...\n}\n\nconst mistralTokenizer = new MistralTokenizer()\n\nexport async function getModelTokens(\n  { model, messages = [], text = '' }: Props,\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\tokens.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::createKnowledge",
    "language": "typescript",
    "label": "createKnowledge",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 237,
    "inDegree": 2,
    "outDegree": 1,
    "code": "function createKnowledge(chunks: Chunk[]) {\n  const knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  } = { content: '', chunks: [] }\n\n  chunks.forEach((chunk) => {\n    const chunkMetadata = chunk.metadata\n\n    if (chunkMetadata) {\n      const meta = JSON.parse(chunkMetadata._node_content) as {\n        metadata: {\n          title?: string\n          document_title?: string\n        }\n        text?: string\n        id_: string\n      }\n      const newDoc = {\n        filename: meta.metadata.title ?? '',\n        document_title: meta.metadata.document_title ?? '',\n        document_content: meta.text ?? '',\n      }\n      knowledge.content += `<Document>${\n        newDoc.document_title\n          ? `This is a fragment titled ${newDoc.document_title}`\n          : ''\n      } From file ${newDoc.filename}.\\nA fragment from document\\n${newDoc.document_content}</Document>`\n      knowledge.chunks.push({\n        score: chunk.similarity ?? 0,\n        chunk_id: chunk.id,\n      })\n    }\n  })\n\n  return knowledge\n}",
    "importStatements": [],
    "codeNoBody": "function createKnowledge(chunks: Chunk[]) {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::processDocuments",
    "language": "typescript",
    "label": "processDocuments",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 213,
    "inDegree": 2,
    "outDegree": 2,
    "code": "function processDocuments(chunks: Chunk[]) {\n  const maxSimilarity = Math.max(...chunks.map((item) => item.similarity))\n  const minSimilarity = Math.min(...chunks.map((item) => item.similarity))\n\n  let normalizedChunks = chunks.map(\n    (chunk) => {\n      return {\n        ...chunk,\n        newSimilarity: (chunk.similarity - minSimilarity) /\n          (maxSimilarity - minSimilarity),\n      }\n    },\n  ).sort((a, b) => b.newSimilarity - a.newSimilarity)\n\n  if (normalizedChunks.length > 3) {\n    const filteredChunks = normalizedChunks\n      .slice(3)\n      .filter((item) => (item?.newSimilarity ?? 0 > 0.6))\n\n    normalizedChunks = [...normalizedChunks.slice(0, 3), ...filteredChunks]\n  }\n\n  console.log(\n    `knowledgeOrderByScore ${normalizedChunks.length} / ${chunks.length}`,\n  )\n\n  return createKnowledge(normalizedChunks)\n}",
    "importStatements": [],
    "codeNoBody": "function processDocuments(chunks: Chunk[]) {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::getModelMaxChunks",
    "language": "typescript",
    "label": "getModelMaxChunks",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 39,
    "inDegree": 2,
    "outDegree": 1,
    "code": "function getModelMaxChunks(model: string | undefined) {\n  return premiumModelsMap.get(model ?? 'gpt-3.5-turbo')?.max_chunks ?? 1024\n}",
    "importStatements": [],
    "codeNoBody": "function getModelMaxChunks(model: string | undefined) {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::getToolsKnowledge",
    "language": "typescript",
    "label": "getToolsKnowledge",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 889,
    "inDegree": 17,
    "outDegree": 11,
    "code": "async function getToolsKnowledge(\n  {\n    agent,\n    lastMessage: lastMessageParam,\n    dailyMaxUsage,\n    dailyUsage,\n    userOrgId,\n    statusId,\n  }: Props,\n) {\n  const lastMessage = cleanText(lastMessageParam)\n\n  let knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  } = { content: '', chunks: [] }\n\n  const modelMaxChunks = getModelMaxChunks(agent.model)\n  let lastMessageEmbedding: number[] = []\n\n  let agentDocumentsVerificationTime = 0\n  let embeddingTime = 0\n  let semanticSearchTime = 0\n\n  try {\n    const agentDocumentsVerificationTimeStart = Date.now()\n    const agentDocumentsCount =\n      await sql`SELECT count(*) as total FROM agents_documents WHERE agent_id = ${agent.id} LIMIT 1`\n\n    agentDocumentsVerificationTime = Date.now() -\n      agentDocumentsVerificationTimeStart\n\n    if (agentDocumentsCount[0].total === '0') {\n      return {\n        knowledge,\n        lastMessageEmbedding,\n        lastMessageTokens: 0,\n        agentDocumentsVerificationTime,\n        embeddingTime,\n        semanticSearchTime,\n      }\n    }\n\n    const lastMessageTokens = tokenizer(lastMessage, 'text-embedding-ada-002')\n    const modelCost = await redis.get<{ input: number }>(\n      `modelCost-text-embedding-ada-002`,\n    )\n\n    const embeddingUsage = new Decimal(modelCost?.input ?? 0).dividedBy(1000)\n      .times(lastMessageTokens).plus(new Decimal(dailyUsage))\n\n    // Max daily usage reached\n    if (\n      dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n      embeddingUsage.gt(new Decimal(dailyMaxUsage))\n    ) {\n      throw Error('maxDailyUsageReached')\n    }\n\n    const embeddingPromises: Promise<any>[] = [\n      createEmbedding({\n        model: 'text-embedding-ada-002',\n        input: [`${lastMessage.slice(0, 512)}`],\n      }),\n    ]\n\n    if (userOrgId) {\n      embeddingPromises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: lastMessageTokens,\n          outputTokens: 0,\n          model: 'text-embedding-ada-002',\n        }),\n      )\n    }\n\n    const embeddingTimeStart = Date.now()\n\n    if (statusId) {\n      const channel = new BroadcastChannel(`chat-status-${statusId}`)\n      channel.postMessage({ message: 'Searching for knowledge', done: false })\n      setTimeout(() => {\n        channel.close()\n      }, 5)\n    }\n\n    const [embeddingResponse] = await Promise.all(embeddingPromises)\n\n    embeddingTime = Date.now() - embeddingTimeStart\n\n    lastMessageEmbedding = embeddingResponse[0].embedding\n\n    const semanticSearchTimeStart = Date.now()\n\n    const chunks = await sql`SELECT * FROM match_documents_llama_v2(${\n      JSON.stringify(lastMessageEmbedding)\n    }, ${agent.id},${\n      modelMaxChunks > 25 ? 25 : modelMaxChunks\n    } )` as unknown as Chunk[]\n\n    semanticSearchTime = Date.now() - semanticSearchTimeStart\n\n    if (chunks.length === 0) {\n      const err = new Error(JSON.stringify({\n        agentId: agent.id,\n        documentsCount: agentDocumentsCount[0].total,\n      }))\n      reportError(err)\n    }\n\n    console.log('chunks from match_documents_llama_test: ', chunks.length)\n\n    knowledge = processDocuments(chunks)\n    return {\n      knowledge,\n      lastMessageEmbedding,\n      lastMessageTokens,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    }\n  } catch (error) {\n    if (\n      typeof error === 'object' && error.message === 'maxDailyUsageReached'\n    ) {\n      throw new HTTPException(400, { message: 'Daily usage limit reached' })\n    }\n    console.error('Error: ', error)\n\n    reportError(error)\n\n    return {\n      knowledge,\n      lastMessageEmbedding,\n      lastMessageTokens: 0,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getToolsKnowledge(\n  {\n    agent,\n    lastMessage: lastMessageParam,\n    dailyMaxUsage,\n    dailyUsage,\n    userOrgId,\n    statusId,\n  }: Props,\n) {\n       //...\n       }",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::Chunk",
    "language": "typescript",
    "label": "Chunk",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 40,
    "inDegree": 6,
    "outDegree": 1,
    "code": "interface Chunk {\n  id: string\n  metadata: Record<string, string>\n  document_id: string\n  document_metadata?: string\n  similarity: number\n  document_tokens: number\n}",
    "importStatements": [],
    "codeNoBody": "interface Chunk {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge",
    "totalTokens": 52,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Props {\n  lastMessage: string\n  agent: {\n    id: string\n    model: string\n  }\n  dailyMaxUsage: number\n  dailyUsage: number\n  userOrgId?: string\n  statusId?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\chat\\tools-knowledge",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\chat\\tools-knowledge.ts",
    "type": "file",
    "totalTokens": 1632,
    "inDegree": 0,
    "outDegree": 8,
    "code": "// deno-lint-ignore-file\n// Utils\nimport { premiumModelsMap, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { cleanText } from '@/lib/utils.ts'\nimport { tokenizer } from '@/lib/tokenizer.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { HTTPException } from 'npm:hono@4.1.0/http-exception'\nimport { redis } from '@/lib/redis.ts'\nimport { createEmbedding } from '@/lib/embeddings/index.ts'\nimport { Decimal } from 'npm:decimal.js@10.4.3'\n\ninterface Props {\n  lastMessage: string\n  agent: {\n    id: string\n    model: string\n  }\n  dailyMaxUsage: number\n  dailyUsage: number\n  userOrgId?: string\n  statusId?: string\n}\n\ninterface Chunk {\n  id: string\n  metadata: Record<string, string>\n  document_id: string\n  document_metadata?: string\n  similarity: number\n  document_tokens: number\n}\n\nexport async function getToolsKnowledge(\n  {\n    agent,\n    lastMessage: lastMessageParam,\n    dailyMaxUsage,\n    dailyUsage,\n    userOrgId,\n    statusId,\n  }: Props,\n) {\n  const lastMessage = cleanText(lastMessageParam)\n\n  let knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  } = { content: '', chunks: [] }\n\n  const modelMaxChunks = getModelMaxChunks(agent.model)\n  let lastMessageEmbedding: number[] = []\n\n  let agentDocumentsVerificationTime = 0\n  let embeddingTime = 0\n  let semanticSearchTime = 0\n\n  try {\n    const agentDocumentsVerificationTimeStart = Date.now()\n    const agentDocumentsCount =\n      await sql`SELECT count(*) as total FROM agents_documents WHERE agent_id = ${agent.id} LIMIT 1`\n\n    agentDocumentsVerificationTime = Date.now() -\n      agentDocumentsVerificationTimeStart\n\n    if (agentDocumentsCount[0].total === '0') {\n      return {\n        knowledge,\n        lastMessageEmbedding,\n        lastMessageTokens: 0,\n        agentDocumentsVerificationTime,\n        embeddingTime,\n        semanticSearchTime,\n      }\n    }\n\n    const lastMessageTokens = tokenizer(lastMessage, 'text-embedding-ada-002')\n    const modelCost = await redis.get<{ input: number }>(\n      `modelCost-text-embedding-ada-002`,\n    )\n\n    const embeddingUsage = new Decimal(modelCost?.input ?? 0).dividedBy(1000)\n      .times(lastMessageTokens).plus(new Decimal(dailyUsage))\n\n    // Max daily usage reached\n    if (\n      dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n      embeddingUsage.gt(new Decimal(dailyMaxUsage))\n    ) {\n      throw Error('maxDailyUsageReached')\n    }\n\n    const embeddingPromises: Promise<any>[] = [\n      createEmbedding({\n        model: 'text-embedding-ada-002',\n        input: [`${lastMessage.slice(0, 512)}`],\n      }),\n    ]\n\n    if (userOrgId) {\n      embeddingPromises.push(\n        addOrgDailyTokens({\n          orgId: userOrgId,\n          inputTokens: lastMessageTokens,\n          outputTokens: 0,\n          model: 'text-embedding-ada-002',\n        }),\n      )\n    }\n\n    const embeddingTimeStart = Date.now()\n\n    if (statusId) {\n      const channel = new BroadcastChannel(`chat-status-${statusId}`)\n      channel.postMessage({ message: 'Searching for knowledge', done: false })\n      setTimeout(() => {\n        channel.close()\n      }, 5)\n    }\n\n    const [embeddingResponse] = await Promise.all(embeddingPromises)\n\n    embeddingTime = Date.now() - embeddingTimeStart\n\n    lastMessageEmbedding = embeddingResponse[0].embedding\n\n    const semanticSearchTimeStart = Date.now()\n\n    const chunks = await sql`SELECT * FROM match_documents_llama_v2(${\n      JSON.stringify(lastMessageEmbedding)\n    }, ${agent.id},${\n      modelMaxChunks > 25 ? 25 : modelMaxChunks\n    } )` as unknown as Chunk[]\n\n    semanticSearchTime = Date.now() - semanticSearchTimeStart\n\n    if (chunks.length === 0) {\n      const err = new Error(JSON.stringify({\n        agentId: agent.id,\n        documentsCount: agentDocumentsCount[0].total,\n      }))\n      reportError(err)\n    }\n\n    console.log('chunks from match_documents_llama_test: ', chunks.length)\n\n    knowledge = processDocuments(chunks)\n    return {\n      knowledge,\n      lastMessageEmbedding,\n      lastMessageTokens,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    }\n  } catch (error) {\n    if (\n      typeof error === 'object' && error.message === 'maxDailyUsageReached'\n    ) {\n      throw new HTTPException(400, { message: 'Daily usage limit reached' })\n    }\n    console.error('Error: ', error)\n\n    reportError(error)\n\n    return {\n      knowledge,\n      lastMessageEmbedding,\n      lastMessageTokens: 0,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    }\n  }\n}\n\n// Helper functions\n\nfunction getModelMaxChunks(model: string | undefined) {\n  return premiumModelsMap.get(model ?? 'gpt-3.5-turbo')?.max_chunks ?? 1024\n}\n\nfunction processDocuments(chunks: Chunk[]) {\n  const maxSimilarity = Math.max(...chunks.map((item) => item.similarity))\n  const minSimilarity = Math.min(...chunks.map((item) => item.similarity))\n\n  let normalizedChunks = chunks.map(\n    (chunk) => {\n      return {\n        ...chunk,\n        newSimilarity: (chunk.similarity - minSimilarity) /\n          (maxSimilarity - minSimilarity),\n      }\n    },\n  ).sort((a, b) => b.newSimilarity - a.newSimilarity)\n\n  if (normalizedChunks.length > 3) {\n    const filteredChunks = normalizedChunks\n      .slice(3)\n      .filter((item) => (item?.newSimilarity ?? 0 > 0.6))\n\n    normalizedChunks = [...normalizedChunks.slice(0, 3), ...filteredChunks]\n  }\n\n  console.log(\n    `knowledgeOrderByScore ${normalizedChunks.length} / ${chunks.length}`,\n  )\n\n  return createKnowledge(normalizedChunks)\n}\n\nfunction createKnowledge(chunks: Chunk[]) {\n  const knowledge: {\n    content: string\n    chunks: {\n      chunk_id: string\n      score: number\n    }[]\n  } = { content: '', chunks: [] }\n\n  chunks.forEach((chunk) => {\n    const chunkMetadata = chunk.metadata\n\n    if (chunkMetadata) {\n      const meta = JSON.parse(chunkMetadata._node_content) as {\n        metadata: {\n          title?: string\n          document_title?: string\n        }\n        text?: string\n        id_: string\n      }\n      const newDoc = {\n        filename: meta.metadata.title ?? '',\n        document_title: meta.metadata.document_title ?? '',\n        document_content: meta.text ?? '',\n      }\n      knowledge.content += `<Document>${\n        newDoc.document_title\n          ? `This is a fragment titled ${newDoc.document_title}`\n          : ''\n      } From file ${newDoc.filename}.\\nA fragment from document\\n${newDoc.document_content}</Document>`\n      knowledge.chunks.push({\n        score: chunk.similarity ?? 0,\n        chunk_id: chunk.id,\n      })\n    }\n  })\n\n  return knowledge\n}\n",
    "importStatements": [
      "import { premiumModelsMap, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'",
      "import { cleanText } from '@/lib/utils.ts'",
      "import { tokenizer } from '@/lib/tokenizer.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import { addOrgDailyTokens } from '@/services/supabase/organizations.ts'",
      "import { HTTPException } from 'npm:hono@4.1.0/http-exception'",
      "import { redis } from '@/lib/redis.ts'",
      "import { createEmbedding } from '@/lib/embeddings/index.ts'",
      "import { Decimal } from 'npm:decimal.js@10.4.3'"
    ],
    "codeNoBody": "// deno-lint-ignore-file\n// Utils\nimport { premiumModelsMap, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { cleanText } from '@/lib/utils.ts'\nimport { tokenizer } from '@/lib/tokenizer.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { HTTPException } from 'npm:hono@4.1.0/http-exception'\nimport { redis } from '@/lib/redis.ts'\nimport { createEmbedding } from '@/lib/embeddings/index.ts'\nimport { Decimal } from 'npm:decimal.js@10.4.3'\ninterface Props {\n//...\n}\n\ninterface Chunk {\n//...\n}\n\nexport async function getToolsKnowledge(\n  {\n    agent,\n    lastMessage: lastMessageParam,\n    dailyMaxUsage,\n    dailyUsage,\n    userOrgId,\n    statusId,\n  }: Props,\n) {\n       //...\n       }\n\n// Helper functions\n\nfunction getModelMaxChunks(model: string | undefined) {\n//...\n}\n\nfunction processDocuments(chunks: Chunk[]) {\n//...\n}\n\nfunction createKnowledge(chunks: Chunk[]) {\n//...\n}",
    "originFile": "\\lib\\chat\\tools-knowledge.ts"
  },
  {
    "id": "\\lib\\consts::PLAN_TEMP_USAGE_DATE",
    "language": "typescript",
    "label": "PLAN_TEMP_USAGE_DATE",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 26,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const PLAN_TEMP_USAGE_DATE = new Date('2024-06-01T00:00:00.000Z')",
    "importStatements": [],
    "codeNoBody": "export const PLAN_TEMP_USAGE_DATE = new Date('2024-06-01T00:00:00.000Z')",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::UNLIMITED_MAX_USAGE",
    "language": "typescript",
    "label": "UNLIMITED_MAX_USAGE",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 10,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const UNLIMITED_MAX_USAGE = -1",
    "importStatements": [],
    "codeNoBody": "export const UNLIMITED_MAX_USAGE = -1",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::channels",
    "language": "typescript",
    "label": "channels",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 80,
    "inDegree": 11,
    "outDegree": 0,
    "code": "export const channels = [\n  'SDK_JS',\n  'SDK_JS DOCUMENTS',\n  'SDK_PYTHON',\n  'SDK_PYTHON DOCUMENTS',\n  'WHATSAPP',\n  'EXTENSION',\n  'VSCODE',\n  'PLAYGROUND',\n  'PLAYGROUND MARKETPLACE',\n  'PLAYGROUND DOCUMENTS',\n  'DOCUMENTS',\n  'API',\n] as const",
    "importStatements": [],
    "codeNoBody": "export const channels = [\n  'SDK_JS',\n  'SDK_JS DOCUMENTS',\n  'SDK_PYTHON',\n  'SDK_PYTHON DOCUMENTS',\n  'WHATSAPP',\n  'EXTENSION',\n  'VSCODE',\n  'PLAYGROUND',\n  'PLAYGROUND MARKETPLACE',\n  'PLAYGROUND DOCUMENTS',\n  'DOCUMENTS',\n  'API',\n] as const",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::freeTrialExtensionFormURL",
    "language": "typescript",
    "label": "freeTrialExtensionFormURL",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 27,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const freeTrialExtensionFormURL = 'https://forms.gle/dmrFXYamEgvtY94w6'",
    "importStatements": [],
    "codeNoBody": "export const freeTrialExtensionFormURL = 'https://forms.gle/dmrFXYamEgvtY94w6'",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::freePlanId",
    "language": "typescript",
    "label": "freePlanId",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 24,
    "inDegree": 22,
    "outDegree": 0,
    "code": "export const freePlanId = '64f219453a7d65c1e6ea1a56'",
    "importStatements": [],
    "codeNoBody": "export const freePlanId = '64f219453a7d65c1e6ea1a56'",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::freeTrialPlanId",
    "language": "typescript",
    "label": "freeTrialPlanId",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 25,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const freeTrialPlanId = '64f219453a7d65c1e6ea1a55'",
    "importStatements": [],
    "codeNoBody": "export const freeTrialPlanId = '64f219453a7d65c1e6ea1a55'",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::templateLocaleMap",
    "language": "typescript",
    "label": "templateLocaleMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 461,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const templateLocaleMap = {\n  es: {\n    'org-invitation': {\n      subject: 'Invitación para unirte a {{organizationName}} en CodeGPT',\n      text:\n        'Saludos,\\n\\nHas sido invitado a unirte a la organización {{organizationName}} en CodeGPT por {{inviter.name}} ({{inviter.email}}).\\n\\nSaludos,\\nEquipo de CodeGPT',\n      html:\n        \"<h1>Saludos,</h1><p>Has sido invitado a unirte a la organización <b>{{organizationName}}</b> en CodeGPT por <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Ver Invitación</a></p><p>Saludos,</p><p>Equipo de CodeGPT</p>\",\n    },\n  },\n  en: {\n    'org-invitation': {\n      subject: 'Invitation to join {{organizationName}} on CodeGPT',\n      text:\n        'Greetings,\\n\\nYou have been invited to join the organization {{organizationName}} on CodeGPT by {{inviter.name}} ({{inviter.email}}).\\n\\nBest,\\nCodeGPT Team',\n      html:\n        \"<h1>Greetings,</h1><p>You have been invited to join the organization <b>{{organizationName}}</b> on CodeGPT by <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Check Invitation</a></p><p>Best,</p><p>CodeGPT Team</p>\",\n    },\n  },\n} as const",
    "importStatements": [],
    "codeNoBody": "export const templateLocaleMap = {\n  es: {\n    'org-invitation': {\n      subject: 'Invitación para unirte a {{organizationName}} en CodeGPT',\n      text:\n        'Saludos,\\n\\nHas sido invitado a unirte a la organización {{organizationName}} en CodeGPT por {{inviter.name}} ({{inviter.email}}).\\n\\nSaludos,\\nEquipo de CodeGPT',\n      html:\n        \"<h1>Saludos,</h1><p>Has sido invitado a unirte a la organización <b>{{organizationName}}</b> en CodeGPT por <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Ver Invitación</a></p><p>Saludos,</p><p>Equipo de CodeGPT</p>\",\n    },\n  },\n  en: {\n    'org-invitation': {\n      subject: 'Invitation to join {{organizationName}} on CodeGPT',\n      text:\n        'Greetings,\\n\\nYou have been invited to join the organization {{organizationName}} on CodeGPT by {{inviter.name}} ({{inviter.email}}).\\n\\nBest,\\nCodeGPT Team',\n      html:\n        \"<h1>Greetings,</h1><p>You have been invited to join the organization <b>{{organizationName}}</b> on CodeGPT by <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Check Invitation</a></p><p>Best,</p><p>CodeGPT Team</p>\",\n    },\n  },\n} as const",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::premiumModelsMap",
    "language": "typescript",
    "label": "premiumModelsMap",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 418,
    "inDegree": 2,
    "outDegree": 1,
    "code": "export const premiumModelsMap = new Map([\n  [\n    'gpt-3.5-turbo',\n    {\n      name: 'gpt-3.5-turbo',\n      max_tokens: 4096,\n      max_chunks: getMaxChunks(4096),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-3.5-turbo-16k',\n    {\n      name: 'gpt-3.5-turbo-16k',\n      max_tokens: 16384,\n      max_chunks: getMaxChunks(16384),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4',\n    {\n      name: 'gpt-4',\n      max_tokens: 8192,\n      max_chunks: getMaxChunks(8192),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4-turbo',\n    {\n      name: 'gpt-4-turbo',\n      max_tokens: 128000,\n      max_chunks: getMaxChunks(128000),\n      provider: 'OpenAI',\n    },\n  ],\n  // [\n  //   'gpt-4-vision-preview',\n  //   {\n  //     name: 'gpt-4-vision',\n  //     max_tokens: 128000,\n  //     max_chunks: getMaxChunks(128000),\n  //     provider: 'OpenAI'\n  //   }\n  // ],\n  [\n    'claude-2.1',\n    {\n      name: 'claude-2.1',\n      max_tokens: 200000,\n      max_chunks: getMaxChunks(200000),\n      provider: 'Anthropic',\n    },\n  ],\n  [\n    'claude-instant-1.2',\n    {\n      name: 'claude-instant-1.2',\n      max_tokens: 100000,\n      max_chunks: getMaxChunks(100000),\n      provider: 'Anthropic',\n    },\n  ],\n])",
    "importStatements": [],
    "codeNoBody": "export const premiumModelsMap = new Map([\n  [\n    'gpt-3.5-turbo',\n    {\n      name: 'gpt-3.5-turbo',\n      max_tokens: 4096,\n      max_chunks: getMaxChunks(4096),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-3.5-turbo-16k',\n    {\n      name: 'gpt-3.5-turbo-16k',\n      max_tokens: 16384,\n      max_chunks: getMaxChunks(16384),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4',\n    {\n      name: 'gpt-4',\n      max_tokens: 8192,\n      max_chunks: getMaxChunks(8192),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4-turbo',\n    {\n      name: 'gpt-4-turbo',\n      max_tokens: 128000,\n      max_chunks: getMaxChunks(128000),\n      provider: 'OpenAI',\n    },\n  ],\n  // [\n  //   'gpt-4-vision-preview',\n  //   {\n  //     name: 'gpt-4-vision',\n  //     max_tokens: 128000,\n  //     max_chunks: getMaxChunks(128000),\n  //     provider: 'OpenAI'\n  //   }\n  // ],\n  [\n    'claude-2.1',\n    {\n      name: 'claude-2.1',\n      max_tokens: 200000,\n      max_chunks: getMaxChunks(200000),\n      provider: 'Anthropic',\n    },\n  ],\n  [\n    'claude-instant-1.2',\n    {\n      name: 'claude-instant-1.2',\n      max_tokens: 100000,\n      max_chunks: getMaxChunks(100000),\n      provider: 'Anthropic',\n    },\n  ],\n])",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::getMaxChunks",
    "language": "typescript",
    "label": "getMaxChunks",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 20,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const getMaxChunks = (tokens: number) => Math.floor(tokens / CHUNK_SIZE) - 1",
    "importStatements": [],
    "codeNoBody": "const getMaxChunks = (tokens: number) => {\n//...\n}",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::CHUNK_SIZE",
    "language": "typescript",
    "label": "CHUNK_SIZE",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 9,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const CHUNK_SIZE = 512 // Tokens",
    "importStatements": [],
    "codeNoBody": "export const CHUNK_SIZE = 512 // Tokens",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts::ACCEPTED_IMAGE_FILES",
    "language": "typescript",
    "label": "ACCEPTED_IMAGE_FILES",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts",
    "totalTokens": 23,
    "inDegree": 7,
    "outDegree": 0,
    "code": "export const ACCEPTED_IMAGE_FILES = ['jpg', 'jpeg', 'png', 'webp', 'gif']",
    "importStatements": [],
    "codeNoBody": "export const ACCEPTED_IMAGE_FILES = ['jpg', 'jpeg', 'png', 'webp', 'gif']",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\consts.ts",
    "type": "file",
    "totalTokens": 1128,
    "inDegree": 0,
    "outDegree": 11,
    "code": "export const ACCEPTED_IMAGE_FILES = ['jpg', 'jpeg', 'png', 'webp', 'gif']\n\nexport const CHUNK_SIZE = 512 // Tokens\nconst getMaxChunks = (tokens: number) => Math.floor(tokens / CHUNK_SIZE) - 1\n\nexport const premiumModelsMap = new Map([\n  [\n    'gpt-3.5-turbo',\n    {\n      name: 'gpt-3.5-turbo',\n      max_tokens: 4096,\n      max_chunks: getMaxChunks(4096),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-3.5-turbo-16k',\n    {\n      name: 'gpt-3.5-turbo-16k',\n      max_tokens: 16384,\n      max_chunks: getMaxChunks(16384),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4',\n    {\n      name: 'gpt-4',\n      max_tokens: 8192,\n      max_chunks: getMaxChunks(8192),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4-turbo',\n    {\n      name: 'gpt-4-turbo',\n      max_tokens: 128000,\n      max_chunks: getMaxChunks(128000),\n      provider: 'OpenAI',\n    },\n  ],\n  // [\n  //   'gpt-4-vision-preview',\n  //   {\n  //     name: 'gpt-4-vision',\n  //     max_tokens: 128000,\n  //     max_chunks: getMaxChunks(128000),\n  //     provider: 'OpenAI'\n  //   }\n  // ],\n  [\n    'claude-2.1',\n    {\n      name: 'claude-2.1',\n      max_tokens: 200000,\n      max_chunks: getMaxChunks(200000),\n      provider: 'Anthropic',\n    },\n  ],\n  [\n    'claude-instant-1.2',\n    {\n      name: 'claude-instant-1.2',\n      max_tokens: 100000,\n      max_chunks: getMaxChunks(100000),\n      provider: 'Anthropic',\n    },\n  ],\n])\n\nexport const templateLocaleMap = {\n  es: {\n    'org-invitation': {\n      subject: 'Invitación para unirte a {{organizationName}} en CodeGPT',\n      text:\n        'Saludos,\\n\\nHas sido invitado a unirte a la organización {{organizationName}} en CodeGPT por {{inviter.name}} ({{inviter.email}}).\\n\\nSaludos,\\nEquipo de CodeGPT',\n      html:\n        \"<h1>Saludos,</h1><p>Has sido invitado a unirte a la organización <b>{{organizationName}}</b> en CodeGPT por <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Ver Invitación</a></p><p>Saludos,</p><p>Equipo de CodeGPT</p>\",\n    },\n  },\n  en: {\n    'org-invitation': {\n      subject: 'Invitation to join {{organizationName}} on CodeGPT',\n      text:\n        'Greetings,\\n\\nYou have been invited to join the organization {{organizationName}} on CodeGPT by {{inviter.name}} ({{inviter.email}}).\\n\\nBest,\\nCodeGPT Team',\n      html:\n        \"<h1>Greetings,</h1><p>You have been invited to join the organization <b>{{organizationName}}</b> on CodeGPT by <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Check Invitation</a></p><p>Best,</p><p>CodeGPT Team</p>\",\n    },\n  },\n} as const\n\nexport const freeTrialPlanId = '64f219453a7d65c1e6ea1a55'\nexport const freePlanId = '64f219453a7d65c1e6ea1a56'\n\nexport const freeTrialExtensionFormURL = 'https://forms.gle/dmrFXYamEgvtY94w6'\n\nexport const channels = [\n  'SDK_JS',\n  'SDK_JS DOCUMENTS',\n  'SDK_PYTHON',\n  'SDK_PYTHON DOCUMENTS',\n  'WHATSAPP',\n  'EXTENSION',\n  'VSCODE',\n  'PLAYGROUND',\n  'PLAYGROUND MARKETPLACE',\n  'PLAYGROUND DOCUMENTS',\n  'DOCUMENTS',\n  'API',\n] as const\n\nexport const UNLIMITED_MAX_USAGE = -1\nexport const PLAN_TEMP_USAGE_DATE = new Date('2024-06-01T00:00:00.000Z')\n",
    "importStatements": [],
    "codeNoBody": "export const ACCEPTED_IMAGE_FILES = ['jpg', 'jpeg', 'png', 'webp', 'gif']\nexport const CHUNK_SIZE = 512 // Tokens\nconst getMaxChunks = (tokens: number) => {\n//...\n}\n\nexport const premiumModelsMap = new Map([\n  [\n    'gpt-3.5-turbo',\n    {\n      name: 'gpt-3.5-turbo',\n      max_tokens: 4096,\n      max_chunks: getMaxChunks(4096),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-3.5-turbo-16k',\n    {\n      name: 'gpt-3.5-turbo-16k',\n      max_tokens: 16384,\n      max_chunks: getMaxChunks(16384),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4',\n    {\n      name: 'gpt-4',\n      max_tokens: 8192,\n      max_chunks: getMaxChunks(8192),\n      provider: 'OpenAI',\n    },\n  ],\n  [\n    'gpt-4-turbo',\n    {\n      name: 'gpt-4-turbo',\n      max_tokens: 128000,\n      max_chunks: getMaxChunks(128000),\n      provider: 'OpenAI',\n    },\n  ],\n  // [\n  //   'gpt-4-vision-preview',\n  //   {\n  //     name: 'gpt-4-vision',\n  //     max_tokens: 128000,\n  //     max_chunks: getMaxChunks(128000),\n  //     provider: 'OpenAI'\n  //   }\n  // ],\n  [\n    'claude-2.1',\n    {\n      name: 'claude-2.1',\n      max_tokens: 200000,\n      max_chunks: getMaxChunks(200000),\n      provider: 'Anthropic',\n    },\n  ],\n  [\n    'claude-instant-1.2',\n    {\n      name: 'claude-instant-1.2',\n      max_tokens: 100000,\n      max_chunks: getMaxChunks(100000),\n      provider: 'Anthropic',\n    },\n  ],\n])\n\nexport const templateLocaleMap = {\n  es: {\n    'org-invitation': {\n      subject: 'Invitación para unirte a {{organizationName}} en CodeGPT',\n      text:\n        'Saludos,\\n\\nHas sido invitado a unirte a la organización {{organizationName}} en CodeGPT por {{inviter.name}} ({{inviter.email}}).\\n\\nSaludos,\\nEquipo de CodeGPT',\n      html:\n        \"<h1>Saludos,</h1><p>Has sido invitado a unirte a la organización <b>{{organizationName}}</b> en CodeGPT por <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Ver Invitación</a></p><p>Saludos,</p><p>Equipo de CodeGPT</p>\",\n    },\n  },\n  en: {\n    'org-invitation': {\n      subject: 'Invitation to join {{organizationName}} on CodeGPT',\n      text:\n        'Greetings,\\n\\nYou have been invited to join the organization {{organizationName}} on CodeGPT by {{inviter.name}} ({{inviter.email}}).\\n\\nBest,\\nCodeGPT Team',\n      html:\n        \"<h1>Greetings,</h1><p>You have been invited to join the organization <b>{{organizationName}}</b> on CodeGPT by <b>{{inviter.name}} ({{inviter.email}})</b>.</p><p style=\\\"text-align:center; margin: 1.25rem auto;\\\"><a ses:no-track href='https://beta.codegpt.co/' style='padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none;'>Check Invitation</a></p><p>Best,</p><p>CodeGPT Team</p>\",\n    },\n  },\n} as const\n\nexport const freeTrialPlanId = '64f219453a7d65c1e6ea1a55'\nexport const freePlanId = '64f219453a7d65c1e6ea1a56'\n\nexport const freeTrialExtensionFormURL = 'https://forms.gle/dmrFXYamEgvtY94w6'\n\nexport const channels = [\n  'SDK_JS',\n  'SDK_JS DOCUMENTS',\n  'SDK_PYTHON',\n  'SDK_PYTHON DOCUMENTS',\n  'WHATSAPP',\n  'EXTENSION',\n  'VSCODE',\n  'PLAYGROUND',\n  'PLAYGROUND MARKETPLACE',\n  'PLAYGROUND DOCUMENTS',\n  'DOCUMENTS',\n  'API',\n] as const\n\nexport const UNLIMITED_MAX_USAGE = -1\nexport const PLAN_TEMP_USAGE_DATE = new Date('2024-06-01T00:00:00.000Z')",
    "originFile": "\\lib\\consts.ts"
  },
  {
    "id": "\\lib\\db\\index::sql",
    "language": "typescript",
    "label": "sql",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\db\\index",
    "totalTokens": 89,
    "inDegree": 67,
    "outDegree": 1,
    "code": "export const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  ssl: {\n    caCerts: [getEnv('SUPABASE_CA_CERTIFICATE')],\n  },\n  connect_timeout: 20,\n  idle_timeout: 20,\n})",
    "importStatements": [],
    "codeNoBody": "export const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  ssl: {\n    caCerts: [getEnv('SUPABASE_CA_CERTIFICATE')],\n  },\n  connect_timeout: 20,\n  idle_timeout: 20,\n})",
    "originFile": "\\lib\\db\\index.ts"
  },
  {
    "id": "\\lib\\db\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\db\\index.ts",
    "type": "file",
    "totalTokens": 123,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import postgres from 'https://deno.land/x/postgresjs@v3.4.3/mod.js'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  ssl: {\n    caCerts: [getEnv('SUPABASE_CA_CERTIFICATE')],\n  },\n  connect_timeout: 20,\n  idle_timeout: 20,\n})\n",
    "importStatements": [
      "import postgres from 'https://deno.land/x/postgresjs@v3.4.3/mod.js'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import postgres from 'https://deno.land/x/postgresjs@v3.4.3/mod.js'\nimport { getEnv } from '@/lib/env.ts'\nexport const sql = postgres({\n  host: getEnv('DATABASE_HOST'),\n  database: getEnv('DATABASE_NAME'),\n  port: Number(getEnv('DATABASE_PORT')),\n  user: getEnv('DATABASE_USERNAME'),\n  password: getEnv('DATABASE_PASSWORD'),\n  ssl: {\n    caCerts: [getEnv('SUPABASE_CA_CERTIFICATE')],\n  },\n  connect_timeout: 20,\n  idle_timeout: 20,\n})",
    "originFile": "\\lib\\db\\index.ts"
  },
  {
    "id": "\\lib\\email::normalizeEmail",
    "language": "typescript",
    "label": "normalizeEmail",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email",
    "totalTokens": 151,
    "inDegree": 1,
    "outDegree": 1,
    "code": "const normalizeEmail = (eMail: string): string => {\n  if (typeof eMail !== 'string') {\n    throw new TypeError('normalizeEmail expects a string')\n  }\n\n  const email = eMail.toLowerCase()\n  const split = email.split('@')\n  let username = split[0]\n  const domainPart = split[split.length - 1]\n\n  if (!domainPart) {\n    throw new Error('Invalid email format')\n  }\n\n  const normalizationRule = normalizeableProviders[domainPart]\n\n  if (normalizationRule?.cut) {\n    username = username.replace(normalizationRule.cut, '')\n  }\n\n  const finalDomain = normalizationRule?.aliasOf || domainPart\n\n  return `${username}@${finalDomain}`\n}",
    "importStatements": [],
    "codeNoBody": "const normalizeEmail = (eMail: string): string => {\n       //...\n       }",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\email::normalizeableProviders",
    "language": "typescript",
    "label": "normalizeableProviders",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email",
    "totalTokens": 94,
    "inDegree": 2,
    "outDegree": 3,
    "code": "const normalizeableProviders: ProviderNormalizationRules = {\n  'gmail.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'googlemail.com': {\n    cut: PLUS_AND_DOT,\n    aliasOf: 'gmail.com',\n  },\n  'hotmail.com': {\n    cut: PLUS_ONLY,\n  },\n  'live.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'outlook.com': {\n    cut: PLUS_ONLY,\n  },\n}",
    "importStatements": [],
    "codeNoBody": "const normalizeableProviders: ProviderNormalizationRules = {\n  'gmail.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'googlemail.com': {\n    cut: PLUS_AND_DOT,\n    aliasOf: 'gmail.com',\n  },\n  'hotmail.com': {\n    cut: PLUS_ONLY,\n  },\n  'live.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'outlook.com': {\n    cut: PLUS_ONLY,\n  },\n}",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\email::ProviderNormalizationRules",
    "language": "typescript",
    "label": "ProviderNormalizationRules",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email",
    "totalTokens": 26,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type ProviderNormalizationRules = Record<\n  string,\n  {\n    cut: RegExp\n    aliasOf?: string\n  }\n>",
    "importStatements": [],
    "codeNoBody": "type ProviderNormalizationRules = Record<\n  string,\n  {\n    cut: RegExp\n    aliasOf?: string\n  }\n>",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\email::PLUS_AND_DOT",
    "language": "typescript",
    "label": "PLUS_AND_DOT",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email",
    "totalTokens": 15,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const PLUS_AND_DOT = /(\\.|(\\+[^@]*))/g",
    "importStatements": [],
    "codeNoBody": "const PLUS_AND_DOT = /(\\.|(\\+[^@]*))/g",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\email::PLUS_ONLY",
    "language": "typescript",
    "label": "PLUS_ONLY",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email",
    "totalTokens": 10,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const PLUS_ONLY = /\\+[^@]*/",
    "importStatements": [],
    "codeNoBody": "const PLUS_ONLY = /\\+[^@]*/",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\email",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\email.ts",
    "type": "file",
    "totalTokens": 298,
    "inDegree": 0,
    "outDegree": 5,
    "code": "const PLUS_ONLY = /\\+[^@]*/\nconst PLUS_AND_DOT = /(\\.|(\\+[^@]*))/g\n\ntype ProviderNormalizationRules = Record<\n  string,\n  {\n    cut: RegExp\n    aliasOf?: string\n  }\n>\n\nconst normalizeableProviders: ProviderNormalizationRules = {\n  'gmail.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'googlemail.com': {\n    cut: PLUS_AND_DOT,\n    aliasOf: 'gmail.com',\n  },\n  'hotmail.com': {\n    cut: PLUS_ONLY,\n  },\n  'live.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'outlook.com': {\n    cut: PLUS_ONLY,\n  },\n}\n\nexport const normalizeEmail = (eMail: string): string => {\n  if (typeof eMail !== 'string') {\n    throw new TypeError('normalizeEmail expects a string')\n  }\n\n  const email = eMail.toLowerCase()\n  const split = email.split('@')\n  let username = split[0]\n  const domainPart = split[split.length - 1]\n\n  if (!domainPart) {\n    throw new Error('Invalid email format')\n  }\n\n  const normalizationRule = normalizeableProviders[domainPart]\n\n  if (normalizationRule?.cut) {\n    username = username.replace(normalizationRule.cut, '')\n  }\n\n  const finalDomain = normalizationRule?.aliasOf || domainPart\n\n  return `${username}@${finalDomain}`\n}\n",
    "importStatements": [],
    "codeNoBody": "const PLUS_ONLY = /\\+[^@]*/\nconst PLUS_AND_DOT = /(\\.|(\\+[^@]*))/g\ntype ProviderNormalizationRules = Record<\n  string,\n  {\n    cut: RegExp\n    aliasOf?: string\n  }\n>\n\nconst normalizeableProviders: ProviderNormalizationRules = {\n  'gmail.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'googlemail.com': {\n    cut: PLUS_AND_DOT,\n    aliasOf: 'gmail.com',\n  },\n  'hotmail.com': {\n    cut: PLUS_ONLY,\n  },\n  'live.com': {\n    cut: PLUS_AND_DOT,\n  },\n  'outlook.com': {\n    cut: PLUS_ONLY,\n  },\n}\n\nexport const normalizeEmail = (eMail: string): string => {\n       //...\n       }",
    "originFile": "\\lib\\email.ts"
  },
  {
    "id": "\\lib\\embeddings\\index::createEmbedding",
    "language": "typescript",
    "label": "createEmbedding",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\embeddings\\index",
    "totalTokens": 67,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function createEmbedding({ model, input }: Props) {\n  if (model === 'text-embedding-ada-002') {\n    const res = await openaiClient().getEmbeddings(\n      AZURE_MODELS_MAP[model].model,\n      input,\n    )\n\n    return res.data\n  }\n\n  return []\n}",
    "importStatements": [],
    "codeNoBody": "async function createEmbedding({ model, input }: Props) {\n       //...\n       }",
    "originFile": "\\lib\\embeddings\\index.ts"
  },
  {
    "id": "\\lib\\embeddings\\index::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\embeddings\\index",
    "totalTokens": 14,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Props {\n  model: string\n  input: string[]\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\lib\\embeddings\\index.ts"
  },
  {
    "id": "\\lib\\embeddings\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\embeddings\\index.ts",
    "type": "file",
    "totalTokens": 117,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { openaiClient } from '@/services/ai/azure/index.ts'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\n\ninterface Props {\n  model: string\n  input: string[]\n}\n\nexport async function createEmbedding({ model, input }: Props) {\n  if (model === 'text-embedding-ada-002') {\n    const res = await openaiClient().getEmbeddings(\n      AZURE_MODELS_MAP[model].model,\n      input,\n    )\n\n    return res.data\n  }\n\n  return []\n}\n",
    "importStatements": [
      "import { openaiClient } from '@/services/ai/azure/index.ts'",
      "import { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'"
    ],
    "codeNoBody": "import { openaiClient } from '@/services/ai/azure/index.ts'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\ninterface Props {\n//...\n}\n\nexport async function createEmbedding({ model, input }: Props) {\n       //...\n       }",
    "originFile": "\\lib\\embeddings\\index.ts"
  },
  {
    "id": "\\lib\\env::getEnv",
    "language": "typescript",
    "label": "getEnv",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\env",
    "totalTokens": 44,
    "inDegree": 41,
    "outDegree": 1,
    "code": "function getEnv(key: keyof Env) {\n  const env = Deno.env.get(key)\n\n  if (!env) {\n    throw new Error(`Missing environment variable: ${key}`)\n  }\n\n  return env\n}",
    "importStatements": [],
    "codeNoBody": "function getEnv(key: keyof Env) {\n       //...\n       }",
    "originFile": "\\lib\\env.ts"
  },
  {
    "id": "\\lib\\env",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\env.ts",
    "type": "file",
    "totalTokens": 75,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import { Env } from '@/types/env.ts'\nimport 'https://deno.land/std@0.210.0/dotenv/load.ts'\n\nexport function getEnv(key: keyof Env) {\n  const env = Deno.env.get(key)\n\n  if (!env) {\n    throw new Error(`Missing environment variable: ${key}`)\n  }\n\n  return env\n}\n",
    "importStatements": [
      "import { Env } from '@/types/env.ts'",
      "import 'https://deno.land/std@0.210.0/dotenv/load.ts'"
    ],
    "codeNoBody": "import { Env } from '@/types/env.ts'\nimport 'https://deno.land/std@0.210.0/dotenv/load.ts'\nexport function getEnv(key: keyof Env) {\n       //...\n       }",
    "originFile": "\\lib\\env.ts"
  },
  {
    "id": "\\lib\\image::getBinaryStreamFromURL",
    "language": "typescript",
    "label": "getBinaryStreamFromURL",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 46,
    "inDegree": 2,
    "outDegree": 0,
    "code": "async function getBinaryStreamFromURL(URL: string) {\n  const response = await fetch(URL)\n  if (response.body === null) {\n    throw new Error('Invalid image url')\n  }\n\n  return response.body\n}",
    "importStatements": [],
    "codeNoBody": "async function getBinaryStreamFromURL(URL: string) {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image::isBase64Image",
    "language": "typescript",
    "label": "isBase64Image",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 30,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function isBase64Image(imageString: string): boolean {\n  return /^data:image\\/[^;]+;base64/.test(imageString)\n}",
    "importStatements": [],
    "codeNoBody": "function isBase64Image(imageString: string): boolean {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image::convertDataURIToBinary",
    "language": "typescript",
    "label": "convertDataURIToBinary",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 118,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function convertDataURIToBinary(dataURI: string) {\n  const BASE64_MARKER = ';base64,'\n  const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length\n  const base64 = dataURI.substring(base64Index)\n  const raw = atob(base64)\n  const rawLength = raw.length\n  const array = new Uint8Array(new ArrayBuffer(rawLength))\n\n  for (let i = 0; i < rawLength; i++) {\n    array[i] = raw.charCodeAt(i)\n  }\n  return array\n}",
    "importStatements": [],
    "codeNoBody": "function convertDataURIToBinary(dataURI: string) {\n//...\n}",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image::getImageDimensionsFromContent",
    "language": "typescript",
    "label": "getImageDimensionsFromContent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 110,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function getImageDimensionsFromContent(imageDataLink: string) {\n  let dimensions\n  if (isBase64Image(imageDataLink)) {\n    const image = convertDataURIToBinary(imageDataLink)\n    dimensions = imageDimensionsFromData(image)\n  } else {\n    const imageStream = await getBinaryStreamFromURL(imageDataLink)\n    dimensions = await imageDimensionsFromStream(imageStream)\n  }\n\n  return {\n    height: dimensions?.height ?? 0,\n    width: dimensions?.width ?? 0,\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getImageDimensionsFromContent(imageDataLink: string) {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image::getImageDimensions",
    "language": "typescript",
    "label": "getImageDimensions",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 295,
    "inDegree": 2,
    "outDegree": 0,
    "code": "async function getImageDimensions(image: File) {\n  const data = new Uint8Array(await image.arrayBuffer())\n\n  const dataView = new DataView(data.buffer)\n\n  if (image.type === 'image/png') {\n    return {\n      width: dataView.getUint32(16),\n      height: dataView.getUint32(20),\n    }\n  }\n  if (image.type === 'image/jpg' || image.type === 'image/jpeg') {\n    for (let i = 0; i < dataView.byteLength - 9; i++) { // - 9 prevent out-of-bounds access\n      if (\n        dataView.getUint16(i) === 0xFFC0 || dataView.getUint16(i) === 0xFFC2\n      ) {\n        return {\n          height: dataView.getUint16(i + 5),\n          width: dataView.getUint16(i + 7),\n        }\n      }\n    }\n  }\n\n  if (image.type === 'image/gif') {\n    return {\n      width: dataView.getUint16(6, true), // Width starts at byte 6 in GIF file\n      height: dataView.getUint16(8, true), // Height starts at byte 8 in GIF file\n    }\n  }\n\n  return {\n    width: dataView.getUint16(26, true),\n    height: dataView.getUint16(28, true),\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getImageDimensions(image: File) {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image::modifyImage",
    "language": "typescript",
    "label": "modifyImage",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image",
    "totalTokens": 257,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function modifyImage(\n  imageFile: File,\n  params: {\n    width: number\n    height?: number\n    mode: 'resize' | 'crop'\n  },\n) {\n  const imageBuffer = new Uint8Array(await imageFile.arrayBuffer())\n\n  const { width: originalWidth, height: originalHeight } =\n    await getImageDimensions(imageFile)\n\n  const ratio = originalWidth / originalHeight\n\n  if (!params.height) {\n    if (originalWidth > originalHeight) {\n      // Landscape\n      params.height = Math.round(params.width / ratio)\n    } else {\n      // Portrait\n      params.height = Math.round(ratio * params.width)\n    }\n  }\n\n  await initialize()\n  const sizingData = new MagickGeometry(\n    params.width,\n    params.height,\n  )\n  sizingData.ignoreAspectRatio = params.height > 0 && params.width > 0\n\n  return new Promise<Uint8Array>((resolve) => {\n    ImageMagick.read(imageBuffer, (image) => {\n      if (params.mode === 'resize') {\n        image.resize(sizingData)\n      } else {\n        image.crop(sizingData)\n      }\n      image.write(\n        (data) => resolve(data),\n      )\n    })\n  })\n}",
    "importStatements": [],
    "codeNoBody": "async function modifyImage(\n  imageFile: File,\n  params: {\n    width: number\n    height?: number\n    mode: 'resize' | 'crop'\n  },\n) {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\image",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\image.ts",
    "type": "file",
    "totalTokens": 921,
    "inDegree": 0,
    "outDegree": 6,
    "code": "import {\n  ImageMagick,\n  initialize,\n  MagickGeometry,\n} from 'https://deno.land/x/imagemagick_deno@0.0.26/mod.ts'\n\nimport {\n  imageDimensionsFromData,\n  imageDimensionsFromStream,\n} from 'image-dimensions'\n\nexport async function modifyImage(\n  imageFile: File,\n  params: {\n    width: number\n    height?: number\n    mode: 'resize' | 'crop'\n  },\n) {\n  const imageBuffer = new Uint8Array(await imageFile.arrayBuffer())\n\n  const { width: originalWidth, height: originalHeight } =\n    await getImageDimensions(imageFile)\n\n  const ratio = originalWidth / originalHeight\n\n  if (!params.height) {\n    if (originalWidth > originalHeight) {\n      // Landscape\n      params.height = Math.round(params.width / ratio)\n    } else {\n      // Portrait\n      params.height = Math.round(ratio * params.width)\n    }\n  }\n\n  await initialize()\n  const sizingData = new MagickGeometry(\n    params.width,\n    params.height,\n  )\n  sizingData.ignoreAspectRatio = params.height > 0 && params.width > 0\n\n  return new Promise<Uint8Array>((resolve) => {\n    ImageMagick.read(imageBuffer, (image) => {\n      if (params.mode === 'resize') {\n        image.resize(sizingData)\n      } else {\n        image.crop(sizingData)\n      }\n      image.write(\n        (data) => resolve(data),\n      )\n    })\n  })\n}\n\nexport async function getImageDimensions(image: File) {\n  const data = new Uint8Array(await image.arrayBuffer())\n\n  const dataView = new DataView(data.buffer)\n\n  if (image.type === 'image/png') {\n    return {\n      width: dataView.getUint32(16),\n      height: dataView.getUint32(20),\n    }\n  }\n  if (image.type === 'image/jpg' || image.type === 'image/jpeg') {\n    for (let i = 0; i < dataView.byteLength - 9; i++) { // - 9 prevent out-of-bounds access\n      if (\n        dataView.getUint16(i) === 0xFFC0 || dataView.getUint16(i) === 0xFFC2\n      ) {\n        return {\n          height: dataView.getUint16(i + 5),\n          width: dataView.getUint16(i + 7),\n        }\n      }\n    }\n  }\n\n  if (image.type === 'image/gif') {\n    return {\n      width: dataView.getUint16(6, true), // Width starts at byte 6 in GIF file\n      height: dataView.getUint16(8, true), // Height starts at byte 8 in GIF file\n    }\n  }\n\n  return {\n    width: dataView.getUint16(26, true),\n    height: dataView.getUint16(28, true),\n  }\n}\n\nexport async function getImageDimensionsFromContent(imageDataLink: string) {\n  let dimensions\n  if (isBase64Image(imageDataLink)) {\n    const image = convertDataURIToBinary(imageDataLink)\n    dimensions = imageDimensionsFromData(image)\n  } else {\n    const imageStream = await getBinaryStreamFromURL(imageDataLink)\n    dimensions = await imageDimensionsFromStream(imageStream)\n  }\n\n  return {\n    height: dimensions?.height ?? 0,\n    width: dimensions?.width ?? 0,\n  }\n}\n\nfunction convertDataURIToBinary(dataURI: string) {\n  const BASE64_MARKER = ';base64,'\n  const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length\n  const base64 = dataURI.substring(base64Index)\n  const raw = atob(base64)\n  const rawLength = raw.length\n  const array = new Uint8Array(new ArrayBuffer(rawLength))\n\n  for (let i = 0; i < rawLength; i++) {\n    array[i] = raw.charCodeAt(i)\n  }\n  return array\n}\n\nexport function isBase64Image(imageString: string): boolean {\n  return /^data:image\\/[^;]+;base64/.test(imageString)\n}\n\nexport async function getBinaryStreamFromURL(URL: string) {\n  const response = await fetch(URL)\n  if (response.body === null) {\n    throw new Error('Invalid image url')\n  }\n\n  return response.body\n}\n",
    "importStatements": [
      "import {\n  ImageMagick,\n  initialize,\n  MagickGeometry,\n} from 'https://deno.land/x/imagemagick_deno@0.0.26/mod.ts'",
      "import {\n  imageDimensionsFromData,\n  imageDimensionsFromStream,\n} from 'image-dimensions'"
    ],
    "codeNoBody": "import {\n  ImageMagick,\n  initialize,\n  MagickGeometry,\n} from 'https://deno.land/x/imagemagick_deno@0.0.26/mod.ts'\nimport {\n  imageDimensionsFromData,\n  imageDimensionsFromStream,\n} from 'image-dimensions'\n\nexport async function modifyImage(\n  imageFile: File,\n  params: {\n    width: number\n    height?: number\n    mode: 'resize' | 'crop'\n  },\n) {\n       //...\n       }\n\nexport async function getImageDimensions(image: File) {\n       //...\n       }\n\nexport async function getImageDimensionsFromContent(imageDataLink: string) {\n       //...\n       }\n\nfunction convertDataURIToBinary(dataURI: string) {\n//...\n}\n\nexport function isBase64Image(imageString: string): boolean {\n       //...\n       }\n\nexport async function getBinaryStreamFromURL(URL: string) {\n       //...\n       }",
    "originFile": "\\lib\\image.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils",
    "totalTokens": 165,
    "inDegree": 3,
    "outDegree": 0,
    "code": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n) {\n  try {\n    const response = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n        client_id: clientId,\n        client_secret: clientSecret,\n      }),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token: newAccessToken, refresh_token: newRefreshToken } =\n      response.data\n    return { newAccessToken, newRefreshToken }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils::TokenResponse",
    "language": "typescript",
    "label": "TokenResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils",
    "totalTokens": 17,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface TokenResponse {\n  access_token: string\n  refresh_token?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface TokenResponse {\n//...\n}",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils::getUserInfo",
    "language": "typescript",
    "label": "getUserInfo",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils",
    "totalTokens": 122,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function getUserInfo(accessToken: string): Promise<UserInfo> {\n  try {\n    const response: AxiosResponse<UserData> = await axios.get(\n      'https://api.bitbucket.org/2.0/user',\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n        },\n      },\n    )\n\n    const userData = response.data\n    const userId = userData.uuid\n    const userName = userData.username\n\n    return { userId, userName }\n  } catch (error) {\n    console.error('Error al obtener la información del usuario:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserInfo(accessToken: string): Promise<UserInfo> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils::UserInfo",
    "language": "typescript",
    "label": "UserInfo",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils",
    "totalTokens": 14,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserInfo {\n  userId: string\n  userName: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UserInfo {\n//...\n}",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils::UserData",
    "language": "typescript",
    "label": "UserData",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils",
    "totalTokens": 14,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserData {\n  uuid: string\n  username: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UserData {\n//...\n}",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\bitbucket-app\\utils",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\bitbucket-app\\utils.ts",
    "type": "file",
    "totalTokens": 345,
    "inDegree": 0,
    "outDegree": 8,
    "code": "import axios, { AxiosResponse } from 'axios'\n\ninterface UserData {\n  uuid: string\n  username: string\n}\n\ninterface UserInfo {\n  userId: string\n  userName: string\n}\n\nexport async function getUserInfo(accessToken: string): Promise<UserInfo> {\n  try {\n    const response: AxiosResponse<UserData> = await axios.get(\n      'https://api.bitbucket.org/2.0/user',\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n        },\n      },\n    )\n\n    const userData = response.data\n    const userId = userData.uuid\n    const userName = userData.username\n\n    return { userId, userName }\n  } catch (error) {\n    console.error('Error al obtener la información del usuario:', error)\n    throw error\n  }\n}\n\ninterface TokenResponse {\n  access_token: string\n  refresh_token?: string\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n) {\n  try {\n    const response = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n        client_id: clientId,\n        client_secret: clientSecret,\n      }),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token: newAccessToken, refresh_token: newRefreshToken } =\n      response.data\n    return { newAccessToken, newRefreshToken }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import axios, { AxiosResponse } from 'axios'"
    ],
    "codeNoBody": "import axios, { AxiosResponse } from 'axios'\ninterface UserData {\n//...\n}\n\ninterface UserInfo {\n//...\n}\n\nexport async function getUserInfo(accessToken: string): Promise<UserInfo> {\n       //...\n       }\n\ninterface TokenResponse {\n//...\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\bitbucket-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\codegpt::completions",
    "language": "typescript",
    "label": "completions",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\codegpt",
    "totalTokens": 1317,
    "inDegree": 2,
    "outDegree": 12,
    "code": "async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n  console.log('dentro de completions', agentId)\n\n  try {\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${null}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      throw new Error('No plan found')\n    }\n\n    if (!agent) {\n      throw new Error(`Agent with ID ${agentId} could not be found`)\n    }\n\n    if (agent?.is_frozen) {\n      throw new Error(\n        `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      )\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const userEmail = result[0].user_email\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      throw new Error('Daily interactions limit reached')\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: userEmail,\n      channel: 'DISCORD',\n      source: 'API',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'discord',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'discord',\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages: messages as ChatMessage[],\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'DISCORD',\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: false,\n      format: 'text',\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    const text = await response.json()\n\n    return text as unknown as string\n  } catch (error: unknown) {\n    console.error('Error capturado en el bloque catch:', error)\n    if (axios.isAxiosError(error)) {\n      console.error('Error details:', error.response?.data.error[0])\n    } else {\n      console.error('Error al enviar mensaje a CodeGPT:', error)\n    }\n    console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n    throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\codegpt.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\codegpt",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\codegpt.ts",
    "type": "file",
    "totalTokens": 2739,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import axios, { AxiosError } from 'axios'\nimport {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'\nimport dotenv from 'dotenv'\nimport type { Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { ChatMessage } from '@/types/index.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\ndotenv.config()\n\nexport async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n  console.log('dentro de completions', agentId)\n\n  try {\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${null}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      throw new Error('No plan found')\n    }\n\n    if (!agent) {\n      throw new Error(`Agent with ID ${agentId} could not be found`)\n    }\n\n    if (agent?.is_frozen) {\n      throw new Error(\n        `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      )\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const userEmail = result[0].user_email\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      throw new Error('Daily interactions limit reached')\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: userEmail,\n      channel: 'DISCORD',\n      source: 'API',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'discord',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'discord',\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages: messages as ChatMessage[],\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'DISCORD',\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: false,\n      format: 'text',\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    const text = await response.json()\n\n    return text as unknown as string\n  } catch (error: unknown) {\n    console.error('Error capturado en el bloque catch:', error)\n    if (axios.isAxiosError(error)) {\n      console.error('Error details:', error.response?.data.error[0])\n    } else {\n      console.error('Error al enviar mensaje a CodeGPT:', error)\n    }\n    console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n    throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n  }\n}\n\n// export async function completion(\n//   message: Message[]\n// ): Promise<CodeGPTResponse> {\n\n//   const payload: any = {\n//     messages: message,\n//     stream: false,\n//     format: 'text',\n//   }\n\n//   try {\n//     // console.log('payload', payload)\n//     // const response = await axios.post<CodeGPTResponse>(url, payload, {\n//     //   headers: {\n//     //     Authorization: `Bearer ${apiKey}`,\n//     //     'Content-Type': 'application/json',\n//     //   },\n//     // })\n\n//     // console.log('response OK', response.data)\n//     // return response.data\n//   } catch (error: unknown) {\n//     console.error('Error capturado en el bloque catch:', error)\n//     if (axios.isAxiosError(error)) {\n//       console.error('Error details:', error.response?.data.error[0])\n//     } else {\n//       console.error('Error al enviar mensaje a CodeGPT:', error)\n//     }\n//     console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n//     throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n//   }\n// }\n// export async function createAgent(nameAgent: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent`;\n//   const payload = { \"name\": nameAgent };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function getAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function listAgents(): Promise<any> {\n//   const url = `${apiEndpoint}/agent`\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function updateAgent(agentId: string, payload: any): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`\n\n//   try {\n//     const response = await axios.patch(url, payload, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function deleteAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.delete(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function usersMe(apiKey: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/me`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function loadDocuments(filename: string): Promise<any> {\n//   const filePath = `./Data/Documents/${filename}`;\n//   const fileContent = await fs.readFile(filePath);\n//   const formData = new FormData();\n//   formData.append('file', fileContent, { filename });\n//   const headers = {\n//     'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//     ...formData.getHeaders(),\n//   };\n//   const url = `${apiEndpoint}/document/load`;\n\n//   try {\n//     const response = await axios.post(url, formData, { headers });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function userExists(email: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/exists`;\n//   const payload = { email };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// function handleAxiosError(error: any): never {\n//   if (axios.isAxiosError(error)) {\n//     console.error('Error details:', error.response?.data.error[0])\n//     throw new Error(error.response?.data.error[0])\n//   } else {\n//     console.error('Error al enviar mensaje a CodeGPT:', error)\n//     throw new Error(error.message)\n//   }\n// }\n",
    "importStatements": [
      "import axios, { AxiosError } from 'axios'",
      "import {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'",
      "import dotenv from 'dotenv'",
      "import type { Context } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getUserAgentById } from '@/services/supabase/agents.ts'",
      "import {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { ChatMessage } from '@/types/index.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import axios, { AxiosError } from 'axios'\nimport {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'\nimport dotenv from 'dotenv'\nimport type { Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { ChatMessage } from '@/types/index.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\ndotenv.config()\nexport async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n       //...\n       }\n\n// export async function completion(\n//   message: Message[]\n// ): Promise<CodeGPTResponse> {\n\n//   const payload: any = {\n//     messages: message,\n//     stream: false,\n//     format: 'text',\n//   }\n\n//   try {\n//     // console.log('payload', payload)\n//     // const response = await axios.post<CodeGPTResponse>(url, payload, {\n//     //   headers: {\n//     //     Authorization: `Bearer ${apiKey}`,\n//     //     'Content-Type': 'application/json',\n//     //   },\n//     // })\n\n//     // console.log('response OK', response.data)\n//     // return response.data\n//   } catch (error: unknown) {\n//     console.error('Error capturado en el bloque catch:', error)\n//     if (axios.isAxiosError(error)) {\n//       console.error('Error details:', error.response?.data.error[0])\n//     } else {\n//       console.error('Error al enviar mensaje a CodeGPT:', error)\n//     }\n//     console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n//     throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n//   }\n// }\n// export async function createAgent(nameAgent: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent`;\n//   const payload = { \"name\": nameAgent };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function getAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function listAgents(): Promise<any> {\n//   const url = `${apiEndpoint}/agent`\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function updateAgent(agentId: string, payload: any): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`\n\n//   try {\n//     const response = await axios.patch(url, payload, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function deleteAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.delete(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function usersMe(apiKey: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/me`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function loadDocuments(filename: string): Promise<any> {\n//   const filePath = `./Data/Documents/${filename}`;\n//   const fileContent = await fs.readFile(filePath);\n//   const formData = new FormData();\n//   formData.append('file', fileContent, { filename });\n//   const headers = {\n//     'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//     ...formData.getHeaders(),\n//   };\n//   const url = `${apiEndpoint}/document/load`;\n\n//   try {\n//     const response = await axios.post(url, formData, { headers });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function userExists(email: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/exists`;\n//   const payload = { email };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// function handleAxiosError(error: any): never {\n//   if (axios.isAxiosError(error)) {\n//     console.error('Error details:', error.response?.data.error[0])\n//     throw new Error(error.response?.data.error[0])\n//   } else {\n//     console.error('Error al enviar mensaje a CodeGPT:', error)\n//     throw new Error(error.message)\n//   }\n// }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\codegpt.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\interfaces::CodeGPTConfig",
    "language": "typescript",
    "label": "CodeGPTConfig",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\interfaces",
    "totalTokens": 24,
    "inDegree": 2,
    "outDegree": 1,
    "code": "interface CodeGPTConfig {\n  apiEndpoint: string\n  apiKey: string\n  agentId: string\n}",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTConfig {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\interfaces::CodeGPTResponse",
    "language": "typescript",
    "label": "CodeGPTResponse",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\interfaces",
    "totalTokens": 7,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type CodeGPTResponse = string",
    "importStatements": [],
    "codeNoBody": "type CodeGPTResponse = string",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\interfaces::CodeGPTRequest",
    "language": "typescript",
    "label": "CodeGPTRequest",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\interfaces",
    "totalTokens": 45,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface CodeGPTRequest {\n  agentId: string\n  messages: Array<Message> // Aquí especificamos que 'messages' es un array de 'Message'\n  stream: boolean\n  format: string\n}",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTRequest {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\interfaces::Message",
    "language": "typescript",
    "label": "Message",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\interfaces",
    "totalTokens": 14,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Message {\n  role: string\n  content: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Message {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\codegpt\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts",
    "type": "file",
    "totalTokens": 148,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// Define la estructura de la solicitud a la API de CodeGPT\nexport interface Message {\n  role: string\n  content: string\n}\n\n// Usar la interfaz 'Message' para definir el tipo de elementos en 'messages'\nexport interface CodeGPTRequest {\n  agentId: string\n  messages: Array<Message> // Aquí especificamos que 'messages' es un array de 'Message'\n  stream: boolean\n  format: string\n}\nexport type CodeGPTResponse = string\n\n// Define la estructura de la configuración de la API de CodeGPT\nexport interface CodeGPTConfig {\n  apiEndpoint: string\n  apiKey: string\n  agentId: string\n}\n",
    "importStatements": [],
    "codeNoBody": "// Define la estructura de la solicitud a la API de CodeGPT\nexport interface Message {\n       //...\n       }\n// Usar la interfaz 'Message' para definir el tipo de elementos en 'messages'\nexport interface CodeGPTRequest {\n       //...\n       }\nexport type CodeGPTResponse = string\n\n// Define la estructura de la configuración de la API de CodeGPT\nexport interface CodeGPTConfig {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\chat::splitMessageIntoChunks",
    "language": "typescript",
    "label": "splitMessageIntoChunks",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\chat",
    "totalTokens": 121,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function splitMessageIntoChunks(\n  message: string,\n  maxChunkSize: number,\n): string[] {\n  const chunks: string[] = []\n  let currentChunk = ''\n\n  for (let i = 0; i < message.length; i++) {\n    const char = message[i]\n    if ((currentChunk + char).length <= maxChunkSize) {\n      currentChunk += char\n    } else {\n      chunks.push(currentChunk)\n      currentChunk = char\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk)\n  }\n\n  return chunks\n}",
    "importStatements": [],
    "codeNoBody": "function splitMessageIntoChunks(\n  message: string,\n  maxChunkSize: number,\n): string[] {\n//...\n}",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\chat.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\chat::handleChatCommand",
    "language": "typescript",
    "label": "handleChatCommand",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\chat",
    "totalTokens": 515,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function handleChatCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n  c: any,\n) {\n  try {\n    // pensar si le puedo dar historial\n    const message = [\n      {\n        role: 'user',\n        content: body.data.options[0].value,\n      },\n    ]\n    const serverId = body.channel.guild_id.toString()\n    const channelId = body.channel.id\n\n    let agentName = ''\n    const response = await sql`\n      select \n        ou.user_id,\n        ou.org_id,\n        coalesce(sc.agent_id, sw.agent_id) agent_id,\n        a.name as agent_name\n      from discord_servers sw\n      join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n      left join discord_channels sc on sc.server_id = sw.id  and sc.id = ${channelId}\n      left join agents a on a.id = coalesce(sc.agent_id, sw.agent_id)\n      where sw.id = ${serverId}`\n\n    let codeGPTResponse: string\n    let responseText\n\n    if (response.length === 0) {\n      responseText = 'The server or channel is not associated with any agent.'\n    } else {\n      const [{ user_id, org_id, agent_id, agent_name }] = response\n      const agentId = agent_id || serverId.agent_id\n      codeGPTResponse = agentId\n        ? await completions(message, agentId, user_id, org_id, c)\n        : 'The server or channel is not associated with any agent'\n\n      agentName = agent_name\n      responseText = codeGPTResponse\n    }\n    const res = `Your agent <${agentName}> says : ${responseText}`\n\n    if (!res) {\n      return {\n        statusCode: 200,\n        body: 'no response generated',\n      }\n    }\n\n    const chunks = splitMessageIntoChunks(res, 2000)\n\n    for (const chunk of chunks) {\n      await rest.post(Routes.webhook(CLIENT_ID as string, body.token), {\n        body: { content: chunk },\n      })\n    }\n\n    console.log('Pasó acá')\n    return {\n      statusCode: 200,\n      body: 'message sent',\n    }\n  } catch (error) {\n    console.error('Error sending message', error)\n    return {\n      statusCode: 400,\n      body: 'failed to sent message',\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function handleChatCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n  c: any,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\chat.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\chat.ts",
    "type": "file",
    "totalTokens": 693,
    "inDegree": 0,
    "outDegree": 2,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { REST, Routes } from 'discord.js'\nimport { sql } from '@/lib/db/index.ts'\nimport { completions } from '@/lib/integrations/discord-app/codegpt/codegpt.ts'\n\nexport async function handleChatCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n  c: any,\n) {\n  try {\n    // pensar si le puedo dar historial\n    const message = [\n      {\n        role: 'user',\n        content: body.data.options[0].value,\n      },\n    ]\n    const serverId = body.channel.guild_id.toString()\n    const channelId = body.channel.id\n\n    let agentName = ''\n    const response = await sql`\n      select \n        ou.user_id,\n        ou.org_id,\n        coalesce(sc.agent_id, sw.agent_id) agent_id,\n        a.name as agent_name\n      from discord_servers sw\n      join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n      left join discord_channels sc on sc.server_id = sw.id  and sc.id = ${channelId}\n      left join agents a on a.id = coalesce(sc.agent_id, sw.agent_id)\n      where sw.id = ${serverId}`\n\n    let codeGPTResponse: string\n    let responseText\n\n    if (response.length === 0) {\n      responseText = 'The server or channel is not associated with any agent.'\n    } else {\n      const [{ user_id, org_id, agent_id, agent_name }] = response\n      const agentId = agent_id || serverId.agent_id\n      codeGPTResponse = agentId\n        ? await completions(message, agentId, user_id, org_id, c)\n        : 'The server or channel is not associated with any agent'\n\n      agentName = agent_name\n      responseText = codeGPTResponse\n    }\n    const res = `Your agent <${agentName}> says : ${responseText}`\n\n    if (!res) {\n      return {\n        statusCode: 200,\n        body: 'no response generated',\n      }\n    }\n\n    const chunks = splitMessageIntoChunks(res, 2000)\n\n    for (const chunk of chunks) {\n      await rest.post(Routes.webhook(CLIENT_ID as string, body.token), {\n        body: { content: chunk },\n      })\n    }\n\n    console.log('Pasó acá')\n    return {\n      statusCode: 200,\n      body: 'message sent',\n    }\n  } catch (error) {\n    console.error('Error sending message', error)\n    return {\n      statusCode: 400,\n      body: 'failed to sent message',\n    }\n  }\n}\n\nfunction splitMessageIntoChunks(\n  message: string,\n  maxChunkSize: number,\n): string[] {\n  const chunks: string[] = []\n  let currentChunk = ''\n\n  for (let i = 0; i < message.length; i++) {\n    const char = message[i]\n    if ((currentChunk + char).length <= maxChunkSize) {\n      currentChunk += char\n    } else {\n      chunks.push(currentChunk)\n      currentChunk = char\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk)\n  }\n\n  return chunks\n}\n",
    "importStatements": [
      "import { REST, Routes } from 'discord.js'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { completions } from '@/lib/integrations/discord-app/codegpt/codegpt.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { REST, Routes } from 'discord.js'\nimport { sql } from '@/lib/db/index.ts'\nimport { completions } from '@/lib/integrations/discord-app/codegpt/codegpt.ts'\nexport async function handleChatCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n  c: any,\n) {\n       //...\n       }\n\nfunction splitMessageIntoChunks(\n  message: string,\n  maxChunkSize: number,\n): string[] {\n//...\n}",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\chat.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\resumen::resumidor",
    "language": "typescript",
    "label": "resumidor",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\resumen",
    "totalTokens": 273,
    "inDegree": 2,
    "outDegree": 0,
    "code": "async function resumidor(mensajes: any[]): Promise<string> {\n  try {\n    let resumen: string = ''\n\n    // Invierte el orden del array para empezar por el mensaje más viejo\n    mensajes.reverse().forEach((mensaje) => {\n      // Verifica si el mensaje proviene de un usuario (no de una aplicación o bot)\n      if (!mensaje.author.bot) {\n        const nombreAutor: string = mensaje.author.username\n        const hora: string = new Date(mensaje.timestamp).toLocaleTimeString() // Convierte la marca de tiempo a hora local\n        const contenido: string = mensaje.content || '' // Si no hay contenido, asigna una cadena vacía\n\n        // Agrega la información del mensaje al resumen\n        resumen += `${nombreAutor} (${hora}): ${contenido}\\n`\n      }\n    })\n\n    const message = [\n      {\n        role: 'user',\n        content:\n          `Haz un resumen de esta conversación: ${resumen}. Si no recibes nada de info ahí, responde que no hay conversaciones para la fecha requerida`,\n      },\n    ]\n    return await completions(message, agent as string)\n  } catch (error) {\n    console.error('Error en la función resumidor:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function resumidor(mensajes: any[]): Promise<string> {\n//...\n}",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\resumen.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\resumen::obtenerMensajesDesde",
    "language": "typescript",
    "label": "obtenerMensajesDesde",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\resumen",
    "totalTokens": 450,
    "inDegree": 2,
    "outDegree": 0,
    "code": "async function obtenerMensajesDesde(\n  rest: REST,\n  channelId: string,\n  fechaHora: Date,\n): Promise<any[]> {\n  try {\n    let mensajes: any[] = []\n    let ultimoId: string | null = null\n    let todosMensajesRecuperados = false\n\n    while (!todosMensajesRecuperados) {\n      const params: any = { limit: 100 }\n      if (ultimoId) {\n        params.before = ultimoId // Usamos 'before' para obtener mensajes anteriores\n      }\n\n      const data: any = await rest.get(Routes.channelMessages(channelId), {\n        query: params,\n      })\n      console.log('while', data.length)\n\n      if (data.length === 0 || data.length < params.limit) {\n        // No hay más mensajes en el canal o hemos recuperado menos mensajes que el límite\n        todosMensajesRecuperados = true\n        const mensajesFiltrados = data.filter(\n          (mensaje: any) => new Date(mensaje.timestamp) >= fechaHora,\n        )\n        mensajes = mensajes.concat(mensajesFiltrados)\n      } else {\n        console.log('2')\n        ultimoId = data[data.length - 1].id\n        const mensajesFiltrados = data.filter(\n          (mensaje: any) => new Date(mensaje.timestamp) >= fechaHora,\n        )\n        console.log('mensajes', mensajes.length)\n        mensajes = mensajes.concat(mensajesFiltrados)\n\n        // Si el último mensaje es igual o anterior a la fechaHora, detiene la búsqueda\n        if (new Date(data[data.length - 1].timestamp) < fechaHora) {\n          todosMensajesRecuperados = true\n        }\n      }\n    }\n    console.log('mensajes', mensajes.length)\n    if (mensajes.length === 0) {\n      console.log('No hay mensajes desde la fecha dada.')\n      return []\n    } else {\n      console.log('Mensajes recuperados:', mensajes)\n      return mensajes\n    }\n  } catch (error) {\n    console.error('Error al obtener mensajes:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function obtenerMensajesDesde(\n  rest: REST,\n  channelId: string,\n  fechaHora: Date,\n): Promise<any[]> {\n//...\n}",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\resumen.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\resumen::handleResumenCanalCommand",
    "language": "typescript",
    "label": "handleResumenCanalCommand",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\resumen",
    "totalTokens": 334,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function handleResumenCanalCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n) {\n  console.log('En resumen')\n  try {\n    // Extrae la fecha, la hora y el ID del canal del cuerpo de la interacción\n    const fecha = body.data.options.find(\n      (opt: any) => opt.name === 'fecha',\n    ).value\n    const hora = body.data.options.find(\n      (opt: any) => opt.name === 'hora',\n    ).value\n    const channelId = body.channel_id\n\n    // Convierte la fecha y la hora a un objeto Date de JavaScript\n    const fechaHora = new Date(`${fecha}T${hora}:00Z`) // Asume que la hora está en UTC\n\n    // Recupera los mensajes del canal desde la fecha y hora especificadas\n    const mensajes = await obtenerMensajesDesde(rest, channelId, fechaHora)\n\n    // Llama a la función \"resumidor\" con los mensajes recuperados\n    const resumen = await resumidor(mensajes)\n\n    // Envía el resumen como respuesta al usuario\n    await rest.post(Routes.webhook(CLIENT_ID as string, body.token), {\n      body: { content: resumen },\n    })\n\n    return {\n      statusCode: 200,\n      body: 'summary send',\n    }\n  } catch (error) {\n    console.error('Error al procesar el comando:', error)\n    return {\n      statusCode: 400,\n      body: 'Error al procesar el comando',\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function handleResumenCanalCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\resumen.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\resumen::agent",
    "language": "typescript",
    "label": "agent",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\resumen",
    "totalTokens": 16,
    "inDegree": 1,
    "outDegree": 0,
    "code": "const agent = Deno.env.get('CODEGPT_AGENT_ID') as string",
    "importStatements": [],
    "codeNoBody": "const agent = Deno.env.get('CODEGPT_AGENT_ID') as string",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\resumen.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\commands\\resumen",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\commands\\resumen.ts",
    "type": "file",
    "totalTokens": 1127,
    "inDegree": 0,
    "outDegree": 4,
    "code": "// deno-lint-ignore-file no-explicit-any no-inferrable-types\n\nimport { REST, Routes } from 'discord.js'\nimport dotenv from 'dotenv'\nimport { completions } from '../codegpt/codegpt.ts'\n\ndotenv.config()\n\nconst agent = Deno.env.get('CODEGPT_AGENT_ID') as string\n\nexport async function handleResumenCanalCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n) {\n  console.log('En resumen')\n  try {\n    // Extrae la fecha, la hora y el ID del canal del cuerpo de la interacción\n    const fecha = body.data.options.find(\n      (opt: any) => opt.name === 'fecha',\n    ).value\n    const hora = body.data.options.find(\n      (opt: any) => opt.name === 'hora',\n    ).value\n    const channelId = body.channel_id\n\n    // Convierte la fecha y la hora a un objeto Date de JavaScript\n    const fechaHora = new Date(`${fecha}T${hora}:00Z`) // Asume que la hora está en UTC\n\n    // Recupera los mensajes del canal desde la fecha y hora especificadas\n    const mensajes = await obtenerMensajesDesde(rest, channelId, fechaHora)\n\n    // Llama a la función \"resumidor\" con los mensajes recuperados\n    const resumen = await resumidor(mensajes)\n\n    // Envía el resumen como respuesta al usuario\n    await rest.post(Routes.webhook(CLIENT_ID as string, body.token), {\n      body: { content: resumen },\n    })\n\n    return {\n      statusCode: 200,\n      body: 'summary send',\n    }\n  } catch (error) {\n    console.error('Error al procesar el comando:', error)\n    return {\n      statusCode: 400,\n      body: 'Error al procesar el comando',\n    }\n  }\n}\nasync function obtenerMensajesDesde(\n  rest: REST,\n  channelId: string,\n  fechaHora: Date,\n): Promise<any[]> {\n  try {\n    let mensajes: any[] = []\n    let ultimoId: string | null = null\n    let todosMensajesRecuperados = false\n\n    while (!todosMensajesRecuperados) {\n      const params: any = { limit: 100 }\n      if (ultimoId) {\n        params.before = ultimoId // Usamos 'before' para obtener mensajes anteriores\n      }\n\n      const data: any = await rest.get(Routes.channelMessages(channelId), {\n        query: params,\n      })\n      console.log('while', data.length)\n\n      if (data.length === 0 || data.length < params.limit) {\n        // No hay más mensajes en el canal o hemos recuperado menos mensajes que el límite\n        todosMensajesRecuperados = true\n        const mensajesFiltrados = data.filter(\n          (mensaje: any) => new Date(mensaje.timestamp) >= fechaHora,\n        )\n        mensajes = mensajes.concat(mensajesFiltrados)\n      } else {\n        console.log('2')\n        ultimoId = data[data.length - 1].id\n        const mensajesFiltrados = data.filter(\n          (mensaje: any) => new Date(mensaje.timestamp) >= fechaHora,\n        )\n        console.log('mensajes', mensajes.length)\n        mensajes = mensajes.concat(mensajesFiltrados)\n\n        // Si el último mensaje es igual o anterior a la fechaHora, detiene la búsqueda\n        if (new Date(data[data.length - 1].timestamp) < fechaHora) {\n          todosMensajesRecuperados = true\n        }\n      }\n    }\n    console.log('mensajes', mensajes.length)\n    if (mensajes.length === 0) {\n      console.log('No hay mensajes desde la fecha dada.')\n      return []\n    } else {\n      console.log('Mensajes recuperados:', mensajes)\n      return mensajes\n    }\n  } catch (error) {\n    console.error('Error al obtener mensajes:', error)\n    throw error\n  }\n}\n\nasync function resumidor(mensajes: any[]): Promise<string> {\n  try {\n    let resumen: string = ''\n\n    // Invierte el orden del array para empezar por el mensaje más viejo\n    mensajes.reverse().forEach((mensaje) => {\n      // Verifica si el mensaje proviene de un usuario (no de una aplicación o bot)\n      if (!mensaje.author.bot) {\n        const nombreAutor: string = mensaje.author.username\n        const hora: string = new Date(mensaje.timestamp).toLocaleTimeString() // Convierte la marca de tiempo a hora local\n        const contenido: string = mensaje.content || '' // Si no hay contenido, asigna una cadena vacía\n\n        // Agrega la información del mensaje al resumen\n        resumen += `${nombreAutor} (${hora}): ${contenido}\\n`\n      }\n    })\n\n    const message = [\n      {\n        role: 'user',\n        content:\n          `Haz un resumen de esta conversación: ${resumen}. Si no recibes nada de info ahí, responde que no hay conversaciones para la fecha requerida`,\n      },\n    ]\n    return await completions(message, agent as string)\n  } catch (error) {\n    console.error('Error en la función resumidor:', error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import { REST, Routes } from 'discord.js'",
      "import dotenv from 'dotenv'",
      "import { completions } from '../codegpt/codegpt.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any no-inferrable-types\nimport { REST, Routes } from 'discord.js'\nimport dotenv from 'dotenv'\nimport { completions } from '../codegpt/codegpt.ts'\n\ndotenv.config()\n\nconst agent = Deno.env.get('CODEGPT_AGENT_ID') as string\n\nexport async function handleResumenCanalCommand(\n  body: any,\n  rest: REST,\n  CLIENT_ID: string | undefined,\n) {\n       //...\n       }\nasync function obtenerMensajesDesde(\n  rest: REST,\n  channelId: string,\n  fechaHora: Date,\n): Promise<any[]> {\n//...\n}\n\nasync function resumidor(mensajes: any[]): Promise<string> {\n//...\n}",
    "originFile": "\\lib\\integrations\\discord-app\\commands\\resumen.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\redirector::redirector",
    "language": "typescript",
    "label": "redirector",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\redirector",
    "totalTokens": 241,
    "inDegree": 3,
    "outDegree": 3,
    "code": "async function redirector(body: any, c: any) {\n  console.log('body on redirector,', body)\n  try {\n    await rest.post(\n      Routes.interactionCallback(body.id, body.token),\n      {\n        body: {\n          type: 5,\n        },\n      },\n    )\n\n    switch (body.data.name) { // Funcionalidades iguales a las de slack y además ésta del comando.\n      case 'chat':\n        await handleChatCommand(body, rest, CLIENT_ID, c)\n        break\n      // case 'resumencanal':\n      //   await handleResumenCanalCommand(body, rest, CLIENT_ID)\n      //   break\n      default:\n        console.error('Comando no reconocido')\n        // En Deno, debes retornar un objeto con la propiedad `body` y opcionalmente `status`\n        return { status: 400, body: 'Comando no reconocido' }\n    }\n  } catch (error) {\n    console.error('Error en redirector:', error)\n    return { status: 500, body: 'Ocurrió un error al procesar el comando' }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function redirector(body: any, c: any) {\n               //...\n               }",
    "originFile": "\\lib\\integrations\\discord-app\\redirector.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\redirector::rest",
    "language": "typescript",
    "label": "rest",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\redirector",
    "totalTokens": 20,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const rest = new REST({ version: '10' }).setToken(BOT_TOKEN as string)",
    "importStatements": [],
    "codeNoBody": "const rest = new REST({ version: '10' }).setToken(BOT_TOKEN as string)",
    "originFile": "\\lib\\integrations\\discord-app\\redirector.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\redirector::CLIENT_ID",
    "language": "typescript",
    "label": "CLIENT_ID",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\redirector",
    "totalTokens": 12,
    "inDegree": 2,
    "outDegree": 1,
    "code": "const CLIENT_ID = getEnv('DISCORD_APPLICATION_ID')",
    "importStatements": [],
    "codeNoBody": "const CLIENT_ID = getEnv('DISCORD_APPLICATION_ID')",
    "originFile": "\\lib\\integrations\\discord-app\\redirector.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\redirector::BOT_TOKEN",
    "language": "typescript",
    "label": "BOT_TOKEN",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\redirector",
    "totalTokens": 13,
    "inDegree": 1,
    "outDegree": 1,
    "code": "const BOT_TOKEN = getEnv('DISCORD_BOT_TOKEN')",
    "importStatements": [],
    "codeNoBody": "const BOT_TOKEN = getEnv('DISCORD_BOT_TOKEN')",
    "originFile": "\\lib\\integrations\\discord-app\\redirector.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\redirector",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\redirector.ts",
    "type": "file",
    "totalTokens": 342,
    "inDegree": 0,
    "outDegree": 4,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { getEnv } from '@/lib/env.ts'\nimport { REST, Routes } from 'discord.js'\nimport { handleChatCommand } from '@/lib/integrations/discord-app/commands/chat.ts'\n\nconst BOT_TOKEN = getEnv('DISCORD_BOT_TOKEN')\nconst CLIENT_ID = getEnv('DISCORD_APPLICATION_ID')\n\nconst rest = new REST({ version: '10' }).setToken(BOT_TOKEN as string)\n\nexport default async function redirector(body: any, c: any) {\n  console.log('body on redirector,', body)\n  try {\n    await rest.post(\n      Routes.interactionCallback(body.id, body.token),\n      {\n        body: {\n          type: 5,\n        },\n      },\n    )\n\n    switch (body.data.name) { // Funcionalidades iguales a las de slack y además ésta del comando.\n      case 'chat':\n        await handleChatCommand(body, rest, CLIENT_ID, c)\n        break\n      // case 'resumencanal':\n      //   await handleResumenCanalCommand(body, rest, CLIENT_ID)\n      //   break\n      default:\n        console.error('Comando no reconocido')\n        // En Deno, debes retornar un objeto con la propiedad `body` y opcionalmente `status`\n        return { status: 400, body: 'Comando no reconocido' }\n    }\n  } catch (error) {\n    console.error('Error en redirector:', error)\n    return { status: 500, body: 'Ocurrió un error al procesar el comando' }\n  }\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { REST, Routes } from 'discord.js'",
      "import { handleChatCommand } from '@/lib/integrations/discord-app/commands/chat.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { getEnv } from '@/lib/env.ts'\nimport { REST, Routes } from 'discord.js'\nimport { handleChatCommand } from '@/lib/integrations/discord-app/commands/chat.ts'\nconst BOT_TOKEN = getEnv('DISCORD_BOT_TOKEN')\nconst CLIENT_ID = getEnv('DISCORD_APPLICATION_ID')\n\nconst rest = new REST({ version: '10' }).setToken(BOT_TOKEN as string)\n\nexport default async function redirector(body: any, c: any) {\n               //...\n               }",
    "originFile": "\\lib\\integrations\\discord-app\\redirector.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces::DiscordTokenResponse",
    "language": "typescript",
    "label": "DiscordTokenResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\interfaces",
    "totalTokens": 370,
    "inDegree": 5,
    "outDegree": 1,
    "code": "interface DiscordTokenResponse {\n  token_type: string\n  access_token: string\n  expires_in: number\n  refresh_token: string\n  scope: string\n  guild: {\n    id: string\n    name: string\n    icon: string | null\n    description: string | null\n    home_header: string | null\n    splash: string | null\n    discovery_splash: string | null\n    features: string[]\n    emojis: any[]\n    stickers: any[]\n    banner: string | null\n    owner_id: string\n    application_id: string | null\n    region: string\n    afk_channel_id: string | null\n    afk_timeout: number\n    system_channel_id: string\n    widget_enabled: boolean\n    widget_channel_id: string | null\n    verification_level: number\n    roles: any[]\n    default_message_notifications: number\n    mfa_level: number\n    explicit_content_filter: number\n    max_presences: number | null\n    max_members: number\n    max_stage_video_channel_users: number\n    max_video_channel_users: number\n    vanity_url_code: string | null\n    premium_tier: number\n    premium_subscription_count: number\n    system_channel_flags: number\n    preferred_locale: string\n    rules_channel_id: string | null\n    safety_alerts_channel_id: string | null\n    public_updates_channel_id: string | null\n    hub_type: string | null\n    premium_progress_bar_enabled: boolean\n    latest_onboarding_question_id: string | null\n    incidents_data: any | null\n    inventory_settings: any | null\n    nsfw: boolean\n    nsfw_level: number\n    embed_enabled: boolean\n    embed_channel_id: string | null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface DiscordTokenResponse {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces::DbServers",
    "language": "typescript",
    "label": "DbServers",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\interfaces",
    "totalTokens": 96,
    "inDegree": 6,
    "outDegree": 1,
    "code": "interface DbServers {\n  id: string // text se representa como string\n  created_at: string // timestamptz se representa como string en JavaScript/TypeScript\n  org_id: string // uuid se representa como string\n  access_token: string // text se representa como string\n  name: string // text se representa como string\n  agent_settings: number // numeric se representa como number\n  agent_id: string // uuid se representa como string\n}",
    "importStatements": [],
    "codeNoBody": "interface DbServers {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\interfaces.ts",
    "type": "file",
    "totalTokens": 480,
    "inDegree": 0,
    "outDegree": 4,
    "code": "// deno-lint-ignore-file no-explicit-any\nexport interface DbServers {\n  id: string // text se representa como string\n  created_at: string // timestamptz se representa como string en JavaScript/TypeScript\n  org_id: string // uuid se representa como string\n  access_token: string // text se representa como string\n  name: string // text se representa como string\n  agent_settings: number // numeric se representa como number\n  agent_id: string // uuid se representa como string\n}\n\nexport interface DiscordTokenResponse {\n  token_type: string\n  access_token: string\n  expires_in: number\n  refresh_token: string\n  scope: string\n  guild: {\n    id: string\n    name: string\n    icon: string | null\n    description: string | null\n    home_header: string | null\n    splash: string | null\n    discovery_splash: string | null\n    features: string[]\n    emojis: any[]\n    stickers: any[]\n    banner: string | null\n    owner_id: string\n    application_id: string | null\n    region: string\n    afk_channel_id: string | null\n    afk_timeout: number\n    system_channel_id: string\n    widget_enabled: boolean\n    widget_channel_id: string | null\n    verification_level: number\n    roles: any[]\n    default_message_notifications: number\n    mfa_level: number\n    explicit_content_filter: number\n    max_presences: number | null\n    max_members: number\n    max_stage_video_channel_users: number\n    max_video_channel_users: number\n    vanity_url_code: string | null\n    premium_tier: number\n    premium_subscription_count: number\n    system_channel_flags: number\n    preferred_locale: string\n    rules_channel_id: string | null\n    safety_alerts_channel_id: string | null\n    public_updates_channel_id: string | null\n    hub_type: string | null\n    premium_progress_bar_enabled: boolean\n    latest_onboarding_question_id: string | null\n    incidents_data: any | null\n    inventory_settings: any | null\n    nsfw: boolean\n    nsfw_level: number\n    embed_enabled: boolean\n    embed_channel_id: string | null\n  }\n}\n",
    "importStatements": [],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nexport interface DbServers {\n       //...\n       }\nexport interface DiscordTokenResponse {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\saveServer",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\saveServer.ts",
    "type": "file",
    "totalTokens": 435,
    "inDegree": 0,
    "outDegree": 0,
    "code": "// import { supabase } from '@/services/supabase/index.ts'\n// import { DiscordTokenResponse } from '@/lib/integrations/discord-app/services/supabase/interfaces.ts'\n\n// export async function saveServer(\n//   tokenData: DiscordTokenResponse,\n// ): Promise<void> {\n//   try {\n//     console.log('Entró a tokenData')\n//     // Verificar si el registro ya existe\n//     const { data: checkResult, error: checkError } = await supabase\n//       .from('discord_servers')\n//       .select('id')\n//       .eq('id', tokenData.guild.id)\n\n//     if (checkError && !checkError.message.includes('No rows found')) {\n//       console.log('Entró a error')\n//       console.error('No existe en tabla', checkError)\n//     }\n\n//     if (checkResult?.length && checkResult?.length > 0) {\n//       console.log('Entró a checkresut', checkResult)\n//       // Si el registro existe, actualizarlo\n//       const { error: updateError } = await supabase\n//         .from('discord_servers')\n//         .update({\n//           access_token: tokenData.access_token,\n//           name: tokenData.guild.name,\n//         })\n//         .eq('id', tokenData.guild.id)\n//       console.log('se supone que guardo?')\n//       if (updateError) {\n//         console.error('Error updating server:', updateError)\n//       }\n//     } else {\n//       // Si el registro no existe, insertarlo\n//       const { error: insertError } = await supabase\n//         .from('discord_servers')\n//         .insert([{\n//           id: tokenData.guild.id,\n//           access_token: tokenData.access_token,\n//           name: tokenData.guild.name,\n//         }])\n//     }\n\n//     if (insertError) {\n//       console.error('Error inserting workspace:', insertError)\n//     }\n//   } finally {\n//   }\n// }\n",
    "importStatements": [],
    "codeNoBody": "// import { supabase } from '@/services/supabase/index.ts'\n// import { DiscordTokenResponse } from '@/lib/integrations/discord-app/services/supabase/interfaces.ts'\n// export async function saveServer(\n//   tokenData: DiscordTokenResponse,\n// ): Promise<void> {\n//   try {\n//     console.log('Entró a tokenData')\n//     // Verificar si el registro ya existe\n//     const { data: checkResult, error: checkError } = await supabase\n//       .from('discord_servers')\n//       .select('id')\n//       .eq('id', tokenData.guild.id)\n\n//     if (checkError && !checkError.message.includes('No rows found')) {\n//       console.log('Entró a error')\n//       console.error('No existe en tabla', checkError)\n//     }\n\n//     if (checkResult?.length && checkResult?.length > 0) {\n//       console.log('Entró a checkresut', checkResult)\n//       // Si el registro existe, actualizarlo\n//       const { error: updateError } = await supabase\n//         .from('discord_servers')\n//         .update({\n//           access_token: tokenData.access_token,\n//           name: tokenData.guild.name,\n//         })\n//         .eq('id', tokenData.guild.id)\n//       console.log('se supone que guardo?')\n//       if (updateError) {\n//         console.error('Error updating server:', updateError)\n//       }\n//     } else {\n//       // Si el registro no existe, insertarlo\n//       const { error: insertError } = await supabase\n//         .from('discord_servers')\n//         .insert([{\n//           id: tokenData.guild.id,\n//           access_token: tokenData.access_token,\n//           name: tokenData.guild.name,\n//         }])\n//     }\n\n//     if (insertError) {\n//       console.error('Error inserting workspace:', insertError)\n//     }\n//   } finally {\n//   }\n// }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\saveServer.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers::deleteServer",
    "language": "typescript",
    "label": "deleteServer",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "totalTokens": 120,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function deleteServer(server_id: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('discord_servers')\n      .delete()\n      .eq('id', server_id)\n\n    if (error) {\n      console.error('Error deleting server:', error)\n      return false\n    } else {\n      console.log(`server with id ${server_id} has been deleted.`)\n      return true\n    }\n  } catch (error) {\n    console.error('An error occurred while deleting workspace:', error)\n    return false\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function deleteServer(server_id: string): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers::readServers",
    "language": "typescript",
    "label": "readServers",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "totalTokens": 163,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function readServers(\n  server_id: string,\n  org_id: string,\n): Promise<DbServers | null> {\n  try {\n    const { data: servers, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('id', server_id)\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading server:', error)\n      return null\n    }\n\n    if (servers && servers.length > 0) {\n      const server: DbServers = servers[0]\n\n      return server\n    } else {\n      return null\n    }\n  } catch (error: any) {\n    console.error('An error occurred while reading servers:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function readServers(\n  server_id: string,\n  org_id: string,\n): Promise<DbServers | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers::getAllServersByOrg",
    "language": "typescript",
    "label": "getAllServersByOrg",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "totalTokens": 122,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getAllServersByOrg(org_id: string): Promise<any> {\n  try {\n    const { data: servers, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading server:', error)\n      return null\n    }\n\n    if (servers && servers.length > 0) {\n      return servers\n    }\n  } catch (error) {\n    console.error('An error occurred while reading servers:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAllServersByOrg(org_id: string): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers::readServer",
    "language": "typescript",
    "label": "readServer",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "totalTokens": 160,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function readServer(\n  server_id: string,\n): Promise<DbServers | null> {\n  try {\n    const { data: workspaces, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('id', server_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      const server: DbServers = workspaces[0]\n      console.log('Response db', server)\n      return server\n    } else {\n      return null\n    }\n  } catch (error: any) {\n    console.error('An error occurred while reading server', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function readServer(\n  server_id: string,\n): Promise<DbServers | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers::saveServer",
    "language": "typescript",
    "label": "saveServer",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "totalTokens": 289,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function saveServer(\n  tokenData: DiscordTokenResponse,\n): Promise<void> {\n  try {\n    const { data: checkResult, error: checkError } = await supabase\n      .from('discord_servers')\n      .select('id')\n      .eq('id', tokenData.guild.id)\n\n    if (checkError && !checkError.message.includes('No rows found')) {\n      console.log('Entró a error')\n      console.error('No existe en tabla', checkError)\n    }\n\n    if (checkResult?.length && checkResult?.length > 0) {\n      const { error: updateError } = await supabase\n        .from('discord_servers')\n        .update({\n          name: tokenData.guild.name,\n        })\n        .eq('id', tokenData.guild.id)\n\n      if (updateError) {\n        console.error('Error updating server:', updateError)\n      }\n    } else {\n      const { error: insertError } = await supabase\n        .from('discord_servers')\n        .insert([{\n          id: tokenData.guild.id,\n          name: tokenData.guild.name,\n        }])\n\n      if (insertError) {\n        console.error('Error inserting server:', insertError)\n      }\n    }\n  } catch (error) {\n    console.error(\n      'An error occurred while inserting/updating a server:',\n      error,\n    )\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function saveServer(\n  tokenData: DiscordTokenResponse,\n): Promise<void> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\discord-app\\services\\supabase\\servers",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts",
    "type": "file",
    "totalTokens": 916,
    "inDegree": 0,
    "outDegree": 7,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\nimport {\n  DbServers,\n  DiscordTokenResponse,\n} from '@/lib/integrations/discord-app/services/supabase/interfaces.ts'\n\nexport async function saveServer(\n  tokenData: DiscordTokenResponse,\n): Promise<void> {\n  try {\n    const { data: checkResult, error: checkError } = await supabase\n      .from('discord_servers')\n      .select('id')\n      .eq('id', tokenData.guild.id)\n\n    if (checkError && !checkError.message.includes('No rows found')) {\n      console.log('Entró a error')\n      console.error('No existe en tabla', checkError)\n    }\n\n    if (checkResult?.length && checkResult?.length > 0) {\n      const { error: updateError } = await supabase\n        .from('discord_servers')\n        .update({\n          name: tokenData.guild.name,\n        })\n        .eq('id', tokenData.guild.id)\n\n      if (updateError) {\n        console.error('Error updating server:', updateError)\n      }\n    } else {\n      const { error: insertError } = await supabase\n        .from('discord_servers')\n        .insert([{\n          id: tokenData.guild.id,\n          name: tokenData.guild.name,\n        }])\n\n      if (insertError) {\n        console.error('Error inserting server:', insertError)\n      }\n    }\n  } catch (error) {\n    console.error(\n      'An error occurred while inserting/updating a server:',\n      error,\n    )\n  }\n}\n\nexport async function readServer(\n  server_id: string,\n): Promise<DbServers | null> {\n  try {\n    const { data: workspaces, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('id', server_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      const server: DbServers = workspaces[0]\n      console.log('Response db', server)\n      return server\n    } else {\n      return null\n    }\n  } catch (error: any) {\n    console.error('An error occurred while reading server', error)\n    return null\n  }\n}\nexport async function getAllServersByOrg(org_id: string): Promise<any> {\n  try {\n    const { data: servers, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading server:', error)\n      return null\n    }\n\n    if (servers && servers.length > 0) {\n      return servers\n    }\n  } catch (error) {\n    console.error('An error occurred while reading servers:', error)\n    return null\n  }\n}\n\nexport async function readServers(\n  server_id: string,\n  org_id: string,\n): Promise<DbServers | null> {\n  try {\n    const { data: servers, error } = await supabase\n      .from('discord_servers')\n      .select('*')\n      .eq('id', server_id)\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading server:', error)\n      return null\n    }\n\n    if (servers && servers.length > 0) {\n      const server: DbServers = servers[0]\n\n      return server\n    } else {\n      return null\n    }\n  } catch (error: any) {\n    console.error('An error occurred while reading servers:', error)\n    return null\n  }\n}\n\nexport async function deleteServer(server_id: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('discord_servers')\n      .delete()\n      .eq('id', server_id)\n\n    if (error) {\n      console.error('Error deleting server:', error)\n      return false\n    } else {\n      console.log(`server with id ${server_id} has been deleted.`)\n      return true\n    }\n  } catch (error) {\n    console.error('An error occurred while deleting workspace:', error)\n    return false\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import {\n  DbServers,\n  DiscordTokenResponse,\n} from '@/lib/integrations/discord-app/services/supabase/interfaces.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\nimport {\n  DbServers,\n  DiscordTokenResponse,\n} from '@/lib/integrations/discord-app/services/supabase/interfaces.ts'\nexport async function saveServer(\n  tokenData: DiscordTokenResponse,\n): Promise<void> {\n       //...\n       }\n\nexport async function readServer(\n  server_id: string,\n): Promise<DbServers | null> {\n       //...\n       }\nexport async function getAllServersByOrg(org_id: string): Promise<any> {\n       //...\n       }\n\nexport async function readServers(\n  server_id: string,\n  org_id: string,\n): Promise<DbServers | null> {\n       //...\n       }\n\nexport async function deleteServer(server_id: string): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\discord-app\\services\\supabase\\servers.ts"
  },
  {
    "id": "\\lib\\integrations\\github-app\\utils::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\github-app\\utils",
    "totalTokens": 246,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n  try {\n    const url = 'https://github.com/login/oauth/access_token'\n    const params = new URLSearchParams()\n    params.append('refresh_token', refreshToken)\n    params.append('grant_type', 'refresh_token')\n    params.append('client_id', clientId)\n    params.append('client_secret', clientSecret)\n\n    const response: AxiosResponse<TokenResponse> = await axios.post(\n      url,\n      params.toString(),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        },\n      },\n    )\n    console.log('response update', response)\n\n    if (response.status === 200) {\n      const { access_token, refresh_token } = response.data\n      return { newAccessToken: access_token, newRefreshToken: refresh_token }\n    } else {\n      console.error('Error al renovar el token de acceso:', response.data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\github-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\github-app\\utils::TokenResponse",
    "language": "typescript",
    "label": "TokenResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\github-app\\utils",
    "totalTokens": 17,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface TokenResponse {\n  access_token: string\n  refresh_token?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface TokenResponse {\n//...\n}",
    "originFile": "\\lib\\integrations\\github-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\github-app\\utils::getUserData",
    "language": "typescript",
    "label": "getUserData",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\github-app\\utils",
    "totalTokens": 58,
    "inDegree": 3,
    "outDegree": 0,
    "code": "async function getUserData(accessToken: string) {\n  const response = await axios.get('https://api.github.com/user', {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  })\n  console.log('response.data', response.data)\n  return response.data\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserData(accessToken: string) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\github-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\github-app\\utils::UserData",
    "language": "typescript",
    "label": "UserData",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\github-app\\utils",
    "totalTokens": 44,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface UserData {\n  login: string\n  id: number\n  name: string\n  email: string\n  avatar_url: string\n  // Agrega aquí otros campos que necesites del objeto userData\n}",
    "importStatements": [],
    "codeNoBody": "interface UserData {\n//...\n}",
    "originFile": "\\lib\\integrations\\github-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\github-app\\utils",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\github-app\\utils.ts",
    "type": "file",
    "totalTokens": 390,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport axios, { AxiosResponse } from 'axios'\n\ninterface UserData {\n  login: string\n  id: number\n  name: string\n  email: string\n  avatar_url: string\n  // Agrega aquí otros campos que necesites del objeto userData\n}\nexport async function getUserData(accessToken: string) {\n  const response = await axios.get('https://api.github.com/user', {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  })\n  console.log('response.data', response.data)\n  return response.data\n}\ninterface TokenResponse {\n  access_token: string\n  refresh_token?: string\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n  try {\n    const url = 'https://github.com/login/oauth/access_token'\n    const params = new URLSearchParams()\n    params.append('refresh_token', refreshToken)\n    params.append('grant_type', 'refresh_token')\n    params.append('client_id', clientId)\n    params.append('client_secret', clientSecret)\n\n    const response: AxiosResponse<TokenResponse> = await axios.post(\n      url,\n      params.toString(),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        },\n      },\n    )\n    console.log('response update', response)\n\n    if (response.status === 200) {\n      const { access_token, refresh_token } = response.data\n      return { newAccessToken: access_token, newRefreshToken: refresh_token }\n    } else {\n      console.error('Error al renovar el token de acceso:', response.data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import axios, { AxiosResponse } from 'axios'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport axios, { AxiosResponse } from 'axios'\ninterface UserData {\n//...\n}\nexport async function getUserData(accessToken: string) {\n       //...\n       }\ninterface TokenResponse {\n//...\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\github-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils::refreshAccessToken",
    "language": "typescript",
    "label": "refreshAccessToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils",
    "totalTokens": 268,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n  try {\n    console.log('on refresh access function')\n    const url = 'https://gitlab.com/oauth/token'\n    const params = new URLSearchParams()\n    params.append('refresh_token', refreshToken)\n    params.append('grant_type', 'refresh_token')\n    params.append('client_id', clientId)\n    params.append('client_secret', clientSecret)\n\n    const response: AxiosResponse<TokenResponse> = await axios.post(\n      url,\n      params.toString(),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        },\n      },\n    )\n    console.log('response update', response)\n\n    if (response.status === 200) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } =\n        response.data\n      // Actualizar el access_token y el refresh_token\n      return { newAccessToken, newRefreshToken }\n    } else {\n      console.error('Error al renovar el token de acceso:', response.data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils::TokenResponse",
    "language": "typescript",
    "label": "TokenResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils",
    "totalTokens": 17,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface TokenResponse {\n  access_token: string\n  refresh_token: string\n}",
    "importStatements": [],
    "codeNoBody": "interface TokenResponse {\n//...\n}",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils::getUserInfo",
    "language": "typescript",
    "label": "getUserInfo",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils",
    "totalTokens": 137,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function getUserInfo(accessToken: string): Promise<UserInfo> {\n  try {\n    const response: AxiosResponse<UserData> = await axios.get(\n      'https://gitlab.com/api/v4/user',\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n        },\n      },\n    )\n\n    const userData = response.data\n    const userId = userData.id\n    const userName = userData.username\n    const userEmail = userData.email\n    console.log('userData', userData)\n    return { userId, userName, userEmail }\n  } catch (error) {\n    console.error('Error al obtener la información del usuario:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserInfo(accessToken: string): Promise<UserInfo> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils::UserInfo",
    "language": "typescript",
    "label": "UserInfo",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils",
    "totalTokens": 19,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserInfo {\n  userId: number\n  userName: string\n  userEmail: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UserInfo {\n//...\n}",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils::UserData",
    "language": "typescript",
    "label": "UserData",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils",
    "totalTokens": 24,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserData {\n  id: number\n  username: string\n  name: string\n  email: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UserData {\n//...\n}",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\gitlab-app\\utils",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\gitlab-app\\utils.ts",
    "type": "file",
    "totalTokens": 490,
    "inDegree": 0,
    "outDegree": 8,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport axios, { AxiosResponse } from 'axios'\n\ninterface UserData {\n  id: number\n  username: string\n  name: string\n  email: string\n}\n\ninterface UserInfo {\n  userId: number\n  userName: string\n  userEmail: string\n}\n\nexport async function getUserInfo(accessToken: string): Promise<UserInfo> {\n  try {\n    const response: AxiosResponse<UserData> = await axios.get(\n      'https://gitlab.com/api/v4/user',\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n        },\n      },\n    )\n\n    const userData = response.data\n    const userId = userData.id\n    const userName = userData.username\n    const userEmail = userData.email\n    console.log('userData', userData)\n    return { userId, userName, userEmail }\n  } catch (error) {\n    console.error('Error al obtener la información del usuario:', error)\n    throw error\n  }\n}\ninterface TokenResponse {\n  access_token: string\n  refresh_token: string\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n  try {\n    console.log('on refresh access function')\n    const url = 'https://gitlab.com/oauth/token'\n    const params = new URLSearchParams()\n    params.append('refresh_token', refreshToken)\n    params.append('grant_type', 'refresh_token')\n    params.append('client_id', clientId)\n    params.append('client_secret', clientSecret)\n\n    const response: AxiosResponse<TokenResponse> = await axios.post(\n      url,\n      params.toString(),\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        },\n      },\n    )\n    console.log('response update', response)\n\n    if (response.status === 200) {\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } =\n        response.data\n      // Actualizar el access_token y el refresh_token\n      return { newAccessToken, newRefreshToken }\n    } else {\n      console.error('Error al renovar el token de acceso:', response.data)\n      return null\n    }\n  } catch (error) {\n    console.error('Error al renovar el token de acceso:', error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import axios, { AxiosResponse } from 'axios'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport axios, { AxiosResponse } from 'axios'\ninterface UserData {\n//...\n}\n\ninterface UserInfo {\n//...\n}\n\nexport async function getUserInfo(accessToken: string): Promise<UserInfo> {\n       //...\n       }\ninterface TokenResponse {\n//...\n}\n\nexport async function refreshAccessToken(\n  refreshToken: string,\n  clientId: string,\n  clientSecret: string,\n): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\gitlab-app\\utils.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\init-bot::getAndSaveBotUserId",
    "language": "typescript",
    "label": "getAndSaveBotUserId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\init-bot",
    "totalTokens": 166,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async function getAndSaveBotUserId(workspace: dbWorkspace) {\n  try {\n    const response = await fetch('https://slack.com/api/auth.test', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Bearer ${workspace.access_token}`,\n      },\n    })\n    const data = await response.json()\n    if (data.ok) {\n      console.log('workspace', workspace.id)\n      updateBotUserId(workspace.id, data.user_id)\n      console.log('data', data)\n      return data\n    } else {\n      throw new Error('No se pudo obtener el bot user ID')\n    }\n  } catch (error: any) {\n    throw Error(`No se pudo seleccionar y guardar el bot userId\", ${error}`)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAndSaveBotUserId(workspace: dbWorkspace) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\init-bot::getWorkspaceAndToken",
    "language": "typescript",
    "label": "getWorkspaceAndToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\init-bot",
    "totalTokens": 118,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function getWorkspaceAndToken(slackEvent: any) {\n  try {\n    let workspace_id = ''\n    if (slackEvent.payload) {\n      slackEvent = JSON.parse(slackEvent.payload)\n\n      slackEvent.team_id\n        ? (workspace_id = slackEvent.team_id)\n        : (workspace_id = slackEvent.team.id)\n    } else {\n      workspace_id = slackEvent.team_id\n    }\n    return workspace_id\n  } catch (error: any) {\n    throw Error(`No se pudo seleccionar el workspace o el token\", ${error}`)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "function getWorkspaceAndToken(slackEvent: any) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\init-bot::dispatchEvent",
    "language": "typescript",
    "label": "dispatchEvent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\init-bot",
    "totalTokens": 277,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function dispatchEvent(\n  event: any,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  try {\n    if (event?.event?.type === 'message') {\n      if (event.event.channel_type === 'im') {\n        return await directMessageEvent(event, workspace, c)\n      }\n\n      if (event.event.thread_ts) {\n        const slackClient = new WebClient(workspace.access_token)\n        const result = await slackClient.conversations.history({\n          channel: event.event.channel,\n          latest: event.event.thread_ts,\n          limit: 1,\n          inclusive: true,\n        })\n\n        let botUserId = workspace.bot_user_id\n        if (!botUserId) {\n          botUserId = await getAndSaveBotUserId(workspace)\n        }\n\n        if (\n          result.messages &&\n          result.messages[0].text?.includes(`<@${botUserId}>`)\n        ) {\n          return await handleMessageEvent(event, workspace, c)\n        }\n      }\n    } else if (event?.event?.type === 'app_mention') {\n      return await handleMessageEvent(event, workspace, c)\n    }\n\n    return {\n      statusCode: 400,\n      body: 'Tipo de evento no reconocido',\n    }\n  } catch (error) {\n    console.error('An error occurred while dispatching the event:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function dispatchEvent(\n  event: any,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\init-bot::selectWorkspace",
    "language": "typescript",
    "label": "selectWorkspace",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\init-bot",
    "totalTokens": 249,
    "inDegree": 3,
    "outDegree": 4,
    "code": "const selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n  try {\n    const workspace_id = getWorkspaceAndToken(slackEvent)\n\n    const workspace: dbWorkspace | null = await readWorkspace(workspace_id) //\n    if (workspace) {\n      dispatchEvent(slackEvent, workspace, c)\n    } else {throw new Error(\n        'No existe el workspace o token de autenticación fallido',\n      )}\n  } catch (error) {\n    console.error('An error occurred while selecting a workspace:', error)\n    throw error\n  }\n}\n\nconst selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n  try {\n    const workspace_id = getWorkspaceAndToken(slackEvent)\n\n    const workspace: dbWorkspace | null = await readWorkspace(workspace_id) //\n    if (workspace) {\n      dispatchEvent(slackEvent, workspace, c)\n    } else {throw new Error(\n        'No existe el workspace o token de autenticación fallido',\n      )}\n  } catch (error) {\n    console.error('An error occurred while selecting a workspace:', error)\n    throw error\n  }\n}\n\nexport { selectWorkspace }",
    "importStatements": [],
    "codeNoBody": "const selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n//...\n}\nconst selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n  try {\n    const workspace_id = getWorkspaceAndToken(slackEvent)\n\n    const workspace: dbWorkspace | null = await readWorkspace(workspace_id) //\n    if (workspace) {\n      dispatchEvent(slackEvent, workspace, c)\n    } else {throw new Error(\n        'No existe el workspace o token de autenticación fallido',\n      )}\n  } catch (error) {\n    console.error('An error occurred while selecting a workspace:', error)\n    throw error\n  }\n}\n\nexport { selectWorkspace }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\init-bot",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts",
    "type": "file",
    "totalTokens": 892,
    "inDegree": 0,
    "outDegree": 5,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport {\n  readWorkspace,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport dotenv from 'dotenv'\n// deno-lint-ignore no-unused-vars\nimport { handleCommand } from '../slack/command-event.ts'\n// import { handleModalSubmission } from '../slack/modal-event.ts'\nimport {\n  directMessageEvent,\n  handleMessageEvent,\n} from '@/lib/integrations/slack-app/slack/message-event.ts'\nimport type { Context } from 'hono'\nimport { WebClient } from '@slack/web-api'\nimport { updateBotUserId } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\n\ndotenv.config()\n\nconst selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n  try {\n    const workspace_id = getWorkspaceAndToken(slackEvent)\n\n    const workspace: dbWorkspace | null = await readWorkspace(workspace_id) //\n    if (workspace) {\n      dispatchEvent(slackEvent, workspace, c)\n    } else {throw new Error(\n        'No existe el workspace o token de autenticación fallido',\n      )}\n  } catch (error) {\n    console.error('An error occurred while selecting a workspace:', error)\n    throw error\n  }\n}\n\n// Función que redirige a la función correspondiente basada en el tipo de evento\nexport async function dispatchEvent(\n  event: any,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  try {\n    if (event?.event?.type === 'message') {\n      if (event.event.channel_type === 'im') {\n        return await directMessageEvent(event, workspace, c)\n      }\n\n      if (event.event.thread_ts) {\n        const slackClient = new WebClient(workspace.access_token)\n        const result = await slackClient.conversations.history({\n          channel: event.event.channel,\n          latest: event.event.thread_ts,\n          limit: 1,\n          inclusive: true,\n        })\n\n        let botUserId = workspace.bot_user_id\n        if (!botUserId) {\n          botUserId = await getAndSaveBotUserId(workspace)\n        }\n\n        if (\n          result.messages &&\n          result.messages[0].text?.includes(`<@${botUserId}>`)\n        ) {\n          return await handleMessageEvent(event, workspace, c)\n        }\n      }\n    } else if (event?.event?.type === 'app_mention') {\n      return await handleMessageEvent(event, workspace, c)\n    }\n\n    return {\n      statusCode: 400,\n      body: 'Tipo de evento no reconocido',\n    }\n  } catch (error) {\n    console.error('An error occurred while dispatching the event:', error)\n    throw error\n  }\n}\n\nexport function getWorkspaceAndToken(slackEvent: any) {\n  try {\n    let workspace_id = ''\n    if (slackEvent.payload) {\n      slackEvent = JSON.parse(slackEvent.payload)\n\n      slackEvent.team_id\n        ? (workspace_id = slackEvent.team_id)\n        : (workspace_id = slackEvent.team.id)\n    } else {\n      workspace_id = slackEvent.team_id\n    }\n    return workspace_id\n  } catch (error: any) {\n    throw Error(`No se pudo seleccionar el workspace o el token\", ${error}`)\n  }\n}\n\nexport async function getAndSaveBotUserId(workspace: dbWorkspace) {\n  try {\n    const response = await fetch('https://slack.com/api/auth.test', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Bearer ${workspace.access_token}`,\n      },\n    })\n    const data = await response.json()\n    if (data.ok) {\n      console.log('workspace', workspace.id)\n      updateBotUserId(workspace.id, data.user_id)\n      console.log('data', data)\n      return data\n    } else {\n      throw new Error('No se pudo obtener el bot user ID')\n    }\n  } catch (error: any) {\n    throw Error(`No se pudo seleccionar y guardar el bot userId\", ${error}`)\n  }\n}\n\nexport { selectWorkspace }\n",
    "importStatements": [
      "import {\n  readWorkspace,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'",
      "import { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'",
      "import dotenv from 'dotenv'",
      "import { handleCommand } from '../slack/command-event.ts'",
      "import {\n  directMessageEvent,\n  handleMessageEvent,\n} from '@/lib/integrations/slack-app/slack/message-event.ts'",
      "import type { Context } from 'hono'",
      "import { WebClient } from '@slack/web-api'",
      "import { updateBotUserId } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport {\n  readWorkspace,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport dotenv from 'dotenv'\n// deno-lint-ignore no-unused-vars\nimport { handleCommand } from '../slack/command-event.ts'\n// import { handleModalSubmission } from '../slack/modal-event.ts'\nimport {\n  directMessageEvent,\n  handleMessageEvent,\n} from '@/lib/integrations/slack-app/slack/message-event.ts'\nimport type { Context } from 'hono'\nimport { WebClient } from '@slack/web-api'\nimport { updateBotUserId } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\ndotenv.config()\n\nconst selectWorkspace = async (slackEvent: any, c: Context): Promise<void> => {\n//...\n}\n\n// Función que redirige a la función correspondiente basada en el tipo de evento\nexport async function dispatchEvent(\n  event: any,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }\n\nexport function getWorkspaceAndToken(slackEvent: any) {\n       //...\n       }\n\nexport async function getAndSaveBotUserId(workspace: dbWorkspace) {\n       //...\n       }\n\nexport { selectWorkspace }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\init-bot.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::ViewSubmissionEvent",
    "language": "typescript",
    "label": "ViewSubmissionEvent",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 63,
    "inDegree": 3,
    "outDegree": 4,
    "code": "interface ViewSubmissionEvent {\n  type: string\n  team: Team\n  user: User\n  api_app_id: string\n  token: string\n  trigger_id: string\n  view: ViewState\n  response_urls: string[]\n  is_enterprise_install: boolean\n  enterprise: any\n}",
    "importStatements": [],
    "codeNoBody": "interface ViewSubmissionEvent {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::ViewState",
    "language": "typescript",
    "label": "ViewState",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 85,
    "inDegree": 4,
    "outDegree": 5,
    "code": "interface ViewState {\n  id: string\n  team_id: string\n  type: string\n  blocks: Block[]\n  private_metadata: string\n  callback_id: string\n  state: {\n    values: StateValues\n  }\n  hash: string\n  title: Title\n  clear_on_close: boolean\n  notify_on_close: boolean\n  submit: Submit\n  root_view_id: string\n}",
    "importStatements": [],
    "codeNoBody": "interface ViewState {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::StateValues",
    "language": "typescript",
    "label": "StateValues",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 58,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface StateValues {\n  agent_selection_block: {\n    agent_selection: {\n      type: string\n      selected_option: {\n        text: {\n          type: string\n          text: string\n          emoji: boolean\n        }\n        value: string\n      }\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface StateValues {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Submit",
    "language": "typescript",
    "label": "Submit",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 19,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Submit {\n  type: string\n  text: string\n  emoji: boolean\n}",
    "importStatements": [],
    "codeNoBody": "interface Submit {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Title",
    "language": "typescript",
    "label": "Title",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 19,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Title {\n  type: string\n  text: string\n  emoji: boolean\n}",
    "importStatements": [],
    "codeNoBody": "interface Title {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Block",
    "language": "typescript",
    "label": "Block",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 52,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Block {\n  type: string\n  block_id: string\n  label: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  optional: boolean\n  dispatch_action: boolean\n  element: Element\n}",
    "importStatements": [],
    "codeNoBody": "interface Block {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Element",
    "language": "typescript",
    "label": "Element",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 41,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Element {\n  type: string\n  action_id: string\n  placeholder: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  options: Option[]\n}",
    "importStatements": [],
    "codeNoBody": "interface Element {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Option",
    "language": "typescript",
    "label": "Option",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 30,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Option {\n  text: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  value: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Option {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::User",
    "language": "typescript",
    "label": "User",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 25,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface User {\n  id: string\n  username: string\n  name: string\n  team_id: string\n}",
    "importStatements": [],
    "codeNoBody": "interface User {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces::Team",
    "language": "typescript",
    "label": "Team",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "totalTokens": 14,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Team {\n  id: string\n  domain: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Team {\n//...\n}",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\app-flow\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts",
    "type": "file",
    "totalTokens": 419,
    "inDegree": 0,
    "outDegree": 20,
    "code": "// deno-lint-ignore-file no-explicit-any\ninterface Team {\n  id: string\n  domain: string\n}\n\ninterface User {\n  id: string\n  username: string\n  name: string\n  team_id: string\n}\n\ninterface Option {\n  text: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  value: string\n}\n\ninterface Element {\n  type: string\n  action_id: string\n  placeholder: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  options: Option[]\n}\n\ninterface Block {\n  type: string\n  block_id: string\n  label: {\n    type: string\n    text: string\n    emoji: boolean\n  }\n  optional: boolean\n  dispatch_action: boolean\n  element: Element\n}\n\ninterface Title {\n  type: string\n  text: string\n  emoji: boolean\n}\n\ninterface Submit {\n  type: string\n  text: string\n  emoji: boolean\n}\n\ninterface StateValues {\n  agent_selection_block: {\n    agent_selection: {\n      type: string\n      selected_option: {\n        text: {\n          type: string\n          text: string\n          emoji: boolean\n        }\n        value: string\n      }\n    }\n  }\n}\n\ninterface ViewState {\n  id: string\n  team_id: string\n  type: string\n  blocks: Block[]\n  private_metadata: string\n  callback_id: string\n  state: {\n    values: StateValues\n  }\n  hash: string\n  title: Title\n  clear_on_close: boolean\n  notify_on_close: boolean\n  submit: Submit\n  root_view_id: string\n}\n\nexport interface ViewSubmissionEvent {\n  type: string\n  team: Team\n  user: User\n  api_app_id: string\n  token: string\n  trigger_id: string\n  view: ViewState\n  response_urls: string[]\n  is_enterprise_install: boolean\n  enterprise: any\n}\n",
    "importStatements": [],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\ninterface Team {\n//...\n}\ninterface User {\n//...\n}\n\ninterface Option {\n//...\n}\n\ninterface Element {\n//...\n}\n\ninterface Block {\n//...\n}\n\ninterface Title {\n//...\n}\n\ninterface Submit {\n//...\n}\n\ninterface StateValues {\n//...\n}\n\ninterface ViewState {\n//...\n}\n\nexport interface ViewSubmissionEvent {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\app-flow\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\codegpt::completions",
    "language": "typescript",
    "label": "completions",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\codegpt",
    "totalTokens": 1301,
    "inDegree": 3,
    "outDegree": 12,
    "code": "async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n  try {\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${null}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      throw new Error('No plan found')\n    }\n\n    if (!agent) {\n      throw new Error(`Agent with ID ${agentId} could not be found`)\n    }\n\n    if (agent.is_frozen) {\n      throw new Error(\n        `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      )\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const userEmail = result[0].user_email\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      throw new Error('Daily interactions limit reached')\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: userEmail,\n      channel: 'SLACK',\n      source: 'API',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'slack',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: id === planId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'slack',\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages: messages as ChatMessage[],\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'SLACK',\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: false,\n      format: 'text',\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    const text = await response.json()\n\n    return text as unknown as string\n  } catch (error: unknown) {\n    console.error('Error capturado en el bloque catch:', error)\n    if (axios.isAxiosError(error)) {\n      console.error('Error details:', error.response?.data.error[0])\n    } else {\n      console.error('Error al enviar mensaje a CodeGPT:', error)\n    }\n    console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n    throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\codegpt.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\codegpt",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\codegpt.ts",
    "type": "file",
    "totalTokens": 2748,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import axios, { AxiosError } from 'axios'\nimport {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'\n// import { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport dotenv from 'dotenv'\nimport type { Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { ChatMessage } from '@/types/index.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\ndotenv.config()\n\nexport async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n  try {\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${null}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      throw new Error('No plan found')\n    }\n\n    if (!agent) {\n      throw new Error(`Agent with ID ${agentId} could not be found`)\n    }\n\n    if (agent.is_frozen) {\n      throw new Error(\n        `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      )\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const userEmail = result[0].user_email\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      throw new Error('Daily interactions limit reached')\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: userEmail,\n      channel: 'SLACK',\n      source: 'API',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'slack',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: id === planId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'slack',\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages: messages as ChatMessage[],\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'SLACK',\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: false,\n      format: 'text',\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    const text = await response.json()\n\n    return text as unknown as string\n  } catch (error: unknown) {\n    console.error('Error capturado en el bloque catch:', error)\n    if (axios.isAxiosError(error)) {\n      console.error('Error details:', error.response?.data.error[0])\n    } else {\n      console.error('Error al enviar mensaje a CodeGPT:', error)\n    }\n    console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n    throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n  }\n}\n\n// export async function completion(\n//   message: Message[]\n// ): Promise<CodeGPTResponse> {\n\n//   const payload: any = {\n//     messages: message,\n//     stream: false,\n//     format: 'text',\n//   }\n\n//   try {\n//     // console.log('payload', payload)\n//     // const response = await axios.post<CodeGPTResponse>(url, payload, {\n//     //   headers: {\n//     //     Authorization: `Bearer ${apiKey}`,\n//     //     'Content-Type': 'application/json',\n//     //   },\n//     // })\n\n//     // console.log('response OK', response.data)\n//     // return response.data\n//   } catch (error: unknown) {\n//     console.error('Error capturado en el bloque catch:', error)\n//     if (axios.isAxiosError(error)) {\n//       console.error('Error details:', error.response?.data.error[0])\n//     } else {\n//       console.error('Error al enviar mensaje a CodeGPT:', error)\n//     }\n//     console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n//     throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n//   }\n// }\n// export async function createAgent(nameAgent: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent`;\n//   const payload = { \"name\": nameAgent };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function getAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function listAgents(): Promise<any> {\n//   const url = `${apiEndpoint}/agent`\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function updateAgent(agentId: string, payload: any): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`\n\n//   try {\n//     const response = await axios.patch(url, payload, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function deleteAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.delete(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function usersMe(apiKey: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/me`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function loadDocuments(filename: string): Promise<any> {\n//   const filePath = `./Data/Documents/${filename}`;\n//   const fileContent = await fs.readFile(filePath);\n//   const formData = new FormData();\n//   formData.append('file', fileContent, { filename });\n//   const headers = {\n//     'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//     ...formData.getHeaders(),\n//   };\n//   const url = `${apiEndpoint}/document/load`;\n\n//   try {\n//     const response = await axios.post(url, formData, { headers });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function userExists(email: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/exists`;\n//   const payload = { email };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// function handleAxiosError(error: any): never {\n//   if (axios.isAxiosError(error)) {\n//     console.error('Error details:', error.response?.data.error[0])\n//     throw new Error(error.response?.data.error[0])\n//   } else {\n//     console.error('Error al enviar mensaje a CodeGPT:', error)\n//     throw new Error(error.message)\n//   }\n// }\n",
    "importStatements": [
      "import axios, { AxiosError } from 'axios'",
      "import {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'",
      "import dotenv from 'dotenv'",
      "import type { Context } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getUserAgentById } from '@/services/supabase/agents.ts'",
      "import {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { ChatMessage } from '@/types/index.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import axios, { AxiosError } from 'axios'\nimport {\n  CodeGPTResponse,\n  Message,\n} from '@/lib/integrations/slack-app/codegpt/interfaces.ts'\n// import { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport dotenv from 'dotenv'\nimport type { Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { ChatMessage } from '@/types/index.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\ndotenv.config()\n\nexport async function completions(\n  messages: Message[],\n  agentId: string,\n  userId: string,\n  orgId: string,\n  c: Context,\n): Promise<CodeGPTResponse> {\n       //...\n       }\n\n// export async function completion(\n//   message: Message[]\n// ): Promise<CodeGPTResponse> {\n\n//   const payload: any = {\n//     messages: message,\n//     stream: false,\n//     format: 'text',\n//   }\n\n//   try {\n//     // console.log('payload', payload)\n//     // const response = await axios.post<CodeGPTResponse>(url, payload, {\n//     //   headers: {\n//     //     Authorization: `Bearer ${apiKey}`,\n//     //     'Content-Type': 'application/json',\n//     //   },\n//     // })\n\n//     // console.log('response OK', response.data)\n//     // return response.data\n//   } catch (error: unknown) {\n//     console.error('Error capturado en el bloque catch:', error)\n//     if (axios.isAxiosError(error)) {\n//       console.error('Error details:', error.response?.data.error[0])\n//     } else {\n//       console.error('Error al enviar mensaje a CodeGPT:', error)\n//     }\n//     console.error(`HTTP error! status: ${(error as AxiosError).message}`)\n//     throw new Error(`HTTP error! status: ${(error as AxiosError).message}`)\n//   }\n// }\n// export async function createAgent(nameAgent: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent`;\n//   const payload = { \"name\": nameAgent };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function getAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function listAgents(): Promise<any> {\n//   const url = `${apiEndpoint}/agent`\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function updateAgent(agentId: string, payload: any): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`\n\n//   try {\n//     const response = await axios.patch(url, payload, {\n//       headers: {\n//         Authorization: `Bearer ${apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     })\n\n//     return response.data\n//   } catch (error) {\n//     handleAxiosError(error)\n//   }\n// }\n\n// export async function deleteAgent(agentId: string): Promise<any> {\n//   const url = `${apiEndpoint}/agent/${agentId}`;\n\n//   try {\n//     const response = await axios.delete(url, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function usersMe(apiKey: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/me`;\n\n//   try {\n//     const response = await axios.get(url, {\n//       headers: {\n//         'Authorization': `Bearer ${apiKey}`,\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function loadDocuments(filename: string): Promise<any> {\n//   const filePath = `./Data/Documents/${filename}`;\n//   const fileContent = await fs.readFile(filePath);\n//   const formData = new FormData();\n//   formData.append('file', fileContent, { filename });\n//   const headers = {\n//     'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//     ...formData.getHeaders(),\n//   };\n//   const url = `${apiEndpoint}/document/load`;\n\n//   try {\n//     const response = await axios.post(url, formData, { headers });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// export async function userExists(email: string): Promise<any> {\n//   const url = `${apiEndpoint}/users/exists`;\n//   const payload = { email };\n\n//   try {\n//     const response = await axios.post(url, payload, {\n//       headers: {\n//         'Authorization': `Bearer ${codeGPTConfig.apiKey}`,\n//         'Content-Type': 'application/json',\n//       },\n//     });\n\n//     return response.data;\n//   } catch (error) {\n//     handleAxiosError(error);\n//   }\n// }\n\n// function handleAxiosError(error: any): never {\n//   if (axios.isAxiosError(error)) {\n//     console.error('Error details:', error.response?.data.error[0])\n//     throw new Error(error.response?.data.error[0])\n//   } else {\n//     console.error('Error al enviar mensaje a CodeGPT:', error)\n//     throw new Error(error.message)\n//   }\n// }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\codegpt.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\interfaces::CodeGPTConfig",
    "language": "typescript",
    "label": "CodeGPTConfig",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\interfaces",
    "totalTokens": 24,
    "inDegree": 2,
    "outDegree": 1,
    "code": "interface CodeGPTConfig {\n  apiEndpoint: string\n  apiKey: string\n  agentId: string\n}",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTConfig {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\interfaces::CodeGPTResponse",
    "language": "typescript",
    "label": "CodeGPTResponse",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\interfaces",
    "totalTokens": 7,
    "inDegree": 6,
    "outDegree": 1,
    "code": "type CodeGPTResponse = string",
    "importStatements": [],
    "codeNoBody": "type CodeGPTResponse = string",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\interfaces::CodeGPTRequest",
    "language": "typescript",
    "label": "CodeGPTRequest",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\interfaces",
    "totalTokens": 45,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface CodeGPTRequest {\n  agentId: string\n  messages: Array<Message> // Aquí especificamos que 'messages' es un array de 'Message'\n  stream: boolean\n  format: string\n}",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTRequest {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\interfaces::Message",
    "language": "typescript",
    "label": "Message",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\interfaces",
    "totalTokens": 14,
    "inDegree": 8,
    "outDegree": 1,
    "code": "interface Message {\n  role: string\n  content: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Message {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\codegpt\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts",
    "type": "file",
    "totalTokens": 148,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// Define la estructura de la solicitud a la API de CodeGPT\nexport interface Message {\n  role: string\n  content: string\n}\n\n// Usar la interfaz 'Message' para definir el tipo de elementos en 'messages'\nexport interface CodeGPTRequest {\n  agentId: string\n  messages: Array<Message> // Aquí especificamos que 'messages' es un array de 'Message'\n  stream: boolean\n  format: string\n}\nexport type CodeGPTResponse = string\n\n// Define la estructura de la configuración de la API de CodeGPT\nexport interface CodeGPTConfig {\n  apiEndpoint: string\n  apiKey: string\n  agentId: string\n}\n",
    "importStatements": [],
    "codeNoBody": "// Define la estructura de la solicitud a la API de CodeGPT\nexport interface Message {\n       //...\n       }\n// Usar la interfaz 'Message' para definir el tipo de elementos en 'messages'\nexport interface CodeGPTRequest {\n       //...\n       }\nexport type CodeGPTResponse = string\n\n// Define la estructura de la configuración de la API de CodeGPT\nexport interface CodeGPTConfig {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\codegpt\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\auth0::auth0Callback",
    "language": "typescript",
    "label": "auth0Callback",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\auth0",
    "totalTokens": 382,
    "inDegree": 3,
    "outDegree": 1,
    "code": "const auth0Callback = async (code: any): Promise<AuthResponse> => {\n  try {\n    const response = await axios.post(\n      'https://slack.com/api/oauth.v2.access',\n      null,\n      {\n        params: {\n          client_id: Deno.env.get('SLACK_CLIENT_ID'),\n          client_secret: Deno.env.get('SLACK_CLIENT_SECRET'),\n          code: code,\n          redirect_uri: Deno.env.get('SLACK_REDIRECT_URI'),\n        },\n      },\n    )\n\n    if (!response.data.ok) {\n      throw new Error(response.data.error)\n    }\n\n    console.log('TOKENS A GUARDAR', response.data)\n    const authResponse: AuthResponse = response.data\n\n    return authResponse\n  } catch (error) {\n    console.error('An error occurred during authentication callback:', error)\n    throw error // Agrega esta línea para devolver el error\n  }\n}\n\nconst auth0Callback = async (code: any): Promise<AuthResponse> => {\n  try {\n    const response = await axios.post(\n      'https://slack.com/api/oauth.v2.access',\n      null,\n      {\n        params: {\n          client_id: Deno.env.get('SLACK_CLIENT_ID'),\n          client_secret: Deno.env.get('SLACK_CLIENT_SECRET'),\n          code: code,\n          redirect_uri: Deno.env.get('SLACK_REDIRECT_URI'),\n        },\n      },\n    )\n\n    if (!response.data.ok) {\n      throw new Error(response.data.error)\n    }\n\n    console.log('TOKENS A GUARDAR', response.data)\n    const authResponse: AuthResponse = response.data\n\n    return authResponse\n  } catch (error) {\n    console.error('An error occurred during authentication callback:', error)\n    throw error // Agrega esta línea para devolver el error\n  }\n}\n\nexport { auth0Callback }",
    "importStatements": [],
    "codeNoBody": "const auth0Callback = async (code: any): Promise<AuthResponse> => {\n//...\n}\nconst auth0Callback = async (code: any): Promise<AuthResponse> => {\n  try {\n    const response = await axios.post(\n      'https://slack.com/api/oauth.v2.access',\n      null,\n      {\n        params: {\n          client_id: Deno.env.get('SLACK_CLIENT_ID'),\n          client_secret: Deno.env.get('SLACK_CLIENT_SECRET'),\n          code: code,\n          redirect_uri: Deno.env.get('SLACK_REDIRECT_URI'),\n        },\n      },\n    )\n\n    if (!response.data.ok) {\n      throw new Error(response.data.error)\n    }\n\n    console.log('TOKENS A GUARDAR', response.data)\n    const authResponse: AuthResponse = response.data\n\n    return authResponse\n  } catch (error) {\n    console.error('An error occurred during authentication callback:', error)\n    throw error // Agrega esta línea para devolver el error\n  }\n}\n\nexport { auth0Callback }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\auth0.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\auth0",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\auth0.ts",
    "type": "file",
    "totalTokens": 239,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import axios from 'axios'\nimport dotenv from 'dotenv'\nimport { AuthResponse } from '@/lib/integrations/slack-app/slack/interfaces.ts'\n\ndotenv.config()\n\n// deno-lint-ignore no-explicit-any\nconst auth0Callback = async (code: any): Promise<AuthResponse> => {\n  try {\n    const response = await axios.post(\n      'https://slack.com/api/oauth.v2.access',\n      null,\n      {\n        params: {\n          client_id: Deno.env.get('SLACK_CLIENT_ID'),\n          client_secret: Deno.env.get('SLACK_CLIENT_SECRET'),\n          code: code,\n          redirect_uri: Deno.env.get('SLACK_REDIRECT_URI'),\n        },\n      },\n    )\n\n    if (!response.data.ok) {\n      throw new Error(response.data.error)\n    }\n\n    console.log('TOKENS A GUARDAR', response.data)\n    const authResponse: AuthResponse = response.data\n\n    return authResponse\n  } catch (error) {\n    console.error('An error occurred during authentication callback:', error)\n    throw error // Agrega esta línea para devolver el error\n  }\n}\n\nexport { auth0Callback }\n",
    "importStatements": [
      "import axios from 'axios'",
      "import dotenv from 'dotenv'",
      "import { AuthResponse } from '@/lib/integrations/slack-app/slack/interfaces.ts'"
    ],
    "codeNoBody": "import axios from 'axios'\nimport dotenv from 'dotenv'\nimport { AuthResponse } from '@/lib/integrations/slack-app/slack/interfaces.ts'\ndotenv.config()\n\n// deno-lint-ignore no-explicit-any\nconst auth0Callback = async (code: any): Promise<AuthResponse> => {\n//...\n}\n\nexport { auth0Callback }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\auth0.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-event::handleCommand",
    "language": "typescript",
    "label": "handleCommand",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-event",
    "totalTokens": 120,
    "inDegree": 1,
    "outDegree": 0,
    "code": "function handleCommand(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n  console.log(event.command)\n  try {\n    if (event.command === '/configureagent') {\n      configureAgent(event, accessToken)\n    }\n    if (event.command === '/ask') {\n      console.log(event)\n      // handleMessageEvent(event,accessToken)\n    }\n    if (event.command === '/selectagent') {\n      selectAgent(event, accessToken)\n    }\n  } catch (error) {\n    console.error('Error al abrir el modal de configuración:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "function handleCommand(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-event",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-event.ts",
    "type": "file",
    "totalTokens": 172,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { SlackCommandEvent } from './interfaces.ts'\nimport { configureAgent } from './command-functions/configure-agent.ts'\nimport { selectAgent } from './command-functions/select-agent.ts'\n\n// Esta función maneja el comando para configurar el agente\nexport function handleCommand(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n  console.log(event.command)\n  try {\n    if (event.command === '/configureagent') {\n      configureAgent(event, accessToken)\n    }\n    if (event.command === '/ask') {\n      console.log(event)\n      // handleMessageEvent(event,accessToken)\n    }\n    if (event.command === '/selectagent') {\n      selectAgent(event, accessToken)\n    }\n  } catch (error) {\n    console.error('Error al abrir el modal de configuración:', error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import { SlackCommandEvent } from './interfaces.ts'",
      "import { configureAgent } from './command-functions/configure-agent.ts'",
      "import { selectAgent } from './command-functions/select-agent.ts'"
    ],
    "codeNoBody": "import { SlackCommandEvent } from './interfaces.ts'\nimport { configureAgent } from './command-functions/configure-agent.ts'\nimport { selectAgent } from './command-functions/select-agent.ts'\n// Esta función maneja el comando para configurar el agente\nexport function handleCommand(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-functions\\ask",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-functions\\ask.ts",
    "type": "file",
    "totalTokens": 424,
    "inDegree": 0,
    "outDegree": 0,
    "code": "// import { WebClient } from '@slack/web-api';\n// import { SlackCommandEvent } from '../interfaces';\n// import { completions } from '../../codegpt/codegpt';\n\n// // Esta función maneja los eventos de mensaje de Slack\n// export async function handleMessageEvent(slackEvent: SlackCommandEvent, access_token: string) {\n\n//   // Crea una instancia del cliente de Slack con tu token de bot\n//   const slackClient = new WebClient(access_token);\n\n//   try {\n//     let message = [\n//       {\n//         role: \"user\",\n//         content : slackEvent.text\n//       }\n//     ]\n//     // Suponiendo que completions es una función que procesa el texto y devuelve una respuesta\n//     const codeGPTResponse = await completions(message);\n//     const responseText = codeGPTResponse;\n\n//     // Prepara los parámetros para enviar la respuesta de CodeGPT al canal de Slack\n//     const postMessageParams = {\n//       channel: slackEvent.channel_id,\n//       text: `<@${slackEvent.user_id}> ${responseText}`,\n//       // Si el mensaje es parte de un hilo, incluye el 'thread_ts' para responder en el hilo\n//       thread_ts: slackEvent.event.thread_ts || undefined\n//     };\n\n//     // Envía la respuesta al canal de Slack usando la API de Slack\n//     await slackClient.chat.postMessage(postMessageParams);\n//   } catch (error) {\n//     console.error('Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:', error);\n//     // Devuelve una respuesta indicando que hubo un error\n//     return {\n//       statusCode: 500,\n//       body: 'Error al procesar el evento de mensaje'\n//     };\n//   }\n\n//   // Devuelve una respuesta para indicar que el evento fue procesado con éxito\n//   return {\n//     statusCode: 200,\n//     body: 'Evento de mensaje procesado'\n//   };\n// }\n",
    "importStatements": [],
    "codeNoBody": "// import { WebClient } from '@slack/web-api';\n// import { SlackCommandEvent } from '../interfaces';\n// import { completions } from '../../codegpt/codegpt';\n// // Esta función maneja los eventos de mensaje de Slack\n// export async function handleMessageEvent(slackEvent: SlackCommandEvent, access_token: string) {\n\n//   // Crea una instancia del cliente de Slack con tu token de bot\n//   const slackClient = new WebClient(access_token);\n\n//   try {\n//     let message = [\n//       {\n//         role: \"user\",\n//         content : slackEvent.text\n//       }\n//     ]\n//     // Suponiendo que completions es una función que procesa el texto y devuelve una respuesta\n//     const codeGPTResponse = await completions(message);\n//     const responseText = codeGPTResponse;\n\n//     // Prepara los parámetros para enviar la respuesta de CodeGPT al canal de Slack\n//     const postMessageParams = {\n//       channel: slackEvent.channel_id,\n//       text: `<@${slackEvent.user_id}> ${responseText}`,\n//       // Si el mensaje es parte de un hilo, incluye el 'thread_ts' para responder en el hilo\n//       thread_ts: slackEvent.event.thread_ts || undefined\n//     };\n\n//     // Envía la respuesta al canal de Slack usando la API de Slack\n//     await slackClient.chat.postMessage(postMessageParams);\n//   } catch (error) {\n//     console.error('Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:', error);\n//     // Devuelve una respuesta indicando que hubo un error\n//     return {\n//       statusCode: 500,\n//       body: 'Error al procesar el evento de mensaje'\n//     };\n//   }\n\n//   // Devuelve una respuesta para indicar que el evento fue procesado con éxito\n//   return {\n//     statusCode: 200,\n//     body: 'Evento de mensaje procesado'\n//   };\n// }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-functions\\ask.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-functions\\configure-agent",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-functions\\configure-agent.ts",
    "type": "file",
    "totalTokens": 701,
    "inDegree": 0,
    "outDegree": 0,
    "code": "// import { ViewsOpenArguments, WebClient } from '@slack/web-api'\n// import { SlackCommandEvent } from '../interfaces.ts'\n// acá toca agregarle llamados a supabase no a turso\n\n// export async function configureAgent(\n//   event: SlackCommandEvent,\n//   accessToken: string,\n// ): Promise<void> {\n//   try {\n//     const agent = await findUserWithAgent(event.user_id)\n\n//     const slackClient = new WebClient(accessToken)\n//     let modal: ViewsOpenArguments\n\n//     console.log('agent', agent)\n//     if (!agent) {\n//       // Define el modal para mostrar el mensaje de que no hay agente seleccionado\n//       modal = {\n//         trigger_id: event.trigger_id,\n//         view: {\n//           type: 'modal',\n//           callback_id: 'agent_not_selected_modal',\n//           title: {\n//             type: 'plain_text',\n//             text: 'Agente no seleccionado',\n//           },\n//           blocks: [\n//             {\n//               type: 'section',\n//               text: {\n//                 type: 'mrkdwn',\n//                 text:\n//                   'No tienes un agente seleccionado, elígelo usando el comando /selectAgent',\n//               },\n//             },\n//           ],\n//         },\n//       }\n//     } else {\n//       // Define el modal para configurar el agente\n//       modal = {\n//         trigger_id: event.trigger_id,\n//         view: {\n//           type: 'modal',\n//           callback_id: 'configure_agent_modal',\n//           title: {\n//             type: 'plain_text',\n//             text: `Configurar ${agent.agent_name}`,\n//           },\n//           // Se elimina la propiedad submit para que los campos no sean obligatorios\n//           blocks: [\n//             {\n//               type: 'input',\n//               block_id: 'prompt_block',\n//               optional: true, // Hace que este campo no sea obligatorio\n//               element: {\n//                 type: 'plain_text_input',\n//                 action_id: 'prompt_input',\n//                 placeholder: {\n//                   type: 'plain_text',\n//                   text: 'Ingrese el prompt del agente',\n//                 },\n//               },\n//               label: {\n//                 type: 'plain_text',\n//                 text: 'Prompt',\n//               },\n//             },\n//             {\n//               type: 'input',\n//               block_id: 'name_block',\n//               optional: true, // Hace que este campo no sea obligatorio\n//               element: {\n//                 type: 'plain_text_input',\n//                 action_id: 'name_input',\n//                 placeholder: {\n//                   type: 'plain_text',\n//                   text: 'Ingrese el nombre del agente',\n//                 },\n//               },\n//               label: {\n//                 type: 'plain_text',\n//                 text: 'Nombre',\n//               },\n//             },\n//           ],\n//           submit: {\n//             type: 'plain_text',\n//             text: 'Guardar',\n//           },\n//         },\n//       }\n//     }\n//     // Abre el modal\n//     await slackClient.views.open(modal)\n//   } catch (error) {\n//     console.error('Error al abrir el modal de configuración:', error)\n//     throw error\n//   }\n// }\n",
    "importStatements": [],
    "codeNoBody": "// import { ViewsOpenArguments, WebClient } from '@slack/web-api'\n// import { SlackCommandEvent } from '../interfaces.ts'\n// acá toca agregarle llamados a supabase no a turso\n// export async function configureAgent(\n//   event: SlackCommandEvent,\n//   accessToken: string,\n// ): Promise<void> {\n//   try {\n//     const agent = await findUserWithAgent(event.user_id)\n\n//     const slackClient = new WebClient(accessToken)\n//     let modal: ViewsOpenArguments\n\n//     console.log('agent', agent)\n//     if (!agent) {\n//       // Define el modal para mostrar el mensaje de que no hay agente seleccionado\n//       modal = {\n//         trigger_id: event.trigger_id,\n//         view: {\n//           type: 'modal',\n//           callback_id: 'agent_not_selected_modal',\n//           title: {\n//             type: 'plain_text',\n//             text: 'Agente no seleccionado',\n//           },\n//           blocks: [\n//             {\n//               type: 'section',\n//               text: {\n//                 type: 'mrkdwn',\n//                 text:\n//                   'No tienes un agente seleccionado, elígelo usando el comando /selectAgent',\n//               },\n//             },\n//           ],\n//         },\n//       }\n//     } else {\n//       // Define el modal para configurar el agente\n//       modal = {\n//         trigger_id: event.trigger_id,\n//         view: {\n//           type: 'modal',\n//           callback_id: 'configure_agent_modal',\n//           title: {\n//             type: 'plain_text',\n//             text: `Configurar ${agent.agent_name}`,\n//           },\n//           // Se elimina la propiedad submit para que los campos no sean obligatorios\n//           blocks: [\n//             {\n//               type: 'input',\n//               block_id: 'prompt_block',\n//               optional: true, // Hace que este campo no sea obligatorio\n//               element: {\n//                 type: 'plain_text_input',\n//                 action_id: 'prompt_input',\n//                 placeholder: {\n//                   type: 'plain_text',\n//                   text: 'Ingrese el prompt del agente',\n//                 },\n//               },\n//               label: {\n//                 type: 'plain_text',\n//                 text: 'Prompt',\n//               },\n//             },\n//             {\n//               type: 'input',\n//               block_id: 'name_block',\n//               optional: true, // Hace que este campo no sea obligatorio\n//               element: {\n//                 type: 'plain_text_input',\n//                 action_id: 'name_input',\n//                 placeholder: {\n//                   type: 'plain_text',\n//                   text: 'Ingrese el nombre del agente',\n//                 },\n//               },\n//               label: {\n//                 type: 'plain_text',\n//                 text: 'Nombre',\n//               },\n//             },\n//           ],\n//           submit: {\n//             type: 'plain_text',\n//             text: 'Guardar',\n//           },\n//         },\n//       }\n//     }\n//     // Abre el modal\n//     await slackClient.views.open(modal)\n//   } catch (error) {\n//     console.error('Error al abrir el modal de configuración:', error)\n//     throw error\n//   }\n// }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-functions\\configure-agent.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent::selectAgent",
    "language": "typescript",
    "label": "selectAgent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent",
    "totalTokens": 333,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function selectAgent(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n  try {\n    const agents = await listAgents()\n    console.log('agents', agents)\n    const slackClient = new WebClient(accessToken)\n    let modal: ViewsOpenArguments\n\n    // Define el modal para seleccionar un agente de un menú desplegable dentro de un bloque de entrada\n    modal = {\n      trigger_id: event.trigger_id,\n      view: {\n        type: 'modal',\n        callback_id: 'select_agent_modal',\n        title: {\n          type: 'plain_text',\n          text: 'Selecciona un Agente',\n        },\n        blocks: [\n          {\n            type: 'input',\n            block_id: 'agent_selection_block',\n            element: {\n              type: 'static_select',\n              placeholder: {\n                type: 'plain_text',\n                text: 'Selecciona un agente',\n              },\n              options: agents.map((agent: Agent) => ({\n                text: {\n                  type: 'plain_text',\n                  text: agent.name,\n                },\n                value: agent.id.toString(),\n              })),\n              action_id: 'agent_selection',\n            },\n            label: {\n              type: 'plain_text',\n              text: 'Agentes disponibles',\n            },\n          },\n        ],\n        submit: {\n          type: 'plain_text',\n          text: 'Confirmar',\n        },\n      },\n    }\n\n    // Abre el modal\n    await slackClient.views.open(modal)\n  } catch (error) {\n    console.error('Error al abrir el modal de selección:', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function selectAgent(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent::Agent",
    "language": "typescript",
    "label": "Agent",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent",
    "totalTokens": 13,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type Agent = Database['public']['Tables']['agents']['Row']",
    "importStatements": [],
    "codeNoBody": "type Agent = Database['public']['Tables']['agents']['Row']",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent.ts",
    "type": "file",
    "totalTokens": 411,
    "inDegree": 0,
    "outDegree": 2,
    "code": "// deno-lint-ignore-file prefer-const\nimport { ViewsOpenArguments, WebClient } from '@slack/web-api'\nimport { SlackCommandEvent } from '../interfaces.ts'\nimport { listAgents } from '../../codegpt/codegpt.ts'\nimport type { Database } from '../../../../../types/supabase.ts'\n\ntype Agent = Database['public']['Tables']['agents']['Row']\n\nexport async function selectAgent(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n  try {\n    const agents = await listAgents()\n    console.log('agents', agents)\n    const slackClient = new WebClient(accessToken)\n    let modal: ViewsOpenArguments\n\n    // Define el modal para seleccionar un agente de un menú desplegable dentro de un bloque de entrada\n    modal = {\n      trigger_id: event.trigger_id,\n      view: {\n        type: 'modal',\n        callback_id: 'select_agent_modal',\n        title: {\n          type: 'plain_text',\n          text: 'Selecciona un Agente',\n        },\n        blocks: [\n          {\n            type: 'input',\n            block_id: 'agent_selection_block',\n            element: {\n              type: 'static_select',\n              placeholder: {\n                type: 'plain_text',\n                text: 'Selecciona un agente',\n              },\n              options: agents.map((agent: Agent) => ({\n                text: {\n                  type: 'plain_text',\n                  text: agent.name,\n                },\n                value: agent.id.toString(),\n              })),\n              action_id: 'agent_selection',\n            },\n            label: {\n              type: 'plain_text',\n              text: 'Agentes disponibles',\n            },\n          },\n        ],\n        submit: {\n          type: 'plain_text',\n          text: 'Confirmar',\n        },\n      },\n    }\n\n    // Abre el modal\n    await slackClient.views.open(modal)\n  } catch (error) {\n    console.error('Error al abrir el modal de selección:', error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import { ViewsOpenArguments, WebClient } from '@slack/web-api'",
      "import { SlackCommandEvent } from '../interfaces.ts'",
      "import { listAgents } from '../../codegpt/codegpt.ts'",
      "import type { Database } from '../../../../../types/supabase.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file prefer-const\nimport { ViewsOpenArguments, WebClient } from '@slack/web-api'\nimport { SlackCommandEvent } from '../interfaces.ts'\nimport { listAgents } from '../../codegpt/codegpt.ts'\nimport type { Database } from '../../../../../types/supabase.ts'\ntype Agent = Database['public']['Tables']['agents']['Row']\n\nexport async function selectAgent(\n  event: SlackCommandEvent,\n  accessToken: string,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\command-functions\\select-agent.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\interfaces::AuthResponse",
    "language": "typescript",
    "label": "AuthResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\interfaces",
    "totalTokens": 143,
    "inDegree": 5,
    "outDegree": 1,
    "code": "interface AuthResponse {\n  ok: boolean\n  app_id: string\n  authed_user: {\n    id: string\n    scope: string\n    access_token: string\n    token_type: string\n  }\n  scope: string\n  token_type: string\n  access_token: string\n  bot_user_id: string\n  team: {\n    id: string\n    name: string\n  }\n  enterprise: any // Puedes especificar el tipo correcto si lo conoces\n  is_enterprise_install: boolean\n  incoming_webhook: {\n    channel: string\n    channel_id: string\n    configuration_url: string\n    url: string\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface AuthResponse {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\interfaces::SlackCommandEvent",
    "language": "typescript",
    "label": "SlackCommandEvent",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\interfaces",
    "totalTokens": 83,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface SlackCommandEvent {\n  token: string\n  team_id: string\n  team_domain: string\n  channel_id: string\n  channel_name: string\n  user_id: string\n  user_name: string\n  command: string\n  text: string\n  api_app_id: string\n  is_enterprise_install: string\n  response_url: string\n  trigger_id: string\n}",
    "importStatements": [],
    "codeNoBody": "interface SlackCommandEvent {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\interfaces::SlackEvent",
    "language": "typescript",
    "label": "SlackEvent",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\interfaces",
    "totalTokens": 185,
    "inDegree": 6,
    "outDegree": 1,
    "code": "interface SlackEvent {\n  token: string\n  team_id: string\n  context_team_id: string\n  context_enterprise_id: string | null\n  api_app_id: string\n  event: {\n    client_msg_id: string\n    type: string\n    text: string\n    user: string\n    ts: string\n    blocks: any[]\n    team: string\n    channel: string\n    event_ts: string\n    channel_type: string\n    bot_id: string\n    thread_ts: string\n  }\n  type: string\n  event_id: string\n  event_time: number\n  authorizations: {\n    enterprise_id: string | null\n    team_id: string\n    user_id: string\n    is_bot: boolean\n    is_enterprise_install: boolean\n  }[]\n  is_ext_shared_channel: boolean\n  event_context: string\n}",
    "importStatements": [],
    "codeNoBody": "interface SlackEvent {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\interfaces.ts",
    "type": "file",
    "totalTokens": 455,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// deno-lint-ignore-file no-explicit-any\n\nexport interface SlackEvent {\n  token: string\n  team_id: string\n  context_team_id: string\n  context_enterprise_id: string | null\n  api_app_id: string\n  event: {\n    client_msg_id: string\n    type: string\n    text: string\n    user: string\n    ts: string\n    blocks: any[]\n    team: string\n    channel: string\n    event_ts: string\n    channel_type: string\n    bot_id: string\n    thread_ts: string\n  }\n  type: string\n  event_id: string\n  event_time: number\n  authorizations: {\n    enterprise_id: string | null\n    team_id: string\n    user_id: string\n    is_bot: boolean\n    is_enterprise_install: boolean\n  }[]\n  is_ext_shared_channel: boolean\n  event_context: string\n}\n// Este es interface de respuesta de cliente. Es el único que admitimos ahora. Podemos sumar más tipos si los necesitamos.\n\nexport interface SlackCommandEvent {\n  token: string\n  team_id: string\n  team_domain: string\n  channel_id: string\n  channel_name: string\n  user_id: string\n  user_name: string\n  command: string\n  text: string\n  api_app_id: string\n  is_enterprise_install: string\n  response_url: string\n  trigger_id: string\n}\nexport interface AuthResponse {\n  ok: boolean\n  app_id: string\n  authed_user: {\n    id: string\n    scope: string\n    access_token: string\n    token_type: string\n  }\n  scope: string\n  token_type: string\n  access_token: string\n  bot_user_id: string\n  team: {\n    id: string\n    name: string\n  }\n  enterprise: any // Puedes especificar el tipo correcto si lo conoces\n  is_enterprise_install: boolean\n  incoming_webhook: {\n    channel: string\n    channel_id: string\n    configuration_url: string\n    url: string\n  }\n}\n",
    "importStatements": [],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nexport interface SlackEvent {\n       //...\n       }\n// Este es interface de respuesta de cliente. Es el único que admitimos ahora. Podemos sumar más tipos si los necesitamos.\n\nexport interface SlackCommandEvent {\n       //...\n       }\nexport interface AuthResponse {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\message-event::directMessageEvent",
    "language": "typescript",
    "label": "directMessageEvent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\message-event",
    "totalTokens": 565,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function directMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  if (!slackEvent.event.client_msg_id || slackEvent.event.bot_id) {\n    return {\n      statusCode: 200,\n      body: 'Evento descartado',\n    }\n  }\n\n  const slackClient = new WebClient(workspace.access_token)\n\n  try {\n    const history = await slackClient.conversations.history({\n      channel: slackEvent.event.channel,\n    })\n\n    const messages = history?.messages?.slice(0, 10).reverse()\n    const messageArray = messages?.map((message) => {\n      let role = 'user'\n      if (message.bot_id) {\n        role = 'assistant'\n      }\n      return { role, content: message.text as string }\n    })\n\n    messageArray?.push({\n      role: 'user',\n      content: slackEvent.event.text,\n    })\n\n    if (!messageArray) {\n      throw new Error(\n        'Hubo un error al obtener el historial de conversaciones.',\n      )\n    }\n\n    const [{ user_id, org_id, agent_id }] = await sql`\n    select\n      ou.user_id,\n      ou.org_id,\n      coalesce(sw.agent_id, (\n        select sc.agent_id\n        from slack_channels sc\n        where sc.workspace_id = sw.id\n        limit 1\n      )) agent_id,\n      a.name as agent_name\n    from slack_workspaces sw\n    join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n    left join agents a on a.id = coalesce(sw.agent_id, (\n      select sc.agent_id\n      from slack_channels sc\n      where sc.workspace_id = sw.id\n      limit 1\n    ))\n    where sw.id = ${workspace.id}`\n\n    const agentId = agent_id || workspace.agent_id\n    const responseText = agentId\n      ? await completions(messageArray, agentId, user_id, org_id, c)\n      : 'No tienes enlazado ningún agente de manera general '\n\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `${responseText}`,\n    }\n\n    await slackClient.chat.postMessage(postMessageParams)\n  } catch (error) {\n    console.error(\n      'Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:',\n      error,\n    )\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `We had a problem processing your message.`,\n    }\n    await slackClient.chat.postMessage(postMessageParams)\n    throw error\n  }\n\n  return {\n    statusCode: 200,\n    body: 'Evento de mensaje procesado',\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function directMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\message-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\message-event::handleMessageEvent",
    "language": "typescript",
    "label": "handleMessageEvent",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\message-event",
    "totalTokens": 839,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function handleMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  if (!slackEvent.event.client_msg_id || slackEvent.event.bot_id) {\n    return {\n      statusCode: 200,\n      body: 'Evento descartado',\n    }\n  }\n\n  const slackClient = new WebClient(workspace.access_token)\n\n  try {\n    const firstMessageParam = {\n      channel: slackEvent.event.channel,\n      text: `:hourglass_flowing_sand:`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n\n    const initialMessageResponse = await slackClient.chat.postMessage(\n      firstMessageParam,\n    )\n\n    let message: { role: 'user' | 'assistant'; content: string }[] = []\n    if (slackEvent.event.thread_ts) {\n      const threadHistory = await slackClient.conversations.replies({\n        channel: slackEvent.event.channel,\n        ts: slackEvent.event.thread_ts,\n      })\n\n      const threadMessages = threadHistory?.messages?.slice(-10)\n      const threadMessageArray = threadMessages?.map((threadMessage) => {\n        let role = 'user'\n        if (threadMessage.bot_id) {\n          role = 'assistant'\n        }\n        const content = threadMessage.text as string\n        if (\n          content !== ':hourglass_flowing_sand:' && !content.includes('Error')\n        ) {\n          return { role, content }\n        }\n        return null\n      }).filter(Boolean)\n\n      message = threadMessageArray as {\n        role: 'user' | 'assistant'\n        content: string\n      }[]\n      if (message.length > 0 && message[0].role === 'assistant') {\n        message = message.slice(1)\n      }\n    } else {\n      message = [\n        {\n          role: 'user',\n          content: slackEvent.event.text,\n        },\n      ]\n    }\n\n    if (!message || message.length === 0) {\n      throw new Error(\n        'Hubo un error al obtener los mensajes de las conversaciones.',\n      )\n    }\n\n    const res = await sql`\n      select \n        ou.user_id,\n        ou.org_id,\n        coalesce(sc.agent_id, sw.agent_id) agent_id,\n        a.name as agent_name\n      from slack_workspaces sw\n      join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n      left join slack_channels sc on sc.workspace_id = sw.id  and sc.id = ${slackEvent.event.channel}\n      left join agents a on a.id = coalesce(sc.agent_id, sw.agent_id)\n      where sw.id = ${workspace.id}`\n\n    let responseText\n    if (res.length === 0) {\n      responseText =\n        'The workspace or channel is not associated with any agent.'\n    } else {\n      const [{ user_id, org_id, agent_id }] = res\n      const agentId = agent_id || workspace.agent_id\n      responseText = agentId && message\n        ? await completions(message, agentId, user_id, org_id, c)\n        : 'No tienes enlazado ningún agente a este canal ni de manera general'\n    }\n\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      ts: initialMessageResponse.ts as string,\n      text: `${responseText}`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n\n    await slackClient.chat.update(postMessageParams)\n  } catch (error) {\n    console.error(\n      'Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:',\n      error,\n    )\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `We had a problem processing your message.`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n    await slackClient.chat.postMessage(postMessageParams)\n    throw error\n  }\n\n  return {\n    statusCode: 200,\n    body: 'Evento de mensaje procesado',\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function handleMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\message-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\message-event",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\message-event.ts",
    "type": "file",
    "totalTokens": 1502,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { WebClient } from '@slack/web-api'\nimport { SlackEvent } from '@/lib/integrations/slack-app/slack/interfaces.ts'\nimport { completions } from '@/lib/integrations/slack-app/codegpt/codegpt.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport { type Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\n\nexport async function handleMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  if (!slackEvent.event.client_msg_id || slackEvent.event.bot_id) {\n    return {\n      statusCode: 200,\n      body: 'Evento descartado',\n    }\n  }\n\n  const slackClient = new WebClient(workspace.access_token)\n\n  try {\n    const firstMessageParam = {\n      channel: slackEvent.event.channel,\n      text: `:hourglass_flowing_sand:`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n\n    const initialMessageResponse = await slackClient.chat.postMessage(\n      firstMessageParam,\n    )\n\n    let message: { role: 'user' | 'assistant'; content: string }[] = []\n    if (slackEvent.event.thread_ts) {\n      const threadHistory = await slackClient.conversations.replies({\n        channel: slackEvent.event.channel,\n        ts: slackEvent.event.thread_ts,\n      })\n\n      const threadMessages = threadHistory?.messages?.slice(-10)\n      const threadMessageArray = threadMessages?.map((threadMessage) => {\n        let role = 'user'\n        if (threadMessage.bot_id) {\n          role = 'assistant'\n        }\n        const content = threadMessage.text as string\n        if (\n          content !== ':hourglass_flowing_sand:' && !content.includes('Error')\n        ) {\n          return { role, content }\n        }\n        return null\n      }).filter(Boolean)\n\n      message = threadMessageArray as {\n        role: 'user' | 'assistant'\n        content: string\n      }[]\n      if (message.length > 0 && message[0].role === 'assistant') {\n        message = message.slice(1)\n      }\n    } else {\n      message = [\n        {\n          role: 'user',\n          content: slackEvent.event.text,\n        },\n      ]\n    }\n\n    if (!message || message.length === 0) {\n      throw new Error(\n        'Hubo un error al obtener los mensajes de las conversaciones.',\n      )\n    }\n\n    const res = await sql`\n      select \n        ou.user_id,\n        ou.org_id,\n        coalesce(sc.agent_id, sw.agent_id) agent_id,\n        a.name as agent_name\n      from slack_workspaces sw\n      join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n      left join slack_channels sc on sc.workspace_id = sw.id  and sc.id = ${slackEvent.event.channel}\n      left join agents a on a.id = coalesce(sc.agent_id, sw.agent_id)\n      where sw.id = ${workspace.id}`\n\n    let responseText\n    if (res.length === 0) {\n      responseText =\n        'The workspace or channel is not associated with any agent.'\n    } else {\n      const [{ user_id, org_id, agent_id }] = res\n      const agentId = agent_id || workspace.agent_id\n      responseText = agentId && message\n        ? await completions(message, agentId, user_id, org_id, c)\n        : 'No tienes enlazado ningún agente a este canal ni de manera general'\n    }\n\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      ts: initialMessageResponse.ts as string,\n      text: `${responseText}`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n\n    await slackClient.chat.update(postMessageParams)\n  } catch (error) {\n    console.error(\n      'Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:',\n      error,\n    )\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `We had a problem processing your message.`,\n      thread_ts: slackEvent.event.thread_ts || slackEvent.event.ts,\n    }\n    await slackClient.chat.postMessage(postMessageParams)\n    throw error\n  }\n\n  return {\n    statusCode: 200,\n    body: 'Evento de mensaje procesado',\n  }\n}\n\nexport async function directMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n  if (!slackEvent.event.client_msg_id || slackEvent.event.bot_id) {\n    return {\n      statusCode: 200,\n      body: 'Evento descartado',\n    }\n  }\n\n  const slackClient = new WebClient(workspace.access_token)\n\n  try {\n    const history = await slackClient.conversations.history({\n      channel: slackEvent.event.channel,\n    })\n\n    const messages = history?.messages?.slice(0, 10).reverse()\n    const messageArray = messages?.map((message) => {\n      let role = 'user'\n      if (message.bot_id) {\n        role = 'assistant'\n      }\n      return { role, content: message.text as string }\n    })\n\n    messageArray?.push({\n      role: 'user',\n      content: slackEvent.event.text,\n    })\n\n    if (!messageArray) {\n      throw new Error(\n        'Hubo un error al obtener el historial de conversaciones.',\n      )\n    }\n\n    const [{ user_id, org_id, agent_id }] = await sql`\n    select\n      ou.user_id,\n      ou.org_id,\n      coalesce(sw.agent_id, (\n        select sc.agent_id\n        from slack_channels sc\n        where sc.workspace_id = sw.id\n        limit 1\n      )) agent_id,\n      a.name as agent_name\n    from slack_workspaces sw\n    join organization_user ou on ou.org_id = sw.org_id and ou.role = 'owner'\n    left join agents a on a.id = coalesce(sw.agent_id, (\n      select sc.agent_id\n      from slack_channels sc\n      where sc.workspace_id = sw.id\n      limit 1\n    ))\n    where sw.id = ${workspace.id}`\n\n    const agentId = agent_id || workspace.agent_id\n    const responseText = agentId\n      ? await completions(messageArray, agentId, user_id, org_id, c)\n      : 'No tienes enlazado ningún agente de manera general '\n\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `${responseText}`,\n    }\n\n    await slackClient.chat.postMessage(postMessageParams)\n  } catch (error) {\n    console.error(\n      'Error al obtener respuesta de CodeGPT o al enviar mensaje a Slack:',\n      error,\n    )\n    const postMessageParams = {\n      channel: slackEvent.event.channel,\n      text: `We had a problem processing your message.`,\n    }\n    await slackClient.chat.postMessage(postMessageParams)\n    throw error\n  }\n\n  return {\n    statusCode: 200,\n    body: 'Evento de mensaje procesado',\n  }\n}\n",
    "importStatements": [
      "import { WebClient } from '@slack/web-api'",
      "import { SlackEvent } from '@/lib/integrations/slack-app/slack/interfaces.ts'",
      "import { completions } from '@/lib/integrations/slack-app/codegpt/codegpt.ts'",
      "import { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'",
      "import { type Context } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { WebClient } from '@slack/web-api'\nimport { SlackEvent } from '@/lib/integrations/slack-app/slack/interfaces.ts'\nimport { completions } from '@/lib/integrations/slack-app/codegpt/codegpt.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nimport { type Context } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nexport async function handleMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }\n\nexport async function directMessageEvent(\n  slackEvent: SlackEvent,\n  workspace: dbWorkspace,\n  c: Context,\n) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\message-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\modal-event::handleModalSubmission",
    "language": "typescript",
    "label": "handleModalSubmission",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\modal-event",
    "totalTokens": 264,
    "inDegree": 1,
    "outDegree": 0,
    "code": "async function handleModalSubmission(event: any) {\n  console.log('Event on handleModalSubmission', event)\n  try {\n    if (event.view.callback_id === 'select_agent_modal') {\n      assignAgentToUser(event)\n    }\n    if (event.view.callback_id === 'configure_agent_modal') {\n      const payload: any = {}\n\n      // Verificar si existe name_block y agregarlo al payload si es así\n      if (event.view.state.values.name_block.name_input.value) {\n        payload.name = event.view.state.values.name_block.name_input.value\n      }\n\n      // Verificar si existe prompt_block y agregarlo al payload si es así\n      if (event.view.state.values.prompt_block.prompt_input.value) {\n        payload.prompt = event.view.state.values.prompt_block.prompt_input.value\n      }\n      console.log(payload)\n      const agent = await findUserWithAgent(event.user.id)\n      updateAgent(agent.agent_id, payload)\n    }\n\n    return {\n      statusCode: 200,\n      body: 'Configuración actualizada con éxito',\n    }\n  } catch (error) {\n    console.error('Error al procesar la configuración del modal:', error)\n    return {\n      statusCode: 500,\n      body: 'Error al procesar la configuración',\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function handleModalSubmission(event: any) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\modal-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\modal-event",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\modal-event.ts",
    "type": "file",
    "totalTokens": 318,
    "inDegree": 0,
    "outDegree": 1,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { updateAgent } from '../codegpt/codegpt.ts'\nimport {\n  assignAgentToUser,\n  findUserWithAgent,\n} from './services/turso/users-repository.ts'\n\nexport async function handleModalSubmission(event: any) {\n  console.log('Event on handleModalSubmission', event)\n  try {\n    if (event.view.callback_id === 'select_agent_modal') {\n      assignAgentToUser(event)\n    }\n    if (event.view.callback_id === 'configure_agent_modal') {\n      const payload: any = {}\n\n      // Verificar si existe name_block y agregarlo al payload si es así\n      if (event.view.state.values.name_block.name_input.value) {\n        payload.name = event.view.state.values.name_block.name_input.value\n      }\n\n      // Verificar si existe prompt_block y agregarlo al payload si es así\n      if (event.view.state.values.prompt_block.prompt_input.value) {\n        payload.prompt = event.view.state.values.prompt_block.prompt_input.value\n      }\n      console.log(payload)\n      const agent = await findUserWithAgent(event.user.id)\n      updateAgent(agent.agent_id, payload)\n    }\n\n    return {\n      statusCode: 200,\n      body: 'Configuración actualizada con éxito',\n    }\n  } catch (error) {\n    console.error('Error al procesar la configuración del modal:', error)\n    return {\n      statusCode: 500,\n      body: 'Error al procesar la configuración',\n    }\n  }\n}\n",
    "importStatements": [
      "import { updateAgent } from '../codegpt/codegpt.ts'",
      "import {\n  assignAgentToUser,\n  findUserWithAgent,\n} from './services/turso/users-repository.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { updateAgent } from '../codegpt/codegpt.ts'\nimport {\n  assignAgentToUser,\n  findUserWithAgent,\n} from './services/turso/users-repository.ts'\nexport async function handleModalSubmission(event: any) {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\modal-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents::getAgentsByOrgId",
    "language": "typescript",
    "label": "getAgentsByOrgId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents",
    "totalTokens": 118,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function getAgentsByOrgId(\n  org_id: string,\n): Promise<dbAgent[] | null> {\n  try {\n    const { data: agents, error } = await supabase\n      .from('agents')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading agents:', error)\n      return null\n    }\n    return agents\n  } catch (error: any) {\n    console.error('An error occurred while reading agents:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAgentsByOrgId(\n  org_id: string,\n): Promise<dbAgent[] | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents.ts",
    "type": "file",
    "totalTokens": 171,
    "inDegree": 0,
    "outDegree": 2,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\nimport { dbAgent } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\n\nexport async function getAgentsByOrgId(\n  org_id: string,\n): Promise<dbAgent[] | null> {\n  try {\n    const { data: agents, error } = await supabase\n      .from('agents')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading agents:', error)\n      return null\n    }\n    return agents\n  } catch (error: any) {\n    console.error('An error occurred while reading agents:', error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { dbAgent } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\nimport { dbAgent } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\nexport async function getAgentsByOrgId(\n  org_id: string,\n): Promise<dbAgent[] | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels::findChannelByWorkspace",
    "language": "typescript",
    "label": "findChannelByWorkspace",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels",
    "totalTokens": 157,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function findChannelByWorkspace(\n  channel_id: string,\n  workspace_id: string,\n): Promise<string | null> {\n  try {\n    const { data, error } = await supabase\n      .from('slack_channels')\n      .select('agent_id')\n      .eq('id', channel_id)\n      .eq('workspace_id', workspace_id)\n      .single()\n\n    if (error) {\n      console.error('Error finding channel:', error)\n      return null\n    }\n\n    // Devolver el 'agent_id' si encontramos una coincidencia\n    return data ? data.agent_id : null\n  } catch (error: any) {\n    console.error('An error occurred while finding channel:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function findChannelByWorkspace(\n  channel_id: string,\n  workspace_id: string,\n): Promise<string | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels::saveOrUpdateChannel",
    "language": "typescript",
    "label": "saveOrUpdateChannel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels",
    "totalTokens": 297,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function saveOrUpdateChannel(\n  agent_id: string,\n  id: string,\n  workspace_id: string,\n  name: string,\n): Promise<any[] | null> {\n  try {\n    // Reemplazamos la tabla a la que se hace la consulta.\n    const { data, error } = await supabase\n      .from('slack_channels')\n      .upsert({ // 'upsert' insertará o actualizará la entrada dependiendo si existe o no.\n        id,\n        agent_id,\n        workspace_id,\n        name,\n        // Notar que 'created_at' no se incluye ya que Supabase maneja automáticamente este campo si está configurado con el valor por defecto 'now()'.\n      }, {\n        onConflict: 'id', // Indicamos que 'id' es nuestra clave única para decidir si actualizamos o insertamos.\n      })\n\n    // Manejamos y mostramos cualquier error que surja.\n    if (error) {\n      console.error('Error saving or updating channel:', error)\n      return null\n    }\n\n    // Devolvemos los datos de los canales actualizados o creados.\n    console.log('Updated or created channel:', data)\n    return data\n  } catch (error: any) {\n    console.error('An error occurred while saving or updating channel:', error)\n    return null\n  }\n} // deno-lint-ignore-file no-explicit-any",
    "importStatements": [],
    "codeNoBody": "async function saveOrUpdateChannel(\n  agent_id: string,\n  id: string,\n  workspace_id: string,\n  name: string,\n): Promise<any[] | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels.ts",
    "type": "file",
    "totalTokens": 505,
    "inDegree": 0,
    "outDegree": 2,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\n\n// La definición de la función para guardar o actualizar un canal en la tabla 'slack_channels'\nexport async function saveOrUpdateChannel(\n  agent_id: string,\n  id: string,\n  workspace_id: string,\n  name: string,\n): Promise<any[] | null> {\n  try {\n    // Reemplazamos la tabla a la que se hace la consulta.\n    const { data, error } = await supabase\n      .from('slack_channels')\n      .upsert({ // 'upsert' insertará o actualizará la entrada dependiendo si existe o no.\n        id,\n        agent_id,\n        workspace_id,\n        name,\n        // Notar que 'created_at' no se incluye ya que Supabase maneja automáticamente este campo si está configurado con el valor por defecto 'now()'.\n      }, {\n        onConflict: 'id', // Indicamos que 'id' es nuestra clave única para decidir si actualizamos o insertamos.\n      })\n\n    // Manejamos y mostramos cualquier error que surja.\n    if (error) {\n      console.error('Error saving or updating channel:', error)\n      return null\n    }\n\n    // Devolvemos los datos de los canales actualizados o creados.\n    console.log('Updated or created channel:', data)\n    return data\n  } catch (error: any) {\n    console.error('An error occurred while saving or updating channel:', error)\n    return null\n  }\n} // deno-lint-ignore-file no-explicit-any\n\nexport async function findChannelByWorkspace(\n  channel_id: string,\n  workspace_id: string,\n): Promise<string | null> {\n  try {\n    const { data, error } = await supabase\n      .from('slack_channels')\n      .select('agent_id')\n      .eq('id', channel_id)\n      .eq('workspace_id', workspace_id)\n      .single()\n\n    if (error) {\n      console.error('Error finding channel:', error)\n      return null\n    }\n\n    // Devolver el 'agent_id' si encontramos una coincidencia\n    return data ? data.agent_id : null\n  } catch (error: any) {\n    console.error('An error occurred while finding channel:', error)\n    return null\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { supabase } from '@/services/supabase/index.ts'\n// La definición de la función para guardar o actualizar un canal en la tabla 'slack_channels'\nexport async function saveOrUpdateChannel(\n  agent_id: string,\n  id: string,\n  workspace_id: string,\n  name: string,\n): Promise<any[] | null> {\n       //...\n       }\n\nexport async function findChannelByWorkspace(\n  channel_id: string,\n  workspace_id: string,\n): Promise<string | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\channels.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces::ChannelType",
    "language": "typescript",
    "label": "ChannelType",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces",
    "totalTokens": 89,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type ChannelType = {\n  id: string // Representa el ID del canal como texto\n  created_at: Date // La fecha y hora de creación con timezone (se associa con el tipo JavaScript Date)\n  workspace_id: string // ID del espacio de trabajo como texto\n  name: string // Nombre del canal como texto\n  agent_id: string // ID del agente representado como UUID en formato de string\n}",
    "importStatements": [],
    "codeNoBody": "type ChannelType = {\n  id: string // Representa el ID del canal como texto\n  created_at: Date // La fecha y hora de creación con timezone (se associa con el tipo JavaScript Date)\n  workspace_id: string // ID del espacio de trabajo como texto\n  name: string // Nombre del canal como texto\n  agent_id: string // ID del agente representado como UUID en formato de string\n}",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces::dbAgent",
    "language": "typescript",
    "label": "dbAgent",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces",
    "totalTokens": 139,
    "inDegree": 5,
    "outDegree": 3,
    "code": "interface dbAgent {\n  agent_type: Database['public']['Enums']['agent_type'] | null\n  created_at: string\n  description: string | null\n  font: string | null\n  id: string\n  image: string | null\n  is_public: boolean\n  model: string\n  name: string\n  org_id: string\n  palette: string | null\n  pincode: string | null\n  prompt: string | null\n  prompt_library: Json | null\n  slug: string\n  status: Database['public']['Enums']['status']\n  temperature: number\n  topk: number\n  welcome: string | null\n}",
    "importStatements": [],
    "codeNoBody": "interface dbAgent {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces::dbWorkspace",
    "language": "typescript",
    "label": "dbWorkspace",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces",
    "totalTokens": 103,
    "inDegree": 13,
    "outDegree": 1,
    "code": "interface dbWorkspace {\n  created_at: string // timestamptz se representa como string en JavaScript/TypeScript\n  org_id: string // uuid se representa como string\n  access_token: string // text se representa como string\n  name: string // text se representa como string\n  agent_settings: number // numeric se representa como number\n  agent_id: string // uuid se representa como string\n  id: string // text se representa como string\n  bot_user_id?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface dbWorkspace {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces.ts",
    "type": "file",
    "totalTokens": 359,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Database } from '@/types/supabase.ts'\nimport { Json } from '@/types/supabase.ts'\nexport interface dbWorkspace {\n  created_at: string // timestamptz se representa como string en JavaScript/TypeScript\n  org_id: string // uuid se representa como string\n  access_token: string // text se representa como string\n  name: string // text se representa como string\n  agent_settings: number // numeric se representa como number\n  agent_id: string // uuid se representa como string\n  id: string // text se representa como string\n  bot_user_id?: string\n}\nexport interface dbAgent {\n  agent_type: Database['public']['Enums']['agent_type'] | null\n  created_at: string\n  description: string | null\n  font: string | null\n  id: string\n  image: string | null\n  is_public: boolean\n  model: string\n  name: string\n  org_id: string\n  palette: string | null\n  pincode: string | null\n  prompt: string | null\n  prompt_library: Json | null\n  slug: string\n  status: Database['public']['Enums']['status']\n  temperature: number\n  topk: number\n  welcome: string | null\n}\n\ntype ChannelType = {\n  id: string // Representa el ID del canal como texto\n  created_at: Date // La fecha y hora de creación con timezone (se associa con el tipo JavaScript Date)\n  workspace_id: string // ID del espacio de trabajo como texto\n  name: string // Nombre del canal como texto\n  agent_id: string // ID del agente representado como UUID en formato de string\n}\n",
    "importStatements": [
      "import { Database } from '@/types/supabase.ts'",
      "import { Json } from '@/types/supabase.ts'"
    ],
    "codeNoBody": "import { Database } from '@/types/supabase.ts'\nimport { Json } from '@/types/supabase.ts'\nexport interface dbWorkspace {\n       //...\n       }\nexport interface dbAgent {\n       //...\n       }\ntype ChannelType = {\n  id: string // Representa el ID del canal como texto\n  created_at: Date // La fecha y hora de creación con timezone (se associa con el tipo JavaScript Date)\n  workspace_id: string // ID del espacio de trabajo como texto\n  name: string // Nombre del canal como texto\n  agent_id: string // ID del agente representado como UUID en formato de string\n}",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\interfaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::updateBotUserId",
    "language": "typescript",
    "label": "updateBotUserId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 141,
    "inDegree": 2,
    "outDegree": 1,
    "code": "async function updateBotUserId(\n  workspace_id: string,\n  botUserId: string,\n): Promise<boolean> {\n  try {\n    console.log('Entró a db')\n    const { error } = await supabase\n      .from('slack_workspaces')\n      .update({ bot_user_id: botUserId })\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error updating bot_user_id:', error)\n      return false\n    }\n\n    console.log('Updated bot_user_id successfully:')\n    return true\n  } catch (error) {\n    console.error('An error occurred while updating bot_user_id:', error)\n    return false\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateBotUserId(\n  workspace_id: string,\n  botUserId: string,\n): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::readWorkspace",
    "language": "typescript",
    "label": "readWorkspace",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 232,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async function readWorkspace(\n  workspace_id: string,\n): Promise<dbWorkspace | null> {\n  try {\n    // Validar con el organizationid que me devuelve con el orgid que tengo en db para permitirle a esto.\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      // Suponiendo que 'id' es una clave única, debería haber solo un resultado\n      const workspace: dbWorkspace = workspaces[0]\n      console.log('Response db', workspace)\n      return workspace\n    } else {\n      return null // Devolver mensaje que no hay org_id asociado.\n    }\n    // deno-lint-ignore no-explicit-any\n  } catch (error: any) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function readWorkspace(\n  workspace_id: string,\n): Promise<dbWorkspace | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::getAllWorkspacesByOrg",
    "language": "typescript",
    "label": "getAllWorkspacesByOrg",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 129,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getAllWorkspacesByOrg(org_id: string): Promise<any> {\n  try {\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      return workspaces\n    }\n  } catch (error) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAllWorkspacesByOrg(org_id: string): Promise<any> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::deleteWorkspace",
    "language": "typescript",
    "label": "deleteWorkspace",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 121,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function deleteWorkspace(workspace_id: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('slack_workspaces')\n      .delete()\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error deleting workspace:', error)\n      return false\n    } else {\n      console.log(`Workspace with id ${workspace_id} has been deleted.`)\n      return true\n    }\n  } catch (error) {\n    console.error('An error occurred while deleting workspace:', error)\n    return false\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function deleteWorkspace(workspace_id: string): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::readWorkspaces",
    "language": "typescript",
    "label": "readWorkspaces",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 265,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function readWorkspaces(\n  workspace_id: string,\n  org_id: string,\n): Promise<dbWorkspace | null> {\n  try {\n    console.log('workspace', workspace_id, 'orgid', org_id)\n    // Validar con el organizationid que me devuelve con el orgid que tengo en db para permitirle a esto.\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('id', workspace_id)\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      // Suponiendo que 'id' es una clave única, debería haber solo un resultado\n      const workspace: dbWorkspace = workspaces[0]\n      console.log('Response db', workspace)\n      return workspace\n    } else {\n      return null // Devolver mensaje que no hay org_id asociado.\n    }\n    // deno-lint-ignore no-explicit-any\n  } catch (error: any) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function readWorkspaces(\n  workspace_id: string,\n  org_id: string,\n): Promise<dbWorkspace | null> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces::updateWorkspaceWithOrg",
    "language": "typescript",
    "label": "updateWorkspaceWithOrg",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "totalTokens": 179,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function updateWorkspaceWithOrg(\n  workspace_id: string,\n  org_id: string,\n): Promise<void> {\n  try {\n    console.log('Entró a updateWorkspaceWithOrg', workspace_id, org_id)\n\n    // Actualizar el campo org_id para el registro con el workspace_id correspondiente\n    const { error: updateError } = await supabase\n      .from('slack_workspaces')\n      .update({ org_id: org_id })\n      .eq('id', workspace_id)\n\n    if (updateError) {\n      console.error('Error updating workspace org_id:', updateError)\n    } else {\n      console.log(\n        `Org_id ${org_id} has been updated for workspace ${workspace_id}.`,\n      )\n    }\n  } catch (error) {\n    console.error('An error occurred while updating workspace with org:', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateWorkspaceWithOrg(\n  workspace_id: string,\n  org_id: string,\n): Promise<void> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts",
    "type": "file",
    "totalTokens": 1837,
    "inDegree": 0,
    "outDegree": 7,
    "code": "import { supabase } from '@/services/supabase/index.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\n\n// export async function insertWorkspace(\n//   authResponse: AuthResponse,\n// ): Promise<void> {\n//   try {\n//     console.log('Entró a insert Workspace')\n//     // Verificar si el registro ya existe\n//     const { data: checkResult, error: checkError } = await supabase\n//       .from('slack_workspaces')\n//       .select('id')\n//       .eq('id', authResponse.team.id)\n\n//     if (checkError && !checkError.message.includes('No rows found')) {\n//       console.log('Entró a error')\n//       console.error('No existe en tabla', checkError)\n//     }\n\n//     if (checkResult?.length && checkResult?.length > 0) {\n//       console.log('Entró a checkresut', checkResult)\n//       // Si el registro existe, actualizarlo\n//       const { error: updateError } = await supabase\n//         .from('slack_workspaces')\n//         .update({\n//           access_token: authResponse.access_token,\n//           name: authResponse.team.name,\n//         })\n//         .eq('id', authResponse.team.id)\n//       console.log('se supone que guardo?')\n//       if (updateError) {\n//         console.error('Error updating workspace:', updateError)\n//       }\n//     } else {\n//       // Si el registro no existe, insertarlo\n//       const { error: insertError } = await supabase\n//         .from('slack_workspaces')\n//         .insert([{ // acá toca establecer bien la conexión con el front.\n//           id: authResponse.team.id,\n//           access_token: authResponse.access_token,\n//           name: authResponse.team.name,\n//           agent_settings: '1',\n//         }])\n\n//       if (insertError) {\n//         console.error('Error inserting workspace:', insertError)\n//       }\n//     }\n//   } catch (error) {\n//     console.error(\n//       'An error occurred while inserting/updating a workspace:',\n//       error,\n//     )\n//   }\n// }\n\n// export async function verifyWorkspaceToken(\n//   workspace_id: string,\n//   token: string,\n// ): Promise<dbWorkspace | false> {\n//   try {\n//     console.log('token', token, 'Workspaceid', workspace_id)\n//     const { data: workspaces, error } = await supabase\n//       .from('slack_workspaces')\n//       .select('*')\n//       .eq('id', workspace_id)\n//       .eq('access_token', token)\n\n//     if (error) {\n//       console.error('Error reading workspace:', error)\n//       return false\n//     }\n\n//     if (workspaces && workspaces.length > 0) {\n//       // Si el workspace existe y el token coincide, devolver el workspace\n//       console.log('Workspace and token match found.')\n//       return workspaces[0]\n//     } else {\n//       // Si no se encuentra un workspace con el ID y token dados, devolver false\n//       console.log('No matching workspace or token found.')\n//       return false\n//     }\n//   } catch (error) {\n//     console.error(\n//       'An error occurred while checking workspace and token:',\n//       error,\n//     )\n//     return false\n//   }\n// }\nexport async function updateWorkspaceWithOrg(\n  workspace_id: string,\n  org_id: string,\n): Promise<void> {\n  try {\n    console.log('Entró a updateWorkspaceWithOrg', workspace_id, org_id)\n\n    // Actualizar el campo org_id para el registro con el workspace_id correspondiente\n    const { error: updateError } = await supabase\n      .from('slack_workspaces')\n      .update({ org_id: org_id })\n      .eq('id', workspace_id)\n\n    if (updateError) {\n      console.error('Error updating workspace org_id:', updateError)\n    } else {\n      console.log(\n        `Org_id ${org_id} has been updated for workspace ${workspace_id}.`,\n      )\n    }\n  } catch (error) {\n    console.error('An error occurred while updating workspace with org:', error)\n  }\n}\n\nexport async function readWorkspaces(\n  workspace_id: string,\n  org_id: string,\n): Promise<dbWorkspace | null> {\n  try {\n    console.log('workspace', workspace_id, 'orgid', org_id)\n    // Validar con el organizationid que me devuelve con el orgid que tengo en db para permitirle a esto.\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('id', workspace_id)\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      // Suponiendo que 'id' es una clave única, debería haber solo un resultado\n      const workspace: dbWorkspace = workspaces[0]\n      console.log('Response db', workspace)\n      return workspace\n    } else {\n      return null // Devolver mensaje que no hay org_id asociado.\n    }\n    // deno-lint-ignore no-explicit-any\n  } catch (error: any) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}\nexport async function deleteWorkspace(workspace_id: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('slack_workspaces')\n      .delete()\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error deleting workspace:', error)\n      return false\n    } else {\n      console.log(`Workspace with id ${workspace_id} has been deleted.`)\n      return true\n    }\n  } catch (error) {\n    console.error('An error occurred while deleting workspace:', error)\n    return false\n  }\n}\n\n// deno-lint-ignore no-explicit-any\nexport async function getAllWorkspacesByOrg(org_id: string): Promise<any> {\n  try {\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('org_id', org_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      return workspaces\n    }\n  } catch (error) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}\n\nexport async function readWorkspace(\n  workspace_id: string,\n): Promise<dbWorkspace | null> {\n  try {\n    // Validar con el organizationid que me devuelve con el orgid que tengo en db para permitirle a esto.\n    const { data: workspaces, error } = await supabase\n      .from('slack_workspaces')\n      .select('*')\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error reading workspace:', error)\n      return null\n    }\n\n    if (workspaces && workspaces.length > 0) {\n      // Suponiendo que 'id' es una clave única, debería haber solo un resultado\n      const workspace: dbWorkspace = workspaces[0]\n      console.log('Response db', workspace)\n      return workspace\n    } else {\n      return null // Devolver mensaje que no hay org_id asociado.\n    }\n    // deno-lint-ignore no-explicit-any\n  } catch (error: any) {\n    console.error('An error occurred while reading workspaces:', error)\n    return null\n  }\n}\n\nexport async function updateBotUserId(\n  workspace_id: string,\n  botUserId: string,\n): Promise<boolean> {\n  try {\n    console.log('Entró a db')\n    const { error } = await supabase\n      .from('slack_workspaces')\n      .update({ bot_user_id: botUserId })\n      .eq('id', workspace_id)\n\n    if (error) {\n      console.error('Error updating bot_user_id:', error)\n      return false\n    }\n\n    console.log('Updated bot_user_id successfully:')\n    return true\n  } catch (error) {\n    console.error('An error occurred while updating bot_user_id:', error)\n    return false\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'"
    ],
    "codeNoBody": "import { supabase } from '@/services/supabase/index.ts'\nimport { dbWorkspace } from '@/lib/integrations/slack-app/slack/services/supabase/interfaces.ts'\n// export async function insertWorkspace(\n//   authResponse: AuthResponse,\n// ): Promise<void> {\n//   try {\n//     console.log('Entró a insert Workspace')\n//     // Verificar si el registro ya existe\n//     const { data: checkResult, error: checkError } = await supabase\n//       .from('slack_workspaces')\n//       .select('id')\n//       .eq('id', authResponse.team.id)\n\n//     if (checkError && !checkError.message.includes('No rows found')) {\n//       console.log('Entró a error')\n//       console.error('No existe en tabla', checkError)\n//     }\n\n//     if (checkResult?.length && checkResult?.length > 0) {\n//       console.log('Entró a checkresut', checkResult)\n//       // Si el registro existe, actualizarlo\n//       const { error: updateError } = await supabase\n//         .from('slack_workspaces')\n//         .update({\n//           access_token: authResponse.access_token,\n//           name: authResponse.team.name,\n//         })\n//         .eq('id', authResponse.team.id)\n//       console.log('se supone que guardo?')\n//       if (updateError) {\n//         console.error('Error updating workspace:', updateError)\n//       }\n//     } else {\n//       // Si el registro no existe, insertarlo\n//       const { error: insertError } = await supabase\n//         .from('slack_workspaces')\n//         .insert([{ // acá toca establecer bien la conexión con el front.\n//           id: authResponse.team.id,\n//           access_token: authResponse.access_token,\n//           name: authResponse.team.name,\n//           agent_settings: '1',\n//         }])\n\n//       if (insertError) {\n//         console.error('Error inserting workspace:', insertError)\n//       }\n//     }\n//   } catch (error) {\n//     console.error(\n//       'An error occurred while inserting/updating a workspace:',\n//       error,\n//     )\n//   }\n// }\n\n// export async function verifyWorkspaceToken(\n//   workspace_id: string,\n//   token: string,\n// ): Promise<dbWorkspace | false> {\n//   try {\n//     console.log('token', token, 'Workspaceid', workspace_id)\n//     const { data: workspaces, error } = await supabase\n//       .from('slack_workspaces')\n//       .select('*')\n//       .eq('id', workspace_id)\n//       .eq('access_token', token)\n\n//     if (error) {\n//       console.error('Error reading workspace:', error)\n//       return false\n//     }\n\n//     if (workspaces && workspaces.length > 0) {\n//       // Si el workspace existe y el token coincide, devolver el workspace\n//       console.log('Workspace and token match found.')\n//       return workspaces[0]\n//     } else {\n//       // Si no se encuentra un workspace con el ID y token dados, devolver false\n//       console.log('No matching workspace or token found.')\n//       return false\n//     }\n//   } catch (error) {\n//     console.error(\n//       'An error occurred while checking workspace and token:',\n//       error,\n//     )\n//     return false\n//   }\n// }\nexport async function updateWorkspaceWithOrg(\n  workspace_id: string,\n  org_id: string,\n): Promise<void> {\n       //...\n       }\n\nexport async function readWorkspaces(\n  workspace_id: string,\n  org_id: string,\n): Promise<dbWorkspace | null> {\n       //...\n       }\nexport async function deleteWorkspace(workspace_id: string): Promise<boolean> {\n       //...\n       }\n\n// deno-lint-ignore no-explicit-any\nexport async function getAllWorkspacesByOrg(org_id: string): Promise<any> {\n       //...\n       }\n\nexport async function readWorkspace(\n  workspace_id: string,\n): Promise<dbWorkspace | null> {\n       //...\n       }\n\nexport async function updateBotUserId(\n  workspace_id: string,\n  botUserId: string,\n): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\services\\supabase\\workspaces.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\verify-event::verificaSlackRequest",
    "language": "typescript",
    "label": "verificaSlackRequest",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\verify-event",
    "totalTokens": 326,
    "inDegree": 3,
    "outDegree": 0,
    "code": "async function verificaSlackRequest(\n  bodyText: string,\n  timestamp: string | null,\n  signature: string | null,\n): Promise<boolean> {\n  try {\n    const signingSecret = Deno.env.get('SLACK_SIGNING_SECRET')\n\n    if (!timestamp || !signature || !signingSecret) {\n      return false\n    }\n\n    // Crea la cadena basada en la versión, timestamp y cuerpo de la solicitud\n    const baseString = `v0:${timestamp}:${bodyText}` // <- Aquí usamos bodyText\n\n    // Utiliza la API Web Crypto para calcular el HMAC con SHA256\n    const encoder = new TextEncoder()\n    const keyData = encoder.encode(signingSecret)\n    const key = await crypto.subtle.importKey(\n      'raw',\n      keyData,\n      { name: 'HMAC', hash: { name: 'SHA-256' } },\n      false,\n      ['sign'],\n    )\n\n    const signatureData = encoder.encode(baseString)\n    const hmac = await crypto.subtle.sign('HMAC', key, signatureData)\n\n    // Convertir el HMAC a formato hexadecimal\n    const mySignature = 'v0=' +\n      Array.from(new Uint8Array(hmac)).map((byte) =>\n        byte.toString(16).padStart(2, '0')\n      ).join('')\n\n    // Compara tu firma con la firma de Slack\n    return signature === mySignature\n  } catch (error) {\n    console.error('Error al verificar la firma de Slack: ', error)\n    return false\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function verificaSlackRequest(\n  bodyText: string,\n  timestamp: string | null,\n  signature: string | null,\n): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\verify-event.ts"
  },
  {
    "id": "\\lib\\integrations\\slack-app\\slack\\verify-event",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\integrations\\slack-app\\slack\\verify-event.ts",
    "type": "file",
    "totalTokens": 327,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export async function verificaSlackRequest(\n  bodyText: string,\n  timestamp: string | null,\n  signature: string | null,\n): Promise<boolean> {\n  try {\n    const signingSecret = Deno.env.get('SLACK_SIGNING_SECRET')\n\n    if (!timestamp || !signature || !signingSecret) {\n      return false\n    }\n\n    // Crea la cadena basada en la versión, timestamp y cuerpo de la solicitud\n    const baseString = `v0:${timestamp}:${bodyText}` // <- Aquí usamos bodyText\n\n    // Utiliza la API Web Crypto para calcular el HMAC con SHA256\n    const encoder = new TextEncoder()\n    const keyData = encoder.encode(signingSecret)\n    const key = await crypto.subtle.importKey(\n      'raw',\n      keyData,\n      { name: 'HMAC', hash: { name: 'SHA-256' } },\n      false,\n      ['sign'],\n    )\n\n    const signatureData = encoder.encode(baseString)\n    const hmac = await crypto.subtle.sign('HMAC', key, signatureData)\n\n    // Convertir el HMAC a formato hexadecimal\n    const mySignature = 'v0=' +\n      Array.from(new Uint8Array(hmac)).map((byte) =>\n        byte.toString(16).padStart(2, '0')\n      ).join('')\n\n    // Compara tu firma con la firma de Slack\n    return signature === mySignature\n  } catch (error) {\n    console.error('Error al verificar la firma de Slack: ', error)\n    return false\n  }\n}\n",
    "importStatements": [],
    "codeNoBody": "export async function verificaSlackRequest(\n  bodyText: string,\n  timestamp: string | null,\n  signature: string | null,\n): Promise<boolean> {\n       //...\n       }",
    "originFile": "\\lib\\integrations\\slack-app\\slack\\verify-event.ts"
  },
  {
    "id": "\\lib\\ip::getIp",
    "language": "typescript",
    "label": "getIp",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ip",
    "totalTokens": 116,
    "inDegree": 33,
    "outDegree": 0,
    "code": "function getIp(c: Context) {\n  let ip\n\n  if (c.req.header('x-forwarded-for')) {\n    ip = c.req.header('x-forwarded-for')?.split(',')[0]\n  } else if (c.req.header('x-real-ip')) {\n    ip = c.req.header('x-real-ip')\n  } else {\n    ip = c.req.header('CF-Connecting-IP')\n  }\n\n  // @ts-expect-error Ip added in the server router middleware\n  return c.req.raw?.ip as string | undefined ?? ip\n}",
    "importStatements": [],
    "codeNoBody": "function getIp(c: Context) {\n       //...\n       }",
    "originFile": "\\lib\\ip.ts"
  },
  {
    "id": "\\lib\\ip",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\ip.ts",
    "type": "file",
    "totalTokens": 126,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { Context } from 'hono'\n\nexport function getIp(c: Context) {\n  let ip\n\n  if (c.req.header('x-forwarded-for')) {\n    ip = c.req.header('x-forwarded-for')?.split(',')[0]\n  } else if (c.req.header('x-real-ip')) {\n    ip = c.req.header('x-real-ip')\n  } else {\n    ip = c.req.header('CF-Connecting-IP')\n  }\n\n  // @ts-expect-error Ip added in the server router middleware\n  return c.req.raw?.ip as string | undefined ?? ip\n}\n",
    "importStatements": [
      "import { Context } from 'hono'"
    ],
    "codeNoBody": "import { Context } from 'hono'\nexport function getIp(c: Context) {\n       //...\n       }",
    "originFile": "\\lib\\ip.ts"
  },
  {
    "id": "\\lib\\mixpanel::mixpanel",
    "language": "typescript",
    "label": "mixpanel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\mixpanel",
    "totalTokens": 1337,
    "inDegree": 11,
    "outDegree": 2,
    "code": "async function mixpanel(\n  { body, source }: {\n    // deno-lint-ignore no-explicit-any\n    body: any[]\n    source?: string\n  },\n) {\n  const PROJECT_TOKEN = getEnv('MIXPANEL_PROJECT_TOKEN')\n  const PROJECT_ID = getEnv('MIXPANEL_PROJECT_ID')\n\n  if (!PROJECT_TOKEN || !PROJECT_ID) return\n\n  body.forEach((item) => {\n    item.properties ??= {\n      plan: '',\n      email: '',\n      ip: '',\n      time: 0,\n      $insert_id: '',\n      source: '',\n      distinct_id: '',\n    }\n\n    item.properties.time = Date.now()\n    item.properties.$insert_id ??= crypto.randomUUID()\n    item.properties.source ??= source ?? 'Playground2'\n    item.event = item.event.includes(':')\n      ? item.event.split(':')[0].trim()\n      : item.event\n  })\n\n  // deno-lint-ignore no-explicit-any\n  const promises: any[] = []\n\n  if (\n    body[0].properties?.distinct_id &&\n    body.some((item) => item.event !== 'completion2')\n  ) {\n    const userProfile: Record<string, string> = {}\n    if (body[0].properties?.email) userProfile.$email = body[0].properties.email\n    if (body[0].properties?.ip) userProfile.ip = body[0].properties.ip\n    // if (body[0].properties?.plan) userProfile.userPlan = body[0].properties.plan\n\n    for (const item of body) {\n      if (item.event === 'changePlan') {\n        userProfile.userPlan = item.properties.newPlan\n        userProfile.planStatus = item.properties.planStatus\n        userProfile.userType = item.properties.userType\n        userProfile.previousStatus = item.properties.previousStatus\n      }\n\n      if (item.event === 'playgroundChat') {\n        if (item.properties.marketplace) {\n          userProfile.userPlan = item.properties.userPlan\n        }\n      }\n    }\n\n    promises.push(fetch(\n      'https://api.mixpanel.com/engage#profile-set',\n      {\n        method: 'POST',\n        headers: {\n          accept: 'text/plain',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify([\n          {\n            $token: '80f454493433c38fcc686e141694a146',\n            $distinct_id: body[0].properties.distinct_id,\n            $set: userProfile,\n          },\n        ]),\n      },\n    ))\n\n    // try {\n    //   await fetch(\n    //     'https://api.mixpanel.com/engage#profile-set',\n    //     {\n    //       method: 'POST',\n    //       headers: {\n    //         accept: 'text/plain',\n    //         'Content-Type': 'application/json',\n    //       },\n    //       body: JSON.stringify([\n    //         {\n    //           $token: '80f454493433c38fcc686e141694a146',\n    //           $distinct_id: body[0].properties.distinct_id,\n    //           $set: userProfile,\n    //         },\n    //       ]),\n    //     },\n    //   )\n    // } catch (error) {\n    //   console.error('Telemetry engage: ', error.response.data)\n    // }\n  }\n\n  if (body.some((item) => item.event === 'completion2')) {\n    let updatePlan = false\n    const userProfile: Record<string, string> = {}\n\n    for (const item of body) {\n      if (item.event === 'completion2') {\n        if (item.properties.consumer_plan_name) {\n          userProfile.userPlan = item.properties.consumer_plan_name\n          updatePlan = true\n        }\n      }\n    }\n\n    const userDistinctId = body.find((item) => item.event === 'completion2')\n      ?.properties?.consumer_distinct_id\n\n    if (userDistinctId && updatePlan) {\n      promises.push(fetch(\n        'https://api.mixpanel.com/engage#profile-set',\n        {\n          method: 'POST',\n          headers: {\n            accept: 'text/plain',\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify([\n            {\n              $token: '80f454493433c38fcc686e141694a146',\n              $distinct_id: userDistinctId,\n              $set: userProfile,\n            },\n          ]),\n        },\n      ))\n      // try {\n      //   await fetch(\n      //     'https://api.mixpanel.com/engage#profile-set',\n      //     {\n      //       method: 'POST',\n      //       headers: {\n      //         accept: 'text/plain',\n      //         'Content-Type': 'application/json',\n      //       },\n      //       body: JSON.stringify([\n      //         {\n      //           $token: '80f454493433c38fcc686e141694a146',\n      //           $distinct_id: userDistinctId,\n      //           $set: userProfile,\n      //         },\n      //       ]),\n      //     },\n      //   )\n      // } catch (error) {\n      //   console.error('Telemetry engage: ', error.response.data)\n      // }\n    }\n  }\n\n  promises.push(fetch(\n    `https://api.mixpanel.com/import?strict=1&project_id=${PROJECT_ID}`,\n    {\n      method: 'POST',\n      headers: {\n        Authorization: `Basic ${PROJECT_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    },\n  ))\n\n  try {\n    // await fetch(\n    //   `https://api.mixpanel.com/import?strict=1&project_id=${PROJECT_ID}`,\n    //   {\n    //     method: 'POST',\n    //     headers: {\n    //       Authorization: `Basic ${PROJECT_TOKEN}`,\n    //       'Content-Type': 'application/json',\n    //     },\n    //     body: JSON.stringify(body),\n    //   },\n    // )\n\n    await Promise.all(promises)\n  } catch (error) {\n    reportError(\n      new Error(JSON.stringify({ error, body, source })),\n      body[0].properties.distinct_id ?? 'Not found in mixpanel body',\n      body[0].properties.email ?? 'Not found in mixpanel body',\n    )\n    console.error('Telemetry Error:', {\n      error: error.response.data,\n      failedRecords: error.response.data.failed_records,\n    })\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function mixpanel(\n  { body, source }: {\n    // deno-lint-ignore no-explicit-any\n    body: any[]\n    source?: string\n  },\n) {\n       //...\n       }",
    "originFile": "\\lib\\mixpanel.ts"
  },
  {
    "id": "\\lib\\mixpanel",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\mixpanel.ts",
    "type": "file",
    "totalTokens": 1363,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { getEnv } from '@/lib/env.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\n\nexport async function mixpanel(\n  { body, source }: {\n    // deno-lint-ignore no-explicit-any\n    body: any[]\n    source?: string\n  },\n) {\n  const PROJECT_TOKEN = getEnv('MIXPANEL_PROJECT_TOKEN')\n  const PROJECT_ID = getEnv('MIXPANEL_PROJECT_ID')\n\n  if (!PROJECT_TOKEN || !PROJECT_ID) return\n\n  body.forEach((item) => {\n    item.properties ??= {\n      plan: '',\n      email: '',\n      ip: '',\n      time: 0,\n      $insert_id: '',\n      source: '',\n      distinct_id: '',\n    }\n\n    item.properties.time = Date.now()\n    item.properties.$insert_id ??= crypto.randomUUID()\n    item.properties.source ??= source ?? 'Playground2'\n    item.event = item.event.includes(':')\n      ? item.event.split(':')[0].trim()\n      : item.event\n  })\n\n  // deno-lint-ignore no-explicit-any\n  const promises: any[] = []\n\n  if (\n    body[0].properties?.distinct_id &&\n    body.some((item) => item.event !== 'completion2')\n  ) {\n    const userProfile: Record<string, string> = {}\n    if (body[0].properties?.email) userProfile.$email = body[0].properties.email\n    if (body[0].properties?.ip) userProfile.ip = body[0].properties.ip\n    // if (body[0].properties?.plan) userProfile.userPlan = body[0].properties.plan\n\n    for (const item of body) {\n      if (item.event === 'changePlan') {\n        userProfile.userPlan = item.properties.newPlan\n        userProfile.planStatus = item.properties.planStatus\n        userProfile.userType = item.properties.userType\n        userProfile.previousStatus = item.properties.previousStatus\n      }\n\n      if (item.event === 'playgroundChat') {\n        if (item.properties.marketplace) {\n          userProfile.userPlan = item.properties.userPlan\n        }\n      }\n    }\n\n    promises.push(fetch(\n      'https://api.mixpanel.com/engage#profile-set',\n      {\n        method: 'POST',\n        headers: {\n          accept: 'text/plain',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify([\n          {\n            $token: '80f454493433c38fcc686e141694a146',\n            $distinct_id: body[0].properties.distinct_id,\n            $set: userProfile,\n          },\n        ]),\n      },\n    ))\n\n    // try {\n    //   await fetch(\n    //     'https://api.mixpanel.com/engage#profile-set',\n    //     {\n    //       method: 'POST',\n    //       headers: {\n    //         accept: 'text/plain',\n    //         'Content-Type': 'application/json',\n    //       },\n    //       body: JSON.stringify([\n    //         {\n    //           $token: '80f454493433c38fcc686e141694a146',\n    //           $distinct_id: body[0].properties.distinct_id,\n    //           $set: userProfile,\n    //         },\n    //       ]),\n    //     },\n    //   )\n    // } catch (error) {\n    //   console.error('Telemetry engage: ', error.response.data)\n    // }\n  }\n\n  if (body.some((item) => item.event === 'completion2')) {\n    let updatePlan = false\n    const userProfile: Record<string, string> = {}\n\n    for (const item of body) {\n      if (item.event === 'completion2') {\n        if (item.properties.consumer_plan_name) {\n          userProfile.userPlan = item.properties.consumer_plan_name\n          updatePlan = true\n        }\n      }\n    }\n\n    const userDistinctId = body.find((item) => item.event === 'completion2')\n      ?.properties?.consumer_distinct_id\n\n    if (userDistinctId && updatePlan) {\n      promises.push(fetch(\n        'https://api.mixpanel.com/engage#profile-set',\n        {\n          method: 'POST',\n          headers: {\n            accept: 'text/plain',\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify([\n            {\n              $token: '80f454493433c38fcc686e141694a146',\n              $distinct_id: userDistinctId,\n              $set: userProfile,\n            },\n          ]),\n        },\n      ))\n      // try {\n      //   await fetch(\n      //     'https://api.mixpanel.com/engage#profile-set',\n      //     {\n      //       method: 'POST',\n      //       headers: {\n      //         accept: 'text/plain',\n      //         'Content-Type': 'application/json',\n      //       },\n      //       body: JSON.stringify([\n      //         {\n      //           $token: '80f454493433c38fcc686e141694a146',\n      //           $distinct_id: userDistinctId,\n      //           $set: userProfile,\n      //         },\n      //       ]),\n      //     },\n      //   )\n      // } catch (error) {\n      //   console.error('Telemetry engage: ', error.response.data)\n      // }\n    }\n  }\n\n  promises.push(fetch(\n    `https://api.mixpanel.com/import?strict=1&project_id=${PROJECT_ID}`,\n    {\n      method: 'POST',\n      headers: {\n        Authorization: `Basic ${PROJECT_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    },\n  ))\n\n  try {\n    // await fetch(\n    //   `https://api.mixpanel.com/import?strict=1&project_id=${PROJECT_ID}`,\n    //   {\n    //     method: 'POST',\n    //     headers: {\n    //       Authorization: `Basic ${PROJECT_TOKEN}`,\n    //       'Content-Type': 'application/json',\n    //     },\n    //     body: JSON.stringify(body),\n    //   },\n    // )\n\n    await Promise.all(promises)\n  } catch (error) {\n    reportError(\n      new Error(JSON.stringify({ error, body, source })),\n      body[0].properties.distinct_id ?? 'Not found in mixpanel body',\n      body[0].properties.email ?? 'Not found in mixpanel body',\n    )\n    console.error('Telemetry Error:', {\n      error: error.response.data,\n      failedRecords: error.response.data.failed_records,\n    })\n  }\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nexport async function mixpanel(\n  { body, source }: {\n    // deno-lint-ignore no-explicit-any\n    body: any[]\n    source?: string\n  },\n) {\n       //...\n       }",
    "originFile": "\\lib\\mixpanel.ts"
  },
  {
    "id": "\\lib\\mixpanel\\providers::getModelProvider",
    "language": "typescript",
    "label": "getModelProvider",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\mixpanel\\providers",
    "totalTokens": 116,
    "inDegree": 21,
    "outDegree": 0,
    "code": "function getModelProvider(model: string) {\n  if (model.includes('gpt')) return 'azure'\n\n  if (model.includes('claude') || model === 'llama3-70b') return 'bedrock'\n\n  if (model.includes('command')) return 'cohere'\n\n  if (['llama3-70b-8192', 'mixtral-8x7b-32768'].includes(model)) return 'groq'\n\n  if (['codestral'].includes(model)) return 'mistral'\n\n  return 'vertex'\n}",
    "importStatements": [],
    "codeNoBody": "function getModelProvider(model: string) {\n       //...\n       }",
    "originFile": "\\lib\\mixpanel\\providers.ts"
  },
  {
    "id": "\\lib\\mixpanel\\providers",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\mixpanel\\providers.ts",
    "type": "file",
    "totalTokens": 117,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export function getModelProvider(model: string) {\n  if (model.includes('gpt')) return 'azure'\n\n  if (model.includes('claude') || model === 'llama3-70b') return 'bedrock'\n\n  if (model.includes('command')) return 'cohere'\n\n  if (['llama3-70b-8192', 'mixtral-8x7b-32768'].includes(model)) return 'groq'\n\n  if (['codestral'].includes(model)) return 'mistral'\n\n  return 'vertex'\n}\n",
    "importStatements": [],
    "codeNoBody": "export function getModelProvider(model: string) {\n       //...\n       }",
    "originFile": "\\lib\\mixpanel\\providers.ts"
  },
  {
    "id": "\\lib\\numbers::normalizeFloat",
    "language": "typescript",
    "label": "normalizeFloat",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\numbers",
    "totalTokens": 24,
    "inDegree": 3,
    "outDegree": 0,
    "code": "function normalizeFloat(number: number) {\n  return Math.round(number * 10000) / 10000\n}",
    "importStatements": [],
    "codeNoBody": "function normalizeFloat(number: number) {\n       //...\n       }",
    "originFile": "\\lib\\numbers.ts"
  },
  {
    "id": "\\lib\\numbers",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\numbers.ts",
    "type": "file",
    "totalTokens": 25,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export function normalizeFloat(number: number) {\n  return Math.round(number * 10000) / 10000\n}\n",
    "importStatements": [],
    "codeNoBody": "export function normalizeFloat(number: number) {\n       //...\n       }",
    "originFile": "\\lib\\numbers.ts"
  },
  {
    "id": "\\lib\\redis::redis",
    "language": "typescript",
    "label": "redis",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\redis",
    "totalTokens": 26,
    "inDegree": 11,
    "outDegree": 1,
    "code": "export const redis = new Redis({\n  url: getEnv('REDIS_URL'),\n  token: getEnv('REDIS_TOKEN'),\n})",
    "importStatements": [],
    "codeNoBody": "export const redis = new Redis({\n  url: getEnv('REDIS_URL'),\n  token: getEnv('REDIS_TOKEN'),\n})",
    "originFile": "\\lib\\redis.ts"
  },
  {
    "id": "\\lib\\redis",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\redis.ts",
    "type": "file",
    "totalTokens": 56,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { Redis } from 'npm:@upstash/redis@1.28.0'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const redis = new Redis({\n  url: getEnv('REDIS_URL'),\n  token: getEnv('REDIS_TOKEN'),\n})\n",
    "importStatements": [
      "import { Redis } from 'npm:@upstash/redis@1.28.0'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { Redis } from 'npm:@upstash/redis@1.28.0'\nimport { getEnv } from '@/lib/env.ts'\nexport const redis = new Redis({\n  url: getEnv('REDIS_URL'),\n  token: getEnv('REDIS_TOKEN'),\n})",
    "originFile": "\\lib\\redis.ts"
  },
  {
    "id": "\\lib\\response::cancel",
    "language": "typescript",
    "label": "cancel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response::codeGPTResponse",
    "totalTokens": 3,
    "inDegree": 2,
    "outDegree": 1,
    "code": "cancel() {}",
    "importStatements": [],
    "codeNoBody": "cancel() {\n    //...\n    }",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::async",
    "language": "typescript",
    "label": "async",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response::codeGPTResponse",
    "totalTokens": 197,
    "inDegree": 2,
    "outDegree": 2,
    "code": "async start(controller) {\n      while (true) {\n        const { done, value } = await getNextValue()\n        if (done) {\n          const doneMessage = encoder.encode(\n            'data: ' + '[DONE]' + '\\n\\n',\n          )\n          controller.enqueue(doneMessage)\n          controller.close()\n          return\n        }\n        const decodedValue = decoder.decode(value)\n        if (decodedValue) {\n          const message = { role: 'assistant', content: decodedValue }\n          const choices = [{ delta: message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n\n          try {\n            const encodedChunk = encoder.encode(\n              'data: ' + JSON.stringify(body) + '\\n\\n',\n            )\n            controller.enqueue(encodedChunk)\n          } catch (e) {\n            console.log(e)\n          }\n        }\n      }\n    }",
    "importStatements": [],
    "codeNoBody": "async start(controller) {\n    //...\n    }",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::getNextValue",
    "language": "typescript",
    "label": "getNextValue",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response::codeGPTResponse",
    "totalTokens": 88,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const getNextValue = async () => {\n    let nextValue:\n      | ReadableStreamDefaultReadResult<BufferSource>\n      | IteratorResult<BufferSource | undefined>\n\n    if (reader) {\n      nextValue = await reader.read()\n    } else if (isIterator) {\n      nextValue = await stream.next()\n    } else {\n      throw new Error('Invalid input stream')\n    }\n\n    return nextValue\n  }",
    "importStatements": [],
    "codeNoBody": "const getNextValue = async () => {\n  //...\n  }",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::codeGPTResponse",
    "language": "typescript",
    "label": "codeGPTResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response",
    "totalTokens": 635,
    "inDegree": 2,
    "outDegree": 7,
    "code": "function codeGPTResponse(\n  stream:\n    | AsyncIterator<BufferSource | undefined>\n    | ReadableStream<BufferSource>,\n  agentResponseTitle: string,\n  outputStream: boolean,\n  format: 'text' | 'json',\n  isCompletion?: boolean,\n):\n  | AsyncIterator<BufferSource | undefined>\n  | ReadableStream\n  | Promise<string | CodeGPTResponse> {\n  if (outputStream && format === 'text') {\n    return stream\n  }\n\n  const encoder = new TextEncoder()\n  const decoder = new TextDecoder()\n\n  let reader: ReadableStreamDefaultReader<BufferSource> | undefined\n  const isStream = isReadableStream(stream)\n  const isIterator = isAsyncIterator(stream)\n  if (isStream) {\n    reader = stream?.getReader()\n  }\n\n  const getNextValue = async () => {\n    let nextValue:\n      | ReadableStreamDefaultReadResult<BufferSource>\n      | IteratorResult<BufferSource | undefined>\n\n    if (reader) {\n      nextValue = await reader.read()\n    } else if (isIterator) {\n      nextValue = await stream.next()\n    } else {\n      throw new Error('Invalid input stream')\n    }\n\n    return nextValue\n  }\n\n  if (!outputStream) {\n    return new Promise((resolve, reject) =>\n      (async () => {\n        let completion = ''\n\n        while (true) {\n          const { done, value } = await getNextValue()\n          if (done) {\n            break\n          }\n\n          completion += decoder.decode(value)\n        }\n        try {\n          const message = { role: 'assistant', content: completion }\n          const choices = [{ message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n          const output = format === 'text' ? completion : body\n          resolve(output)\n        } catch (err) {\n          reject(err)\n        }\n      })()\n    )\n  }\n\n  return new ReadableStream({\n    async start(controller) {\n      while (true) {\n        const { done, value } = await getNextValue()\n        if (done) {\n          const doneMessage = encoder.encode(\n            'data: ' + '[DONE]' + '\\n\\n',\n          )\n          controller.enqueue(doneMessage)\n          controller.close()\n          return\n        }\n        const decodedValue = decoder.decode(value)\n        if (decodedValue) {\n          const message = { role: 'assistant', content: decodedValue }\n          const choices = [{ delta: message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n\n          try {\n            const encodedChunk = encoder.encode(\n              'data: ' + JSON.stringify(body) + '\\n\\n',\n            )\n            controller.enqueue(encodedChunk)\n          } catch (e) {\n            console.log(e)\n          }\n        }\n      }\n    },\n    cancel() {},\n  })\n}",
    "importStatements": [],
    "codeNoBody": "function codeGPTResponse(\n  stream:\n    | AsyncIterator<BufferSource | undefined>\n    | ReadableStream<BufferSource>,\n  agentResponseTitle: string,\n  outputStream: boolean,\n  format: 'text' | 'json',\n  isCompletion?: boolean,\n):\n  | AsyncIterator<BufferSource | undefined>\n  | ReadableStream\n  | Promise<string | CodeGPTResponse> {\n  if (outputStream && format === 'text') {\n    return stream\n  }\n  const encoder = new TextEncoder()\n  const decoder = new TextDecoder()\n\n  let reader: ReadableStreamDefaultReader<BufferSource> | undefined\n  const isStream = isReadableStream(stream)\n  const isIterator = isAsyncIterator(stream)\n  if (isStream) {\n    reader = stream?.getReader()\n  }\n\n  const getNextValue = async () => {\n    let nextValue:\n      | ReadableStreamDefaultReadResult<BufferSource>\n      | IteratorResult<BufferSource | undefined>\n\n    if (reader) {\n      nextValue = await reader.read()\n    } else if (isIterator) {\n      nextValue = await stream.next()\n    } else {\n      throw new Error('Invalid input stream')\n    }\n\n    return nextValue\n  }\n\n  if (!outputStream) {\n    return new Promise((resolve, reject) =>\n      (async () => {\n        let completion = ''\n\n        while (true) {\n          const { done, value } = await getNextValue()\n          if (done) {\n            break\n          }\n\n          completion += decoder.decode(value)\n        }\n        try {\n          const message = { role: 'assistant', content: completion }\n          const choices = [{ message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n          const output = format === 'text' ? completion : body\n          resolve(output)\n        } catch (err) {\n          reject(err)\n        }\n      })()\n    )\n  }\n\n  return new ReadableStream({\n    async start(controller) {\n      while (true) {\n        const { done, value } = await getNextValue()\n        if (done) {\n          const doneMessage = encoder.encode(\n            'data: ' + '[DONE]' + '\\n\\n',\n          )\n          controller.enqueue(doneMessage)\n          controller.close()\n          return\n        }\n        const decodedValue = decoder.decode(value)\n        if (decodedValue) {\n          const message = { role: 'assistant', content: decodedValue }\n          const choices = [{ delta: message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n\n          try {\n            const encodedChunk = encoder.encode(\n              'data: ' + JSON.stringify(body) + '\\n\\n',\n            )\n            controller.enqueue(encodedChunk)\n          } catch (e) {\n            console.log(e)\n          }\n        }\n      }\n    },\n    cancel() {},\n  })\n}",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::isAsyncIterator",
    "language": "typescript",
    "label": "isAsyncIterator",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response",
    "totalTokens": 42,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function isAsyncIterator(\n  obj: unknown,\n): obj is AsyncIterator<BufferSource | undefined> {\n  return typeof obj === 'object' && obj !== null && Symbol.asyncIterator in obj\n}",
    "importStatements": [],
    "codeNoBody": "function isAsyncIterator(\n  obj: unknown,\n): obj is AsyncIterator<BufferSource | undefined> {\n//...\n}",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::isReadableStream",
    "language": "typescript",
    "label": "isReadableStream",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response",
    "totalTokens": 38,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function isReadableStream(obj: unknown): obj is ReadableStream<unknown> {\n  return typeof obj === 'object' && obj !== null && 'getReader' in obj\n}",
    "importStatements": [],
    "codeNoBody": "function isReadableStream(obj: unknown): obj is ReadableStream<unknown> {\n//...\n}",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response::CodeGPTResponse",
    "language": "typescript",
    "label": "CodeGPTResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response",
    "totalTokens": 35,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface CodeGPTResponse {\n  agentName?: string\n  model?: string\n  choices: Array<{ message: { role: string; content: string } }>\n}",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTResponse {\n//...\n}",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\response",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\response.ts",
    "type": "file",
    "totalTokens": 751,
    "inDegree": 0,
    "outDegree": 5,
    "code": "interface CodeGPTResponse {\n  agentName?: string\n  model?: string\n  choices: Array<{ message: { role: string; content: string } }>\n}\n\nfunction isReadableStream(obj: unknown): obj is ReadableStream<unknown> {\n  return typeof obj === 'object' && obj !== null && 'getReader' in obj\n}\n\nfunction isAsyncIterator(\n  obj: unknown,\n): obj is AsyncIterator<BufferSource | undefined> {\n  return typeof obj === 'object' && obj !== null && Symbol.asyncIterator in obj\n}\n\nexport function codeGPTResponse(\n  stream:\n    | AsyncIterator<BufferSource | undefined>\n    | ReadableStream<BufferSource>,\n  agentResponseTitle: string,\n  outputStream: boolean,\n  format: 'text' | 'json',\n  isCompletion?: boolean,\n):\n  | AsyncIterator<BufferSource | undefined>\n  | ReadableStream\n  | Promise<string | CodeGPTResponse> {\n  if (outputStream && format === 'text') {\n    return stream\n  }\n\n  const encoder = new TextEncoder()\n  const decoder = new TextDecoder()\n\n  let reader: ReadableStreamDefaultReader<BufferSource> | undefined\n  const isStream = isReadableStream(stream)\n  const isIterator = isAsyncIterator(stream)\n  if (isStream) {\n    reader = stream?.getReader()\n  }\n\n  const getNextValue = async () => {\n    let nextValue:\n      | ReadableStreamDefaultReadResult<BufferSource>\n      | IteratorResult<BufferSource | undefined>\n\n    if (reader) {\n      nextValue = await reader.read()\n    } else if (isIterator) {\n      nextValue = await stream.next()\n    } else {\n      throw new Error('Invalid input stream')\n    }\n\n    return nextValue\n  }\n\n  if (!outputStream) {\n    return new Promise((resolve, reject) =>\n      (async () => {\n        let completion = ''\n\n        while (true) {\n          const { done, value } = await getNextValue()\n          if (done) {\n            break\n          }\n\n          completion += decoder.decode(value)\n        }\n        try {\n          const message = { role: 'assistant', content: completion }\n          const choices = [{ message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n          const output = format === 'text' ? completion : body\n          resolve(output)\n        } catch (err) {\n          reject(err)\n        }\n      })()\n    )\n  }\n\n  return new ReadableStream({\n    async start(controller) {\n      while (true) {\n        const { done, value } = await getNextValue()\n        if (done) {\n          const doneMessage = encoder.encode(\n            'data: ' + '[DONE]' + '\\n\\n',\n          )\n          controller.enqueue(doneMessage)\n          controller.close()\n          return\n        }\n        const decodedValue = decoder.decode(value)\n        if (decodedValue) {\n          const message = { role: 'assistant', content: decodedValue }\n          const choices = [{ delta: message }]\n          const body = {\n            ...(!isCompletion\n              ? { agentName: agentResponseTitle }\n              : { model: agentResponseTitle }),\n            choices,\n          }\n\n          try {\n            const encodedChunk = encoder.encode(\n              'data: ' + JSON.stringify(body) + '\\n\\n',\n            )\n            controller.enqueue(encodedChunk)\n          } catch (e) {\n            console.log(e)\n          }\n        }\n      }\n    },\n    cancel() {},\n  })\n}\n",
    "importStatements": [],
    "codeNoBody": "interface CodeGPTResponse {\n//...\n}\nfunction isReadableStream(obj: unknown): obj is ReadableStream<unknown> {\n//...\n}\n\nfunction isAsyncIterator(\n  obj: unknown,\n): obj is AsyncIterator<BufferSource | undefined> {\n//...\n}\n\nexport function codeGPTResponse(\n  stream:\n    | AsyncIterator<BufferSource | undefined>\n    | ReadableStream<BufferSource>,\n  agentResponseTitle: string,\n  outputStream: boolean,\n  format: 'text' | 'json',\n  isCompletion?: boolean,\n):\n  | AsyncIterator<BufferSource | undefined>\n  | ReadableStream\n  | Promise<string | CodeGPTResponse> {\n       //...\n       }",
    "originFile": "\\lib\\response.ts"
  },
  {
    "id": "\\lib\\tokenizer::tokenizer",
    "language": "typescript",
    "label": "tokenizer",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\tokenizer",
    "totalTokens": 48,
    "inDegree": 6,
    "outDegree": 1,
    "code": "const tokenizer = (text: string, model?: TiktokenModel) => {\n  const enc = encodingForModel(model ?? 'gpt-4')\n\n  const tokens = enc.encode(text)\n\n  return tokens.length ?? 0\n}",
    "importStatements": [],
    "codeNoBody": "const tokenizer = (text: string, model?: TiktokenModel) => {\n       //...\n       }",
    "originFile": "\\lib\\tokenizer.ts"
  },
  {
    "id": "\\lib\\tokenizer::TiktokenModel",
    "language": "typescript",
    "label": "TiktokenModel",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\tokenizer",
    "totalTokens": 215,
    "inDegree": 5,
    "outDegree": 1,
    "code": "type TiktokenModel =\n  | 'text-embedding-ada-002'\n  | 'gpt-3.5-turbo'\n  | 'gpt-35-turbo'\n  | 'gpt-3.5-turbo-0301'\n  | 'gpt-3.5-turbo-0613'\n  | 'gpt-3.5-turbo-1106'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-3.5-turbo-16k-0613'\n  | 'gpt-4'\n  | 'gpt-4-0314'\n  | 'gpt-4-0613'\n  | 'gpt-4-32k'\n  | 'gpt-4-32k-0314'\n  | 'gpt-4-32k-0613'\n  | 'gpt-4-1106-preview'\n  | 'gpt-4-vision-preview'",
    "importStatements": [],
    "codeNoBody": "type TiktokenModel =\n  | 'text-embedding-ada-002'\n  | 'gpt-3.5-turbo'\n  | 'gpt-35-turbo'\n  | 'gpt-3.5-turbo-0301'\n  | 'gpt-3.5-turbo-0613'\n  | 'gpt-3.5-turbo-1106'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-3.5-turbo-16k-0613'\n  | 'gpt-4'\n  | 'gpt-4-0314'\n  | 'gpt-4-0613'\n  | 'gpt-4-32k'\n  | 'gpt-4-32k-0314'\n  | 'gpt-4-32k-0613'\n  | 'gpt-4-1106-preview'\n  | 'gpt-4-vision-preview'",
    "originFile": "\\lib\\tokenizer.ts"
  },
  {
    "id": "\\lib\\tokenizer",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\tokenizer.ts",
    "type": "file",
    "totalTokens": 278,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import { encodingForModel } from 'js-tiktoken'\n\nexport type TiktokenModel =\n  | 'text-embedding-ada-002'\n  | 'gpt-3.5-turbo'\n  | 'gpt-35-turbo'\n  | 'gpt-3.5-turbo-0301'\n  | 'gpt-3.5-turbo-0613'\n  | 'gpt-3.5-turbo-1106'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-3.5-turbo-16k-0613'\n  | 'gpt-4'\n  | 'gpt-4-0314'\n  | 'gpt-4-0613'\n  | 'gpt-4-32k'\n  | 'gpt-4-32k-0314'\n  | 'gpt-4-32k-0613'\n  | 'gpt-4-1106-preview'\n  | 'gpt-4-vision-preview'\n\nexport const tokenizer = (text: string, model?: TiktokenModel) => {\n  const enc = encodingForModel(model ?? 'gpt-4')\n\n  const tokens = enc.encode(text)\n\n  return tokens.length ?? 0\n}\n",
    "importStatements": [
      "import { encodingForModel } from 'js-tiktoken'"
    ],
    "codeNoBody": "import { encodingForModel } from 'js-tiktoken'\nexport type TiktokenModel =\n  | 'text-embedding-ada-002'\n  | 'gpt-3.5-turbo'\n  | 'gpt-35-turbo'\n  | 'gpt-3.5-turbo-0301'\n  | 'gpt-3.5-turbo-0613'\n  | 'gpt-3.5-turbo-1106'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-3.5-turbo-16k-0613'\n  | 'gpt-4'\n  | 'gpt-4-0314'\n  | 'gpt-4-0613'\n  | 'gpt-4-32k'\n  | 'gpt-4-32k-0314'\n  | 'gpt-4-32k-0613'\n  | 'gpt-4-1106-preview'\n  | 'gpt-4-vision-preview'\n\nexport const tokenizer = (text: string, model?: TiktokenModel) => {\n       //...\n       }",
    "originFile": "\\lib\\tokenizer.ts"
  },
  {
    "id": "\\lib\\usage::usageAdapter",
    "language": "typescript",
    "label": "usageAdapter",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\usage",
    "totalTokens": 147,
    "inDegree": 2,
    "outDegree": 1,
    "code": "function usageAdapter(params: Params): NewUsage[number] {\n  const {\n    type,\n    channel,\n    embeddingTokens,\n    userId,\n    planName,\n    agentId,\n    completionToken,\n    promptToken,\n    orgId,\n  } = params\n  return {\n    org_id: orgId,\n    type,\n    channel,\n    source: 'API',\n    model: 'text-embedding-ada-002',\n    plan_name: planName,\n    embeddings_tokens: embeddingTokens,\n    user_id: userId,\n    agent_id: agentId ?? null,\n    ...(completionToken ? { completion_token: completionToken } : {}),\n    ...(promptToken ? { prompt_token: promptToken } : {}),\n  }\n}",
    "importStatements": [],
    "codeNoBody": "function usageAdapter(params: Params): NewUsage[number] {\n//...\n}",
    "originFile": "\\lib\\usage.ts"
  },
  {
    "id": "\\lib\\usage::createNewUsageObject",
    "language": "typescript",
    "label": "createNewUsageObject",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\usage",
    "totalTokens": 46,
    "inDegree": 3,
    "outDegree": 2,
    "code": "function createNewUsageObject(params: Params | Array<Params>): NewUsage {\n  if (Array.isArray(params)) {\n    return params.map((param) => usageAdapter(param))\n  }\n\n  return [usageAdapter(params)]\n}",
    "importStatements": [],
    "codeNoBody": "function createNewUsageObject(params: Params | Array<Params>): NewUsage {\n       //...\n       }",
    "originFile": "\\lib\\usage.ts"
  },
  {
    "id": "\\lib\\usage::Params",
    "language": "typescript",
    "label": "Params",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\usage",
    "totalTokens": 62,
    "inDegree": 5,
    "outDegree": 1,
    "code": "interface Params {\n  type: UsageType\n  channel: string\n  planName: Plan['name']\n  embeddingTokens: number\n  userId: Profile['id']\n  agentId?: Agent['id']\n  promptToken?: number\n  completionToken?: number\n  orgId: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Params {\n//...\n}",
    "originFile": "\\lib\\usage.ts"
  },
  {
    "id": "\\lib\\usage",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\usage.ts",
    "type": "file",
    "totalTokens": 283,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import type {\n  Agent,\n  NewUsage,\n  Plan,\n  Profile,\n  UsageType,\n} from '../types/index.ts'\n\ninterface Params {\n  type: UsageType\n  channel: string\n  planName: Plan['name']\n  embeddingTokens: number\n  userId: Profile['id']\n  agentId?: Agent['id']\n  promptToken?: number\n  completionToken?: number\n  orgId: string\n}\nexport function createNewUsageObject(params: Params | Array<Params>): NewUsage {\n  if (Array.isArray(params)) {\n    return params.map((param) => usageAdapter(param))\n  }\n\n  return [usageAdapter(params)]\n}\n\nfunction usageAdapter(params: Params): NewUsage[number] {\n  const {\n    type,\n    channel,\n    embeddingTokens,\n    userId,\n    planName,\n    agentId,\n    completionToken,\n    promptToken,\n    orgId,\n  } = params\n  return {\n    org_id: orgId,\n    type,\n    channel,\n    source: 'API',\n    model: 'text-embedding-ada-002',\n    plan_name: planName,\n    embeddings_tokens: embeddingTokens,\n    user_id: userId,\n    agent_id: agentId ?? null,\n    ...(completionToken ? { completion_token: completionToken } : {}),\n    ...(promptToken ? { prompt_token: promptToken } : {}),\n  }\n}\n",
    "importStatements": [
      "import type {\n  Agent,\n  NewUsage,\n  Plan,\n  Profile,\n  UsageType,\n} from '../types/index.ts'"
    ],
    "codeNoBody": "import type {\n  Agent,\n  NewUsage,\n  Plan,\n  Profile,\n  UsageType,\n} from '../types/index.ts'\ninterface Params {\n//...\n}\nexport function createNewUsageObject(params: Params | Array<Params>): NewUsage {\n       //...\n       }\n\nfunction usageAdapter(params: Params): NewUsage[number] {\n//...\n}",
    "originFile": "\\lib\\usage.ts"
  },
  {
    "id": "\\lib\\utils::getConvertedText",
    "language": "typescript",
    "label": "getConvertedText",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils",
    "totalTokens": 280,
    "inDegree": 3,
    "outDegree": 0,
    "code": "async function getConvertedText(jobId: string) {\n  const res = await fetch(\n    `https://v2.convertapi.com/async/job/${jobId}`,\n  )\n\n  if ([400, 404].indexOf(res.status) !== -1) {\n    return { content: '', code: res.status, status: 'Invalid jobId' }\n  }\n\n  if (res.status === 202) {\n    return {\n      content: '',\n      code: res.status,\n      status: 'Convertion still in progress',\n    }\n  }\n\n  const data: { Files: { FileData: string }[] } = await res.json()\n  const base64content = data.Files[0].FileData as string\n\n  const binaryString = atob(base64content)\n  const bytes = new Uint8Array(binaryString.length)\n\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n\n  const decoder = new TextDecoder()\n  const decodedContent = decoder.decode(bytes)\n\n  // Remove extra spaces and new lines\n  const content = `\"${\n    decodedContent\n      .replaceAll('\\r\\n', '\\n')\n      .replaceAll('\\n\\n', '\\n')\n      .trim()\n  }\"`\n\n  return { content, code: res.status, status: 'Success' }\n}",
    "importStatements": [],
    "codeNoBody": "async function getConvertedText(jobId: string) {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\lib\\utils::getTextFromFile",
    "language": "typescript",
    "label": "getTextFromFile",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils",
    "totalTokens": 275,
    "inDegree": 5,
    "outDegree": 1,
    "code": "async function getTextFromFile(file: File) {\n  const fileSplit = file.name.split('.')\n  const type = fileSplit.pop() ?? ''\n  const name = fileSplit.join('.')\n  const mimeType = file.type\n\n  let content = ''\n\n  // Return text if it's txt, csv, log, json, or md\n  if (\n    ['txt', 'csv', 'log', 'json', 'md'].includes(type) ||\n    mimeType.includes('text/')\n  ) {\n    content = await file.text()\n    return { content, name, type: 'txt', jobId: '' }\n  }\n\n  // Return text from ConvertAPI\n  const formData = new FormData()\n  formData.append('File', file)\n\n  const fileExtensionResult = ['xls', 'xlsx'].includes(type) ? 'csv' : 'txt'\n\n  const res = await fetch(\n    `https://v2.convertapi.com/async/convert/${type}/to/${fileExtensionResult}?Secret=${\n      getEnv(\n        'CONVERT_API_SECRET',\n      )\n    }`,\n    {\n      method: 'POST',\n      body: formData,\n    },\n  )\n  const data: { JobId: string } = await res.json()\n  const jobId = data.JobId as string\n\n  return { content, name, type: fileExtensionResult, jobId }\n}",
    "importStatements": [],
    "codeNoBody": "async function getTextFromFile(file: File) {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\lib\\utils::cleanText",
    "language": "typescript",
    "label": "cleanText",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils",
    "totalTokens": 78,
    "inDegree": 4,
    "outDegree": 0,
    "code": "const cleanText = (text: string) => {\n  if (!text) {\n    return ''\n  }\n  text = text.replaceAll(/({)/g, '%7B').replaceAll(/(})/g, '%7D')\n  return text.replaceAll(/<\\|.*?\\|>/g, (match) => {\n    return match.replaceAll('|', '\\\\|')\n  })\n}",
    "importStatements": [],
    "codeNoBody": "const cleanText = (text: string) => {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\lib\\utils::sendError",
    "language": "typescript",
    "label": "sendError",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils",
    "totalTokens": 81,
    "inDegree": 19,
    "outDegree": 0,
    "code": "function sendError(e: any, c: Context) {\n  console.error(e)\n\n  if (e instanceof HTTPException) {\n    return c.json({ message: e.message }, e.status)\n  }\n\n  if (e instanceof Error) {\n    return c.json({ message: e.message }, 400)\n  }\n\n  return c.json({ message: 'Internal Server Error' }, 500)\n}",
    "importStatements": [],
    "codeNoBody": "function sendError(e: any, c: Context) {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\lib\\utils::getAuthorization",
    "language": "typescript",
    "label": "getAuthorization",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils",
    "totalTokens": 272,
    "inDegree": 47,
    "outDegree": 2,
    "code": "async function getAuthorization(c: Context, throwError = true) {\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n  const orgId = c.req.header('CodeGPT-Org-Id') ?? null\n  let userId = null\n  let apiKey = null\n\n  if (!accessToken && throwError) {\n    throw new HTTPException(400, { message: 'Missing access token' })\n  }\n\n  if (accessToken && !accessToken.startsWith('sk-')) {\n    const secret = getEnv('SUPABASE_JWT')\n\n    try {\n      const { payload } = await jwtVerify(\n        accessToken,\n        new TextEncoder().encode(secret),\n      )\n\n      if (!payload.sub) {\n        throw new HTTPException(400, { message: 'Invalid access token' })\n      }\n\n      userId = payload.sub\n    } catch (_error) {\n      throw new HTTPException(400, { message: 'Invalid access token' })\n    }\n  } else {\n    apiKey = accessToken\n  }\n\n  const { success } = uuidSchema.safeParse(orgId)\n\n  if (orgId && !success) {\n    throw new HTTPException(400, { message: 'Invalid org id' })\n  }\n\n  return {\n    apiKey: apiKey ?? null,\n    orgId,\n    userId,\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getAuthorization(c: Context, throwError = true) {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\lib\\utils",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\lib\\utils.ts",
    "type": "file",
    "totalTokens": 1057,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { getEnv } from '@/lib/env.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport type { Context } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\nimport { jwtVerify } from 'jose'\n\nexport async function getAuthorization(c: Context, throwError = true) {\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n  const orgId = c.req.header('CodeGPT-Org-Id') ?? null\n  let userId = null\n  let apiKey = null\n\n  if (!accessToken && throwError) {\n    throw new HTTPException(400, { message: 'Missing access token' })\n  }\n\n  if (accessToken && !accessToken.startsWith('sk-')) {\n    const secret = getEnv('SUPABASE_JWT')\n\n    try {\n      const { payload } = await jwtVerify(\n        accessToken,\n        new TextEncoder().encode(secret),\n      )\n\n      if (!payload.sub) {\n        throw new HTTPException(400, { message: 'Invalid access token' })\n      }\n\n      userId = payload.sub\n    } catch (_error) {\n      throw new HTTPException(400, { message: 'Invalid access token' })\n    }\n  } else {\n    apiKey = accessToken\n  }\n\n  const { success } = uuidSchema.safeParse(orgId)\n\n  if (orgId && !success) {\n    throw new HTTPException(400, { message: 'Invalid org id' })\n  }\n\n  return {\n    apiKey: apiKey ?? null,\n    orgId,\n    userId,\n  }\n}\n\n// deno-lint-ignore no-explicit-any\nexport function sendError(e: any, c: Context) {\n  console.error(e)\n\n  if (e instanceof HTTPException) {\n    return c.json({ message: e.message }, e.status)\n  }\n\n  if (e instanceof Error) {\n    return c.json({ message: e.message }, 400)\n  }\n\n  return c.json({ message: 'Internal Server Error' }, 500)\n}\n\nexport const cleanText = (text: string) => {\n  if (!text) {\n    return ''\n  }\n  text = text.replaceAll(/({)/g, '%7B').replaceAll(/(})/g, '%7D')\n  return text.replaceAll(/<\\|.*?\\|>/g, (match) => {\n    return match.replaceAll('|', '\\\\|')\n  })\n}\n\nexport async function getTextFromFile(file: File) {\n  const fileSplit = file.name.split('.')\n  const type = fileSplit.pop() ?? ''\n  const name = fileSplit.join('.')\n  const mimeType = file.type\n\n  let content = ''\n\n  // Return text if it's txt, csv, log, json, or md\n  if (\n    ['txt', 'csv', 'log', 'json', 'md'].includes(type) ||\n    mimeType.includes('text/')\n  ) {\n    content = await file.text()\n    return { content, name, type: 'txt', jobId: '' }\n  }\n\n  // Return text from ConvertAPI\n  const formData = new FormData()\n  formData.append('File', file)\n\n  const fileExtensionResult = ['xls', 'xlsx'].includes(type) ? 'csv' : 'txt'\n\n  const res = await fetch(\n    `https://v2.convertapi.com/async/convert/${type}/to/${fileExtensionResult}?Secret=${\n      getEnv(\n        'CONVERT_API_SECRET',\n      )\n    }`,\n    {\n      method: 'POST',\n      body: formData,\n    },\n  )\n  const data: { JobId: string } = await res.json()\n  const jobId = data.JobId as string\n\n  return { content, name, type: fileExtensionResult, jobId }\n}\n\nexport async function getConvertedText(jobId: string) {\n  const res = await fetch(\n    `https://v2.convertapi.com/async/job/${jobId}`,\n  )\n\n  if ([400, 404].indexOf(res.status) !== -1) {\n    return { content: '', code: res.status, status: 'Invalid jobId' }\n  }\n\n  if (res.status === 202) {\n    return {\n      content: '',\n      code: res.status,\n      status: 'Convertion still in progress',\n    }\n  }\n\n  const data: { Files: { FileData: string }[] } = await res.json()\n  const base64content = data.Files[0].FileData as string\n\n  const binaryString = atob(base64content)\n  const bytes = new Uint8Array(binaryString.length)\n\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n\n  const decoder = new TextDecoder()\n  const decodedContent = decoder.decode(bytes)\n\n  // Remove extra spaces and new lines\n  const content = `\"${\n    decodedContent\n      .replaceAll('\\r\\n', '\\n')\n      .replaceAll('\\n\\n', '\\n')\n      .trim()\n  }\"`\n\n  return { content, code: res.status, status: 'Success' }\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { uuidSchema } from '@/schemas/index.ts'",
      "import type { Context } from 'hono'",
      "import { HTTPException } from 'hono/http-exception'",
      "import { jwtVerify } from 'jose'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport type { Context } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\nimport { jwtVerify } from 'jose'\nexport async function getAuthorization(c: Context, throwError = true) {\n       //...\n       }\n\n// deno-lint-ignore no-explicit-any\nexport function sendError(e: any, c: Context) {\n       //...\n       }\n\nexport const cleanText = (text: string) => {\n       //...\n       }\n\nexport async function getTextFromFile(file: File) {\n       //...\n       }\n\nexport async function getConvertedText(jobId: string) {\n       //...\n       }",
    "originFile": "\\lib\\utils.ts"
  },
  {
    "id": "\\routes\\agents\\index::agents",
    "language": "typescript",
    "label": "agents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\index",
    "totalTokens": 3732,
    "inDegree": 3,
    "outDegree": 9,
    "code": "const agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents }",
    "importStatements": [],
    "codeNoBody": "const agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents }",
    "originFile": "\\routes\\agents\\index.ts"
  },
  {
    "id": "\\routes\\agents\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\index.ts",
    "type": "file",
    "totalTokens": 2023,
    "inDegree": 0,
    "outDegree": 10,
    "code": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { agentCreateSchema, agentUpdateSchema } from '@/schemas/agent.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { updateAgentImageByAgentId } from '@/services/supabase/agents.ts'\nimport { agentDocumentsSchema } from '@/schemas/agent.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\n\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Create an Agent\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Get an Agent by id\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update an Agent by id\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update an Agent's image by id\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\n\n// Update Agent documents\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Delete an Agent by id\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { agentCreateSchema, agentUpdateSchema } from '@/schemas/agent.ts'",
      "import { getAuthorization, sendError } from '@/lib/utils.ts'",
      "import { uuidSchema } from '@/schemas/index.ts'",
      "import { updateAgentImageByAgentId } from '@/services/supabase/agents.ts'",
      "import { agentDocumentsSchema } from '@/schemas/agent.ts'",
      "import { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { agentCreateSchema, agentUpdateSchema } from '@/schemas/agent.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { updateAgentImageByAgentId } from '@/services/supabase/agents.ts'\nimport { agentDocumentsSchema } from '@/schemas/agent.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents =\n      await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId})`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Create an Agent\nagents.post('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await agentCreateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  try {\n    const [{ validate_max_agents: ids }] =\n      await sql`SELECT * FROM validate_max_agents(${orgId}, ${apiKey}, ${userId})`\n    const { orgId: validatedOrgId } = ids\n    const [agentCreated] = await sql`INSERT INTO agents ${\n      sql({\n        ...agent,\n        org_id: validatedOrgId,\n      })\n    } returning agents.id,\n      agents.org_id,\n      agents.created_at,\n      agents.pincode,\n      agents.is_public,\n      agents.welcome,\n      agents.image,\n      agents.agent_type,\n      agents.name,\n      agents.prompt,\n      agents.model,\n      agents.description,\n      agents.temperature,\n      agents.topk `\n    return c.json(agentCreated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Get an Agent by id\nagents.get('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n  const includeQuery = c.req.query('populate')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = includeQuery?.split(',').includes('agent_documents')\n      ? await sql`SELECT * FROM get_agent_with_documents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n      : await sql`SELECT * FROM get_agents_by_org_id_and_api_key_or_user_id(${orgId}, ${apiKey}, ${userId}, ${id})`\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agent.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } = agent\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agent })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update an Agent by id\nagents.patch('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const agent = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentUpdated] =\n      await sql`SELECT * FROM update_agent_by_org_id_and_api_key_or_user_id(\n        ${orgId}, \n        ${apiKey}, \n        ${userId}, \n        ${id}, \n        ${sql.json(agent)}\n    )`\n\n    if (!agentUpdated) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (agentUpdated.agent_type === 'qa') {\n      const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n        agentUpdated\n      return c.json({ ...filteredAgent })\n    }\n\n    return c.json({ ...agentUpdated })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update an Agent's image by id\nagents.patch('/:id/image', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const agentId = c.req.param('id')\n  const body = await c.req.parseBody()\n  const imageFile = body?.file as File\n\n  const { success } = uuidSchema.safeParse(agentId)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  if (!imageFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n\n  if (imageFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const rows =\n      await sql`SELECT user_org_id, plan_user_id, user_email FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Unauthorized' }, 401)\n    }\n\n    const [{ user_org_id, plan_user_id, user_email }] = rows\n\n    const acceptedImageFormats = user_email.endsWith('@judini.ai')\n      ? ACCEPTED_IMAGE_FILES\n      : ACCEPTED_IMAGE_FILES.filter((format) => format !== 'gif')\n\n    const isAcceptedImage = acceptedImageFormats.includes(\n      imageFile.type.split('/')[1],\n    )\n\n    if (!isAcceptedImage) {\n      return c.json({ message: 'Invalid image type' }, 400)\n    }\n\n    const { url } = await updateAgentImageByAgentId(\n      imageFile,\n      agentId,\n      user_org_id,\n      plan_user_id,\n    )\n    return c.json({ message: 'Agent image updated successfully', url })\n  } catch (error) {\n    console.log('Error updating agent image:', error)\n    return sendError(error, c)\n  }\n})\n\n// Update Agent documents\nagents.patch('/:id/documents', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  if (!apiKey && !userId) {\n    return c.json({ message: 'Missing api key or user id' }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const json = await c.req.json()\n\n  const parsed = await agentDocumentsSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.message }, 400)\n  }\n\n  const { agent_documents: agentDocuments } = parsed.data\n\n  const { success } = uuidSchema.safeParse(id)\n  if (!success) {\n    return c.json({ message: 'Invalid endpoint parameters' }, 400)\n  }\n\n  try {\n    const formattedAgentDocuments = JSON.stringify(agentDocuments)\n      .replace('[', '{')\n      .replace(']', '}')\n\n    await sql`SELECT * FROM set_agent_documents_from_api(${formattedAgentDocuments}, ${id}, ${orgId}, ${userId}, ${apiKey})`\n    return c.json({ message: 'Agent documents set successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Delete an Agent by id\nagents.delete('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agentDeleted] =\n      await sql`SELECT * FROM delete_agent_by_agent_id_and_org_id_and_user_id(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!agentDeleted) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    await sql`SELECT * FROM check_and_unfreeze_agent_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Agent deleted successfully' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents }",
    "originFile": "\\routes\\agents\\index.ts"
  },
  {
    "id": "\\routes\\agents\\marketplace-favorites\\index::getMarketplaceFavoritesAgents",
    "language": "typescript",
    "label": "getMarketplaceFavoritesAgents",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\marketplace-favorites\\index",
    "totalTokens": 586,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getMarketplaceFavoritesAgents({ orgId, apiKey, userId }: {\n  orgId: string | null\n  apiKey: string | null\n  userId: string | null\n}) {\n  try {\n    const marketplaceFavoriteAgents = await sql`\n      WITH\n        plan_limits AS (\n          SELECT\n            plan_user_id,\n            user_org_id\n          FROM\n            get_plan_limits (\n              ${orgId},\n              ${apiKey},\n              ${userId}\n            )\n        ),\n        agent_details AS (\n          SELECT\n            agents.created_at,\n            agents.name,\n            agents.model,\n            agents.temperature,\n            agents.prompt,\n            agents.topk,\n            agents.welcome,\n            agents.status,\n            agents.id,\n            agents.image,\n            agents.org_id,\n            agents.agent_type,\n            agents.prompt_library,\n            agents.palette,\n            agents.font,\n            agents.slug,\n            COALESCE(ROUND(AVG(ar.rating), 1), NULL) AS rating,\n            COUNT(DISTINCT ar.user_id) AS total_rating_users,\n            ARRAY_AGG(DISTINCT tags.name) AS tags\n          FROM\n            agents\n            JOIN agents_tags at ON at.agent_id = agents.id\n            JOIN tags ON at.tag_id = tags.id\n            LEFT JOIN agents_rating ar ON ar.agent_id = agents.id\n          GROUP BY\n            agents.id\n        ),\n        favorite_details AS (\n          SELECT\n            maf.agent_id,\n            BOOL_OR(maf.is_frozen) AS is_frozen,\n            COUNT(DISTINCT maf.user_id) AS total_favorite_users,\n            COALESCE(BOOL_OR(maf.user_id = pl.user_org_id), false) AS is_installed\n          FROM\n            plan_limits pl\n            JOIN marketplace_agents_favorites maf ON maf.org_id = pl.user_org_id\n          GROUP BY\n            maf.agent_id\n        )\n      SELECT\n        a.*,\n        fd.total_favorite_users,\n        fd.is_frozen,\n        fd.is_installed,\n        pd.id AS product_detail_id,\n        pd.tagline,\n        pd.description,\n        ur.rating AS user_rating,\n        o.name AS organization_name,\n        o.image AS organization_image,\n        o.verified AS organization_verified,\n        o.id AS marketplace_agent_org_id\n      FROM\n        agent_details a\n        JOIN favorite_details fd ON a.id = fd.agent_id\n        JOIN marketplace_agents ma ON ma.agent_id = a.id\n        JOIN product_details pd ON pd.id = ma.product_details_id\n        JOIN organizations o ON o.id = a.org_id\n        CROSS JOIN plan_limits pl\n        LEFT JOIN agents_rating ur ON ur.agent_id = a.id\n        AND ur.user_id = pl.plan_user_id\n    `\n\n    return marketplaceFavoriteAgents\n  } catch (error) {\n    console.log('Error getting marketplace favorite agents', error)\n    return []\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getMarketplaceFavoritesAgents({ orgId, apiKey, userId }: {\n  orgId: string | null\n  apiKey: string | null\n  userId: string | null\n}) {\n//...\n}",
    "originFile": "\\routes\\agents\\marketplace-favorites\\index.ts"
  },
  {
    "id": "\\routes\\agents\\marketplace-favorites\\index::marketplaceFavoriteAgents",
    "language": "typescript",
    "label": "marketplaceFavoriteAgents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\marketplace-favorites\\index",
    "totalTokens": 361,
    "inDegree": 3,
    "outDegree": 4,
    "code": "const agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents = await getMarketplaceFavoritesAgents({\n      orgId,\n      apiKey,\n      userId,\n    })\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  const id = c.req.param('id')\n\n  try {\n    const rows =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!rows || !rows[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    const { plan_user_id, user_org_id } = rows[0]\n\n    await sql`insert into marketplace_agents_favorites (agent_id, org_id, user_id) values (${id}, ${user_org_id}, ${plan_user_id})`\n\n    return c.json({ message: 'Agent added to favorites' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceFavoriteAgents }",
    "importStatements": [],
    "codeNoBody": "const agents = new Hono()\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  try {\n    const allAgents = await getMarketplaceFavoritesAgents({\n      orgId,\n      apiKey,\n      userId,\n    })\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nagents.post('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  const id = c.req.param('id')\n\n  try {\n    const rows =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!rows || !rows[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    const { plan_user_id, user_org_id } = rows[0]\n\n    await sql`insert into marketplace_agents_favorites (agent_id, org_id, user_id) values (${id}, ${user_org_id}, ${plan_user_id})`\n\n    return c.json({ message: 'Agent added to favorites' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceFavoriteAgents }",
    "originFile": "\\routes\\agents\\marketplace-favorites\\index.ts"
  },
  {
    "id": "\\routes\\agents\\marketplace-favorites\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\marketplace-favorites\\index.ts",
    "type": "file",
    "totalTokens": 987,
    "inDegree": 0,
    "outDegree": 6,
    "code": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\n\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents = await getMarketplaceFavoritesAgents({\n      orgId,\n      apiKey,\n      userId,\n    })\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nagents.post('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  const id = c.req.param('id')\n\n  try {\n    const rows =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!rows || !rows[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    const { plan_user_id, user_org_id } = rows[0]\n\n    await sql`insert into marketplace_agents_favorites (agent_id, org_id, user_id) values (${id}, ${user_org_id}, ${plan_user_id})`\n\n    return c.json({ message: 'Agent added to favorites' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceFavoriteAgents }\n\nasync function getMarketplaceFavoritesAgents({ orgId, apiKey, userId }: {\n  orgId: string | null\n  apiKey: string | null\n  userId: string | null\n}) {\n  try {\n    const marketplaceFavoriteAgents = await sql`\n      WITH\n        plan_limits AS (\n          SELECT\n            plan_user_id,\n            user_org_id\n          FROM\n            get_plan_limits (\n              ${orgId},\n              ${apiKey},\n              ${userId}\n            )\n        ),\n        agent_details AS (\n          SELECT\n            agents.created_at,\n            agents.name,\n            agents.model,\n            agents.temperature,\n            agents.prompt,\n            agents.topk,\n            agents.welcome,\n            agents.status,\n            agents.id,\n            agents.image,\n            agents.org_id,\n            agents.agent_type,\n            agents.prompt_library,\n            agents.palette,\n            agents.font,\n            agents.slug,\n            COALESCE(ROUND(AVG(ar.rating), 1), NULL) AS rating,\n            COUNT(DISTINCT ar.user_id) AS total_rating_users,\n            ARRAY_AGG(DISTINCT tags.name) AS tags\n          FROM\n            agents\n            JOIN agents_tags at ON at.agent_id = agents.id\n            JOIN tags ON at.tag_id = tags.id\n            LEFT JOIN agents_rating ar ON ar.agent_id = agents.id\n          GROUP BY\n            agents.id\n        ),\n        favorite_details AS (\n          SELECT\n            maf.agent_id,\n            BOOL_OR(maf.is_frozen) AS is_frozen,\n            COUNT(DISTINCT maf.user_id) AS total_favorite_users,\n            COALESCE(BOOL_OR(maf.user_id = pl.user_org_id), false) AS is_installed\n          FROM\n            plan_limits pl\n            JOIN marketplace_agents_favorites maf ON maf.org_id = pl.user_org_id\n          GROUP BY\n            maf.agent_id\n        )\n      SELECT\n        a.*,\n        fd.total_favorite_users,\n        fd.is_frozen,\n        fd.is_installed,\n        pd.id AS product_detail_id,\n        pd.tagline,\n        pd.description,\n        ur.rating AS user_rating,\n        o.name AS organization_name,\n        o.image AS organization_image,\n        o.verified AS organization_verified,\n        o.id AS marketplace_agent_org_id\n      FROM\n        agent_details a\n        JOIN favorite_details fd ON a.id = fd.agent_id\n        JOIN marketplace_agents ma ON ma.agent_id = a.id\n        JOIN product_details pd ON pd.id = ma.product_details_id\n        JOIN organizations o ON o.id = a.org_id\n        CROSS JOIN plan_limits pl\n        LEFT JOIN agents_rating ur ON ur.agent_id = a.id\n        AND ur.user_id = pl.plan_user_id\n    `\n\n    return marketplaceFavoriteAgents\n  } catch (error) {\n    console.log('Error getting marketplace favorite agents', error)\n    return []\n  }\n}\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getAuthorization, sendError } from '@/lib/utils.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const allAgents = await getMarketplaceFavoritesAgents({\n      orgId,\n      apiKey,\n      userId,\n    })\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nagents.post('/:id', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n  const id = c.req.param('id')\n\n  try {\n    const rows =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!rows || !rows[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    const { plan_user_id, user_org_id } = rows[0]\n\n    await sql`insert into marketplace_agents_favorites (agent_id, org_id, user_id) values (${id}, ${user_org_id}, ${plan_user_id})`\n\n    return c.json({ message: 'Agent added to favorites' })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceFavoriteAgents }\n\nasync function getMarketplaceFavoritesAgents({ orgId, apiKey, userId }: {\n  orgId: string | null\n  apiKey: string | null\n  userId: string | null\n}) {\n//...\n}",
    "originFile": "\\routes\\agents\\marketplace-favorites\\index.ts"
  },
  {
    "id": "\\routes\\agents\\marketplace\\index::marketplaceAgents",
    "language": "typescript",
    "label": "marketplaceAgents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\marketplace\\index",
    "totalTokens": 160,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const agents = new Hono()\nagents.get('/', async (c) => {\n  try {\n    const allAgents = await sql`SELECT * FROM get_marketplace_agents()`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceAgents }",
    "importStatements": [],
    "codeNoBody": "const agents = new Hono()\nagents.get('/', async (c) => {\n  try {\n    const allAgents = await sql`SELECT * FROM get_marketplace_agents()`\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceAgents }",
    "originFile": "\\routes\\agents\\marketplace\\index.ts"
  },
  {
    "id": "\\routes\\agents\\marketplace\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\marketplace\\index.ts",
    "type": "file",
    "totalTokens": 197,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { sendError } from '@/lib/utils.ts'\n\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  try {\n    const allAgents = await sql`SELECT * FROM get_marketplace_agents()`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceAgents }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { sendError } from '@/lib/utils.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sql } from '@/lib/db/index.ts'\nimport { sendError } from '@/lib/utils.ts'\nconst agents = new Hono()\n\n// Get all Agents\nagents.get('/', async (c) => {\n  try {\n    const allAgents = await sql`SELECT * FROM get_marketplace_agents()`\n\n    if (!allAgents || allAgents.length === 0) {\n      return c.json({ message: 'No agents found' }, 404)\n    }\n\n    const agents = allAgents?.map((agent) => {\n      if (agent.agent_type === 'qa') {\n        const { temperature: _temperature, topk: _topk, ...filteredAgent } =\n          agent\n        return filteredAgent\n      }\n\n      return agent\n    })\n\n    return c.json(agents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { agents as marketplaceAgents }",
    "originFile": "\\routes\\agents\\marketplace\\index.ts"
  },
  {
    "id": "\\routes\\agents\\widget\\index::widgetAgent",
    "language": "typescript",
    "label": "widgetAgent",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\widget\\index",
    "totalTokens": 363,
    "inDegree": 3,
    "outDegree": 3,
    "code": "const widgetAgent = new Hono()\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst widgetAgent = new Hono()\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgetAgent }",
    "importStatements": [],
    "codeNoBody": "const widgetAgent = new Hono()\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst widgetAgent = new Hono()\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgetAgent }",
    "originFile": "\\routes\\agents\\widget\\index.ts"
  },
  {
    "id": "\\routes\\agents\\widget\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\agents\\widget\\index.ts",
    "type": "file",
    "totalTokens": 234,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { sendError } from '@/lib/utils.ts'\nimport { Hono } from 'hono'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nconst widgetAgent = new Hono()\n\n// Get an Agent by id\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgetAgent }\n",
    "importStatements": [
      "import { sendError } from '@/lib/utils.ts'",
      "import { Hono } from 'hono'",
      "import { uuidSchema } from '@/schemas/index.ts'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { sendError } from '@/lib/utils.ts'\nimport { Hono } from 'hono'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { sql } from '@/lib/db/index.ts'\nconst widgetAgent = new Hono()\n\n// Get an Agent by id\nwidgetAgent.get('/:id', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      SELECT \n        a.id, \n        a.name, \n        a.image \n      FROM widgets\n      JOIN agents a ON a.id = widgets.agent_id \n      WHERE \n        widgets.id = ${id}\n        AND widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgetAgent }",
    "originFile": "\\routes\\agents\\widget\\index.ts"
  },
  {
    "id": "\\routes\\apikeys\\index::apiKeySchema",
    "language": "typescript",
    "label": "apiKeySchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\apikeys\\index",
    "totalTokens": 12,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const apiKeySchema = z.string().startsWith('sk-')",
    "importStatements": [],
    "codeNoBody": "const apiKeySchema = z.string().startsWith('sk-')",
    "originFile": "\\routes\\apikeys\\index.ts"
  },
  {
    "id": "\\routes\\apikeys\\index::apiKeys",
    "language": "typescript",
    "label": "apiKeys",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\apikeys\\index",
    "totalTokens": 365,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const apiKeys = new Hono()\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nconst apiKeys = new Hono()\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nexport { apiKeys }",
    "importStatements": [],
    "codeNoBody": "const apiKeys = new Hono()\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nconst apiKeys = new Hono()\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nexport { apiKeys }",
    "originFile": "\\routes\\apikeys\\index.ts"
  },
  {
    "id": "\\routes\\apikeys\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\apikeys\\index.ts",
    "type": "file",
    "totalTokens": 232,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { sql } from '@/lib/db/index.ts'\n\nconst apiKeys = new Hono()\n\nconst apiKeySchema = z.string().startsWith('sk-')\n\n// Get client ip\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nexport { apiKeys }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { z } from 'zod'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { sql } from '@/lib/db/index.ts'\nconst apiKeys = new Hono()\n\nconst apiKeySchema = z.string().startsWith('sk-')\n\n// Get client ip\napiKeys.get('/:apiKey', async (c) => {\n  try {\n    const paramsApiKey = c.req.param('apiKey')\n    const parsed = await apiKeySchema.spa(paramsApiKey)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.message }, 400)\n    }\n\n    const apiKey = parsed.data\n\n    const rows = await sql`SELECT 1 FROM api_keys ak WHERE ak.key = ${apiKey}`\n\n    if (rows.length === 0) {\n      return c.json({ error: 'Invalid API key' }, 404)\n    }\n\n    return c.json({ message: 'API key is valid' })\n  } catch (e) {\n    console.log('Error getting apikey', e)\n    return c.json({ error: 'Server error, please try again' }, 500)\n  }\n})\n\nexport { apiKeys }",
    "originFile": "\\routes\\apikeys\\index.ts"
  },
  {
    "id": "\\routes\\bitbucket::bitbucketApp",
    "language": "typescript",
    "label": "bitbucketApp",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\bitbucket",
    "totalTokens": 2976,
    "inDegree": 3,
    "outDegree": 5,
    "code": "const bitbucketApp = new Hono()\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst bitbucketApp = new Hono()\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { bitbucketApp }",
    "importStatements": [],
    "codeNoBody": "const bitbucketApp = new Hono()\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst bitbucketApp = new Hono()\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { bitbucketApp }",
    "originFile": "\\routes\\bitbucket.ts"
  },
  {
    "id": "\\routes\\bitbucket",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\bitbucket.ts",
    "type": "file",
    "totalTokens": 1807,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserInfo } from '@/lib/integrations/bitbucket-app/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { refreshAccessToken } from '@/lib/integrations/bitbucket-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\n\nconst bitbucketApp = new Hono()\n\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\n// bitbucketApp.get('/verify-user', async (c) => {\n//   try {\n//     const accessToken = null\n\n//     const headers = {\n//       'Authorization': `Bearer ${accessToken}`,\n//       'Accept': 'application/json',\n//     }\n\n//     const response = await axios.get('https://api.bitbucket.org/2.0/user', {\n//       headers,\n//     })\n\n//     if (response.status === 200) {\n//       const userData = response.data\n//       return c.json({\n//         displayName: userData.display_name,\n//         username: userData.username,\n//         accountId: userData.uuid,\n//       })\n//     } else {\n//       return c.json({\n//         error:\n//           `Error al obtener información del usuario: ${response.status} - ${response.statusText}`,\n//       }, 400)\n//     }\n//   } catch (error) {\n//     console.error('Error al verificar el usuario:', error)\n//     return c.json({ error: 'Error al verificar el usuario' }, 500)\n//   }\n// })\n\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nexport { bitbucketApp }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import axios from 'axios'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getUserInfo } from '@/lib/integrations/bitbucket-app/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { refreshAccessToken } from '@/lib/integrations/bitbucket-app/utils.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserInfo } from '@/lib/integrations/bitbucket-app/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { refreshAccessToken } from '@/lib/integrations/bitbucket-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nconst bitbucketApp = new Hono()\n\nbitbucketApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const tokenResponse = await axios.post(\n      'https://bitbucket.org/site/oauth2/access_token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n\n    const { access_token, refresh_token } = tokenResponse.data\n    console.log('Accesos', tokenResponse.data)\n\n    const { userId, userName } = await getUserInfo(access_token)\n    console.log('userId, userName', userId, userName)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/bitbucket/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\nbitbucketApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('BITBUCKET_KEY')\n    const clientSecret = getEnv('BITBUCKET_SECRET')\n\n    const connection = await sql`\n        SELECT * FROM bitbucket_connections\n        WHERE id = ${id ?? ''}\n      `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const _username = connection[0].name\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    // Obtén los espacios de trabajo del usuario\n    let workspacesResponse\n    try {\n      workspacesResponse = await axios.get(\n        'https://api.bitbucket.org/2.0/workspaces',\n        { headers },\n      )\n    } catch (error) {\n      if (error.response && error.response.status === 401) {\n        // El token de acceso está vencido, intentar renovarlo\n        const tokens = await refreshAccessToken(\n          refreshToken,\n          clientId,\n          clientSecret,\n        )\n        if (tokens) {\n          const { newAccessToken, newRefreshToken } = tokens\n          // Actualizar el token de acceso en la base de datos\n          await sql`\n            UPDATE bitbucket_connections\n            SET access_token = ${newAccessToken},\n                refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n            WHERE id = ${id ?? ''} \n          `\n\n          accessToken = newAccessToken\n          headers.Authorization = `Bearer ${accessToken}`\n\n          // Intentar la solicitud nuevamente con el token actualizado\n          workspacesResponse = await axios.get(\n            'https://api.bitbucket.org/2.0/workspaces',\n            { headers },\n          )\n        } else {\n          // El token de reinicio también está vencido\n          console.log('El token de reinicio está vencido')\n          return c.text('El token de reinicio está vencido', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    let allRepos: any = []\n\n    // Para cada espacio de trabajo, obtén los repositorios\n    for (const workspace of workspacesResponse.data.values) {\n      const url = `https://api.bitbucket.org/2.0/repositories/${workspace.slug}`\n      const reposResponse = await axios.get(url, { headers })\n\n      const repos = reposResponse.data.values.map(async (repo: any) => {\n        const branchesUrl = `${repo.links.branches.href}?query=default`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n        const branches = branchesResponse.data.values.map((branch: any) => ({\n          name: branch.name,\n          sha: branch.target.hash,\n        }))\n\n        return {\n          id: repo.uuid,\n          name: repo.name,\n          workspace: repo.workspace.name,\n          is_private: repo.is_private,\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n      allRepos = allRepos.concat(reposWithBranches)\n    }\n\n    return new Response(JSON.stringify(allRepos), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\n// bitbucketApp.get('/verify-user', async (c) => {\n//   try {\n//     const accessToken = null\n\n//     const headers = {\n//       'Authorization': `Bearer ${accessToken}`,\n//       'Accept': 'application/json',\n//     }\n\n//     const response = await axios.get('https://api.bitbucket.org/2.0/user', {\n//       headers,\n//     })\n\n//     if (response.status === 200) {\n//       const userData = response.data\n//       return c.json({\n//         displayName: userData.display_name,\n//         username: userData.username,\n//         accountId: userData.uuid,\n//       })\n//     } else {\n//       return c.json({\n//         error:\n//           `Error al obtener información del usuario: ${response.status} - ${response.statusText}`,\n//       }, 400)\n//     }\n//   } catch (error) {\n//     console.error('Error al verificar el usuario:', error)\n//     return c.json({ error: 'Error al verificar el usuario' }, 500)\n//   }\n// })\n\nbitbucketApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla bitbucket_connections\n    const result = await sql`\n      DELETE FROM bitbucket_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nexport { bitbucketApp }",
    "originFile": "\\routes\\bitbucket.ts"
  },
  {
    "id": "\\routes\\chat\\autocomplete::autocomplete",
    "language": "typescript",
    "label": "autocomplete",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\autocomplete",
    "totalTokens": 1054,
    "inDegree": 3,
    "outDegree": 9,
    "code": "const autocomplete = new Hono()\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst autocomplete = new Hono()\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { autocomplete }",
    "importStatements": [],
    "codeNoBody": "const autocomplete = new Hono()\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst autocomplete = new Hono()\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { autocomplete }",
    "originFile": "\\routes\\chat\\autocomplete.ts"
  },
  {
    "id": "\\routes\\chat\\autocomplete",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\autocomplete.ts",
    "type": "file",
    "totalTokens": 672,
    "inDegree": 0,
    "outDegree": 10,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { channels } from '@/lib/consts.ts'\n// import { openAIAutocomplete } from '@/routes/chat/lib/openai.ts'\nimport { codestralAutocomplete } from '@/routes/chat/lib/codestral.ts'\nimport { autocompleteSchema } from '@/schemas/chat.ts'\nimport { Channels } from '@/types/index.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\n\nconst autocomplete = new Hono()\n\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { autocomplete }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import { channels } from '@/lib/consts.ts'",
      "import { codestralAutocomplete } from '@/routes/chat/lib/codestral.ts'",
      "import { autocompleteSchema } from '@/schemas/chat.ts'",
      "import { Channels } from '@/types/index.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getFreePlan } from '@/services/supabase/plan.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { channels } from '@/lib/consts.ts'\n// import { openAIAutocomplete } from '@/routes/chat/lib/openai.ts'\nimport { codestralAutocomplete } from '@/routes/chat/lib/codestral.ts'\nimport { autocompleteSchema } from '@/schemas/chat.ts'\nimport { Channels } from '@/types/index.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nconst autocomplete = new Hono()\n\nautocomplete.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await autocompleteSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    prompt,\n    maxTokens,\n    suffix,\n    temperature,\n    stop,\n  } = parsed.data\n\n  let userId = cUserId\n  const channel = c.req.header('channel') as unknown as Channels ?? 'VSCODE'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const [res, freePlan] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`,\n      getFreePlan(),\n    ])\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const ip = getIp(c)\n    if (!ip) {\n      throw new Error('Something went wrong')\n    }\n\n    const {\n      user_org_id,\n      plan_name,\n      plan_user_id,\n      user_email,\n      distinct_id,\n      id: planId,\n    } = res[0]\n\n    if (plan_name === freePlan?.name) {\n      return c.json(\n        { message: 'User must be premium to use this feature' },\n        403,\n      )\n    }\n\n    const metadata = {\n      userId: plan_user_id,\n      orgId: user_org_id,\n      planName: plan_name,\n      channel,\n      email: user_email,\n      ip,\n      distinctId: distinct_id,\n      planId,\n    } as const\n\n    const autocomplete = await codestralAutocomplete({\n      prompt,\n      maxTokens,\n      temperature,\n      suffix,\n      stop,\n      metadata,\n      extensionVersion,\n    })\n\n    return c.json({ ...autocomplete })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { autocomplete }",
    "originFile": "\\routes\\chat\\autocomplete.ts"
  },
  {
    "id": "\\routes\\chat\\completion::onFinal",
    "language": "typescript",
    "label": "onFinal",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\completion",
    "totalTokens": 37,
    "inDegree": 3,
    "outDegree": 1,
    "code": "const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }",
    "importStatements": [],
    "codeNoBody": "const onFinal = async () => {\n    //...\n    }",
    "originFile": "\\routes\\chat\\completion.ts"
  },
  {
    "id": "\\routes\\chat\\completion::chatCompletion",
    "language": "typescript",
    "label": "chatCompletion",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\completion",
    "totalTokens": 1735,
    "inDegree": 3,
    "outDegree": 9,
    "code": "const chatCompletion = new Hono()\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst chatCompletion = new Hono()\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { chatCompletion }",
    "importStatements": [],
    "codeNoBody": "const chatCompletion = new Hono()\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst chatCompletion = new Hono()\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { chatCompletion }",
    "originFile": "\\routes\\chat\\completion.ts"
  },
  {
    "id": "\\routes\\chat\\completion",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\completion.ts",
    "type": "file",
    "totalTokens": 995,
    "inDegree": 0,
    "outDegree": 10,
    "code": "import { Hono } from 'hono'\nimport { noAgentCompletionValidationSchema } from '@/schemas/chat.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport {\n  channels,\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { openAICompletion } from '@/routes/chat/lib/openai.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\n\nconst chatCompletion = new Hono()\n\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n      if (!hasUnlimitedInteractions) {\n        await updateOrganizationsInteractions(\n          user_org_id,\n        )\n      }\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { chatCompletion }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { noAgentCompletionValidationSchema } from '@/schemas/chat.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import {\n  channels,\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'",
      "import { openAICompletion } from '@/routes/chat/lib/openai.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { noAgentCompletionValidationSchema } from '@/schemas/chat.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport {\n  channels,\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { openAICompletion } from '@/routes/chat/lib/openai.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nconst chatCompletion = new Hono()\n\nchatCompletion.post('/', async (c) => {\n  const { userId: cUserId, apiKey: cApiKey, orgId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await noAgentCompletionValidationSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages: incommingMessages,\n    model,\n    max_tokens,\n    stream,\n    format = 'text',\n    functions,\n    function_call,\n  } = parsed.data\n\n  const messages = incommingMessages.slice(-10)\n\n  let userId = cUserId\n  const channel = c.req.header('channel') ?? userId ? 'VSCODE' : 'WHATSAPP'\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  if (\n    (typeof channel !== 'string' || !channels.includes(channel))\n  ) {\n    return c.json({ message: 'Invalid channel' }, 400)\n  }\n\n  try {\n    const res =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${cApiKey}, ${userId})`\n\n    if (!res || !res[0]) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!userId) {\n      userId = res[0]?.plan_user_id\n    }\n\n    const {\n      user_org_id,\n      daily_max_usage,\n      daily_usage,\n      plan_name,\n      plan_user_id,\n      vision,\n      user_email,\n      distinct_id,\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions: dailyInteractions,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = res[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && dailyInteractions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const limits = {\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      vision,\n    }\n\n    const metadata = {\n      userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      planName: 'Plan Enterprise',\n      planId: '64f257043a7d65c1e6ea1a86',\n      email: 'dev@judini.ai',\n      userType: 'subscribed',\n      consumerOrgId: user_org_id,\n      consumerPlanName: plan_name,\n      channel,\n      consumerEmail: user_email,\n      consumerDistinctId: distinct_id,\n      consumerPlanId: planId,\n      consumerUserType: planId === freePlanId ? 'free' : 'subscribed',\n      consumerUserId: plan_user_id,\n    } as const\n\n    const onFinal = async () => {\n    //...\n    }\n\n    return await openAICompletion({\n      c,\n      messages,\n      model,\n      format,\n      limits,\n      stream,\n      max_tokens,\n      metadata,\n      functions,\n      extensionVersion,\n      onFinal,\n      function_call,\n    })\n  } catch (error) {\n    console.error(error)\n    if (userId) {\n      reportError(error, userId)\n    }\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { chatCompletion }",
    "originFile": "\\routes\\chat\\completion.ts"
  },
  {
    "id": "\\routes\\chat\\extension::chatExtension",
    "language": "typescript",
    "label": "chatExtension",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\extension",
    "totalTokens": 1471,
    "inDegree": 3,
    "outDegree": 11,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      agentId,\n      messages,\n      stream = true,\n      format = 'text',\n      statusId,\n      functions,\n      function_call,\n    } = parsed.data\n\n    const tokens = Boolean(c.req.header('tokens'))\n    const channel = c.req.header('channel') ?? 'vscode'\n    const extensionVersion = c.req.header('codegpt-version') ?? null\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: result[0].user_email,\n      source: 'vscode',\n      tokens,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = []\n\n    if (tokens) {\n      body.push({\n        event: 'Chat',\n        properties,\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: [`${channel.toLowerCase()} agent`, 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: channel.toUpperCase(),\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    console.log(\n      'Total time',\n      (Date.now() - totalTime) / 1000,\n      'seconds before stream text to user',\n    )\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatExtension }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      agentId,\n      messages,\n      stream = true,\n      format = 'text',\n      statusId,\n      functions,\n      function_call,\n    } = parsed.data\n\n    const tokens = Boolean(c.req.header('tokens'))\n    const channel = c.req.header('channel') ?? 'vscode'\n    const extensionVersion = c.req.header('codegpt-version') ?? null\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: result[0].user_email,\n      source: 'vscode',\n      tokens,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = []\n\n    if (tokens) {\n      body.push({\n        event: 'Chat',\n        properties,\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: [`${channel.toLowerCase()} agent`, 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: channel.toUpperCase(),\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    console.log(\n      'Total time',\n      (Date.now() - totalTime) / 1000,\n      'seconds before stream text to user',\n    )\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatExtension }",
    "originFile": "\\routes\\chat\\extension.ts"
  },
  {
    "id": "\\routes\\chat\\extension",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\extension.ts",
    "type": "file",
    "totalTokens": 1650,
    "inDegree": 0,
    "outDegree": 12,
    "code": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\n\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      agentId,\n      messages,\n      stream = true,\n      format = 'text',\n      statusId,\n      functions,\n      function_call,\n    } = parsed.data\n\n    const tokens = Boolean(c.req.header('tokens'))\n    const channel = c.req.header('channel') ?? 'vscode'\n    const extensionVersion = c.req.header('codegpt-version') ?? null\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: result[0].user_email,\n      source: 'vscode',\n      tokens,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = []\n\n    if (tokens) {\n      body.push({\n        event: 'Chat',\n        properties,\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: [`${channel.toLowerCase()} agent`, 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: channel.toUpperCase(),\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    console.log(\n      'Total time',\n      (Date.now() - totalTime) / 1000,\n      'seconds before stream text to user',\n    )\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatExtension }\n",
    "importStatements": [
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { messageCreateSchema } from '@/schemas/chat.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getUserAgentById } from '@/services/supabase/agents.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      agentId,\n      messages,\n      stream = true,\n      format = 'text',\n      statusId,\n      functions,\n      function_call,\n    } = parsed.data\n\n    const tokens = Boolean(c.req.header('tokens'))\n    const channel = c.req.header('channel') ?? 'vscode'\n    const extensionVersion = c.req.header('codegpt-version') ?? null\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentId),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentId,\n      plan: plan_name,\n      email: result[0].user_email,\n      source: 'vscode',\n      tokens,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = []\n\n    if (tokens) {\n      body.push({\n        event: 'Chat',\n        properties,\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name: plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: [`${channel.toLowerCase()} agent`, 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: channel.toUpperCase(),\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n    console.log(\n      'Total time',\n      (Date.now() - totalTime) / 1000,\n      'seconds before stream text to user',\n    )\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatExtension }",
    "originFile": "\\routes\\chat\\extension.ts"
  },
  {
    "id": "\\routes\\chat\\freeplan::onFinal",
    "language": "typescript",
    "label": "onFinal",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\freeplan",
    "totalTokens": 136,
    "inDegree": 3,
    "outDegree": 1,
    "code": "const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }",
    "importStatements": [],
    "codeNoBody": "const onFinal = async () => {\n    //...\n    }",
    "originFile": "\\routes\\chat\\freeplan.ts"
  },
  {
    "id": "\\routes\\chat\\freeplan::AgentModel",
    "language": "typescript",
    "label": "AgentModel",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\freeplan",
    "totalTokens": 62,
    "inDegree": 4,
    "outDegree": 1,
    "code": "type AgentModel =\n  | 'gpt-3.5-turbo'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-4'\n  | 'gpt-4-vision'\n  | 'gpt-4-turbo'",
    "importStatements": [],
    "codeNoBody": "type AgentModel =\n  | 'gpt-3.5-turbo'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-4'\n  | 'gpt-4-vision'\n  | 'gpt-4-turbo'",
    "originFile": "\\routes\\chat\\freeplan.ts"
  },
  {
    "id": "\\routes\\chat\\freeplan::freePlanCompletion",
    "language": "typescript",
    "label": "freePlanCompletion",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\freeplan",
    "totalTokens": 3978,
    "inDegree": 3,
    "outDegree": 15,
    "code": "const freePlanCompletion = new Hono()\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nconst freePlanCompletion = new Hono()\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nexport { freePlanCompletion }",
    "importStatements": [],
    "codeNoBody": "const freePlanCompletion = new Hono()\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nconst freePlanCompletion = new Hono()\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nexport { freePlanCompletion }",
    "originFile": "\\routes\\chat\\freeplan.ts"
  },
  {
    "id": "\\routes\\chat\\freeplan",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\freeplan.ts",
    "type": "file",
    "totalTokens": 2269,
    "inDegree": 0,
    "outDegree": 18,
    "code": "import { Hono } from 'hono'\nimport { noSessionChatSchema } from '@/schemas/chat.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { openAICompletion } from '@/routes/chat/lib/openai.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { getMarketplaceAgentAsAnonymous } from '@/services/supabase/agents.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { channels } from '@/lib/consts.ts'\n\ntype AgentModel =\n  | 'gpt-3.5-turbo'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-4'\n  | 'gpt-4-vision'\n  | 'gpt-4-turbo'\n\nconst freePlanCompletion = new Hono()\n\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n      if (ip && freePlan?.status) {\n        await redis.set(redisKey, completionCount + 1)\n\n        const ttl = await redis.ttl(redisKey)\n        if (ttl !== -1) {\n          return\n        }\n\n        // Calculate the next 0hs UTC in Unix timestamp format\n        const now = new Date()\n        const nextMidnightUtc = Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + 1,\n        ) / 1000\n\n        await redis.expireat(redisKey, nextMidnightUtc)\n      }\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nexport { freePlanCompletion }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { noSessionChatSchema } from '@/schemas/chat.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import { getFreePlan } from '@/services/supabase/plan.ts'",
      "import { redis } from '@/lib/redis.ts'",
      "import { openAICompletion } from '@/routes/chat/lib/openai.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { getMarketplaceAgentAsAnonymous } from '@/services/supabase/agents.ts'",
      "import { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { freePlanId } from '@/lib/consts.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'",
      "import { channels } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { noSessionChatSchema } from '@/schemas/chat.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { openAICompletion } from '@/routes/chat/lib/openai.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { getMarketplaceAgentAsAnonymous } from '@/services/supabase/agents.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { channels } from '@/lib/consts.ts'\ntype AgentModel =\n  | 'gpt-3.5-turbo'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-4'\n  | 'gpt-4-vision'\n  | 'gpt-4-turbo'\n\nconst freePlanCompletion = new Hono()\n\nfreePlanCompletion.post('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  const json = await c.req.json()\n\n  const parsed = await noSessionChatSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const {\n    messages,\n    stream = true,\n    format = 'text',\n    agentId,\n    functions,\n    function_call,\n  } = parsed.data\n\n  const userId = c.req.header('distinct-id') ?? ''\n  const channel =\n    (c.req.header('channel') ?? 'VSCODE') as typeof channels[number]\n\n  const freePlanIsNotActive = !freePlan || !freePlan?.status\n  if (freePlanIsNotActive) {\n    return c.json(\n      { message: 'Free Plan is no longer active' },\n      { status: 410 },\n    )\n  }\n\n  const extensionVersion = c.req.header('codegpt-version') ?? null\n\n  try {\n    const ip = getIp(c)\n    if (!ip) {\n      return c.json(\n        { message: 'There was an error creating the completion' },\n        { status: 500 },\n      )\n    }\n\n    const redisKey = `freeChat-${ip}`\n    const freePlanCompletions = await redis.get(redisKey)\n    const completionCount = freePlanCompletions\n      ? Number(freePlanCompletions)\n      : 0\n    const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n\n    if (\n      !freePlanIsNotActive &&\n      completionCount >= completionLimit\n    ) {\n      return c.json({\n        message: 'Daily completion limit reached',\n      }, { status: 429 })\n    }\n\n    const onFinal = async () => {\n    //...\n    }\n\n    if (!agentId) {\n      const model: AgentModel = 'gpt-3.5-turbo'\n\n      const max_tokens = 500\n      const metadata = {\n        userId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        orgId: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n        distinctId: '664ea16c-f918-4d48-900c-fa728c992b4f',\n        planName: 'Plan Enterprise',\n        planId: '64f257043a7d65c1e6ea1a86',\n        extensionVersion,\n        userType: 'subscribed',\n        email: 'dev@judini.ai',\n        consumerDistinctId: userId,\n        consumerPlanName: freePlan?.name,\n        consumerUserType: 'free',\n        consumerPlanId: freePlan?.id,\n        channel,\n      }\n\n      const limits = {\n        dailyMaxUsage: -1,\n        dailyUsage: 0,\n      }\n\n      return await openAICompletion({\n        c,\n        messages,\n        model,\n        format,\n        limits,\n        stream,\n        max_tokens,\n        metadata,\n        onFinal,\n        functions,\n        function_call,\n        extensionVersion,\n      })\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getMarketplaceAgentAsAnonymous({ id: agentId })\n\n    if (!agent) {\n      return c.json({\n        message: `Marketplace agent with ID ${agentId} not found`,\n      }, 404)\n    }\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(\n        agent.org_id,\n      ),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    if (!ownerInfo) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    const { distinct_id, email, id, name } = ownerInfo\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n    })\n\n    const properties: Record<string, string | boolean | undefined | null> = {\n      distinct_id: userId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: freePlan.name,\n      source: 'API',\n      channel,\n      email: null,\n    }\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: agent.org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: userId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: 'free',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: userId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: agent.org_id,\n          user_type: 'free',\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'vscode',\n          version: extensionVersion,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'VSCODE',\n      planName: subscription.plan.name,\n      orgId: agent.org_id,\n      body,\n      dailyMaxUsage: -1,\n      dailyUsage: 0,\n      stream: stream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      functions,\n      function_call,\n    })\n\n    await onFinal()\n\n    return response\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nfreePlanCompletion.get('/', async (c) => {\n  const freePlan = await getFreePlan()\n\n  if (freePlan && !freePlan?.status) {\n    return c.json({ 'Free Plan': 'Not active' }, { status: 410 })\n  }\n\n  return c.json({ 'Free Plan': 'Active' })\n})\n\nexport { freePlanCompletion }",
    "originFile": "\\routes\\chat\\freeplan.ts"
  },
  {
    "id": "\\routes\\chat\\index::chat",
    "language": "typescript",
    "label": "chat",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\index",
    "totalTokens": 3334,
    "inDegree": 3,
    "outDegree": 12,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nconst chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nconst chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat }",
    "originFile": "\\routes\\chat\\index.ts"
  },
  {
    "id": "\\routes\\chat\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\index.ts",
    "type": "file",
    "totalTokens": 1864,
    "inDegree": 0,
    "outDegree": 13,
    "code": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\n\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { PLAN_TEMP_USAGE_DATE, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { channels } from '@/lib/consts.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { freePlanId } from '@/lib/consts.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat }\n",
    "importStatements": [
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { messageCreateSchema } from '@/schemas/chat.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getUserAgentById } from '@/services/supabase/agents.ts'",
      "import { PLAN_TEMP_USAGE_DATE, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { channels } from '@/lib/consts.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { freePlanId } from '@/lib/consts.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { PLAN_TEMP_USAGE_DATE, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { channels } from '@/lib/consts.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { freePlanId } from '@/lib/consts.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      channel = 'API',\n      statusId,\n    } = parsed.data\n\n    const source = c.req.header('X-CodeGPT-Source') ?? 'API'\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      const noOrgHeaderMessage = !orgId\n        ? ' You should always specify the organization ID in the CodeGPT-Org-Id header.'\n        : ''\n      return c.json({\n        message: `Agent with ID ${agentId} not found in organization with ID: ${\n          result[0].user_org_id\n        }.${noOrgHeaderMessage}`,\n      }, 404)\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    if (\n      channel && (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const plan = result[0]\n    const userOrgID = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions &&\n      daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({ message: 'Daily interactions limit reached' }, 403)\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: userOrgID,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: getIp(c),\n      agent_id: agentID,\n      plan: name,\n      userPlan: plan_name,\n      email: userEmail,\n      channel,\n      source: 'API',\n    }\n\n    const body = [\n      {\n        event: 'completion',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'api'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: plan_name,\n      orgId: userOrgID,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: userOrgID,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgID,\n      )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max usage reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'Invalid credentials') {\n      return c.json({\n        error: 'invalidCredentials',\n        description: 'Your API key or access token is invalid.',\n      })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat }",
    "originFile": "\\routes\\chat\\index.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\codestral::codestralAutocomplete",
    "language": "typescript",
    "label": "codestralAutocomplete",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\codestral",
    "totalTokens": 830,
    "inDegree": 3,
    "outDegree": 5,
    "code": "async function codestralAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n  const model = 'codestral'\n\n  const codestralResponse = await createMistralFIMResponse({\n    model,\n    prompt,\n    suffix,\n    maxTokens,\n    temperature,\n    stop,\n  })\n\n  const { response } = codestralResponse\n\n  if (!response) {\n    return {\n      choices: [{ text: '', finish_reason: null }],\n    }\n  }\n\n  const { channel, email, ip, planName, distinctId, planId } = metadata\n  const body = [{\n    event: 'Autocomplete',\n    properties: {\n      distinct_id: distinctId,\n      model,\n      channel,\n      plan: planName,\n      prompt_tokens: response.usage?.prompt_tokens ?? 0,\n      completion_tokens: response.usage?.completion_tokens ?? 0,\n      ip,\n      email,\n    },\n  }, {\n    event: 'completion2',\n    properties: {\n      distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      ip,\n      email: 'dev@judini.ai',\n      organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: 'subscribed',\n      plan_id: '64f257043a7d65c1e6ea1a86',\n      plan_name: 'Plan Enterprise',\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      model,\n      agent_model: null,\n      consumer_distinct_id: distinctId,\n      consumer_email: email,\n      consumer_plan_id: planId,\n      consumer_plan_name: planName,\n      consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: response.usage?.prompt_tokens ?? 0,\n      tokens_completion: response.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (response.usage?.prompt_tokens ??\n        0) + (response.usage?.completion_tokens ?? 0),\n    },\n  }, {\n    event: 'completion2consumer',\n    properties: {\n      distinct_id: distinctId,\n      ip,\n      email,\n      owner_organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: planId === freePlanId ? 'free' : 'subscribed',\n      plan_id: planId,\n      plan_name: planName,\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      model,\n      agent_model: null,\n      owner_distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      owner_email: 'dev@judini.ai',\n      owner_plan_id: '64f257043a7d65c1e6ea1a86',\n      owner_plan_name: 'Plan Enterprise',\n      owner_user_type: 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: response.usage?.prompt_tokens ?? 0,\n      tokens_completion: response.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (response.usage?.prompt_tokens ??\n        0) + (response.usage?.completion_tokens ?? 0),\n    },\n  }]\n\n  await mixpanel({ body, source: 'API' })\n  return {\n    choices: response.choices.map((choice) => {\n      return {\n        text: choice.message.content,\n        finish_reason: choice.finish_reason,\n      }\n    }),\n    usage: response.usage,\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function codestralAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n       //...\n       }",
    "originFile": "\\routes\\chat\\lib\\codestral.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\codestral::AutocompleteParams",
    "language": "typescript",
    "label": "AutocompleteParams",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\codestral",
    "totalTokens": 87,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface AutocompleteParams {\n  prompt: string\n  maxTokens: number\n  temperature: number\n  stop?: string[] | string\n  suffix?: string\n  metadata: {\n    channel: Channels\n    userId: string\n    planName: string\n    email: string\n    ip: string\n    distinctId: string\n    planId: string\n  }\n  extensionVersion: string | null\n}",
    "importStatements": [],
    "codeNoBody": "interface AutocompleteParams {\n//...\n}",
    "originFile": "\\routes\\chat\\lib\\codestral.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\codestral",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\codestral.ts",
    "type": "file",
    "totalTokens": 990,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { freePlanId } from '@/lib/consts.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Channels } from '@/types/index.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { createMistralFIMResponse } from '@/services/ai/mistral/autocomplete.ts'\n\ninterface AutocompleteParams {\n  prompt: string\n  maxTokens: number\n  temperature: number\n  stop?: string[] | string\n  suffix?: string\n  metadata: {\n    channel: Channels\n    userId: string\n    planName: string\n    email: string\n    ip: string\n    distinctId: string\n    planId: string\n  }\n  extensionVersion: string | null\n}\n\nexport async function codestralAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n  const model = 'codestral'\n\n  const codestralResponse = await createMistralFIMResponse({\n    model,\n    prompt,\n    suffix,\n    maxTokens,\n    temperature,\n    stop,\n  })\n\n  const { response } = codestralResponse\n\n  if (!response) {\n    return {\n      choices: [{ text: '', finish_reason: null }],\n    }\n  }\n\n  const { channel, email, ip, planName, distinctId, planId } = metadata\n  const body = [{\n    event: 'Autocomplete',\n    properties: {\n      distinct_id: distinctId,\n      model,\n      channel,\n      plan: planName,\n      prompt_tokens: response.usage?.prompt_tokens ?? 0,\n      completion_tokens: response.usage?.completion_tokens ?? 0,\n      ip,\n      email,\n    },\n  }, {\n    event: 'completion2',\n    properties: {\n      distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      ip,\n      email: 'dev@judini.ai',\n      organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: 'subscribed',\n      plan_id: '64f257043a7d65c1e6ea1a86',\n      plan_name: 'Plan Enterprise',\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      model,\n      agent_model: null,\n      consumer_distinct_id: distinctId,\n      consumer_email: email,\n      consumer_plan_id: planId,\n      consumer_plan_name: planName,\n      consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: response.usage?.prompt_tokens ?? 0,\n      tokens_completion: response.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (response.usage?.prompt_tokens ??\n        0) + (response.usage?.completion_tokens ?? 0),\n    },\n  }, {\n    event: 'completion2consumer',\n    properties: {\n      distinct_id: distinctId,\n      ip,\n      email,\n      owner_organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: planId === freePlanId ? 'free' : 'subscribed',\n      plan_id: planId,\n      plan_name: planName,\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      model,\n      agent_model: null,\n      owner_distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      owner_email: 'dev@judini.ai',\n      owner_plan_id: '64f257043a7d65c1e6ea1a86',\n      owner_plan_name: 'Plan Enterprise',\n      owner_user_type: 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: response.usage?.prompt_tokens ?? 0,\n      tokens_completion: response.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (response.usage?.prompt_tokens ??\n        0) + (response.usage?.completion_tokens ?? 0),\n    },\n  }]\n\n  await mixpanel({ body, source: 'API' })\n  return {\n    choices: response.choices.map((choice) => {\n      return {\n        text: choice.message.content,\n        finish_reason: choice.finish_reason,\n      }\n    }),\n    usage: response.usage,\n  }\n}\n",
    "importStatements": [
      "import { freePlanId } from '@/lib/consts.ts'",
      "import { mixpanel } from '@/lib/mixpanel.ts'",
      "import { Channels } from '@/types/index.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'",
      "import { createMistralFIMResponse } from '@/services/ai/mistral/autocomplete.ts'"
    ],
    "codeNoBody": "import { freePlanId } from '@/lib/consts.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Channels } from '@/types/index.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { createMistralFIMResponse } from '@/services/ai/mistral/autocomplete.ts'\ninterface AutocompleteParams {\n//...\n}\n\nexport async function codestralAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n       //...\n       }",
    "originFile": "\\routes\\chat\\lib\\codestral.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::openAIAutocomplete",
    "language": "typescript",
    "label": "openAIAutocomplete",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 999,
    "inDegree": 1,
    "outDegree": 8,
    "code": "async function openAIAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n  const apiKey = getEnv(\n    APIKEY_MAP['DEFAULT'],\n  )\n\n  const model = 'gpt-3.5-turbo-instruct'\n  const azureModel = MODEL_MAP[model]\n\n  const azureUrl = new URL(getEnv('AZURE_INSTRUCT'))\n\n  const pathname = azureUrl.pathname.split('/').slice(0, 3).join('/')\n  const baseURL = `${azureUrl.origin}${pathname}/${azureModel}`\n\n  const openai = new OpenAI({\n    apiKey,\n    baseURL,\n    defaultQuery: { 'api-version': '2023-09-15-preview' },\n    defaultHeaders: {\n      'api-key': apiKey,\n    },\n  })\n\n  const json = await openai.completions.create(\n    {\n      prompt,\n      model,\n      max_tokens: maxTokens,\n      temperature,\n      stop,\n      ...(suffix ? { suffix } : {}),\n    },\n  )\n\n  const {\n    channel,\n    email,\n    ip,\n    planName,\n    distinctId,\n    planId,\n    orgId,\n  } = metadata\n  const body = [{\n    event: 'Autocomplete',\n    properties: {\n      distinct_id: distinctId,\n      model,\n      channel,\n      plan: planName,\n      prompt_tokens: json.usage?.prompt_tokens ?? 0,\n      completion_tokens: json.usage?.completion_tokens ?? 0,\n      ip,\n      email,\n    },\n  }, {\n    event: 'completion2',\n    properties: {\n      distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      ip,\n      email: 'dev@judini.ai',\n      organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: 'subscribed',\n      plan_id: '64f257043a7d65c1e6ea1a86',\n      plan_name: 'Plan Enterprise',\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      agent_model: null,\n      model,\n      consumer_distinct_id: distinctId,\n      consumer_email: email,\n      consumer_plan_id: planId,\n      consumer_plan_name: planName,\n      consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: json.usage?.prompt_tokens ?? 0,\n      tokens_completion: json.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (json.usage?.prompt_tokens ??\n        0) + (json.usage?.completion_tokens ?? 0),\n    },\n  }, {\n    event: 'completion2consumer',\n    properties: {\n      distinct_id: distinctId,\n      ip,\n      email,\n      owner_organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: planId === freePlanId ? 'free' : 'subscribed',\n      plan_id: planId,\n      plan_name: planName,\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      agent_model: null,\n      model,\n      owner_distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      owner_email: 'dev@judini.ai',\n      owner_plan_id: '64f257043a7d65c1e6ea1a86',\n      owner_plan_name: 'Plan Enterprise',\n      owner_user_type: 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: json.usage?.prompt_tokens ?? 0,\n      tokens_completion: json.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (json.usage?.prompt_tokens ??\n        0) + (json.usage?.completion_tokens ?? 0),\n    },\n  }]\n\n  await Promise.all([\n    mixpanel({ body, source: 'API' }),\n    sql`\n      SELECT insert_orgs_usage(\n        ${orgId}, \n        ${json.usage?.prompt_tokens ?? 0}, \n        ${json.usage?.completion_tokens ?? 0},\n        ${model}\n      )\n    `,\n  ])\n  return {\n    choices: json.choices.map((choice) => {\n      return {\n        text: choice.text,\n        finish_reason: choice.finish_reason,\n      }\n    }),\n    usage: json.usage,\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function openAIAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n       //...\n       }",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::AutocompleteParams",
    "language": "typescript",
    "label": "AutocompleteParams",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 93,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface AutocompleteParams {\n  prompt: string\n  maxTokens: number\n  temperature: number\n  stop?: string[] | string\n  suffix?: string\n  metadata: {\n    channel: Channels\n    userId: string\n    planName: string\n    email: string\n    ip: string\n    distinctId: string\n    planId: string\n    orgId: string\n  }\n  extensionVersion: string | null\n}",
    "importStatements": [],
    "codeNoBody": "interface AutocompleteParams {\n//...\n}",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::calculateImageTokenCost",
    "language": "typescript",
    "label": "calculateImageTokenCost",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 287,
    "inDegree": 2,
    "outDegree": 0,
    "code": "function calculateImageTokenCost(\n  height: number,\n  width: number,\n  detail: 'low' | 'high',\n) {\n  let prompt_token = 85 // Base cost for all images\n\n  if (detail === 'low') {\n    // For low detail, cost is a fixed 85 tokens\n    return prompt_token\n  }\n\n  if (detail === 'high') {\n    // Scale down image if necessary\n    if (height > 2048 || width > 2048) {\n      const ratio = height / width\n      if (height > width) {\n        height = 2048\n        width = Math.floor(height / ratio)\n      } else {\n        width = 2048\n        height = Math.floor(width * ratio)\n      }\n    }\n\n    // Scale down to 768px on the shortest side\n    if (height < width) {\n      const ratio = height / width\n      height = 768\n      width = Math.floor(height / ratio)\n    } else {\n      const ratio = width / height\n      width = 768\n      height = Math.floor(width / ratio)\n    }\n\n    // Calculate the number of 512px tiles\n    const tiles = Math.ceil(height / 512) * Math.ceil(width / 512)\n\n    // Update token cost\n    prompt_token += tiles * 170\n  }\n\n  return prompt_token\n}",
    "importStatements": [],
    "codeNoBody": "function calculateImageTokenCost(\n  height: number,\n  width: number,\n  detail: 'low' | 'high',\n) {\n//...\n}",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::onFinal",
    "language": "typescript",
    "label": "onFinal",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai::openAICompletion",
    "totalTokens": 656,
    "inDegree": 3,
    "outDegree": 7,
    "code": "async onFinal() {\n      const channel = channelM ?? 'VSCODE'\n      const usage: UsageInsert[] = [{\n        type: 'CHAT',\n        channel,\n        source: 'API',\n        model,\n        plan_name: consumerUserId ? consumerPlanName as string : planName,\n        user_id: consumerUserId ?? userId,\n        org_id: consumerOrgId ?? orgId,\n        prompt_token: prompt_tokens,\n        completion_token: completion_tokens,\n      }]\n\n      const body = [{\n        event: 'completion',\n        properties: {\n          distinct_id: consumerDistinctId,\n          model,\n          channel,\n          userPlan: consumerPlanName,\n          plan: planName,\n          prompt_tokens,\n          completion_tokens,\n          ip,\n          email: consumerEmail ?? null,\n        },\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email,\n          organization_id: orgId,\n          user_type: userType,\n          plan_id: planId,\n          plan_name: planName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          consumer_distinct_id: consumerDistinctId,\n          consumer_email: consumerEmail,\n          consumer_plan_id: consumerPlanId,\n          consumer_plan_name: consumerPlanName,\n          consumer_user_type: consumerUserType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: consumerDistinctId,\n          ip: getIp(c),\n          email: consumerEmail ?? null,\n          owner_organization_id: orgId,\n          user_type: consumerUserType,\n          plan_id: consumerPlanId,\n          plan_name: consumerPlanName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          owner_distinct_id: distinctId,\n          owner_email: email,\n          owner_plan_id: planId,\n          owner_plan_name: planName,\n          owner_user_type: userType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }]\n\n      const promises = [\n        mixpanel({ body, source: 'API' }),\n      ]\n\n      if (orgId) {\n        promises.push(\n          saveUsage(usage),\n          addOrgDailyTokens({\n            orgId,\n            inputTokens: prompt_tokens,\n            outputTokens: completion_tokens,\n            model,\n          }),\n        )\n      }\n\n      if (onFinal) {\n        const isOnFinalPromise = onFinal.toString().includes('async')\n        if (isOnFinalPromise) {\n          promises.push((onFinal as () => Promise<void>)())\n        } else {\n          onFinal()\n        }\n      }\n\n      await Promise.all(promises)\n    }",
    "importStatements": [],
    "codeNoBody": "async onFinal() {\n    //...\n    }",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::onToken",
    "language": "typescript",
    "label": "onToken",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai::openAICompletion",
    "totalTokens": 79,
    "inDegree": 2,
    "outDegree": 2,
    "code": "onToken(token) {\n      if (!token) return\n      completion_tokens += 1\n\n      const completionUsage = outputCost * completion_tokens\n\n      if (\n        dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n        normalizeFloat(promptUsage + completionUsage) >=\n          normalizeFloat(dailyMaxUsage * 10000000)\n      ) {\n        controller.abort()\n      }\n    }",
    "importStatements": [],
    "codeNoBody": "onToken(token) {\n    //...\n    }",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::openAICompletion",
    "language": "typescript",
    "label": "openAICompletion",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 1745,
    "inDegree": 5,
    "outDegree": 22,
    "code": "async function openAICompletion(\n  {\n    c,\n    messages,\n    model,\n    limits,\n    max_tokens = 500,\n    format = 'text',\n    stream = true,\n    metadata,\n    functions,\n    extensionVersion,\n    onFinal,\n  }: Params,\n) {\n  const ip = getIp(c)\n  const {\n    userId,\n    channel: channelM,\n    orgId,\n    userType,\n    planName,\n    email,\n    distinctId,\n    planId,\n    consumerDistinctId,\n    consumerEmail,\n    consumerPlanName,\n    consumerOrgId,\n    consumerPlanId,\n    consumerUserType,\n    consumerUserId,\n  } = metadata ??\n    {\n      channel: 'VSCODE',\n      userId: '',\n      orgId: '',\n      planName: 'Free Plan',\n      email: '',\n    }\n  const { dailyMaxUsage, dailyUsage } = limits\n  const controller = new AbortController()\n\n  const isVision = model === 'gpt-4-vision'\n  if (isVision && !limits?.vision) {\n    return c.json({\n      message:\n        `This feature, GPT Vision, isn't available for your current plan. Please upgrade to be able to use it.`,\n    }, { status: 403 })\n  }\n\n  const apiKey = getEnv(\n    APIKEY_MAP[model as keyof typeof APIKEY_MAP] ??\n      APIKEY_MAP['DEFAULT'],\n  )\n  const azureModel = MODEL_MAP[model as keyof typeof MODEL_MAP]\n\n  const azureUrl = new URL(\n    getEnv(\n      AZURE_URL_MAP[model as keyof typeof AZURE_URL_MAP] ??\n        AZURE_URL_MAP['DEFAULT'],\n    ),\n  )\n\n  let prompt_tokens = 0\n  let completion_tokens = 0\n  if (isVision) {\n    for await (const { content } of messages) {\n      if (!content) return\n      if (!Array.isArray(content)) return\n      let text = ''\n      for (const item of content) {\n        if (item.type === 'text') {\n          prompt_tokens += 6\n          text += item.text\n        } else {\n          const { height, width } = await getImageDimensionsFromContent(\n            item.image_url?.url ?? '',\n          )\n\n          prompt_tokens += calculateImageTokenCost(\n            height,\n            width,\n            item.image_url?.detail ?? 'high',\n          )\n\n          prompt_tokens += tokenizer(text, 'gpt-4')\n        }\n      }\n    }\n  } else {\n    const tokenizerModel = ['gpt-4-turbo', 'gpt-4o'].includes(model)\n      ? 'gpt-4'\n      : model as TiktokenModel\n    const contentMessages = messages.map((m) => m.content)\n      .join('')\n    prompt_tokens += tokenizer(\n      contentMessages,\n      tokenizerModel,\n    )\n    prompt_tokens += 6 * messages.length\n  }\n\n  const modelCost = await redis.get<{ input: number; output: number }>(\n    `modelCost-${model}`,\n  )\n\n  const promptUsage = ((modelCost?.input ?? 0) * 10000) * prompt_tokens +\n    dailyUsage * 10000000\n\n  if (\n    dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n    normalizeFloat(promptUsage) > normalizeFloat(dailyMaxUsage * 10000000)\n  ) {\n    return c.json({\n      message: 'Daily max usage reached',\n    }, { status: 403 })\n  }\n\n  const pathname = azureUrl.pathname.split('/').slice(0, 3).join('/')\n  const baseURL = `${azureUrl.origin}${pathname}/${azureModel}`\n\n  const apiVersion =\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].apiVersion\n\n  const openai = new OpenAI({\n    apiKey,\n    baseURL,\n    defaultQuery: { 'api-version': apiVersion },\n    defaultHeaders: {\n      'api-key': apiKey,\n    },\n  })\n\n  const response = await openai.chat.completions.create({\n    model,\n    stream: true,\n    max_tokens: max_tokens || 500,\n    messages: messages as ChatCompletionMessageParam[],\n    functions,\n  }, {\n    // deno-lint-ignore no-explicit-any\n    signal: controller.signal as any,\n  })\n\n  const outputCost = (modelCost?.output ?? 0) * 10000\n\n  const streamResponse = OpenAIStream(response, {\n    onToken(token) {\n      if (!token) return\n      completion_tokens += 1\n\n      const completionUsage = outputCost * completion_tokens\n\n      if (\n        dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n        normalizeFloat(promptUsage + completionUsage) >=\n          normalizeFloat(dailyMaxUsage * 10000000)\n      ) {\n        controller.abort()\n      }\n    },\n    async onFinal() {\n      const channel = channelM ?? 'VSCODE'\n      const usage: UsageInsert[] = [{\n        type: 'CHAT',\n        channel,\n        source: 'API',\n        model,\n        plan_name: consumerUserId ? consumerPlanName as string : planName,\n        user_id: consumerUserId ?? userId,\n        org_id: consumerOrgId ?? orgId,\n        prompt_token: prompt_tokens,\n        completion_token: completion_tokens,\n      }]\n\n      const body = [{\n        event: 'completion',\n        properties: {\n          distinct_id: consumerDistinctId,\n          model,\n          channel,\n          userPlan: consumerPlanName,\n          plan: planName,\n          prompt_tokens,\n          completion_tokens,\n          ip,\n          email: consumerEmail ?? null,\n        },\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email,\n          organization_id: orgId,\n          user_type: userType,\n          plan_id: planId,\n          plan_name: planName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          consumer_distinct_id: consumerDistinctId,\n          consumer_email: consumerEmail,\n          consumer_plan_id: consumerPlanId,\n          consumer_plan_name: consumerPlanName,\n          consumer_user_type: consumerUserType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: consumerDistinctId,\n          ip: getIp(c),\n          email: consumerEmail ?? null,\n          owner_organization_id: orgId,\n          user_type: consumerUserType,\n          plan_id: consumerPlanId,\n          plan_name: consumerPlanName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          owner_distinct_id: distinctId,\n          owner_email: email,\n          owner_plan_id: planId,\n          owner_plan_name: planName,\n          owner_user_type: userType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }]\n\n      const promises = [\n        mixpanel({ body, source: 'API' }),\n      ]\n\n      if (orgId) {\n        promises.push(\n          saveUsage(usage),\n          addOrgDailyTokens({\n            orgId,\n            inputTokens: prompt_tokens,\n            outputTokens: completion_tokens,\n            model,\n          }),\n        )\n      }\n\n      if (onFinal) {\n        const isOnFinalPromise = onFinal.toString().includes('async')\n        if (isOnFinalPromise) {\n          promises.push((onFinal as () => Promise<void>)())\n        } else {\n          onFinal()\n        }\n      }\n\n      await Promise.all(promises)\n    },\n  })\n\n  const isCompletion = true\n\n  const output = await codeGPTResponse(\n    streamResponse,\n    model,\n    stream,\n    format,\n    isCompletion,\n  )\n\n  if (!stream) {\n    if (format === 'text' && typeof output === 'string') {\n      return c.text(output)\n    }\n    return c.json(output)\n  }\n\n  return new StreamingTextResponse(output as ReadableStream)\n}",
    "importStatements": [],
    "codeNoBody": "async function openAICompletion(\n  {\n    c,\n    messages,\n    model,\n    limits,\n    max_tokens = 500,\n    format = 'text',\n    stream = true,\n    metadata,\n    functions,\n    extensionVersion,\n    onFinal,\n  }: Params,\n) {\n  const ip = getIp(c)\n  const {\n    userId,\n    channel: channelM,\n    orgId,\n    userType,\n    planName,\n    email,\n    distinctId,\n    planId,\n    consumerDistinctId,\n    consumerEmail,\n    consumerPlanName,\n    consumerOrgId,\n    consumerPlanId,\n    consumerUserType,\n    consumerUserId,\n  } = metadata ??\n    {\n      channel: 'VSCODE',\n      userId: '',\n      orgId: '',\n      planName: 'Free Plan',\n      email: '',\n    }\n  const { dailyMaxUsage, dailyUsage } = limits\n  const controller = new AbortController()\n  const isVision = model === 'gpt-4-vision'\n  if (isVision && !limits?.vision) {\n    return c.json({\n      message:\n        `This feature, GPT Vision, isn't available for your current plan. Please upgrade to be able to use it.`,\n    }, { status: 403 })\n  }\n\n  const apiKey = getEnv(\n    APIKEY_MAP[model as keyof typeof APIKEY_MAP] ??\n      APIKEY_MAP['DEFAULT'],\n  )\n  const azureModel = MODEL_MAP[model as keyof typeof MODEL_MAP]\n\n  const azureUrl = new URL(\n    getEnv(\n      AZURE_URL_MAP[model as keyof typeof AZURE_URL_MAP] ??\n        AZURE_URL_MAP['DEFAULT'],\n    ),\n  )\n\n  let prompt_tokens = 0\n  let completion_tokens = 0\n  if (isVision) {\n    for await (const { content } of messages) {\n      if (!content) return\n      if (!Array.isArray(content)) return\n      let text = ''\n      for (const item of content) {\n        if (item.type === 'text') {\n          prompt_tokens += 6\n          text += item.text\n        } else {\n          const { height, width } = await getImageDimensionsFromContent(\n            item.image_url?.url ?? '',\n          )\n\n          prompt_tokens += calculateImageTokenCost(\n            height,\n            width,\n            item.image_url?.detail ?? 'high',\n          )\n\n          prompt_tokens += tokenizer(text, 'gpt-4')\n        }\n      }\n    }\n  } else {\n    const tokenizerModel = ['gpt-4-turbo', 'gpt-4o'].includes(model)\n      ? 'gpt-4'\n      : model as TiktokenModel\n    const contentMessages = messages.map((m) => m.content)\n      .join('')\n    prompt_tokens += tokenizer(\n      contentMessages,\n      tokenizerModel,\n    )\n    prompt_tokens += 6 * messages.length\n  }\n\n  const modelCost = await redis.get<{ input: number; output: number }>(\n    `modelCost-${model}`,\n  )\n\n  const promptUsage = ((modelCost?.input ?? 0) * 10000) * prompt_tokens +\n    dailyUsage * 10000000\n\n  if (\n    dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n    normalizeFloat(promptUsage) > normalizeFloat(dailyMaxUsage * 10000000)\n  ) {\n    return c.json({\n      message: 'Daily max usage reached',\n    }, { status: 403 })\n  }\n\n  const pathname = azureUrl.pathname.split('/').slice(0, 3).join('/')\n  const baseURL = `${azureUrl.origin}${pathname}/${azureModel}`\n\n  const apiVersion =\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].apiVersion\n\n  const openai = new OpenAI({\n    apiKey,\n    baseURL,\n    defaultQuery: { 'api-version': apiVersion },\n    defaultHeaders: {\n      'api-key': apiKey,\n    },\n  })\n\n  const response = await openai.chat.completions.create({\n    model,\n    stream: true,\n    max_tokens: max_tokens || 500,\n    messages: messages as ChatCompletionMessageParam[],\n    functions,\n  }, {\n    // deno-lint-ignore no-explicit-any\n    signal: controller.signal as any,\n  })\n\n  const outputCost = (modelCost?.output ?? 0) * 10000\n\n  const streamResponse = OpenAIStream(response, {\n    onToken(token) {\n      if (!token) return\n      completion_tokens += 1\n\n      const completionUsage = outputCost * completion_tokens\n\n      if (\n        dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n        normalizeFloat(promptUsage + completionUsage) >=\n          normalizeFloat(dailyMaxUsage * 10000000)\n      ) {\n        controller.abort()\n      }\n    },\n    async onFinal() {\n      const channel = channelM ?? 'VSCODE'\n      const usage: UsageInsert[] = [{\n        type: 'CHAT',\n        channel,\n        source: 'API',\n        model,\n        plan_name: consumerUserId ? consumerPlanName as string : planName,\n        user_id: consumerUserId ?? userId,\n        org_id: consumerOrgId ?? orgId,\n        prompt_token: prompt_tokens,\n        completion_token: completion_tokens,\n      }]\n\n      const body = [{\n        event: 'completion',\n        properties: {\n          distinct_id: consumerDistinctId,\n          model,\n          channel,\n          userPlan: consumerPlanName,\n          plan: planName,\n          prompt_tokens,\n          completion_tokens,\n          ip,\n          email: consumerEmail ?? null,\n        },\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email,\n          organization_id: orgId,\n          user_type: userType,\n          plan_id: planId,\n          plan_name: planName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          consumer_distinct_id: consumerDistinctId,\n          consumer_email: consumerEmail,\n          consumer_plan_id: consumerPlanId,\n          consumer_plan_name: consumerPlanName,\n          consumer_user_type: consumerUserType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: consumerDistinctId,\n          ip: getIp(c),\n          email: consumerEmail ?? null,\n          owner_organization_id: orgId,\n          user_type: consumerUserType,\n          plan_id: consumerPlanId,\n          plan_name: consumerPlanName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          owner_distinct_id: distinctId,\n          owner_email: email,\n          owner_plan_id: planId,\n          owner_plan_name: planName,\n          owner_user_type: userType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }]\n\n      const promises = [\n        mixpanel({ body, source: 'API' }),\n      ]\n\n      if (orgId) {\n        promises.push(\n          saveUsage(usage),\n          addOrgDailyTokens({\n            orgId,\n            inputTokens: prompt_tokens,\n            outputTokens: completion_tokens,\n            model,\n          }),\n        )\n      }\n\n      if (onFinal) {\n        const isOnFinalPromise = onFinal.toString().includes('async')\n        if (isOnFinalPromise) {\n          promises.push((onFinal as () => Promise<void>)())\n        } else {\n          onFinal()\n        }\n      }\n\n      await Promise.all(promises)\n    },\n  })\n\n  const isCompletion = true\n\n  const output = await codeGPTResponse(\n    streamResponse,\n    model,\n    stream,\n    format,\n    isCompletion,\n  )\n\n  if (!stream) {\n    if (format === 'text' && typeof output === 'string') {\n      return c.text(output)\n    }\n    return c.json(output)\n  }\n\n  return new StreamingTextResponse(output as ReadableStream)\n}",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::AZURE_URL_MAP",
    "language": "typescript",
    "label": "AZURE_URL_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 56,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const AZURE_URL_MAP = {\n  'gpt-4-vision': 'AZURE_4_VISION',\n  'gpt-4-turbo': 'AZURE_4_TURBO',\n  'DEFAULT': 'AZURE_35',\n} as const",
    "importStatements": [],
    "codeNoBody": "const AZURE_URL_MAP = {\n  'gpt-4-vision': 'AZURE_4_VISION',\n  'gpt-4-turbo': 'AZURE_4_TURBO',\n  'DEFAULT': 'AZURE_35',\n} as const",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::APIKEY_MAP",
    "language": "typescript",
    "label": "APIKEY_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 52,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const APIKEY_MAP = {\n  'gpt-4-vision': 'AZURE_KEY_VISION',\n  'gpt-4-turbo': 'AZURE_KEY_TURBO',\n  'DEFAULT': 'AZURE_KEY',\n} as const",
    "importStatements": [],
    "codeNoBody": "const APIKEY_MAP = {\n  'gpt-4-vision': 'AZURE_KEY_VISION',\n  'gpt-4-turbo': 'AZURE_KEY_TURBO',\n  'DEFAULT': 'AZURE_KEY',\n} as const",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::MODEL_MAP",
    "language": "typescript",
    "label": "MODEL_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 134,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const MODEL_MAP = {\n  'gpt-3.5-turbo': 'gpt350613',\n  'gpt-3.5-turbo-instruct': 'gpt-35-turbo-instruct',\n  'gpt-3.5-turbo-16k': 'gpt3516k',\n  'gpt-4': 'gpt4',\n  'gpt-4-vision': 'gpt4vision',\n  'gpt-4-turbo': 'gpt4turbopreview',\n  'gpt-4o': 'gpt-4o',\n} as const",
    "importStatements": [],
    "codeNoBody": "const MODEL_MAP = {\n  'gpt-3.5-turbo': 'gpt350613',\n  'gpt-3.5-turbo-instruct': 'gpt-35-turbo-instruct',\n  'gpt-3.5-turbo-16k': 'gpt3516k',\n  'gpt-4': 'gpt4',\n  'gpt-4-vision': 'gpt4vision',\n  'gpt-4-turbo': 'gpt4turbopreview',\n  'gpt-4o': 'gpt-4o',\n} as const",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai::Params",
    "language": "typescript",
    "label": "Params",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai",
    "totalTokens": 239,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Params {\n  c: Context\n  messages: NoAgentCompletionValidationType['messages']\n  model: NoAgentCompletionValidationType['model']\n  limits: {\n    dailyMaxUsage: number\n    dailyUsage: number\n    dailyMaxTokens?: number\n    dailyTokens?: number\n    vision?: boolean\n  }\n  functions?: FunctionDefinition[]\n  max_tokens?: NoAgentCompletionValidationType['max_tokens']\n  format: NoAgentCompletionValidationType['format']\n  stream: NoAgentCompletionValidationType['stream']\n  onFinal?: () => void | Promise<void>\n  metadata?: {\n    userId: string\n    channel?: typeof channels[number]\n    orgId: string\n    planName: string\n    email: string\n    distinctId: string\n    planId: string\n    userType?: string\n    consumerDistinctId?: string\n    consumerEmail?: string\n    consumerPlanName?: string\n    consumerPlanId?: string\n    consumerUserType?: string\n    consumerOrgId?: string\n    consumerUserId?: string\n  }\n  function_call?: FunctionCallPreset | FunctionName\n  extensionVersion: string | null\n}",
    "importStatements": [],
    "codeNoBody": "interface Params {\n//...\n}",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\lib\\openai",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\lib\\openai.ts",
    "type": "file",
    "totalTokens": 3940,
    "inDegree": 0,
    "outDegree": 10,
    "code": "import OpenAI from 'openai'\nimport { getEnv } from '@/lib/env.ts'\nimport { type NoAgentCompletionValidationType } from '@/schemas/chat.ts'\nimport { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'\nimport { getImageDimensionsFromContent } from '@/lib/image.ts'\nimport { ChatCompletionMessageParam } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'\nimport { channels, freePlanId, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { OpenAIStream } from 'ai'\nimport { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { codeGPTResponse } from '@/lib/response.ts'\nimport { StreamingTextResponse } from 'ai'\nimport { Context } from 'hono'\nimport { getIp } from '@/lib/ip.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { normalizeFloat } from '@/lib/numbers.ts'\nimport { Channels } from '@/types/index.ts'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport type {\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { sql } from '@/lib/db/index.ts'\n\ninterface Params {\n  c: Context\n  messages: NoAgentCompletionValidationType['messages']\n  model: NoAgentCompletionValidationType['model']\n  limits: {\n    dailyMaxUsage: number\n    dailyUsage: number\n    dailyMaxTokens?: number\n    dailyTokens?: number\n    vision?: boolean\n  }\n  functions?: FunctionDefinition[]\n  max_tokens?: NoAgentCompletionValidationType['max_tokens']\n  format: NoAgentCompletionValidationType['format']\n  stream: NoAgentCompletionValidationType['stream']\n  onFinal?: () => void | Promise<void>\n  metadata?: {\n    userId: string\n    channel?: typeof channels[number]\n    orgId: string\n    planName: string\n    email: string\n    distinctId: string\n    planId: string\n    userType?: string\n    consumerDistinctId?: string\n    consumerEmail?: string\n    consumerPlanName?: string\n    consumerPlanId?: string\n    consumerUserType?: string\n    consumerOrgId?: string\n    consumerUserId?: string\n  }\n  function_call?: FunctionCallPreset | FunctionName\n  extensionVersion: string | null\n}\n\nconst MODEL_MAP = {\n  'gpt-3.5-turbo': 'gpt350613',\n  'gpt-3.5-turbo-instruct': 'gpt-35-turbo-instruct',\n  'gpt-3.5-turbo-16k': 'gpt3516k',\n  'gpt-4': 'gpt4',\n  'gpt-4-vision': 'gpt4vision',\n  'gpt-4-turbo': 'gpt4turbopreview',\n  'gpt-4o': 'gpt-4o',\n} as const\n\nconst APIKEY_MAP = {\n  'gpt-4-vision': 'AZURE_KEY_VISION',\n  'gpt-4-turbo': 'AZURE_KEY_TURBO',\n  'DEFAULT': 'AZURE_KEY',\n} as const\n\nconst AZURE_URL_MAP = {\n  'gpt-4-vision': 'AZURE_4_VISION',\n  'gpt-4-turbo': 'AZURE_4_TURBO',\n  'DEFAULT': 'AZURE_35',\n} as const\n\nexport async function openAICompletion(\n  {\n    c,\n    messages,\n    model,\n    limits,\n    max_tokens = 500,\n    format = 'text',\n    stream = true,\n    metadata,\n    functions,\n    extensionVersion,\n    onFinal,\n  }: Params,\n) {\n  const ip = getIp(c)\n  const {\n    userId,\n    channel: channelM,\n    orgId,\n    userType,\n    planName,\n    email,\n    distinctId,\n    planId,\n    consumerDistinctId,\n    consumerEmail,\n    consumerPlanName,\n    consumerOrgId,\n    consumerPlanId,\n    consumerUserType,\n    consumerUserId,\n  } = metadata ??\n    {\n      channel: 'VSCODE',\n      userId: '',\n      orgId: '',\n      planName: 'Free Plan',\n      email: '',\n    }\n  const { dailyMaxUsage, dailyUsage } = limits\n  const controller = new AbortController()\n\n  const isVision = model === 'gpt-4-vision'\n  if (isVision && !limits?.vision) {\n    return c.json({\n      message:\n        `This feature, GPT Vision, isn't available for your current plan. Please upgrade to be able to use it.`,\n    }, { status: 403 })\n  }\n\n  const apiKey = getEnv(\n    APIKEY_MAP[model as keyof typeof APIKEY_MAP] ??\n      APIKEY_MAP['DEFAULT'],\n  )\n  const azureModel = MODEL_MAP[model as keyof typeof MODEL_MAP]\n\n  const azureUrl = new URL(\n    getEnv(\n      AZURE_URL_MAP[model as keyof typeof AZURE_URL_MAP] ??\n        AZURE_URL_MAP['DEFAULT'],\n    ),\n  )\n\n  let prompt_tokens = 0\n  let completion_tokens = 0\n  if (isVision) {\n    for await (const { content } of messages) {\n      if (!content) return\n      if (!Array.isArray(content)) return\n      let text = ''\n      for (const item of content) {\n        if (item.type === 'text') {\n          prompt_tokens += 6\n          text += item.text\n        } else {\n          const { height, width } = await getImageDimensionsFromContent(\n            item.image_url?.url ?? '',\n          )\n\n          prompt_tokens += calculateImageTokenCost(\n            height,\n            width,\n            item.image_url?.detail ?? 'high',\n          )\n\n          prompt_tokens += tokenizer(text, 'gpt-4')\n        }\n      }\n    }\n  } else {\n    const tokenizerModel = ['gpt-4-turbo', 'gpt-4o'].includes(model)\n      ? 'gpt-4'\n      : model as TiktokenModel\n    const contentMessages = messages.map((m) => m.content)\n      .join('')\n    prompt_tokens += tokenizer(\n      contentMessages,\n      tokenizerModel,\n    )\n    prompt_tokens += 6 * messages.length\n  }\n\n  const modelCost = await redis.get<{ input: number; output: number }>(\n    `modelCost-${model}`,\n  )\n\n  const promptUsage = ((modelCost?.input ?? 0) * 10000) * prompt_tokens +\n    dailyUsage * 10000000\n\n  if (\n    dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n    normalizeFloat(promptUsage) > normalizeFloat(dailyMaxUsage * 10000000)\n  ) {\n    return c.json({\n      message: 'Daily max usage reached',\n    }, { status: 403 })\n  }\n\n  const pathname = azureUrl.pathname.split('/').slice(0, 3).join('/')\n  const baseURL = `${azureUrl.origin}${pathname}/${azureModel}`\n\n  const apiVersion =\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].apiVersion\n\n  const openai = new OpenAI({\n    apiKey,\n    baseURL,\n    defaultQuery: { 'api-version': apiVersion },\n    defaultHeaders: {\n      'api-key': apiKey,\n    },\n  })\n\n  const response = await openai.chat.completions.create({\n    model,\n    stream: true,\n    max_tokens: max_tokens || 500,\n    messages: messages as ChatCompletionMessageParam[],\n    functions,\n  }, {\n    // deno-lint-ignore no-explicit-any\n    signal: controller.signal as any,\n  })\n\n  const outputCost = (modelCost?.output ?? 0) * 10000\n\n  const streamResponse = OpenAIStream(response, {\n    onToken(token) {\n      if (!token) return\n      completion_tokens += 1\n\n      const completionUsage = outputCost * completion_tokens\n\n      if (\n        dailyMaxUsage !== UNLIMITED_MAX_USAGE &&\n        normalizeFloat(promptUsage + completionUsage) >=\n          normalizeFloat(dailyMaxUsage * 10000000)\n      ) {\n        controller.abort()\n      }\n    },\n    async onFinal() {\n      const channel = channelM ?? 'VSCODE'\n      const usage: UsageInsert[] = [{\n        type: 'CHAT',\n        channel,\n        source: 'API',\n        model,\n        plan_name: consumerUserId ? consumerPlanName as string : planName,\n        user_id: consumerUserId ?? userId,\n        org_id: consumerOrgId ?? orgId,\n        prompt_token: prompt_tokens,\n        completion_token: completion_tokens,\n      }]\n\n      const body = [{\n        event: 'completion',\n        properties: {\n          distinct_id: consumerDistinctId,\n          model,\n          channel,\n          userPlan: consumerPlanName,\n          plan: planName,\n          prompt_tokens,\n          completion_tokens,\n          ip,\n          email: consumerEmail ?? null,\n        },\n      }, {\n        event: 'completion2',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email,\n          organization_id: orgId,\n          user_type: userType,\n          plan_id: planId,\n          plan_name: planName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          consumer_distinct_id: consumerDistinctId,\n          consumer_email: consumerEmail,\n          consumer_plan_id: consumerPlanId,\n          consumer_plan_name: consumerPlanName,\n          consumer_user_type: consumerUserType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }, {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: consumerDistinctId,\n          ip: getIp(c),\n          email: consumerEmail ?? null,\n          owner_organization_id: orgId,\n          user_type: consumerUserType,\n          plan_id: consumerPlanId,\n          plan_name: consumerPlanName,\n          agent_id: null,\n          agent_name: null,\n          agent_provider: getModelProvider(model),\n          agent_model: null,\n          model,\n          owner_distinct_id: distinctId,\n          owner_email: email,\n          owner_plan_id: planId,\n          owner_plan_name: planName,\n          owner_user_type: userType,\n          source: channel.toLowerCase(),\n          version: extensionVersion,\n          tokens_prompt: prompt_tokens,\n          tokens_completion: completion_tokens,\n          tokens_embedding: 0,\n          tokens_total: prompt_tokens + completion_tokens,\n        },\n      }]\n\n      const promises = [\n        mixpanel({ body, source: 'API' }),\n      ]\n\n      if (orgId) {\n        promises.push(\n          saveUsage(usage),\n          addOrgDailyTokens({\n            orgId,\n            inputTokens: prompt_tokens,\n            outputTokens: completion_tokens,\n            model,\n          }),\n        )\n      }\n\n      if (onFinal) {\n        const isOnFinalPromise = onFinal.toString().includes('async')\n        if (isOnFinalPromise) {\n          promises.push((onFinal as () => Promise<void>)())\n        } else {\n          onFinal()\n        }\n      }\n\n      await Promise.all(promises)\n    },\n  })\n\n  const isCompletion = true\n\n  const output = await codeGPTResponse(\n    streamResponse,\n    model,\n    stream,\n    format,\n    isCompletion,\n  )\n\n  if (!stream) {\n    if (format === 'text' && typeof output === 'string') {\n      return c.text(output)\n    }\n    return c.json(output)\n  }\n\n  return new StreamingTextResponse(output as ReadableStream)\n}\n\nfunction calculateImageTokenCost(\n  height: number,\n  width: number,\n  detail: 'low' | 'high',\n) {\n  let prompt_token = 85 // Base cost for all images\n\n  if (detail === 'low') {\n    // For low detail, cost is a fixed 85 tokens\n    return prompt_token\n  }\n\n  if (detail === 'high') {\n    // Scale down image if necessary\n    if (height > 2048 || width > 2048) {\n      const ratio = height / width\n      if (height > width) {\n        height = 2048\n        width = Math.floor(height / ratio)\n      } else {\n        width = 2048\n        height = Math.floor(width * ratio)\n      }\n    }\n\n    // Scale down to 768px on the shortest side\n    if (height < width) {\n      const ratio = height / width\n      height = 768\n      width = Math.floor(height / ratio)\n    } else {\n      const ratio = width / height\n      width = 768\n      height = Math.floor(width / ratio)\n    }\n\n    // Calculate the number of 512px tiles\n    const tiles = Math.ceil(height / 512) * Math.ceil(width / 512)\n\n    // Update token cost\n    prompt_token += tiles * 170\n  }\n\n  return prompt_token\n}\n\ninterface AutocompleteParams {\n  prompt: string\n  maxTokens: number\n  temperature: number\n  stop?: string[] | string\n  suffix?: string\n  metadata: {\n    channel: Channels\n    userId: string\n    planName: string\n    email: string\n    ip: string\n    distinctId: string\n    planId: string\n    orgId: string\n  }\n  extensionVersion: string | null\n}\n\nexport async function openAIAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n  const apiKey = getEnv(\n    APIKEY_MAP['DEFAULT'],\n  )\n\n  const model = 'gpt-3.5-turbo-instruct'\n  const azureModel = MODEL_MAP[model]\n\n  const azureUrl = new URL(getEnv('AZURE_INSTRUCT'))\n\n  const pathname = azureUrl.pathname.split('/').slice(0, 3).join('/')\n  const baseURL = `${azureUrl.origin}${pathname}/${azureModel}`\n\n  const openai = new OpenAI({\n    apiKey,\n    baseURL,\n    defaultQuery: { 'api-version': '2023-09-15-preview' },\n    defaultHeaders: {\n      'api-key': apiKey,\n    },\n  })\n\n  const json = await openai.completions.create(\n    {\n      prompt,\n      model,\n      max_tokens: maxTokens,\n      temperature,\n      stop,\n      ...(suffix ? { suffix } : {}),\n    },\n  )\n\n  const {\n    channel,\n    email,\n    ip,\n    planName,\n    distinctId,\n    planId,\n    orgId,\n  } = metadata\n  const body = [{\n    event: 'Autocomplete',\n    properties: {\n      distinct_id: distinctId,\n      model,\n      channel,\n      plan: planName,\n      prompt_tokens: json.usage?.prompt_tokens ?? 0,\n      completion_tokens: json.usage?.completion_tokens ?? 0,\n      ip,\n      email,\n    },\n  }, {\n    event: 'completion2',\n    properties: {\n      distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      ip,\n      email: 'dev@judini.ai',\n      organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: 'subscribed',\n      plan_id: '64f257043a7d65c1e6ea1a86',\n      plan_name: 'Plan Enterprise',\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      agent_model: null,\n      model,\n      consumer_distinct_id: distinctId,\n      consumer_email: email,\n      consumer_plan_id: planId,\n      consumer_plan_name: planName,\n      consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: json.usage?.prompt_tokens ?? 0,\n      tokens_completion: json.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (json.usage?.prompt_tokens ??\n        0) + (json.usage?.completion_tokens ?? 0),\n    },\n  }, {\n    event: 'completion2consumer',\n    properties: {\n      distinct_id: distinctId,\n      ip,\n      email,\n      owner_organization_id: '3d08113c-55ad-40f7-b6ec-b4ab73faf825',\n      user_type: planId === freePlanId ? 'free' : 'subscribed',\n      plan_id: planId,\n      plan_name: planName,\n      agent_id: null,\n      agent_name: null,\n      agent_provider: getModelProvider(model),\n      agent_model: null,\n      model,\n      owner_distinct_id: '664ea16c-f918-4d48-900c-fa728c992b4f',\n      owner_email: 'dev@judini.ai',\n      owner_plan_id: '64f257043a7d65c1e6ea1a86',\n      owner_plan_name: 'Plan Enterprise',\n      owner_user_type: 'subscribed',\n      source: channel.toLowerCase(),\n      version: extensionVersion,\n      autocomplete: true,\n      tokens_prompt: json.usage?.prompt_tokens ?? 0,\n      tokens_completion: json.usage?.completion_tokens ?? 0,\n      tokens_embedding: 0,\n      tokens_total: (json.usage?.prompt_tokens ??\n        0) + (json.usage?.completion_tokens ?? 0),\n    },\n  }]\n\n  await Promise.all([\n    mixpanel({ body, source: 'API' }),\n    sql`\n      SELECT insert_orgs_usage(\n        ${orgId}, \n        ${json.usage?.prompt_tokens ?? 0}, \n        ${json.usage?.completion_tokens ?? 0},\n        ${model}\n      )\n    `,\n  ])\n  return {\n    choices: json.choices.map((choice) => {\n      return {\n        text: choice.text,\n        finish_reason: choice.finish_reason,\n      }\n    }),\n    usage: json.usage,\n  }\n}\n",
    "importStatements": [
      "import OpenAI from 'openai'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { type NoAgentCompletionValidationType } from '@/schemas/chat.ts'",
      "import { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'",
      "import { getImageDimensionsFromContent } from '@/lib/image.ts'",
      "import { ChatCompletionMessageParam } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'",
      "import { channels, freePlanId, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'",
      "import { OpenAIStream } from 'ai'",
      "import { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'",
      "import { mixpanel } from '@/lib/mixpanel.ts'",
      "import { addOrgDailyTokens } from '@/services/supabase/organizations.ts'",
      "import { codeGPTResponse } from '@/lib/response.ts'",
      "import { StreamingTextResponse } from 'ai'",
      "import { Context } from 'hono'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { redis } from '@/lib/redis.ts'",
      "import { normalizeFloat } from '@/lib/numbers.ts'",
      "import { Channels } from '@/types/index.ts'",
      "import { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'",
      "import type {\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n} from 'npm:@azure/openai@1.0.0-beta.12'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import OpenAI from 'openai'\nimport { getEnv } from '@/lib/env.ts'\nimport { type NoAgentCompletionValidationType } from '@/schemas/chat.ts'\nimport { type TiktokenModel, tokenizer } from '@/lib/tokenizer.ts'\nimport { getImageDimensionsFromContent } from '@/lib/image.ts'\nimport { ChatCompletionMessageParam } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'\nimport { channels, freePlanId, UNLIMITED_MAX_USAGE } from '@/lib/consts.ts'\nimport { OpenAIStream } from 'ai'\nimport { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { addOrgDailyTokens } from '@/services/supabase/organizations.ts'\nimport { codeGPTResponse } from '@/lib/response.ts'\nimport { StreamingTextResponse } from 'ai'\nimport { Context } from 'hono'\nimport { getIp } from '@/lib/ip.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { normalizeFloat } from '@/lib/numbers.ts'\nimport { Channels } from '@/types/index.ts'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport type {\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { sql } from '@/lib/db/index.ts'\ninterface Params {\n//...\n}\n\nconst MODEL_MAP = {\n  'gpt-3.5-turbo': 'gpt350613',\n  'gpt-3.5-turbo-instruct': 'gpt-35-turbo-instruct',\n  'gpt-3.5-turbo-16k': 'gpt3516k',\n  'gpt-4': 'gpt4',\n  'gpt-4-vision': 'gpt4vision',\n  'gpt-4-turbo': 'gpt4turbopreview',\n  'gpt-4o': 'gpt-4o',\n} as const\n\nconst APIKEY_MAP = {\n  'gpt-4-vision': 'AZURE_KEY_VISION',\n  'gpt-4-turbo': 'AZURE_KEY_TURBO',\n  'DEFAULT': 'AZURE_KEY',\n} as const\n\nconst AZURE_URL_MAP = {\n  'gpt-4-vision': 'AZURE_4_VISION',\n  'gpt-4-turbo': 'AZURE_4_TURBO',\n  'DEFAULT': 'AZURE_35',\n} as const\n\nexport async function openAICompletion(\n  {\n    c,\n    messages,\n    model,\n    limits,\n    max_tokens = 500,\n    format = 'text',\n    stream = true,\n    metadata,\n    functions,\n    extensionVersion,\n    onFinal,\n  }: Params,\n) {\n       //...\n       }\n\nfunction calculateImageTokenCost(\n  height: number,\n  width: number,\n  detail: 'low' | 'high',\n) {\n//...\n}\n\ninterface AutocompleteParams {\n//...\n}\n\nexport async function openAIAutocomplete(\n  {\n    prompt,\n    maxTokens,\n    stop,\n    suffix,\n    temperature,\n    metadata,\n    extensionVersion,\n  }: AutocompleteParams,\n) {\n       //...\n       }",
    "originFile": "\\routes\\chat\\lib\\openai.ts"
  },
  {
    "id": "\\routes\\chat\\marketplace\\agents::chatMarketplace",
    "language": "typescript",
    "label": "chatMarketplace",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\marketplace\\agents",
    "totalTokens": 2024,
    "inDegree": 3,
    "outDegree": 12,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      function_call,\n      sessionId,\n      format = 'text',\n      ip,\n      statusId,\n      functions,\n    } = parsed.data\n\n    const source = c.req.header('channel') ?? 'vscode'\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!userId) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getMarketplaceAgentById({ id: agentId, userId }),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const subscription = await getActiveSubscriptionByOrgId(\n      agent.original_org_id,\n    )\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      daily_completion_count,\n      daily_interactions,\n      daily_max_usage,\n      daily_usage,\n      plan_user_id,\n      distinct_id: distinctId,\n      plan_temp_usage,\n      plan_created_at,\n    } = result[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : daily_completion_count\n\n    const unlimitedInteractionsUser =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === -1\n        : daily_completion_count === -1\n\n    if (\n      (!unlimitedInteractionsUser &&\n        daily_interactions >= dailyInteractionsLimit)\n    ) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: result[0].user_org_id,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    // deno-lint-ignore no-explicit-any\n    const body: Array<Record<string, any>> = [\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: result[0].id,\n          consumer_plan_name: result[0].plan_name,\n          consumer_user_type: result[0].id === freePlanId\n            ? 'free'\n            : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: result[0].id === freePlanId ? 'free' : 'subscribed',\n          plan_id: result[0].id,\n          plan_name: result[0].plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n    ]\n\n    const properties: Record<string, string | boolean | undefined> = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: result[0].plan_name,\n      email: result[0].user_email,\n    }\n\n    if (source === 'playground2') {\n      body.push({\n        event: 'playgroundChat',\n        properties,\n      })\n    }\n\n    if (!agent.is_installed) {\n      body.push({\n        event: 'addMarketplaceAgent',\n        properties: {\n          ...properties,\n          plan: result[0].plan_name,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND MARKETPLACE',\n      planName: subscription.plan.name,\n      orgId: agent.original_org_id,\n      userId: plan_user_id,\n      body,\n      sessionId,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: result[0].user_org_id,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    // If free plan, update interaction count on the agent organization\n    const updateInteractionsPromises = []\n    if (\n      !unlimitedInteractions\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        agent.original_org_id,\n      ))\n    }\n\n    if (\n      !unlimitedInteractionsUser\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        result[0].user_org_id,\n      ))\n    }\n    if (updateInteractionsPromises.length > 0) {\n      await Promise.all(updateInteractionsPromises).catch((error) => {\n        console.error(error)\n      })\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'install_limit_reached') {\n      return c.json({\n        error: 'installLimitReached',\n        description:\n          `Marketplace agents installation limit reached for your current plan. Please upgrade to install more.`,\n      }, 403)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatMarketplace }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      function_call,\n      sessionId,\n      format = 'text',\n      ip,\n      statusId,\n      functions,\n    } = parsed.data\n\n    const source = c.req.header('channel') ?? 'vscode'\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!userId) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getMarketplaceAgentById({ id: agentId, userId }),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const subscription = await getActiveSubscriptionByOrgId(\n      agent.original_org_id,\n    )\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      daily_completion_count,\n      daily_interactions,\n      daily_max_usage,\n      daily_usage,\n      plan_user_id,\n      distinct_id: distinctId,\n      plan_temp_usage,\n      plan_created_at,\n    } = result[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : daily_completion_count\n\n    const unlimitedInteractionsUser =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === -1\n        : daily_completion_count === -1\n\n    if (\n      (!unlimitedInteractionsUser &&\n        daily_interactions >= dailyInteractionsLimit)\n    ) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: result[0].user_org_id,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    // deno-lint-ignore no-explicit-any\n    const body: Array<Record<string, any>> = [\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: result[0].id,\n          consumer_plan_name: result[0].plan_name,\n          consumer_user_type: result[0].id === freePlanId\n            ? 'free'\n            : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: result[0].id === freePlanId ? 'free' : 'subscribed',\n          plan_id: result[0].id,\n          plan_name: result[0].plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n    ]\n\n    const properties: Record<string, string | boolean | undefined> = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: result[0].plan_name,\n      email: result[0].user_email,\n    }\n\n    if (source === 'playground2') {\n      body.push({\n        event: 'playgroundChat',\n        properties,\n      })\n    }\n\n    if (!agent.is_installed) {\n      body.push({\n        event: 'addMarketplaceAgent',\n        properties: {\n          ...properties,\n          plan: result[0].plan_name,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND MARKETPLACE',\n      planName: subscription.plan.name,\n      orgId: agent.original_org_id,\n      userId: plan_user_id,\n      body,\n      sessionId,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: result[0].user_org_id,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    // If free plan, update interaction count on the agent organization\n    const updateInteractionsPromises = []\n    if (\n      !unlimitedInteractions\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        agent.original_org_id,\n      ))\n    }\n\n    if (\n      !unlimitedInteractionsUser\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        result[0].user_org_id,\n      ))\n    }\n    if (updateInteractionsPromises.length > 0) {\n      await Promise.all(updateInteractionsPromises).catch((error) => {\n        console.error(error)\n      })\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'install_limit_reached') {\n      return c.json({\n        error: 'installLimitReached',\n        description:\n          `Marketplace agents installation limit reached for your current plan. Please upgrade to install more.`,\n      }, 403)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatMarketplace }",
    "originFile": "\\routes\\chat\\marketplace\\agents.ts"
  },
  {
    "id": "\\routes\\chat\\marketplace\\agents",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\marketplace\\agents.ts",
    "type": "file",
    "totalTokens": 2217,
    "inDegree": 0,
    "outDegree": 13,
    "code": "import { Hono } from 'hono'\nimport { messageCreateShareAgentSchema } from '@/schemas/chat.ts'\n\nimport { getMarketplaceAgentById } from '@/services/supabase/agents.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      function_call,\n      sessionId,\n      format = 'text',\n      ip,\n      statusId,\n      functions,\n    } = parsed.data\n\n    const source = c.req.header('channel') ?? 'vscode'\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!userId) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getMarketplaceAgentById({ id: agentId, userId }),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const subscription = await getActiveSubscriptionByOrgId(\n      agent.original_org_id,\n    )\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      daily_completion_count,\n      daily_interactions,\n      daily_max_usage,\n      daily_usage,\n      plan_user_id,\n      distinct_id: distinctId,\n      plan_temp_usage,\n      plan_created_at,\n    } = result[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : daily_completion_count\n\n    const unlimitedInteractionsUser =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === -1\n        : daily_completion_count === -1\n\n    if (\n      (!unlimitedInteractionsUser &&\n        daily_interactions >= dailyInteractionsLimit)\n    ) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: result[0].user_org_id,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    // deno-lint-ignore no-explicit-any\n    const body: Array<Record<string, any>> = [\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: result[0].id,\n          consumer_plan_name: result[0].plan_name,\n          consumer_user_type: result[0].id === freePlanId\n            ? 'free'\n            : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: result[0].id === freePlanId ? 'free' : 'subscribed',\n          plan_id: result[0].id,\n          plan_name: result[0].plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n    ]\n\n    const properties: Record<string, string | boolean | undefined> = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: result[0].plan_name,\n      email: result[0].user_email,\n    }\n\n    if (source === 'playground2') {\n      body.push({\n        event: 'playgroundChat',\n        properties,\n      })\n    }\n\n    if (!agent.is_installed) {\n      body.push({\n        event: 'addMarketplaceAgent',\n        properties: {\n          ...properties,\n          plan: result[0].plan_name,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND MARKETPLACE',\n      planName: subscription.plan.name,\n      orgId: agent.original_org_id,\n      userId: plan_user_id,\n      body,\n      sessionId,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: result[0].user_org_id,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    // If free plan, update interaction count on the agent organization\n    const updateInteractionsPromises = []\n    if (\n      !unlimitedInteractions\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        agent.original_org_id,\n      ))\n    }\n\n    if (\n      !unlimitedInteractionsUser\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        result[0].user_org_id,\n      ))\n    }\n    if (updateInteractionsPromises.length > 0) {\n      await Promise.all(updateInteractionsPromises).catch((error) => {\n        console.error(error)\n      })\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'install_limit_reached') {\n      return c.json({\n        error: 'installLimitReached',\n        description:\n          `Marketplace agents installation limit reached for your current plan. Please upgrade to install more.`,\n      }, 403)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatMarketplace }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { messageCreateShareAgentSchema } from '@/schemas/chat.ts'",
      "import { getMarketplaceAgentById } from '@/services/supabase/agents.ts'",
      "import { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { messageCreateShareAgentSchema } from '@/schemas/chat.ts'\nimport { getMarketplaceAgentById } from '@/services/supabase/agents.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      function_call,\n      sessionId,\n      format = 'text',\n      ip,\n      statusId,\n      functions,\n    } = parsed.data\n\n    const source = c.req.header('channel') ?? 'vscode'\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!userId) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getMarketplaceAgentById({ id: agentId, userId }),\n      getOwnerInfoByAgentId({ agentId }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found' }, 404)\n    }\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const subscription = await getActiveSubscriptionByOrgId(\n      agent.original_org_id,\n    )\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined\n    ) {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        error: 'agentInstallationFrozen',\n        description:\n          `Agent with ID ${agentId}'s installation is inactive because of current plan limits.`,\n      }, 403)\n    }\n\n    const { daily_interactions: dailyInteractions } = subscription?.organization\n    const { daily_completion_count: dailyCompletionLimit } = subscription?.plan\n    const unlimitedInteractions = dailyCompletionLimit === -1\n\n    if ((!unlimitedInteractions && dailyInteractions >= dailyCompletionLimit)) {\n      return c.json({\n        error: 'interactionLimitReached',\n        description:\n          `${agent.name}'s organization with ID ${subscription.org_id} has reached it's daily interaction limit for its current plan.`,\n      }, {\n        status: 403,\n      })\n    }\n\n    const {\n      daily_completion_count,\n      daily_interactions,\n      daily_max_usage,\n      daily_usage,\n      plan_user_id,\n      distinct_id: distinctId,\n      plan_temp_usage,\n      plan_created_at,\n    } = result[0]\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : daily_completion_count\n\n    const unlimitedInteractionsUser =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === -1\n        : daily_completion_count === -1\n\n    if (\n      (!unlimitedInteractionsUser &&\n        daily_interactions >= dailyInteractionsLimit)\n    ) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1]?.content ?? '',\n      userOrgId: result[0].user_org_id,\n      statusId,\n    })\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    // deno-lint-ignore no-explicit-any\n    const body: Array<Record<string, any>> = [\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: result[0].user_email,\n          consumer_plan_id: result[0].id,\n          consumer_plan_name: result[0].plan_name,\n          consumer_user_type: result[0].id === freePlanId\n            ? 'free'\n            : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: result[0].user_email,\n          owner_organization_id: org_id,\n          user_type: result[0].id === freePlanId ? 'free' : 'subscribed',\n          plan_id: result[0].id,\n          plan_name: result[0].plan_name,\n          agent_id: agentId,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source,\n          version: null,\n          marketplace: true,\n        },\n      },\n    ]\n\n    const properties: Record<string, string | boolean | undefined> = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: true,\n      plan: subscription.plan.name,\n      userPlan: result[0].plan_name,\n      email: result[0].user_email,\n    }\n\n    if (source === 'playground2') {\n      body.push({\n        event: 'playgroundChat',\n        properties,\n      })\n    }\n\n    if (!agent.is_installed) {\n      body.push({\n        event: 'addMarketplaceAgent',\n        properties: {\n          ...properties,\n          plan: result[0].plan_name,\n        },\n      })\n    }\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['marketplace agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND MARKETPLACE',\n      planName: subscription.plan.name,\n      orgId: agent.original_org_id,\n      userId: plan_user_id,\n      body,\n      sessionId,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId: result[0].user_org_id,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n      functions,\n      function_call,\n    })\n\n    // If free plan, update interaction count on the agent organization\n    const updateInteractionsPromises = []\n    if (\n      !unlimitedInteractions\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        agent.original_org_id,\n      ))\n    }\n\n    if (\n      !unlimitedInteractionsUser\n    ) {\n      updateInteractionsPromises.push(updateOrganizationsInteractions(\n        result[0].user_org_id,\n      ))\n    }\n    if (updateInteractionsPromises.length > 0) {\n      await Promise.all(updateInteractionsPromises).catch((error) => {\n        console.error(error)\n      })\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'install_limit_reached') {\n      return c.json({\n        error: 'installLimitReached',\n        description:\n          `Marketplace agents installation limit reached for your current plan. Please upgrade to install more.`,\n      }, 403)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatMarketplace }",
    "originFile": "\\routes\\chat\\marketplace\\agents.ts"
  },
  {
    "id": "\\routes\\chat\\playground::chatPlayground",
    "language": "typescript",
    "label": "chatPlayground",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\playground",
    "totalTokens": 1887,
    "inDegree": 3,
    "outDegree": 12,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found', code: 'plan_not_found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n        code: 'frozen_agent',\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({\n        message: 'Messages not found',\n        code: 'messages_not_found',\n      }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgId = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({\n        message: 'Daily interactions limit reached',\n        code: 'interaction_limit_reached',\n      }, 403)\n    }\n\n    const knowledgeTime = Date.now()\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId,\n      statusId,\n    })\n\n    console.log(\n      `Knowledge time: ${Math.round(Date.now() - knowledgeTime)} ms`,\n    )\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentID,\n      marketplace: false,\n      plan: plan_name,\n      email: userEmail,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'playgroundChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n    ]\n\n    const streamTime = Date.now()\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND',\n      planName: plan_name,\n      orgId: userOrgId,\n      saveMessages: true,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    console.log(\n      `Stream time: ${Math.round(Date.now() - streamTime)} ms`,\n    )\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgId,\n      )\n    }\n    console.log(`Total time: ${Math.round(Date.now() - totalTime)} ms`)\n\n    return response\n  } catch (error) {\n    console.log('ERROR =>', JSON.stringify(error))\n    reportError(error)\n\n    const groqErrorCode = error?.error?.error?.code ?? ''\n    const groqTokensLimit = error?.headers?.['x-ratelimit-limit-tokens'] ?? 0\n\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'block_list') {\n      return c.json(\n        'Your message contains blocked content, please modify it and try again',\n        403,\n      )\n    }\n\n    if (groqErrorCode === 'rate_limit_exceeded') {\n      return c.json(\n        {\n          error:\n            `You exceeded the ${groqTokensLimit} token limit. Please try again with less messages and/or knowledge.`,\n          code: 'rate_limit_exceeded',\n        },\n        500,\n      )\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatPlayground }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found', code: 'plan_not_found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n        code: 'frozen_agent',\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({\n        message: 'Messages not found',\n        code: 'messages_not_found',\n      }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgId = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({\n        message: 'Daily interactions limit reached',\n        code: 'interaction_limit_reached',\n      }, 403)\n    }\n\n    const knowledgeTime = Date.now()\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId,\n      statusId,\n    })\n\n    console.log(\n      `Knowledge time: ${Math.round(Date.now() - knowledgeTime)} ms`,\n    )\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentID,\n      marketplace: false,\n      plan: plan_name,\n      email: userEmail,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'playgroundChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n    ]\n\n    const streamTime = Date.now()\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND',\n      planName: plan_name,\n      orgId: userOrgId,\n      saveMessages: true,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    console.log(\n      `Stream time: ${Math.round(Date.now() - streamTime)} ms`,\n    )\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgId,\n      )\n    }\n    console.log(`Total time: ${Math.round(Date.now() - totalTime)} ms`)\n\n    return response\n  } catch (error) {\n    console.log('ERROR =>', JSON.stringify(error))\n    reportError(error)\n\n    const groqErrorCode = error?.error?.error?.code ?? ''\n    const groqTokensLimit = error?.headers?.['x-ratelimit-limit-tokens'] ?? 0\n\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'block_list') {\n      return c.json(\n        'Your message contains blocked content, please modify it and try again',\n        403,\n      )\n    }\n\n    if (groqErrorCode === 'rate_limit_exceeded') {\n      return c.json(\n        {\n          error:\n            `You exceeded the ${groqTokensLimit} token limit. Please try again with less messages and/or knowledge.`,\n          code: 'rate_limit_exceeded',\n        },\n        500,\n      )\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatPlayground }",
    "originFile": "\\routes\\chat\\playground.ts"
  },
  {
    "id": "\\routes\\chat\\playground",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\playground.ts",
    "type": "file",
    "totalTokens": 2080,
    "inDegree": 0,
    "outDegree": 13,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\n\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found', code: 'plan_not_found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n        code: 'frozen_agent',\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({\n        message: 'Messages not found',\n        code: 'messages_not_found',\n      }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgId = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({\n        message: 'Daily interactions limit reached',\n        code: 'interaction_limit_reached',\n      }, 403)\n    }\n\n    const knowledgeTime = Date.now()\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId,\n      statusId,\n    })\n\n    console.log(\n      `Knowledge time: ${Math.round(Date.now() - knowledgeTime)} ms`,\n    )\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentID,\n      marketplace: false,\n      plan: plan_name,\n      email: userEmail,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'playgroundChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n    ]\n\n    const streamTime = Date.now()\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND',\n      planName: plan_name,\n      orgId: userOrgId,\n      saveMessages: true,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    console.log(\n      `Stream time: ${Math.round(Date.now() - streamTime)} ms`,\n    )\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgId,\n      )\n    }\n    console.log(`Total time: ${Math.round(Date.now() - totalTime)} ms`)\n\n    return response\n  } catch (error) {\n    console.log('ERROR =>', JSON.stringify(error))\n    reportError(error)\n\n    const groqErrorCode = error?.error?.error?.code ?? ''\n    const groqTokensLimit = error?.headers?.['x-ratelimit-limit-tokens'] ?? 0\n\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'block_list') {\n      return c.json(\n        'Your message contains blocked content, please modify it and try again',\n        403,\n      )\n    }\n\n    if (groqErrorCode === 'rate_limit_exceeded') {\n      return c.json(\n        {\n          error:\n            `You exceeded the ${groqTokensLimit} token limit. Please try again with less messages and/or knowledge.`,\n          code: 'rate_limit_exceeded',\n        },\n        500,\n      )\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatPlayground }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { messageCreateSchema } from '@/schemas/chat.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getUserAgentById } from '@/services/supabase/agents.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { messageCreateSchema } from '@/schemas/chat.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nimport { getUserAgentById } from '@/services/supabase/agents.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { updateOrganizationsInteractions } from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { createResponse } from '@/lib/chat/streaming.ts'\nimport {\n  freePlanId,\n  PLAN_TEMP_USAGE_DATE,\n  UNLIMITED_MAX_USAGE,\n} from '@/lib/consts.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const totalTime = Date.now()\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const json = await c.req.json()\n\n    const parsed = await messageCreateSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agent: agentParam,\n      agentId,\n      messages,\n      format = 'text',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const agentID = agentParam ?? agentId\n\n    if (!agentID) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    let planAndAgentTime = Date.now()\n    const [result, agent, ownerInfo] = await Promise.all([\n      sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`,\n      getUserAgentById(agentID),\n      getOwnerInfoByAgentId({ agentId: agentID }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (!result || !result[0] || !ownerInfo) {\n      return c.json({ message: 'No plan found', code: 'plan_not_found' }, 404)\n    }\n\n    if (!agent || agent.org_id !== result[0].user_org_id) {\n      return c.json(\n        { message: 'Agent not found', code: 'agent_not_found' },\n        404,\n      )\n    }\n\n    if (agent.is_frozen) {\n      return c.json({\n        message:\n          `Agent with ID ${agentId} is currently inactive because of plan limits and cannot be used to generate a response.`,\n        code: 'frozen_agent',\n      }, 403)\n    }\n\n    if (!messages) {\n      return c.json({\n        message: 'Messages not found',\n        code: 'messages_not_found',\n      }, 404)\n    }\n\n    const plan = result[0]\n    const userOrgId = result[0].user_org_id\n    const planUserId = result[0].plan_user_id\n    const userEmail = result[0].user_email\n    const distinctId = result[0].distinct_id\n    const {\n      daily_completion_count: dailyCompletionCount,\n      daily_interactions,\n      plan_name,\n      daily_max_usage,\n      daily_usage,\n      id: planId,\n      plan_temp_usage,\n      plan_created_at,\n    } = plan\n\n    const dailyInteractionsLimit =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage\n        : dailyCompletionCount\n\n    const hasUnlimitedInteractions =\n      new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE\n        ? plan_temp_usage === UNLIMITED_MAX_USAGE\n        : Number(dailyCompletionCount) === UNLIMITED_MAX_USAGE\n\n    if (\n      !hasUnlimitedInteractions && daily_interactions >= dailyInteractionsLimit\n    ) {\n      return c.json({\n        message: 'Daily interactions limit reached',\n        code: 'interaction_limit_reached',\n      }, 403)\n    }\n\n    const knowledgeTime = Date.now()\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId,\n      statusId,\n    })\n\n    console.log(\n      `Knowledge time: ${Math.round(Date.now() - knowledgeTime)} ms`,\n    )\n\n    const properties = {\n      distinct_id: distinctId,\n      ip: ip ?? getIp(c),\n      agent_id: agentID,\n      marketplace: false,\n      plan: plan_name,\n      email: userEmail,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'playgroundChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: distinctId,\n          consumer_email: userEmail,\n          consumer_plan_id: planId,\n          consumer_plan_name: plan_name,\n          consumer_user_type: planId === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: distinctId,\n          ip: getIp(c),\n          email: userEmail,\n          owner_organization_id: org_id,\n          user_type: planId === freePlanId ? 'free' : 'subscribed',\n          plan_id: planId,\n          plan_name,\n          agent_id: agentID,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'playground2',\n          api_call_endpoint: '/api/v1/chat/playground',\n          api_call_timestamp: new Date().toISOString(),\n          api_call_status_code: 200,\n          version: null,\n        },\n      },\n    ]\n\n    const streamTime = Date.now()\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      userId: planUserId,\n      tags: ['agent', 'playground vicuna'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'PLAYGROUND',\n      planName: plan_name,\n      orgId: userOrgId,\n      saveMessages: true,\n      body,\n      dailyMaxUsage: daily_max_usage,\n      dailyUsage: daily_usage,\n      userOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    console.log(\n      `Stream time: ${Math.round(Date.now() - streamTime)} ms`,\n    )\n\n    // If free plan, update interaction count\n    if (!hasUnlimitedInteractions) {\n      await updateOrganizationsInteractions(\n        userOrgId,\n      )\n    }\n    console.log(`Total time: ${Math.round(Date.now() - totalTime)} ms`)\n\n    return response\n  } catch (error) {\n    console.log('ERROR =>', JSON.stringify(error))\n    reportError(error)\n\n    const groqErrorCode = error?.error?.error?.code ?? ''\n    const groqTokensLimit = error?.headers?.['x-ratelimit-limit-tokens'] ?? 0\n\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    if (error.message === 'Non active subscription') {\n      return c.json({\n        error: 'noActiveSubscription',\n        description: 'No active subscription found.',\n      }, { status: 403 })\n    }\n\n    if (error.message === 'block_list') {\n      return c.json(\n        'Your message contains blocked content, please modify it and try again',\n        403,\n      )\n    }\n\n    if (groqErrorCode === 'rate_limit_exceeded') {\n      return c.json(\n        {\n          error:\n            `You exceeded the ${groqTokensLimit} token limit. Please try again with less messages and/or knowledge.`,\n          code: 'rate_limit_exceeded',\n        },\n        500,\n      )\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatPlayground }",
    "originFile": "\\routes\\chat\\playground.ts"
  },
  {
    "id": "\\routes\\chat\\share::getUserId",
    "language": "typescript",
    "label": "getUserId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\share",
    "totalTokens": 97,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getUserId(c: Context) {\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const secret = getEnv('SUPABASE_JWT')\n\n  try {\n    const { payload } = await jwtVerify(\n      accessToken ?? '',\n      new TextEncoder().encode(secret),\n    )\n\n    if (!payload.sub) {\n      return undefined\n    }\n\n    return payload.sub\n  } catch (_error) {\n    return undefined\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserId(c: Context) {\n//...\n}",
    "originFile": "\\routes\\chat\\share.ts"
  },
  {
    "id": "\\routes\\chat\\share::chatShare",
    "language": "typescript",
    "label": "chatShare",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\share",
    "totalTokens": 1801,
    "inDegree": 3,
    "outDegree": 13,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      format = 'text',\n      pincode,\n      sessionId,\n      channel = 'PLAYGROUND SHARE AGENT',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const userId = await getUserId(c)\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!pincode) {\n      return c.json({ message: 'Pincode not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getPublicAgentById({ agentId, pincode })\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    // deno-lint-ignore no-explicit-any\n    const promises: any[] = [\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ]\n\n    if (userId) {\n      promises.push(\n        sql`\n          SELECT \n            ou.org_id \n          FROM organization_user ou\n          WHERE ou.user_id = ${userId}\n        `,\n      )\n      promises.push(\n        sql`SELECT * FROM get_plan_limits(${null}, ${null}, ${userId})`,\n      )\n    }\n\n    const [subscription, ownerInfo, userOrganizations = [], planResult = []] =\n      await Promise.all(\n        promises,\n      )\n\n    if ([1, 2].includes(agent?.share_agent_type_id ?? 3)) {\n      if (userOrganizations.length === 0) {\n        return c.json({\n          message: 'You must be logged in to chat with this agent',\n        }, { status: 403 })\n      }\n\n      if (agent?.share_agent_type_id === 1) {\n        const orgIds = userOrganizations.map(\n          ({ org_id }: { org_id: string }) => {\n            return org_id\n          },\n        )\n\n        if (!orgIds.includes(agentOrgId)) {\n          return c.json({\n            message: 'You must be in the organization to chat with this agent',\n          }, { status: 403 })\n        }\n      }\n    }\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: false,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      consumer_id: userId ?? null,\n      source: 'API',\n      channel,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const consumerUserType = planResult?.[0]?.id\n      ? planResult?.[0]?.id === freePlanId ? 'free' : 'subscribed'\n      : null\n\n    const body = [\n      {\n        event: 'sharedChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          consumer_email: planResult?.[0]?.user_email ?? null,\n          consumer_plan_id: planResult?.[0]?.id ?? null,\n          consumer_plan_name: planResult?.[0]?.plan_name ?? null,\n          consumer_user_type: consumerUserType,\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          ip: getIp(c),\n          email: planResult?.[0]?.user_email ?? null,\n          owner_organization_id: org_id,\n          user_type: consumerUserType,\n          plan_id: planResult?.[0]?.id ?? null,\n          plan_name: planResult?.[0]?.plan_name ?? null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n    ]\n\n    const tags = [\n      'shared agent',\n      'playground vicuna',\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      userId,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatShare }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      format = 'text',\n      pincode,\n      sessionId,\n      channel = 'PLAYGROUND SHARE AGENT',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const userId = await getUserId(c)\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!pincode) {\n      return c.json({ message: 'Pincode not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getPublicAgentById({ agentId, pincode })\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    // deno-lint-ignore no-explicit-any\n    const promises: any[] = [\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ]\n\n    if (userId) {\n      promises.push(\n        sql`\n          SELECT \n            ou.org_id \n          FROM organization_user ou\n          WHERE ou.user_id = ${userId}\n        `,\n      )\n      promises.push(\n        sql`SELECT * FROM get_plan_limits(${null}, ${null}, ${userId})`,\n      )\n    }\n\n    const [subscription, ownerInfo, userOrganizations = [], planResult = []] =\n      await Promise.all(\n        promises,\n      )\n\n    if ([1, 2].includes(agent?.share_agent_type_id ?? 3)) {\n      if (userOrganizations.length === 0) {\n        return c.json({\n          message: 'You must be logged in to chat with this agent',\n        }, { status: 403 })\n      }\n\n      if (agent?.share_agent_type_id === 1) {\n        const orgIds = userOrganizations.map(\n          ({ org_id }: { org_id: string }) => {\n            return org_id\n          },\n        )\n\n        if (!orgIds.includes(agentOrgId)) {\n          return c.json({\n            message: 'You must be in the organization to chat with this agent',\n          }, { status: 403 })\n        }\n      }\n    }\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: false,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      consumer_id: userId ?? null,\n      source: 'API',\n      channel,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const consumerUserType = planResult?.[0]?.id\n      ? planResult?.[0]?.id === freePlanId ? 'free' : 'subscribed'\n      : null\n\n    const body = [\n      {\n        event: 'sharedChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          consumer_email: planResult?.[0]?.user_email ?? null,\n          consumer_plan_id: planResult?.[0]?.id ?? null,\n          consumer_plan_name: planResult?.[0]?.plan_name ?? null,\n          consumer_user_type: consumerUserType,\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          ip: getIp(c),\n          email: planResult?.[0]?.user_email ?? null,\n          owner_organization_id: org_id,\n          user_type: consumerUserType,\n          plan_id: planResult?.[0]?.id ?? null,\n          plan_name: planResult?.[0]?.plan_name ?? null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n    ]\n\n    const tags = [\n      'shared agent',\n      'playground vicuna',\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      userId,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatShare }",
    "originFile": "\\routes\\chat\\share.ts"
  },
  {
    "id": "\\routes\\chat\\share",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\share.ts",
    "type": "file",
    "totalTokens": 2111,
    "inDegree": 0,
    "outDegree": 15,
    "code": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Context, Hono } from 'hono'\nimport { messageCreateShareAgentSchema } from '@/schemas/chat.ts'\n\nimport { getPublicAgentById } from '@/services/supabase/agents.ts'\nimport {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '@/lib/env.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      format = 'text',\n      pincode,\n      sessionId,\n      channel = 'PLAYGROUND SHARE AGENT',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const userId = await getUserId(c)\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!pincode) {\n      return c.json({ message: 'Pincode not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getPublicAgentById({ agentId, pincode })\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    // deno-lint-ignore no-explicit-any\n    const promises: any[] = [\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ]\n\n    if (userId) {\n      promises.push(\n        sql`\n          SELECT \n            ou.org_id \n          FROM organization_user ou\n          WHERE ou.user_id = ${userId}\n        `,\n      )\n      promises.push(\n        sql`SELECT * FROM get_plan_limits(${null}, ${null}, ${userId})`,\n      )\n    }\n\n    const [subscription, ownerInfo, userOrganizations = [], planResult = []] =\n      await Promise.all(\n        promises,\n      )\n\n    if ([1, 2].includes(agent?.share_agent_type_id ?? 3)) {\n      if (userOrganizations.length === 0) {\n        return c.json({\n          message: 'You must be logged in to chat with this agent',\n        }, { status: 403 })\n      }\n\n      if (agent?.share_agent_type_id === 1) {\n        const orgIds = userOrganizations.map(\n          ({ org_id }: { org_id: string }) => {\n            return org_id\n          },\n        )\n\n        if (!orgIds.includes(agentOrgId)) {\n          return c.json({\n            message: 'You must be in the organization to chat with this agent',\n          }, { status: 403 })\n        }\n      }\n    }\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: false,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      consumer_id: userId ?? null,\n      source: 'API',\n      channel,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const consumerUserType = planResult?.[0]?.id\n      ? planResult?.[0]?.id === freePlanId ? 'free' : 'subscribed'\n      : null\n\n    const body = [\n      {\n        event: 'sharedChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          consumer_email: planResult?.[0]?.user_email ?? null,\n          consumer_plan_id: planResult?.[0]?.id ?? null,\n          consumer_plan_name: planResult?.[0]?.plan_name ?? null,\n          consumer_user_type: consumerUserType,\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          ip: getIp(c),\n          email: planResult?.[0]?.user_email ?? null,\n          owner_organization_id: org_id,\n          user_type: consumerUserType,\n          plan_id: planResult?.[0]?.id ?? null,\n          plan_name: planResult?.[0]?.plan_name ?? null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n    ]\n\n    const tags = [\n      'shared agent',\n      'playground vicuna',\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      userId,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatShare }\n\nasync function getUserId(c: Context) {\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const secret = getEnv('SUPABASE_JWT')\n\n  try {\n    const { payload } = await jwtVerify(\n      accessToken ?? '',\n      new TextEncoder().encode(secret),\n    )\n\n    if (!payload.sub) {\n      return undefined\n    }\n\n    return payload.sub\n  } catch (_error) {\n    return undefined\n  }\n}\n",
    "importStatements": [
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { Context, Hono } from 'hono'",
      "import { messageCreateShareAgentSchema } from '@/schemas/chat.ts'",
      "import { getPublicAgentById } from '@/services/supabase/agents.ts'",
      "import {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'",
      "import { jwtVerify } from 'jose'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Context, Hono } from 'hono'\nimport { messageCreateShareAgentSchema } from '@/schemas/chat.ts'\nimport { getPublicAgentById } from '@/services/supabase/agents.ts'\nimport {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '@/lib/env.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateShareAgentSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      agentId,\n      messages,\n      format = 'text',\n      pincode,\n      sessionId,\n      channel = 'PLAYGROUND SHARE AGENT',\n      ip,\n      statusId,\n    } = parsed.data\n\n    const userId = await getUserId(c)\n\n    if (!agentId) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!pincode) {\n      return c.json({ message: 'Pincode not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const agent = await getPublicAgentById({ agentId, pincode })\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    // deno-lint-ignore no-explicit-any\n    const promises: any[] = [\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ]\n\n    if (userId) {\n      promises.push(\n        sql`\n          SELECT \n            ou.org_id \n          FROM organization_user ou\n          WHERE ou.user_id = ${userId}\n        `,\n      )\n      promises.push(\n        sql`SELECT * FROM get_plan_limits(${null}, ${null}, ${userId})`,\n      )\n    }\n\n    const [subscription, ownerInfo, userOrganizations = [], planResult = []] =\n      await Promise.all(\n        promises,\n      )\n\n    if ([1, 2].includes(agent?.share_agent_type_id ?? 3)) {\n      if (userOrganizations.length === 0) {\n        return c.json({\n          message: 'You must be logged in to chat with this agent',\n        }, { status: 403 })\n      }\n\n      if (agent?.share_agent_type_id === 1) {\n        const orgIds = userOrganizations.map(\n          ({ org_id }: { org_id: string }) => {\n            return org_id\n          },\n        )\n\n        if (!orgIds.includes(agentOrgId)) {\n          return c.json({\n            message: 'You must be in the organization to chat with this agent',\n          }, { status: 403 })\n        }\n      }\n    }\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agentId,\n      marketplace: false,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      consumer_id: userId ?? null,\n      source: 'API',\n      channel,\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const consumerUserType = planResult?.[0]?.id\n      ? planResult?.[0]?.id === freePlanId ? 'free' : 'subscribed'\n      : null\n\n    const body = [\n      {\n        event: 'sharedChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          consumer_email: planResult?.[0]?.user_email ?? null,\n          consumer_plan_id: planResult?.[0]?.id ?? null,\n          consumer_plan_name: planResult?.[0]?.plan_name ?? null,\n          consumer_user_type: consumerUserType,\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: planResult?.[0]?.distinct_id ?? sessionId,\n          ip: getIp(c),\n          email: planResult?.[0]?.user_email ?? null,\n          owner_organization_id: org_id,\n          user_type: consumerUserType,\n          plan_id: planResult?.[0]?.id ?? null,\n          plan_name: planResult?.[0]?.plan_name ?? null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'sharedChat',\n          version: null,\n        },\n      },\n    ]\n\n    const tags = [\n      'shared agent',\n      'playground vicuna',\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent.prompt ?? '',\n        temperature: agent.temperature ?? 0.7,\n        memory: agent.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel,\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      userId,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error?.code === 'content_filter') {\n      return c.json({\n        description:\n          'Your message contains forbidden content, please modify it and try again',\n        error: 'content_filter',\n      }, 403)\n    }\n\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatShare }\n\nasync function getUserId(c: Context) {\n//...\n}",
    "originFile": "\\routes\\chat\\share.ts"
  },
  {
    "id": "\\routes\\chat\\status\\index::cancel",
    "language": "typescript",
    "label": "cancel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\status\\index",
    "totalTokens": 12,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const cancel = () => {\n    channel.close()\n  }",
    "importStatements": [],
    "codeNoBody": "const cancel = () => {\n  //...\n  }",
    "originFile": "\\routes\\chat\\status\\index.ts"
  },
  {
    "id": "\\routes\\chat\\status\\index::start",
    "language": "typescript",
    "label": "start",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\status\\index",
    "totalTokens": 74,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }",
    "importStatements": [],
    "codeNoBody": "const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }",
    "originFile": "\\routes\\chat\\status\\index.ts"
  },
  {
    "id": "\\routes\\chat\\status\\index::chatStatus",
    "language": "typescript",
    "label": "chatStatus",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\status\\index",
    "totalTokens": 387,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const chatStatus = new Hono()\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nconst chatStatus = new Hono()\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nexport { chatStatus }",
    "importStatements": [],
    "codeNoBody": "const chatStatus = new Hono()\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nconst chatStatus = new Hono()\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nexport { chatStatus }",
    "originFile": "\\routes\\chat\\status\\index.ts"
  },
  {
    "id": "\\routes\\chat\\status\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\status\\index.ts",
    "type": "file",
    "totalTokens": 206,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Hono } from 'hono'\n\nconst chatStatus = new Hono()\n\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n\n      if (event.data.done) {\n        channel.close()\n        controller.close()\n      }\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nexport { chatStatus }\n",
    "importStatements": [
      "import { Hono } from 'hono'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nconst chatStatus = new Hono()\n\nchatStatus.get('/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`chat-status-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }\n\n  const cancel = () => {\n  //...\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nexport { chatStatus }",
    "originFile": "\\routes\\chat\\status\\index.ts"
  },
  {
    "id": "\\routes\\chat\\widget::chatWidget",
    "language": "typescript",
    "label": "chatWidget",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\widget",
    "totalTokens": 1410,
    "inDegree": 3,
    "outDegree": 11,
    "code": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateWidgetSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      widgetId,\n      messages,\n      format = 'text',\n      sessionId,\n      ip,\n      statusId,\n    } = parsed.data\n\n    if (!widgetId) {\n      return c.json({ message: 'Widget id not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [agent] = await sql`\n      select \n        a.id,\n        a.org_id,\n        a.model,\n        a.prompt,\n        a.name,\n        a.temperature,\n        a.memory\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${widgetId}\n        and widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n      },\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agent.id,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      source: 'API',\n      channel: 'WIDGET',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'widgetChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: sessionId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: null,\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: sessionId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: org_id,\n          user_type: null,\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent?.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['agent', 'widget'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'WIDGET',\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatWidget }",
    "importStatements": [],
    "codeNoBody": "const chat = new Hono()\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n    const parsed = await messageCreateWidgetSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      widgetId,\n      messages,\n      format = 'text',\n      sessionId,\n      ip,\n      statusId,\n    } = parsed.data\n\n    if (!widgetId) {\n      return c.json({ message: 'Widget id not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [agent] = await sql`\n      select \n        a.id,\n        a.org_id,\n        a.model,\n        a.prompt,\n        a.name,\n        a.temperature,\n        a.memory\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${widgetId}\n        and widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n      },\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agent.id,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      source: 'API',\n      channel: 'WIDGET',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'widgetChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: sessionId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: null,\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: sessionId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: org_id,\n          user_type: null,\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent?.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['agent', 'widget'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'WIDGET',\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatWidget }",
    "originFile": "\\routes\\chat\\widget.ts"
  },
  {
    "id": "\\routes\\chat\\widget",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\chat\\widget.ts",
    "type": "file",
    "totalTokens": 1581,
    "inDegree": 0,
    "outDegree": 12,
    "code": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { messageCreateWidgetSchema } from '@/schemas/chat.ts'\nimport {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\n\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateWidgetSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      widgetId,\n      messages,\n      format = 'text',\n      sessionId,\n      ip,\n      statusId,\n    } = parsed.data\n\n    if (!widgetId) {\n      return c.json({ message: 'Widget id not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [agent] = await sql`\n      select \n        a.id,\n        a.org_id,\n        a.model,\n        a.prompt,\n        a.name,\n        a.temperature,\n        a.memory\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${widgetId}\n        and widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n      },\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agent.id,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      source: 'API',\n      channel: 'WIDGET',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'widgetChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: sessionId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: null,\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: sessionId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: org_id,\n          user_type: null,\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent?.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['agent', 'widget'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'WIDGET',\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatWidget }\n",
    "importStatements": [
      "import { createResponse } from '@/lib/chat/streaming.ts'",
      "import { Hono } from 'hono'",
      "import { messageCreateWidgetSchema } from '@/schemas/chat.ts'",
      "import {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'",
      "import { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'",
      "import { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'",
      "import { getModelProvider } from '@/lib/mixpanel/providers.ts'"
    ],
    "codeNoBody": "import { createResponse } from '@/lib/chat/streaming.ts'\nimport { Hono } from 'hono'\nimport { messageCreateWidgetSchema } from '@/schemas/chat.ts'\nimport {\n  getOrganizationOwnerDistinctId,\n  updateOrganizationsInteractions,\n} from '@/services/supabase/organizations.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getActiveSubscriptionByOrgId } from '@/services/supabase/subscription.ts'\nimport { getToolsKnowledge } from '@/lib/chat/tools-knowledge.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getOwnerInfoByAgentId } from '@/services/db/mixpanel.ts'\nimport { freePlanId, PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nimport { getModelProvider } from '@/lib/mixpanel/providers.ts'\nconst chat = new Hono()\n\nchat.post('/', async (c) => {\n  try {\n    const json = await c.req.json()\n\n    const parsed = await messageCreateWidgetSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const {\n      stream: isStream = true,\n      widgetId,\n      messages,\n      format = 'text',\n      sessionId,\n      ip,\n      statusId,\n    } = parsed.data\n\n    if (!widgetId) {\n      return c.json({ message: 'Widget id not found' }, 404)\n    }\n\n    let planAndAgentTime = Date.now()\n\n    const [agent] = await sql`\n      select \n        a.id,\n        a.org_id,\n        a.model,\n        a.prompt,\n        a.name,\n        a.temperature,\n        a.memory\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${widgetId}\n        and widgets.enabled = true\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    if (!messages) {\n      return c.json({ message: 'Messages not found' }, 404)\n    }\n\n    const { org_id: agentOrgId } = agent\n\n    const [subscription, ownerInfo] = await Promise.all([\n      getActiveSubscriptionByOrgId(agentOrgId),\n      getOwnerInfoByAgentId({ agentId: agent.id }),\n    ])\n\n    planAndAgentTime = Date.now() - planAndAgentTime\n\n    if (\n      !subscription ||\n      !['active', 'trialing'].includes(subscription?.status) ||\n      subscription?.organization?.daily_interactions === undefined ||\n      subscription?.plan?.daily_completion_count === undefined ||\n      !ownerInfo\n    ) {\n      return c.json({ error: 'noActiveSubscription' }, { status: 403 })\n    }\n\n    const { daily_interactions: dailyInteractions, daily_usage } = subscription\n      ?.organization\n    const {\n      daily_completion_count: dailyCompletionLimit,\n      daily_max_usage,\n      temp_usage,\n    } = subscription?.plan\n\n    const dailyInteractionsLimit =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage\n        : dailyCompletionLimit\n\n    const unlimitedInteractions =\n      new Date(subscription.created_at) >= PLAN_TEMP_USAGE_DATE\n        ? temp_usage === -1\n        : dailyCompletionLimit === -1\n\n    if (!unlimitedInteractions && dailyInteractions >= dailyInteractionsLimit) {\n      return c.json({ error: 'interactionLimitReached' }, {\n        status: 403,\n      })\n    }\n\n    const {\n      knowledge,\n      lastMessageTokens,\n      lastMessageEmbedding,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n    } = await getToolsKnowledge({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n      },\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      lastMessage: messages[messages.length - 1].content,\n      userOrgId: agentOrgId,\n      statusId,\n    })\n\n    const distinctId = await getOrganizationOwnerDistinctId({\n      orgId: subscription.org_id,\n    })\n    const properties = {\n      ip: ip ?? getIp(c),\n      agent_id: agent.id,\n      plan: subscription.plan.name,\n      distinct_id: distinctId,\n      source: 'API',\n      channel: 'WIDGET',\n    }\n\n    const { distinct_id, email, org_id, id, name } = ownerInfo\n\n    const body = [\n      {\n        event: 'widgetChat',\n        properties,\n      },\n      {\n        event: 'completion2',\n        properties: {\n          distinct_id,\n          ip: getIp(c),\n          email,\n          organization_id: org_id,\n          user_type: id === freePlanId ? 'free' : 'subscribed',\n          plan_id: id,\n          plan_name: name,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          consumer_distinct_id: sessionId,\n          consumer_email: null,\n          consumer_plan_id: null,\n          consumer_plan_name: null,\n          consumer_user_type: null,\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n      {\n        event: 'completion2consumer',\n        properties: {\n          distinct_id: sessionId,\n          ip: getIp(c),\n          email: null,\n          owner_organization_id: org_id,\n          user_type: null,\n          plan_id: null,\n          plan_name: null,\n          agent_id: agent.id,\n          agent_name: agent.name,\n          agent_provider: getModelProvider(agent.model),\n          agent_model: agent.model,\n          owner_distinct_id: distinct_id,\n          owner_email: email,\n          owner_plan_id: id,\n          owner_plan_name: name,\n          owner_user_type: id === freePlanId ? 'free' : 'subscribed',\n          source: 'widget',\n          version: null,\n          referrer: c.req.header('Referer'),\n        },\n      },\n    ]\n\n    const response = await createResponse({\n      agent: {\n        id: agent.id,\n        model: agent.model,\n        name: agent.name,\n        prompt: agent?.prompt ?? '',\n        temperature: agent?.temperature ?? 0.7,\n        memory: agent?.memory ?? 5,\n      },\n      knowledge,\n      isReload: c.req.header('isReload'),\n      messages,\n      tags: ['agent', 'widget'],\n      lastMessageTokens,\n      lastMessageEmbedding,\n      channel: 'WIDGET',\n      planName: subscription.plan.name,\n      orgId: agentOrgId,\n      sessionId,\n      body,\n      dailyMaxUsage: daily_max_usage ?? 0,\n      dailyUsage: daily_usage,\n      userOrgId: agentOrgId,\n      stream: isStream,\n      format,\n      c,\n      agentDocumentsVerificationTime,\n      embeddingTime,\n      semanticSearchTime,\n      planAndAgentTime,\n      statusId,\n    })\n\n    // If free plan, update interaction count\n    if (!unlimitedInteractions) {\n      await updateOrganizationsInteractions(agentOrgId)\n        .catch(\n          () => null,\n        )\n    }\n\n    return response\n  } catch (error) {\n    if (error.message === 'Aborted' || error.name === 'AbortError') {\n      return c.json('Daily max tokens reached', 500)\n    }\n\n    return c.json('Server error, please try again', 500)\n  }\n})\n\nexport { chat as chatWidget }",
    "originFile": "\\routes\\chat\\widget.ts"
  },
  {
    "id": "\\routes\\discord::hexToUint8Array",
    "language": "typescript",
    "label": "hexToUint8Array",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\discord",
    "totalTokens": 68,
    "inDegree": 3,
    "outDegree": 0,
    "code": "function hexToUint8Array(hexString: string): Uint8Array {\n  const matches = hexString.match(/.{1,2}/g)\n  if (matches === null) {\n    throw new Error('Invalid hex string')\n  }\n  return new Uint8Array(matches.map((byte) => parseInt(byte, 16)))\n}",
    "importStatements": [],
    "codeNoBody": "function hexToUint8Array(hexString: string): Uint8Array {\n//...\n}",
    "originFile": "\\routes\\discord.ts"
  },
  {
    "id": "\\routes\\discord::discord",
    "language": "typescript",
    "label": "discord",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\discord",
    "totalTokens": 2494,
    "inDegree": 3,
    "outDegree": 6,
    "code": "const discord = new Hono()\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst discord = new Hono()\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { discord }",
    "importStatements": [],
    "codeNoBody": "const discord = new Hono()\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst discord = new Hono()\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { discord }",
    "originFile": "\\routes\\discord.ts"
  },
  {
    "id": "\\routes\\discord",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\discord.ts",
    "type": "file",
    "totalTokens": 1421,
    "inDegree": 0,
    "outDegree": 8,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport nacl from 'tweetnacl'\nimport redirector from '@/lib/integrations/discord-app/redirector.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { deleteServer } from '@/lib/integrations/discord-app/services/supabase/servers.ts'\n\nconst discord = new Hono()\n\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\n\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nfunction hexToUint8Array(hexString: string): Uint8Array {\n  const matches = hexString.match(/.{1,2}/g)\n  if (matches === null) {\n    throw new Error('Invalid hex string')\n  }\n  return new Uint8Array(matches.map((byte) => parseInt(byte, 16)))\n}\n\nexport { discord }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import nacl from 'tweetnacl'",
      "import redirector from '@/lib/integrations/discord-app/redirector.ts'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { deleteServer } from '@/lib/integrations/discord-app/services/supabase/servers.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport nacl from 'tweetnacl'\nimport redirector from '@/lib/integrations/discord-app/redirector.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { deleteServer } from '@/lib/integrations/discord-app/services/supabase/servers.ts'\nconst discord = new Hono()\n\ndiscord.post('/event', async (c) => {\n  const publicKey = getEnv('DISCORD_PUBLIC_KEY')\n  try {\n    console.log('Entró a event')\n    const signature = c.req.header('x-signature-ed25519')\n    const timestamp = c.req.header('x-signature-timestamp')\n    const body = await c.req.json()\n\n    if (typeof signature !== 'string' || typeof timestamp !== 'string') {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (!publicKey) {\n      throw new Error('Public key is not defined')\n    }\n\n    const isVerified = nacl.sign.detached.verify(\n      new TextEncoder().encode(timestamp + JSON.stringify(body)),\n      hexToUint8Array(signature),\n      hexToUint8Array(publicKey),\n    )\n\n    if (!isVerified) {\n      return new Response('Invalid request signature', { status: 401 })\n    }\n\n    if (body && body.type === 1) {\n      console.log('Received PING from Discord')\n\n      return c.json({ type: 1 })\n    }\n\n    await redirector(body, c)\n  } catch (error: any) {\n    console.error('Error handling event', error)\n    return new Response(error.message, { status: 400 })\n  }\n})\ndiscord.get('/callback', async (c) => {\n  try {\n    const code = c.req.query('code')\n    const url = c.req.query('state')\n    console.log('url', url)\n\n    if (typeof code !== 'string') {\n      return new Response('Authorization code is missing or invalid', {\n        status: 400,\n      })\n    }\n\n    const params = new URLSearchParams({\n      client_id: Deno.env.get('DISCORD_APPLICATION_ID') as string,\n      client_secret: Deno.env.get('DISCORD_CLIENT_SECRET') as string,\n      code: code,\n      grant_type: 'authorization_code',\n      redirect_uri: `https://api-beta.codegpt.co/api/v1/discord/callback`,\n      scope: 'identify',\n    })\n\n    const tokenResponse = await fetch('https://discord.com/api/oauth2/token', {\n      method: 'POST',\n      body: params,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    })\n\n    if (!tokenResponse.ok) {\n      const errorBody = await tokenResponse.text()\n      console.error('Error response body:', errorBody)\n      throw new Error(`Failed to exchange code for access token: ${errorBody}`)\n    }\n\n    const response = await tokenResponse.json()\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/discord/servers/${response.guild.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.guild.name)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error in /discord-callback', error)\n\n    return new Response(error.message || 'Unknown error', { status: 500 })\n  }\n})\ndiscord.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const response = await fetch(\n      `https://discord.com/api/guilds/${id}/channels`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = await response.json() //\n    if (response.ok) {\n      const channelsSimplified = result.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      console.log('error', result)\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\n\ndiscord.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const serverIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    const revocationResult = []\n\n    // Eliminar solo el servidor específico\n    const response = await fetch(\n      `https://discord.com/api/v10/users/@me/guilds/${serverIdToDelete}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bot ${getEnv('DISCORD_BOT_TOKEN')}`,\n        },\n      },\n    )\n\n    const result = response\n    revocationResult.push({\n      serverId: serverIdToDelete,\n      revocationResult: result.ok,\n    })\n\n    if (result.ok) {\n      await deleteServer(serverIdToDelete as string)\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 3\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResult), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nfunction hexToUint8Array(hexString: string): Uint8Array {\n//...\n}\n\nexport { discord }",
    "originFile": "\\routes\\discord.ts"
  },
  {
    "id": "\\routes\\documents::documents",
    "language": "typescript",
    "label": "documents",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\documents",
    "totalTokens": 4294,
    "inDegree": 3,
    "outDegree": 22,
    "code": "const documents = new Hono()\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nconst documents = new Hono()\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { documents }",
    "importStatements": [],
    "codeNoBody": "const documents = new Hono()\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nconst documents = new Hono()\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { documents }",
    "originFile": "\\routes\\documents.ts"
  },
  {
    "id": "\\routes\\documents",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\documents.ts",
    "type": "file",
    "totalTokens": 2404,
    "inDegree": 0,
    "outDegree": 23,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization, getTextFromFile, sendError } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport {\n  createDocument,\n  createDocumentBucket,\n  deleteDocumentBucket,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { metadataSchema } from '@/schemas/metadata.ts'\nimport { retrieveDocumentContentsFromBucket } from '@/services/supabase/documents.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { getDocumentsWithStorage } from '@/services/supabase/documents.ts'\nimport { tokenizer } from '@/lib/tokenizer.ts'\nimport { cleanText } from '@/lib/utils.ts'\nimport { createNewUsageObject } from '@/lib/usage.ts'\nimport { saveUsage } from '@/services/supabase/usage.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Document } from '@/types/index.ts'\nimport { channels } from '@/lib/consts.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\n\nconst documents = new Hono()\n\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\n\n// Get all Documents\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\n\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { documents }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization, getTextFromFile, sendError } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import {\n  createDocument,\n  createDocumentBucket,\n  deleteDocumentBucket,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'",
      "import { uuidSchema } from '@/schemas/index.ts'",
      "import { metadataSchema } from '@/schemas/metadata.ts'",
      "import { retrieveDocumentContentsFromBucket } from '@/services/supabase/documents.ts'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getDocumentsWithStorage } from '@/services/supabase/documents.ts'",
      "import { tokenizer } from '@/lib/tokenizer.ts'",
      "import { cleanText } from '@/lib/utils.ts'",
      "import { createNewUsageObject } from '@/lib/usage.ts'",
      "import { saveUsage } from '@/services/supabase/usage.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { mixpanel } from '@/lib/mixpanel.ts'",
      "import { Document } from '@/types/index.ts'",
      "import { channels } from '@/lib/consts.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization, getTextFromFile, sendError } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport {\n  createDocument,\n  createDocumentBucket,\n  deleteDocumentBucket,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { metadataSchema } from '@/schemas/metadata.ts'\nimport { retrieveDocumentContentsFromBucket } from '@/services/supabase/documents.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { getDocumentsWithStorage } from '@/services/supabase/documents.ts'\nimport { tokenizer } from '@/lib/tokenizer.ts'\nimport { cleanText } from '@/lib/utils.ts'\nimport { createNewUsageObject } from '@/lib/usage.ts'\nimport { saveUsage } from '@/services/supabase/usage.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { Document } from '@/types/index.ts'\nimport { channels } from '@/lib/consts.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nconst documents = new Hono()\n\ndocuments.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const channel = c.req.header('channel') ?? userId\n    ? 'PLAYGROUND DOCUMENTS'\n    : 'DOCUMENTS'\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  const documentId = crypto.randomUUID()\n  let fileId = ''\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      text_storage,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    fileId = `${user_org_id}/${crypto.randomUUID()}`\n\n    let file, metadata, source, chunkSize, chunkOverlap, paragraph_separator\n\n    if (contentType === 'multipart/form-data') {\n      const body = await c.req.parseBody()\n      file = body.file\n      chunkSize = body?.chunk_size ?? '512'\n      chunkOverlap = body?.chunk_overlap ?? '0'\n      paragraph_separator = body?.paragraph_separator ?? null\n      metadata = body.metadata as unknown as\n        | Document['metadata']\n        | undefined\n      source = body.source ?? 'file'\n    } else {\n      const content = await c.req.text()\n      file = new File([content], `${documentId}.txt`, { type: 'text/plain' })\n      source = 'API'\n    }\n\n    if (typeof file === 'string' || Array.isArray(file)) {\n      return c.json({ message: 'Invalid file' }, 400)\n    }\n\n    if (file.type !== 'text/plain') {\n      return c.json({\n        message: 'Invalid file type. Only txt files are currently allowed.',\n      }, 400)\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      return c.json({ message: 'File size over the 2MB limit' }, 400)\n    }\n\n    if (\n      (typeof channel !== 'string' || !channels.includes(channel))\n    ) {\n      return c.json({ message: 'Invalid channel' }, 400)\n    }\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    const storageLimit = Number(text_storage)\n    let totalDocumentSize = 0\n    if (documentsWithStorage?.length) {\n      for (const document of documentsWithStorage) {\n        totalDocumentSize += document?.size as number\n      }\n\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n\n      totalDocumentSize = totalDocumentSize / (1024 * 1024)\n      const unlimitedStorage = storageLimit === -1\n      if (\n        !unlimitedStorage &&\n        totalDocumentSize + file.size / (1024 * 1024) >= storageLimit\n      ) {\n        return c.json({ error: 'Storage limit reached' }, { status: 403 })\n      }\n    }\n\n    const { name, content, type } = await getTextFromFile(file)\n    fileId += `.${type}`\n\n    let tokens = 0\n    if (content) {\n      const cleanContent = cleanText(content as string)\n      tokens = tokenizer(cleanContent, 'text-embedding-ada-002')\n    }\n\n    const formData = new FormData()\n\n    formData.set('file', file)\n    formData.set('type', type)\n    formData.set('user_id', plan_user_id)\n    formData.set('org_id', user_org_id)\n    formData.set('chunk_size', String(chunkSize))\n    formData.set('chunk_overlap', String(chunkOverlap))\n    formData.set('paragraph_separator', String(paragraph_separator))\n\n    if (metadata) {\n      formData.set('metadata', JSON.stringify(metadata))\n    }\n\n    console.log('Uploading document:', {\n      fileId,\n      name,\n      userId: plan_user_id,\n      documentId,\n      orgId: String(user_org_id),\n      fileType: 'text',\n      tokens,\n      metadata,\n    })\n\n    const [document] = await Promise.all([\n      createDocument({\n        fileId,\n        fileName: name,\n        userId: plan_user_id,\n        documentId,\n        orgId: String(user_org_id),\n        fileType: 'text',\n        tokens,\n        metadata,\n      }),\n      createDocumentBucket(file, fileId),\n    ])\n\n    formData.set('document_id', document.id)\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/knowledge/learn`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: formData,\n    })\n\n    if (!res.ok) {\n      console.log('Error uploading document =>', res)\n      throw new Error('Error uploading document')\n    }\n\n    const data = await res.json()\n\n    const mixBody = [\n      {\n        event: source === 'url' ? 'newFileUrl' : 'newFile',\n        properties: {\n          distinct_id,\n          email: user_email,\n          plan: plan_name,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          embedding_tokens: tokens,\n          chunks: data.total_chunks,\n        },\n      },\n    ]\n\n    const promises = [mixpanel({ body: mixBody })]\n\n    if (tokens) {\n      formData.set('tokens', tokens.toString())\n\n      const usage = createNewUsageObject({\n        userId: plan_user_id,\n        channel,\n        type: 'TRAINING',\n        planName: plan_name,\n        embeddingTokens: tokens,\n        orgId: String(user_org_id),\n      })\n\n      promises.push(saveUsage(usage))\n    }\n\n    await Promise.allSettled(promises).catch((error) => {\n      console.log('Error while saving usage: ', error)\n    })\n\n    return c.json({ file, documentId: document.id }, 200)\n  } catch (error) {\n    reportError(error, userId ?? '')\n    console.log('Error uploading document:', error)\n    await Promise.allSettled([\n      deleteDocumentById(documentId),\n      deleteDocumentBucket(fileId),\n    ]).catch(\n      (error) => {\n        reportError(error, userId ?? '')\n        console.log('Error deleting document:', error)\n      },\n    )\n    return sendError(error, c)\n  }\n})\n\n// Get all Documents\ndocuments.get('/', async (c) => {\n  const { apiKey, orgId, userId } = await getAuthorization(c)\n\n  try {\n    const documents =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId})`\n\n    if (!documents) {\n      return c.json({ message: 'No documents found' }, 404)\n    }\n\n    return c.json(documents)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\ndocuments.get('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM get_documents_from_api(${apiKey}, ${userId}, ${orgId}, ${id})`\n\n    if (!document) {\n      return c.json({ message: 'No document found' }, 404)\n    }\n\n    const content = await retrieveDocumentContentsFromBucket(\n      document.file_id,\n    )\n    return c.json({ ...document, content })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\ndocuments.patch('/:id/metadata', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await metadataSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  const metadata = parsed.data\n\n  try {\n    await sql`SELECT * FROM update_document_metada_from_api(${id}, ${\n      sql.json(metadata)\n    },${apiKey}, ${userId}, ${orgId})`\n\n    return c.json({ message: 'Document metadata updated successfully' })\n  } catch (error) {\n    console.log('Error updating document:', error)\n    return sendError(error, c)\n  }\n})\n\ndocuments.delete('/:id', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid document id' }, 400)\n  }\n\n  try {\n    const [document] =\n      await sql`SELECT * FROM validate_document_ownership_from_api(${id}, ${orgId}, ${userId}, ${apiKey})`\n\n    if (!document) {\n      return c.json({ message: 'Document not found' }, 404)\n    }\n\n    await Promise.all([\n      deleteDocumentById(id),\n      deleteDocumentBucket(document.file_id),\n    ])\n\n    await sql`SELECT * FROM check_and_unfreeze_document_by_orgid_userid_or_apikey(${orgId}, ${apiKey}, ${userId})`\n\n    return c.json({ message: 'Document deleted successfully' })\n  } catch (error) {\n    console.log('Error deleting document:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { documents }",
    "originFile": "\\routes\\documents.ts"
  },
  {
    "id": "\\routes\\extensions\\index::cancel",
    "language": "typescript",
    "label": "cancel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\extensions\\index",
    "totalTokens": 12,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const cancel = () => {\n    channel.close()\n  }",
    "importStatements": [],
    "codeNoBody": "const cancel = () => {\n  //...\n  }",
    "originFile": "\\routes\\extensions\\index.ts"
  },
  {
    "id": "\\routes\\extensions\\index::start",
    "language": "typescript",
    "label": "start",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\extensions\\index",
    "totalTokens": 63,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }",
    "importStatements": [],
    "codeNoBody": "const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }",
    "originFile": "\\routes\\extensions\\index.ts"
  },
  {
    "id": "\\routes\\extensions\\index::extensions",
    "language": "typescript",
    "label": "extensions",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\extensions\\index",
    "totalTokens": 512,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const extensions = new Hono()\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nconst extensions = new Hono()\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { extensions }",
    "importStatements": [],
    "codeNoBody": "const extensions = new Hono()\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nconst extensions = new Hono()\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { extensions }",
    "originFile": "\\routes\\extensions\\index.ts"
  },
  {
    "id": "\\routes\\extensions\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\extensions\\index.ts",
    "type": "file",
    "totalTokens": 268,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Hono } from 'hono'\n\nconst extensions = new Hono()\n\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { extensions }\n",
    "importStatements": [
      "import { Hono } from 'hono'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nconst extensions = new Hono()\n\nextensions.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }\n\n  const cancel = () => {\n  //...\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nextensions.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { extensions }",
    "originFile": "\\routes\\extensions\\index.ts"
  },
  {
    "id": "\\routes\\github-app::githubApp",
    "language": "typescript",
    "label": "githubApp",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\github-app",
    "totalTokens": 3109,
    "inDegree": 3,
    "outDegree": 4,
    "code": "const githubApp = new Hono()\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst githubApp = new Hono()\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { githubApp }",
    "importStatements": [],
    "codeNoBody": "const githubApp = new Hono()\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst githubApp = new Hono()\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { githubApp }",
    "originFile": "\\routes\\github-app.ts"
  },
  {
    "id": "\\routes\\github-app",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\github-app.ts",
    "type": "file",
    "totalTokens": 1663,
    "inDegree": 0,
    "outDegree": 5,
    "code": "// deno-lint-ignore-file\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserData } from '@/lib/integrations/github-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nconst githubApp = new Hono()\n\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\n\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n// endpoint acá que reciba username, accesstoken, nombre del repo, branch. LLamar al service de python para que descargue el repo.\nexport { githubApp }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import axios from 'axios'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getUserData } from '@/lib/integrations/github-app/utils.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserData } from '@/lib/integrations/github-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nconst githubApp = new Hono()\n\ngithubApp.get('/oauth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return c.text('No se proporcionó un código de autorización', 400)\n    }\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n    const redirectUri = getEnv('GITHUB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://github.com/login/oauth/access_token',\n      null,\n      {\n        params: {\n          client_id: clientId,\n          client_secret: clientSecret,\n          code,\n          redirect_uri: redirectUri,\n        },\n        headers: {\n          'Accept': 'application/json',\n        },\n      },\n    )\n\n    const { access_token } = tokenResponse.data\n\n    const data = await getUserData(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${getEnv('PLAYGROUND_URL')}/api/github/connection/${data.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', data.login)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en /oauth/callback:', error)\n    return c.text('Error al obtener los tokens de acceso', 500)\n  }\n})\ngithubApp.get('/get-repos', async (c) => {\n  try {\n    console.log('Entró a get repos')\n    const id = c.req.query('id')\n\n    if (!id) return c.json('No se proporcionó un id', 400)\n\n    const clientId = getEnv('GITHUB_CLIENT_ID')\n    const clientSecret = getEnv('GITHUB_CLIENT_SECRET')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    if (!resp[0]) return c.text('No hay ninguna conexión', 400)\n\n    const connection = await sql`\n      SELECT * FROM github_connections\n      WHERE id = ${id} AND org_id = ${resp[0].user_org_id}\n    `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    const accessToken = `${connection[0].access_token}`\n    const orgsUrl = 'https://api.github.com/user/orgs'\n    const userReposUrl = 'k'\n    const userUrl = 'https://api.github.com/user'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/vnd.github+json',\n    }\n\n    // Obtener la información del usuario\n    const userResponse = await axios.get(userUrl, { headers })\n    const userLogin = userResponse.data.login\n    console.log('Usuario autenticado:', userLogin)\n\n    // Obtener los repositorios personales del usuario\n    const userReposResponse = await axios.get(userReposUrl, { headers })\n    const userRepos = userReposResponse.data\n\n    // Obtener las organizaciones a las que el usuario tiene acceso\n    const orgsResponse = await axios.get(orgsUrl, { headers })\n    const orgs = orgsResponse.data\n\n    // Obtener los repositorios de cada organización\n    const orgReposPromises = orgs.map(async (org: any) => {\n      const reposUrl = `https://api.github.com/orgs/${org.login}/repos`\n      const reposResponse = await axios.get(reposUrl, { headers })\n      return reposResponse.data.map((repo: any) => ({\n        ...repo,\n        // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n        organization: org.login,\n      }))\n    })\n\n    const orgRepos = await Promise.all(orgReposPromises)\n    const flattenedOrgRepos = orgRepos.flat()\n\n    // Combinar los repositorios personales y los de las organizaciones\n    const allRepos = userRepos.map((repo: any) => ({\n      ...repo,\n      // isCreator: repo.owner.login === userLogin, // Comentado por ahora\n      organization: repo.owner.type === 'Organization'\n        ? repo.owner.login\n        : null,\n    })).concat(flattenedOrgRepos)\n\n    // Obtener las branches de cada repositorio\n    const branchesPromises = allRepos.map(async (repo: any) => {\n      const branchesUrl =\n        `https://api.github.com/repos/${repo.owner.login}/${repo.name}/branches`\n      const branchesResponse = await axios.get(branchesUrl, { headers })\n      return {\n        ...repo,\n        branches: branchesResponse.data,\n      }\n    })\n\n    const reposWithBranches = await Promise.all(branchesPromises)\n\n    return new Response(JSON.stringify(reposWithBranches), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al obtener los repositorios:', error)\n    return new Response(\n      JSON.stringify({ error: 'Error al obtener los repositorios' }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  }\n})\n\ngithubApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla github_connections\n    const result = await sql`\n      DELETE FROM github_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n// endpoint acá que reciba username, accesstoken, nombre del repo, branch. LLamar al service de python para que descargue el repo.\nexport { githubApp }",
    "originFile": "\\routes\\github-app.ts"
  },
  {
    "id": "\\routes\\github::github",
    "language": "typescript",
    "label": "github",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\github",
    "totalTokens": 1430,
    "inDegree": 3,
    "outDegree": 8,
    "code": "const github = new Hono()\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst github = new Hono()\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { github }",
    "importStatements": [],
    "codeNoBody": "const github = new Hono()\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst github = new Hono()\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { github }",
    "originFile": "\\routes\\github.ts"
  },
  {
    "id": "\\routes\\github",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\github.ts",
    "type": "file",
    "totalTokens": 860,
    "inDegree": 0,
    "outDegree": 9,
    "code": "import { Hono } from 'hono'\nimport {\n  createDocument,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { githubLinkSchema } from '../schemas/document.ts'\nimport { getEnv } from '../lib/env.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { mixpanel } from '../lib/mixpanel.ts'\nimport { getDocumentsWithStorage } from '@/services/supabase/documents.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'\n\nconst github = new Hono()\n\n// Get text from file\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { github }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import {\n  createDocument,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { githubLinkSchema } from '../schemas/document.ts'",
      "import { getEnv } from '../lib/env.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { mixpanel } from '../lib/mixpanel.ts'",
      "import { getDocumentsWithStorage } from '@/services/supabase/documents.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport {\n  createDocument,\n  deleteDocumentById,\n} from '@/services/supabase/documents.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { githubLinkSchema } from '../schemas/document.ts'\nimport { getEnv } from '../lib/env.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { mixpanel } from '../lib/mixpanel.ts'\nimport { getDocumentsWithStorage } from '@/services/supabase/documents.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { saveUsage, UsageInsert } from '@/services/supabase/usage.ts'\nconst github = new Hono()\n\n// Get text from file\ngithub.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await githubLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url } = parsed.data\n\n  const documentId = crypto.randomUUID()\n  const githubUrl = new URL(url)\n\n  const name = githubUrl.pathname.slice(1)\n\n  try {\n    const [{\n      plan_user_id,\n      user_org_id,\n      files,\n      plan_name,\n      user_email,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    // Verify file limits according to plan\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    // Verify if the user has reached any of the plan limits\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const [, res] = await Promise.all([\n      createDocument({\n        fileName: name,\n        documentId,\n        userId: plan_user_id,\n        orgId: user_org_id,\n        fileType: 'repository',\n      }),\n      fetch(`${getEnv('CODEGPT_API_URL')}/convert/github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          url,\n          document_id: documentId,\n        }),\n      }),\n    ])\n    const data = await res.json()\n\n    console.log({ data, res })\n\n    if (!data || !res.ok) {\n      await deleteDocumentById(documentId)\n      const error = data?.detail ?? 'Error uploading document'\n      return c.json({\n        error,\n      }, { status: 500 })\n    }\n\n    const usage: UsageInsert[] = [{\n      type: 'TRAINING',\n      channel: 'PLAYGROUND GITHUB',\n      source: 'API',\n      model: 'text-embedding-ada-002',\n      plan_name: plan_name,\n      embeddings_tokens: data.token_usage,\n      user_id: plan_user_id,\n      org_id: user_org_id,\n    }]\n\n    const body = [\n      {\n        event: 'newFileWithCode',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n          chunks: data.total_chunks,\n          embedding_tokens: data.token_usage,\n        },\n      },\n    ]\n\n    await Promise.all([\n      mixpanel({ body }),\n      saveUsage(usage),\n    ])\n\n    return c.json({ data, documentId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    deleteDocumentById(documentId)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { github }",
    "originFile": "\\routes\\github.ts"
  },
  {
    "id": "\\routes\\gitlab::gitlabApp",
    "language": "typescript",
    "label": "gitlabApp",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\gitlab",
    "totalTokens": 2992,
    "inDegree": 3,
    "outDegree": 5,
    "code": "const gitlabApp = new Hono()\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst gitlabApp = new Hono()\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { gitlabApp }",
    "importStatements": [],
    "codeNoBody": "const gitlabApp = new Hono()\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nconst gitlabApp = new Hono()\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { gitlabApp }",
    "originFile": "\\routes\\gitlab.ts"
  },
  {
    "id": "\\routes\\gitlab",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\gitlab.ts",
    "type": "file",
    "totalTokens": 1590,
    "inDegree": 0,
    "outDegree": 6,
    "code": "// deno-lint-ignore-file\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserInfo } from '@/lib/integrations/gitlab-app/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { refreshAccessToken } from '@/lib/integrations/gitlab-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\n\nconst gitlabApp = new Hono()\n\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\n\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\n\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nexport { gitlabApp }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import axios from 'axios'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { getUserInfo } from '@/lib/integrations/gitlab-app/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { refreshAccessToken } from '@/lib/integrations/gitlab-app/utils.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file\nimport { Hono } from 'hono'\nimport axios from 'axios'\nimport { getEnv } from '@/lib/env.ts'\nimport { getUserInfo } from '@/lib/integrations/gitlab-app/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { refreshAccessToken } from '@/lib/integrations/gitlab-app/utils.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nconst gitlabApp = new Hono()\n\ngitlabApp.get('/auth', async (c) => {\n  try {\n    const url = getEnv('PLAYGROUND_URL')\n    const code = c.req.query('code')\n\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n    const redirectUri = getEnv('GITLAB_REDIRECT_URI')\n\n    const tokenResponse = await axios.post(\n      'https://gitlab.com/oauth/token',\n      {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        client_secret: clientSecret,\n        redirect_uri: redirectUri,\n      },\n      {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    )\n    console.log(tokenResponse.data)\n    const { access_token, refresh_token } = tokenResponse.data\n\n    const { userId, userName, userEmail } = await getUserInfo(access_token)\n\n    const frontendRedirectUrl = new URL(\n      `${url}/api/gitlab/connection/${userId}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('login_name', userName)\n    frontendRedirectUrl.searchParams.append('access_token', access_token)\n    frontendRedirectUrl.searchParams.append('refresh_token', refresh_token)\n    frontendRedirectUrl.searchParams.append('email', userEmail)\n    console.log(frontendRedirectUrl.toString())\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error) {\n    console.error('Error en la autenticación:', error)\n    return c.text('Error en la autenticación', 500)\n  }\n})\n\ngitlabApp.get('/get-repos', async (c) => {\n  try {\n    const id = c.req.query('id')\n    const clientId = getEnv('GITLAB_APP_ID')\n    const clientSecret = getEnv('GITLAB_SECRET_ID')\n\n    const connection = await sql`\n          SELECT * FROM gitlab_connections\n          WHERE id = ${id}\n        `\n\n    if (connection.length === 0) {\n      console.log('No hay ninguna conexión')\n      return new Response(\n        JSON.stringify({ error: 'No se encontró la conexión' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let accessToken = connection[0].access_token\n    const refreshToken = connection[0].refresh_token\n    const url = 'https://gitlab.com/api/v4/projects?membership=true'\n\n    const headers = {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n    }\n\n    let response\n    let isTokenRefreshed = false\n\n    try {\n      response = await axios.get(url, { headers })\n      // console.log(response, 'response pro')\n    } catch (error) {\n      if (\n        error.response && error.response.status === 401 && !isTokenRefreshed\n      ) {\n        // El token de acceso está vencido, intentar renovarlo\n        if (refreshToken) {\n          const { newAccessToken, newRefreshToken } = await refreshAccessToken(\n            refreshToken,\n            clientId,\n            clientSecret,\n          )\n          if (newAccessToken) {\n            // Actualizar el token de acceso en la base de datos\n            await sql`\n                  UPDATE gitlab_connections\n                  SET access_token = ${newAccessToken},\n                      refresh_token = COALESCE(${newRefreshToken}, refresh_token)\n                  WHERE id = ${id}`\n\n            accessToken = newAccessToken\n            headers.Authorization = `Bearer ${accessToken}`\n            isTokenRefreshed = true\n\n            // Intentar la solicitud nuevamente con el token actualizado\n            response = await axios.get(url, { headers })\n          } else {\n            // El token de reinicio también está vencido\n            console.log('El token de reinicio está vencido')\n            return c.text('El token de reinicio está vencido', 401)\n          }\n        } else {\n          // No hay token de reinicio disponible\n          console.log('No hay token de reinicio disponible')\n          return c.text('No hay token de reinicio disponible', 401)\n        }\n      } else {\n        throw error\n      }\n    }\n\n    if (response && response.status === 200) {\n      console.log('repos', response.data)\n      const repos = response.data.map(async (repo: any) => {\n        const branchesUrl =\n          `https://gitlab.com/api/v4/projects/${repo.id}/repository/branches`\n        const branchesResponse = await axios.get(branchesUrl, { headers })\n\n        const branches = branchesResponse.data.map((branch: any) => ({\n          name: branch.name,\n        }))\n\n        return {\n          id: repo.id,\n          name: repo.name,\n          private: repo.visibility === 'private',\n          branches,\n        }\n      })\n\n      const reposWithBranches = await Promise.all(repos)\n\n      return new Response(JSON.stringify(reposWithBranches), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    } else {\n      throw new Error(\n        `Error fetching repos: ${response.status} ${response.statusText}`,\n      )\n    }\n  } catch (error) {\n    console.error('Error en get connections:', error)\n    return c.text(\n      `Error al obtener los tokens de acceso: ${error.message}`,\n      500,\n    )\n  }\n})\n\ngitlabApp.delete('/disconnect', async (c) => {\n  try {\n    const id = c.req.query('id') // Obtener el id de la conexión a eliminar\n\n    if (!id) {\n      return new Response(\n        JSON.stringify({ error: 'El parámetro id es requerido' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n\n    // Eliminar la conexión específica de la tabla gitlab_connections\n    const result = await sql`\n      DELETE FROM gitlab_connections\n      WHERE id = ${id} AND org_id = ${orgId}\n    `\n\n    if (result.count === 0) {\n      return new Response(\n        JSON.stringify({\n          error: 'No se encontró la conexión o no pertenece a la organización',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ message: 'Conexión eliminada exitosamente' }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    )\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nexport { gitlabApp }",
    "originFile": "\\routes\\gitlab.ts"
  },
  {
    "id": "\\routes\\ip::ip",
    "language": "typescript",
    "label": "ip",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\ip",
    "totalTokens": 80,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const ip = new Hono()\nip.get('/', async (c) => {\n  await getAuthorization(c)\n\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nconst ip = new Hono()\nip.get('/', async (c) => {\n  await getAuthorization(c)\n\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nexport { ip }",
    "importStatements": [],
    "codeNoBody": "const ip = new Hono()\nip.get('/', async (c) => {\n  await getAuthorization(c)\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nconst ip = new Hono()\nip.get('/', async (c) => {\n  await getAuthorization(c)\n\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nexport { ip }",
    "originFile": "\\routes\\ip.ts"
  },
  {
    "id": "\\routes\\ip",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\ip.ts",
    "type": "file",
    "totalTokens": 79,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { getIp } from '@/lib/ip.ts'\n\nconst ip = new Hono()\n\n// Get client ip\nip.get('/', async (c) => {\n  await getAuthorization(c)\n\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nexport { ip }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { getIp } from '@/lib/ip.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { getIp } from '@/lib/ip.ts'\nconst ip = new Hono()\n\n// Get client ip\nip.get('/', async (c) => {\n  await getAuthorization(c)\n\n  const ip = getIp(c)\n  return c.json({ ip })\n})\n\nexport { ip }",
    "originFile": "\\routes\\ip.ts"
  },
  {
    "id": "\\routes\\me::me",
    "language": "typescript",
    "label": "me",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\me",
    "totalTokens": 1080,
    "inDegree": 3,
    "outDegree": 8,
    "code": "const me = new Hono()\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nconst me = new Hono()\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nexport { me }",
    "importStatements": [],
    "codeNoBody": "const me = new Hono()\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nconst me = new Hono()\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nexport { me }",
    "originFile": "\\routes\\me.ts"
  },
  {
    "id": "\\routes\\me",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\me.ts",
    "type": "file",
    "totalTokens": 673,
    "inDegree": 0,
    "outDegree": 9,
    "code": "import { Hono } from 'hono'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getOrganization } from '@/services/supabase/organizations.ts'\nimport { getUserProfile } from '@/services/supabase/profiles.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\n\nconst me = new Hono()\n\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nexport { me }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getFreePlan } from '@/services/supabase/plan.ts'",
      "import { redis } from '@/lib/redis.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { getOrganization } from '@/services/supabase/organizations.ts'",
      "import { getUserProfile } from '@/services/supabase/profiles.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'",
      "import { PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { getOrganization } from '@/services/supabase/organizations.ts'\nimport { getUserProfile } from '@/services/supabase/profiles.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nimport { PLAN_TEMP_USAGE_DATE } from '@/lib/consts.ts'\nconst me = new Hono()\n\nme.get('/', async (c) => {\n  const { apiKey, userId, orgId } = await getAuthorization(c, false)\n\n  try {\n    if (!apiKey && !userId) {\n      const freePlan = await getFreePlan()\n\n      if (!freePlan || !freePlan?.status) {\n        return c.json({ message: 'Free Plan is no longer active' }, {\n          status: 410,\n        })\n      }\n\n      const ip = getIp(c)\n      if (!ip) {\n        return c.json(\n          { message: 'There was an error getting the daily usage' },\n          { status: 500 },\n        )\n      }\n\n      const redisKey = `freeChat-${ip}`\n      const freePlanCompletions = await redis.get(redisKey)\n      const completionCount = freePlanCompletions\n        ? Number(freePlanCompletions)\n        : 0\n\n      const completionLimit = freePlan?.trial_daily_interaction_limit ?? 0\n      return c.json({\n        dailyUsage: completionCount,\n        dailyMaxUsage: completionLimit,\n        plan: freePlan.name,\n      })\n    } else {\n      const [{\n        plan_user_id,\n        user_org_id,\n        daily_completion_count,\n        plan_name,\n        user_email,\n        plan_temp_usage,\n        plan_created_at,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      const [userProfile, orgInfo] = await Promise.all([\n        getUserProfile({ userId: plan_user_id }),\n        getOrganization({ orgId: user_org_id }),\n      ])\n      const dailyInteractionsLimit =\n        new Date(plan_created_at) >= PLAN_TEMP_USAGE_DATE &&\n          plan_temp_usage !== -1\n          ? plan_temp_usage\n          : daily_completion_count\n\n      return c.json({\n        dailyUsage: orgInfo?.dailyInteractions ?? -1,\n        dailyMaxUsage: dailyInteractionsLimit ?? -1,\n        user: {\n          username: userProfile.username,\n          fullName: userProfile.full_name,\n          avatarUrl: userProfile.avatar_url,\n          email: user_email,\n          distinct_id: userProfile.distinct_id,\n          status: userProfile.status,\n        },\n        ...(orgInfo?.name\n          ? {\n            org: {\n              name: orgInfo.name,\n              image: orgInfo.image,\n            },\n          }\n          : {}),\n        plan: plan_name,\n      })\n    }\n  } catch (error) {\n    reportError(error)\n    return c.json({ error: 'Server Error, please try again later.' }, 500)\n  }\n})\n\nexport { me }",
    "originFile": "\\routes\\me.ts"
  },
  {
    "id": "\\routes\\metadata::metadata",
    "language": "typescript",
    "label": "metadata",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\metadata",
    "totalTokens": 778,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const metadata = new Hono()\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst metadata = new Hono()\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { metadata }",
    "importStatements": [],
    "codeNoBody": "const metadata = new Hono()\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst metadata = new Hono()\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { metadata }",
    "originFile": "\\routes\\metadata.ts"
  },
  {
    "id": "\\routes\\metadata",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\metadata.ts",
    "type": "file",
    "totalTokens": 432,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { generateMetadata } from '@/lib/ai/metadata.ts'\n\nconst metadata = new Hono()\n\n// Get text from file\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { metadata }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { generateMetadata } from '@/lib/ai/metadata.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { generateMetadata } from '@/lib/ai/metadata.ts'\nconst metadata = new Hono()\n\n// Get text from file\nmetadata.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const contentType = c.req.raw.headers.get('Content-Type')?.split(';')[0]\n  if (\n    !contentType || !['multipart/form-data', 'text/plain'].includes(contentType)\n  ) {\n    return c.json({\n      message: 'Invalid content type sent',\n    }, 400)\n  }\n\n  let file\n  if (contentType === 'multipart/form-data') {\n    const body = await c.req.parseBody()\n    file = body['file'] as File | undefined\n  } else {\n    const content = await c.req.text()\n    file = new File([content], `metadata.txt`, { type: 'text/plain' })\n  }\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  if (file.type !== 'text/plain') {\n    return c.json(\n      { error: 'Invalid file type. Please upload a .txt file' },\n      { status: 400 },\n    )\n  }\n\n  if (file.size > 1024 * 1024 * 2) {\n    return c.json({ error: 'File size exceeds 2MB limit' }, { status: 400 })\n  }\n\n  const text = await file.text()\n  if (!text || typeof text !== 'string') {\n    return c.json(\n      { error: 'Missing text content or sent content is not text' },\n      { status: 400 },\n    )\n  }\n\n  try {\n    const metadata = await generateMetadata(text)\n    return c.json({ metadata }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { metadata }",
    "originFile": "\\routes\\metadata.ts"
  },
  {
    "id": "\\routes\\organizations\\index::organizations",
    "language": "typescript",
    "label": "organizations",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\organizations\\index",
    "totalTokens": 1086,
    "inDegree": 3,
    "outDegree": 5,
    "code": "const organizations = new Hono()\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nconst organizations = new Hono()\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { organizations }",
    "importStatements": [],
    "codeNoBody": "const organizations = new Hono()\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nconst organizations = new Hono()\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { organizations }",
    "originFile": "\\routes\\organizations\\index.ts"
  },
  {
    "id": "\\routes\\organizations\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\organizations\\index.ts",
    "type": "file",
    "totalTokens": 616,
    "inDegree": 0,
    "outDegree": 6,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { supabase } from '@/services/supabase/index.ts'\n\nconst organizations = new Hono()\n\n// Update user's avatar\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { organizations }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization, sendError } from '@/lib/utils.ts'",
      "import { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { supabase } from '@/services/supabase/index.ts'\nconst organizations = new Hono()\n\n// Update user's avatar\norganizations.patch('/:id/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  const orgId = c.req.param('id')\n\n  try {\n    const rows = await sql`\n      SELECT ou.role\n      FROM organization_user ou\n      WHERE ou.org_id = ${orgId}\n    `\n\n    if (rows.length === 0) {\n      return c.json({ message: 'Organization not found' }, 400)\n    }\n\n    const [{ role }] = rows\n\n    if (role !== 'owner') {\n      return c.json(\n        { message: 'You are not the owner of this organization' },\n        400,\n      )\n    }\n\n    const { error } = await supabase.storage.from('org_images').upload(\n      orgId,\n      avatarFile,\n      {\n        cacheControl: '0',\n        upsert: true,\n      },\n    )\n\n    if (error) {\n      console.log({ error })\n      return c.json({ error: error.message }, 400)\n    }\n\n    const { data: signedURL } = supabase.storage.from('org_images')\n      .getPublicUrl(orgId)\n\n    const imageUrl = `${signedURL.publicUrl}?t=${Date.now()}`\n    await sql`UPDATE organizations SET image = ${imageUrl} WHERE id = ${orgId}`\n\n    await supabase.from('onboarding').upsert({ org_id: orgId, org_img: true })\n\n    return c.json({ message: 'Avatar updated successfully' })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { organizations }",
    "originFile": "\\routes\\organizations\\index.ts"
  },
  {
    "id": "\\routes\\slack::slack",
    "language": "typescript",
    "label": "slack",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\slack",
    "totalTokens": 2846,
    "inDegree": 3,
    "outDegree": 10,
    "code": "const slack = new Hono()\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nconst slack = new Hono()\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { slack }",
    "importStatements": [],
    "codeNoBody": "const slack = new Hono()\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nconst slack = new Hono()\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { slack }",
    "originFile": "\\routes\\slack.ts"
  },
  {
    "id": "\\routes\\slack",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\slack.ts",
    "type": "file",
    "totalTokens": 1633,
    "inDegree": 0,
    "outDegree": 11,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport { auth0Callback } from '@/lib/integrations/slack-app/slack/auth0.ts'\nimport { selectWorkspace } from '@/lib/integrations/slack-app/app-flow/init-bot.ts'\nimport {\n  deleteWorkspace,\n  readWorkspaces,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { saveOrUpdateChannel } from '@/lib/integrations/slack-app/slack/services/supabase/channels.ts'\nimport { verificaSlackRequest } from '@/lib/integrations/slack-app/slack/verify-event.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { getAllWorkspacesByOrg } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\n\nconst slack = new Hono()\n\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\n\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { slack }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { auth0Callback } from '@/lib/integrations/slack-app/slack/auth0.ts'",
      "import { selectWorkspace } from '@/lib/integrations/slack-app/app-flow/init-bot.ts'",
      "import {\n  deleteWorkspace,\n  readWorkspaces,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'",
      "import { saveOrUpdateChannel } from '@/lib/integrations/slack-app/slack/services/supabase/channels.ts'",
      "import { verificaSlackRequest } from '@/lib/integrations/slack-app/slack/verify-event.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { getAllWorkspacesByOrg } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport { Hono } from 'hono'\nimport { auth0Callback } from '@/lib/integrations/slack-app/slack/auth0.ts'\nimport { selectWorkspace } from '@/lib/integrations/slack-app/app-flow/init-bot.ts'\nimport {\n  deleteWorkspace,\n  readWorkspaces,\n} from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { saveOrUpdateChannel } from '@/lib/integrations/slack-app/slack/services/supabase/channels.ts'\nimport { verificaSlackRequest } from '@/lib/integrations/slack-app/slack/verify-event.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { getAllWorkspacesByOrg } from '@/lib/integrations/slack-app/slack/services/supabase/workspaces.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nconst slack = new Hono()\n\nslack.get('/oauth/callback', async (c) => {\n  try {\n    const url = c.req.query('state')\n\n    const code = c.req.query('code')\n\n    if (!code) {\n      return new Response('Código de autorización no proporcionado.', {\n        status: 400,\n      })\n    }\n\n    const response = await auth0Callback(code)\n    const frontendRedirectUrl = new URL(\n      `${url}/api/slack/workspaces/${response.team.id}/callback`,\n    )\n\n    frontendRedirectUrl.searchParams.append('name', response.team.name)\n    frontendRedirectUrl.searchParams.append(\n      'slack_token',\n      response.access_token,\n    )\n    frontendRedirectUrl.searchParams.append('bot_user_id', response.bot_user_id)\n\n    return c.redirect(frontendRedirectUrl.toString(), 302)\n  } catch (error: any) {\n    console.error('Error en el intercambio de código de OAuth:', error)\n    // res.status(500).send('Error en la autenticación de OAuth.')\n  }\n})\n\nslack.post('/events', async (c) => {\n  try {\n    const rawBody = await c.req.arrayBuffer()\n    const bodyText = new TextDecoder().decode(rawBody)\n\n    const isValidRequest = await verificaSlackRequest(\n      bodyText,\n      c.req.raw.headers.get('X-Slack-Request-Timestamp'),\n      c.req.raw.headers.get('X-Slack-Signature'),\n    )\n\n    if (!isValidRequest) {\n      throw new Error('Verification failed: Invalid signature.')\n    }\n\n    const contentType = c.req.header('Content-Type')\n    let slackEvent\n\n    if (contentType?.includes('application/json')) {\n      slackEvent = JSON.parse(bodyText)\n    } else if (contentType?.includes('application/x-www-form-urlencoded')) {\n      slackEvent = Object.fromEntries(new URLSearchParams(bodyText))\n    } else if (contentType?.includes('text/plain')) {\n      slackEvent = bodyText\n    } else {\n      throw new Error(`Unsupported Content-Type: ${contentType}`)\n    }\n\n    if (slackEvent && slackEvent.challenge) {\n      return c.json({ challenge: slackEvent.challenge })\n    }\n\n    await selectWorkspace(slackEvent, c)\n\n    return c.text('', { status: 200 })\n  } catch (error) {\n    console.error('Error processing Slack message:', error)\n    reportError(error)\n    return c.text('Error processing Slack message', { status: 500 })\n  }\n})\nslack.delete('/disconnect-bot', async (c) => {\n  try {\n    let { apiKey, orgId, userId } = await getAuthorization(c)\n    const workspaceIdToDelete = c.req.query('id')\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    orgId = resp[0].user_org_id as string\n    const allWorkspaces = await getAllWorkspacesByOrg(orgId as string)\n    const revocationResults = []\n    const successfulWorkspaceIds = []\n\n    for (const workspace of allWorkspaces) {\n      const botToken = await readWorkspaces(\n        workspace.id as string,\n        orgId as string,\n      )\n\n      const response = await fetch('https://slack.com/api/auth.revoke', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': `Bearer ${botToken?.access_token}`,\n        },\n      })\n\n      const result = await response.json()\n      revocationResults.push({\n        workspaceId: workspace.id,\n        revocationResult: result,\n      })\n      if (result.ok) {\n        successfulWorkspaceIds.push(workspace.id)\n      }\n    }\n\n    if (successfulWorkspaceIds.length > 0) {\n      for (const workspaceId of successfulWorkspaceIds) {\n        if (workspaceId === workspaceIdToDelete) {\n          await deleteWorkspace(workspaceId)\n        }\n      }\n    }\n\n    await sql`\n      DELETE FROM marketplace_apps_favorites\n        WHERE app_id = 1\n          AND org_id = ${orgId}\n    `\n\n    return new Response(JSON.stringify(revocationResults), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar el bot`,\n      { status: 500 },\n    )\n  }\n})\nslack.get('/search-channels', async (c) => {\n  try {\n    const id = c.req.query('id')\n\n    const { apiKey, orgId, userId } = await getAuthorization(c)\n\n    const resp =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const botToken = await readWorkspaces(\n      id as string,\n      resp[0].user_org_id as string,\n    )\n\n    if (!botToken) {\n      throw new Error(\n        'Bot token no encontrado para el ID del workspace proporcionado',\n      )\n    }\n\n    const response = await fetch('https://slack.com/api/conversations.list', {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${botToken.access_token}`,\n      },\n    })\n\n    const result = await response.json() // Conviertes la respuesta en JSON\n\n    if (result.ok) {\n      const channelsSimplified = result.channels.map((channel: any) => ({\n        id: channel.id,\n        name: channel.name,\n      }))\n      const payload = {\n        channels: channelsSimplified,\n      }\n\n      return new Response(JSON.stringify(payload), { status: 200 })\n    } else {\n      return new Response(`Error al buscar los canales: ${result.error}`, {\n        status: 400,\n      })\n    }\n  } catch (error) {\n    console.error('Error al buscar canales:', error)\n    return new Response(\n      `Error interno del servidor al buscar canales`,\n      { status: 500 },\n    )\n  }\n})\nslack.post('/save-config', async (c) => { // probablemente se vaya de borrada, no se está usando, front guarda solo.\n  try {\n    const payload = await c.req.json()\n    await saveOrUpdateChannel(\n      payload.agent_id,\n      payload.channel_id,\n      payload.workspace_id,\n      payload.channel_name,\n    )\n\n    return new Response(JSON.stringify('configuración guardada con exito'), {\n      status: 200,\n    })\n  } catch (error) {\n    console.error('Error al intentar desconectar el bot:', error)\n    return new Response(\n      `Error interno del servidor al intentar desconectar guardar la configuración`,\n      { status: 500 },\n    )\n  }\n})\n\nexport { slack }",
    "originFile": "\\routes\\slack.ts"
  },
  {
    "id": "\\routes\\telemetry::telemetry",
    "language": "typescript",
    "label": "telemetry",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\telemetry",
    "totalTokens": 714,
    "inDegree": 3,
    "outDegree": 6,
    "code": "const telemetry = new Hono()\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst telemetry = new Hono()\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { telemetry }",
    "importStatements": [],
    "codeNoBody": "const telemetry = new Hono()\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nconst telemetry = new Hono()\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { telemetry }",
    "originFile": "\\routes\\telemetry.ts"
  },
  {
    "id": "\\routes\\telemetry",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\telemetry.ts",
    "type": "file",
    "totalTokens": 452,
    "inDegree": 0,
    "outDegree": 7,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\n\nconst telemetry = new Hono()\n\n// Get text from file\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { telemetry }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { getFreePlan } from '@/services/supabase/plan.ts'",
      "import { getIp } from '@/lib/ip.ts'",
      "import { mixpanel } from '@/lib/mixpanel.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { getFreePlan } from '@/services/supabase/plan.ts'\nimport { getIp } from '@/lib/ip.ts'\nimport { mixpanel } from '@/lib/mixpanel.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nconst telemetry = new Hono()\n\n// Get text from file\ntelemetry.post('/', async (c) => {\n  try {\n    const body = await c.req.json()\n    const freePlan = await getFreePlan()\n    const source = c.req.header('source') ?? 'vscode'\n\n    try {\n      const { userId, apiKey, orgId } = await getAuthorization(c)\n\n      const [{\n        user_email,\n        plan_name,\n        distinct_id,\n      }] =\n        await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n      body[0].properties.distinct_id = distinct_id\n      body[0].properties.plan = plan_name\n      body[0].properties.email = user_email\n    } catch (_error) {\n      body[0].properties.plan = freePlan?.name\n    }\n\n    body[0].properties.ip ??= getIp(c)\n\n    // deno-lint-ignore no-explicit-any\n    const userCreatedEvent = body.find((item: any) =>\n      item.event === 'userCreated'\n    )\n\n    if (userCreatedEvent) {\n      body.push({\n        event: 'changePlan',\n        properties: {\n          distinct_id: userCreatedEvent.properties.distinct_id,\n          newPlan: 'Free',\n          previousPlan: null,\n          periodicity: null,\n          price: null,\n          planStatus: 'free',\n          userType: 'anonymous',\n          previousStatus: null,\n        },\n      })\n    }\n\n    await mixpanel({ body, source })\n\n    return c.json({ message: 'Success' })\n  } catch (error) {\n    console.error(error)\n    reportError(error)\n\n    return c.json({ error: error.message }, 500)\n  }\n})\n\nexport { telemetry }",
    "originFile": "\\routes\\telemetry.ts"
  },
  {
    "id": "\\routes\\text::text",
    "language": "typescript",
    "label": "text",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\text",
    "totalTokens": 732,
    "inDegree": 3,
    "outDegree": 3,
    "code": "const text = new Hono()\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nconst text = new Hono()\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nexport { text }",
    "importStatements": [],
    "codeNoBody": "const text = new Hono()\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nconst text = new Hono()\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nexport { text }",
    "originFile": "\\routes\\text.ts"
  },
  {
    "id": "\\routes\\text",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\text.ts",
    "type": "file",
    "totalTokens": 410,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization, getTextFromFile } from '@/lib/utils.ts'\nimport { getConvertedText } from '@/lib/utils.ts'\n\nconst text = new Hono()\n\n// Get text from file\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nexport { text }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization, getTextFromFile } from '@/lib/utils.ts'",
      "import { getConvertedText } from '@/lib/utils.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization, getTextFromFile } from '@/lib/utils.ts'\nimport { getConvertedText } from '@/lib/utils.ts'\nconst text = new Hono()\n\n// Get text from file\ntext.post('/', async (c) => {\n  await getAuthorization(c)\n\n  const body = await c.req.parseBody()\n\n  const file = body['file'] as File | undefined\n\n  if (!file) {\n    return c.json({ error: 'Missing file' }, { status: 400 })\n  }\n\n  // if file exceed 20MB or startsWith('text/') and exceeds 2MB\n  if (\n    file.size > 1024 * 1024 * 20 ||\n    (file.type.startsWith('text/') && file.size > 1024 * 1024 * 2)\n  ) {\n    return c.json({ error: 'File size exceeded size' }, { status: 400 })\n  }\n\n  try {\n    const { content, name, type, jobId } = await getTextFromFile(file)\n\n    return c.json({ content, name, type, jobId }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\ntext.get('/:id', async (c) => {\n  await getAuthorization(c)\n\n  const jobId = c.req.param('id')\n\n  if (!jobId) {\n    return c.json({ error: 'Missing jobId' }, { status: 400 })\n  }\n\n  try {\n    const { content, status, code } = await getConvertedText(jobId)\n    return c.json({ content, status }, { status: code })\n  } catch (error) {\n    console.log('Error getting converted text', error)\n    return c.json({ error: 'Error getting converted text' }, { status: 500 })\n  }\n})\n\nexport { text }",
    "originFile": "\\routes\\text.ts"
  },
  {
    "id": "\\routes\\usage",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\usage.ts",
    "type": "file",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "code": "",
    "importStatements": [],
    "codeNoBody": "",
    "originFile": "\\routes\\usage.ts"
  },
  {
    "id": "\\routes\\user::user",
    "language": "typescript",
    "label": "user",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\user",
    "totalTokens": 1174,
    "inDegree": 3,
    "outDegree": 4,
    "code": "const user = new Hono()\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nconst user = new Hono()\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { user }",
    "importStatements": [],
    "codeNoBody": "const user = new Hono()\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nconst user = new Hono()\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { user }",
    "originFile": "\\routes\\user.ts"
  },
  {
    "id": "\\routes\\user",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\user.ts",
    "type": "file",
    "totalTokens": 672,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Hono } from 'hono'\nimport { sql } from '../lib/db/index.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { userUpdateSchema } from '@/schemas/user.ts'\nimport { updateAvatar } from '../services/supabase/profiles.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\n\nconst user = new Hono()\n\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update user's avatar\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { user }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sql } from '../lib/db/index.ts'",
      "import { getAuthorization, sendError } from '@/lib/utils.ts'",
      "import { userUpdateSchema } from '@/schemas/user.ts'",
      "import { updateAvatar } from '../services/supabase/profiles.ts'",
      "import { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sql } from '../lib/db/index.ts'\nimport { getAuthorization, sendError } from '@/lib/utils.ts'\nimport { userUpdateSchema } from '@/schemas/user.ts'\nimport { updateAvatar } from '../services/supabase/profiles.ts'\nimport { ACCEPTED_IMAGE_FILES } from '@/lib/consts.ts'\nconst user = new Hono()\n\nuser.get('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  try {\n    const user =\n      await sql`SELECT * FROM get_user_data_by_api_key_or_user_id(${apiKey}, ${userId})`\n\n    if (!user) {\n      return c.json({ message: 'User not found' }, 404)\n    }\n\n    return c.json(user)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nuser.patch('/', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const json = await c.req.json()\n\n  const parsed = await userUpdateSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const user = parsed.data\n\n  try {\n    const userData = {\n      ...user,\n      ...(user?.username ? { username: user.username.toLowerCase() } : {}),\n    }\n\n    const [{ plan_user_id: validUserId }] =\n      await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n    const [userUpdated] = await sql`UPDATE profiles SET ${\n      sql(\n        userData,\n      )\n    } WHERE id = ${validUserId} RETURNING username, full_name, avatar_url`\n\n    return c.json(userUpdated)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\n// Update user's avatar\nuser.patch('/avatar', async (c) => {\n  const { apiKey, userId } = await getAuthorization(c)\n\n  const [{ plan_user_id: validUserId }] =\n    await sql`SELECT * FROM get_plan_limits(${null}, ${apiKey}, ${userId})`\n\n  if (!validUserId) {\n    return c.json({ message: 'Invalid api key or user id' }, 400)\n  }\n\n  const body = await c.req.parseBody()\n  const avatarFile = body?.file as File\n\n  if (!avatarFile) {\n    return c.json({ message: 'Image file not found' }, 400)\n  }\n  const isAcceptedImage = ACCEPTED_IMAGE_FILES.includes(\n    avatarFile.type.split('/')[1],\n  )\n\n  if (!isAcceptedImage) {\n    return c.json({ message: 'Invalid image type' }, 400)\n  }\n\n  if (avatarFile.size > 1024 * 1024 * 2) {\n    return c.json({ message: 'Image file too large' }, 400)\n  }\n\n  try {\n    const { url } = await updateAvatar(avatarFile, validUserId)\n    return c.json({ message: 'Avatar updated successfully', url })\n  } catch (error) {\n    console.log('Error updating avatar:', error)\n    return sendError(error, c)\n  }\n})\n\nexport { user }",
    "originFile": "\\routes\\user.ts"
  },
  {
    "id": "\\routes\\vscode\\index::cancel",
    "language": "typescript",
    "label": "cancel",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\vscode\\index",
    "totalTokens": 12,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const cancel = () => {\n    channel.close()\n  }",
    "importStatements": [],
    "codeNoBody": "const cancel = () => {\n  //...\n  }",
    "originFile": "\\routes\\vscode\\index.ts"
  },
  {
    "id": "\\routes\\vscode\\index::start",
    "language": "typescript",
    "label": "start",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\vscode\\index",
    "totalTokens": 63,
    "inDegree": 3,
    "outDegree": 0,
    "code": "const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }",
    "importStatements": [],
    "codeNoBody": "const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }",
    "originFile": "\\routes\\vscode\\index.ts"
  },
  {
    "id": "\\routes\\vscode\\index::vscode",
    "language": "typescript",
    "label": "vscode",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\vscode\\index",
    "totalTokens": 516,
    "inDegree": 3,
    "outDegree": 2,
    "code": "const vscode = new Hono()\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nconst vscode = new Hono()\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { vscode }",
    "importStatements": [],
    "codeNoBody": "const vscode = new Hono()\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nconst vscode = new Hono()\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { vscode }",
    "originFile": "\\routes\\vscode\\index.ts"
  },
  {
    "id": "\\routes\\vscode\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\vscode\\index.ts",
    "type": "file",
    "totalTokens": 270,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Hono } from 'hono'\n\nconst vscode = new Hono()\n\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n    controller.enqueue('retry 1000\\n\\n')\n\n    channel.onmessage = (event) => {\n      controller.enqueue(`data: ${JSON.stringify(event.data)}\\n\\n`)\n      channel.close()\n      controller.close()\n    }\n  }\n\n  const cancel = () => {\n    channel.close()\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { vscode }\n",
    "importStatements": [
      "import { Hono } from 'hono'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nconst vscode = new Hono()\n\nvscode.get('/connection/:id', (c) => {\n  const id = c.req.param('id')\n  const channel = new BroadcastChannel(`vscode-${id}`)\n\n  const start = (controller: ReadableStreamDefaultController) => {\n  //...\n  }\n\n  const cancel = () => {\n  //...\n  }\n\n  const body = new ReadableStream({ start, cancel })\n  const response = body.pipeThrough(new TextEncoderStream())\n\n  return new Response(response, {\n    headers: {\n      'content-type': 'text/event-stream',\n      'cache-control': 'no-cache',\n    },\n  })\n})\n\nvscode.post('/connection/:id', async (c) => {\n  const id = c.req.param('id')\n  const json = await c.req.json()\n  const channel = new BroadcastChannel(`vscode-${id}`)\n  channel.postMessage(json)\n  setTimeout(() => {\n    channel.close()\n  }, 5)\n\n  return c.json({ ok: true })\n})\n\nexport { vscode }",
    "originFile": "\\routes\\vscode\\index.ts"
  },
  {
    "id": "\\routes\\web::web",
    "language": "typescript",
    "label": "web",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\web",
    "totalTokens": 1198,
    "inDegree": 3,
    "outDegree": 5,
    "code": "const web = new Hono()\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst web = new Hono()\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { web }",
    "importStatements": [],
    "codeNoBody": "const web = new Hono()\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nconst web = new Hono()\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { web }",
    "originFile": "\\routes\\web.ts"
  },
  {
    "id": "\\routes\\web",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\web.ts",
    "type": "file",
    "totalTokens": 703,
    "inDegree": 0,
    "outDegree": 6,
    "code": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { webLinkSchema } from '@/schemas/document.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { mixpanel } from '../lib/mixpanel.ts'\nimport { getDocumentsWithStorage } from '../services/supabase/documents.ts'\nimport { getIp } from '@/lib/ip.ts'\n\nconst web = new Hono()\n\n// Get text from file\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { web }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { getAuthorization } from '@/lib/utils.ts'",
      "import { webLinkSchema } from '@/schemas/document.ts'",
      "import { getEnv } from '@/lib/env.ts'",
      "import { sql } from '@/lib/db/index.ts'",
      "import { mixpanel } from '../lib/mixpanel.ts'",
      "import { getDocumentsWithStorage } from '../services/supabase/documents.ts'",
      "import { getIp } from '@/lib/ip.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { getAuthorization } from '@/lib/utils.ts'\nimport { webLinkSchema } from '@/schemas/document.ts'\nimport { getEnv } from '@/lib/env.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { mixpanel } from '../lib/mixpanel.ts'\nimport { getDocumentsWithStorage } from '../services/supabase/documents.ts'\nimport { getIp } from '@/lib/ip.ts'\nconst web = new Hono()\n\n// Get text from file\nweb.post('/', async (c) => {\n  const { orgId, apiKey, userId } = await getAuthorization(c)\n  const accessToken = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  const json = await c.req.json()\n\n  const parsed = await webLinkSchema.spa(json)\n\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.issues }, 400)\n  }\n\n  const { url: urlParam } = parsed.data\n  let url = urlParam as string\n\n  // if a YouTube video get the video id\n  const youtubeRegex =\n    /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtu\\.be)\\/(?:watch\\?v=)?(.+)/\n  const youtubeMatch = url.match(youtubeRegex)\n  if (youtubeMatch) {\n    const videoId = youtubeMatch[1]\n    url = `https://www.youtube.com/watch?v=${videoId as string}`\n  }\n\n  try {\n    const [{\n      user_org_id,\n      files,\n      user_email,\n      plan_name,\n      distinct_id,\n    }] =\n      await sql`SELECT * FROM get_plan_limits(${orgId}, ${apiKey}, ${userId})`\n\n    const documentsWithStorage = await getDocumentsWithStorage({\n      orgId: user_org_id,\n    })\n\n    const fileLimit = Number(files)\n    if (documentsWithStorage?.length) {\n      const unlimitedFiles = fileLimit === -1\n      if (!unlimitedFiles && documentsWithStorage?.length >= fileLimit) {\n        return c.json({ error: 'File limit reached' }, 403)\n      }\n    }\n\n    const res = await fetch(`${getEnv('CODEGPT_API_URL')}/convert/website`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url,\n      }),\n    })\n\n    if (!res.ok) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const data = await res.json()\n\n    if (!data) {\n      return c.json({ error: 'Error uploading document' }, { status: 500 })\n    }\n\n    const body = [\n      {\n        event: 'newFileFromWeb',\n        properties: {\n          email: user_email,\n          plan: plan_name,\n          distinct_id,\n          ip: getIp(c),\n          source: userId ? 'Playground2' : 'API',\n        },\n      },\n    ]\n\n    await mixpanel({ body })\n    return c.json({ data }, { status: 200 })\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    return c.json({ error: 'Error uploading document' }, { status: 500 })\n  }\n})\n\nexport { web }",
    "originFile": "\\routes\\web.ts"
  },
  {
    "id": "\\routes\\webhooks\\models::modelsPricing",
    "language": "typescript",
    "label": "modelsPricing",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\webhooks\\models",
    "totalTokens": 492,
    "inDegree": 3,
    "outDegree": 4,
    "code": "const modelsPricing = new Hono()\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst modelsPricing = new Hono()\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { modelsPricing }",
    "importStatements": [],
    "codeNoBody": "const modelsPricing = new Hono()\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst modelsPricing = new Hono()\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { modelsPricing }",
    "originFile": "\\routes\\webhooks\\models.ts"
  },
  {
    "id": "\\routes\\webhooks\\models",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\webhooks\\models.ts",
    "type": "file",
    "totalTokens": 305,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { Hono } from 'hono'\nimport { sendError } from '@/lib/utils.ts'\nimport { EventSchema } from '@/schemas/models_pricing.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { getEnv } from '@/lib/env.ts'\n\nconst modelsPricing = new Hono()\n\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { modelsPricing }\n",
    "importStatements": [
      "import { Hono } from 'hono'",
      "import { sendError } from '@/lib/utils.ts'",
      "import { EventSchema } from '@/schemas/models_pricing.ts'",
      "import { redis } from '@/lib/redis.ts'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { Hono } from 'hono'\nimport { sendError } from '@/lib/utils.ts'\nimport { EventSchema } from '@/schemas/models_pricing.ts'\nimport { redis } from '@/lib/redis.ts'\nimport { getEnv } from '@/lib/env.ts'\nconst modelsPricing = new Hono()\n\nmodelsPricing.post('/', async (c) => {\n  try {\n    const secretKey = getEnv('PLAYGROUND_SECRET_KEY')\n\n    const json = await c.req.json()\n\n    const parsed = await EventSchema.spa(json)\n\n    if (!parsed.success) {\n      return c.json({ error: parsed.error.issues }, 400)\n    }\n\n    const modelPricingTableEvent = parsed.data\n\n    const secretKeyFromHeader = c.req.header('Secret-Key')\n    if (!secretKeyFromHeader || secretKeyFromHeader !== secretKey) {\n      return c.json({ message: 'Invalid request' }, 403)\n    }\n\n    const { type, record, old_record } = modelPricingTableEvent\n    const { name, input, output } = record ?? old_record ?? {}\n    switch (type) {\n      case 'DELETE':\n        await redis.del(`modelCost-${name}`)\n        break\n      default:\n        await redis.set(`modelCost-${name}`, { input, output })\n    }\n\n    return c.json({ received: true })\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { modelsPricing }",
    "originFile": "\\routes\\webhooks\\models.ts"
  },
  {
    "id": "\\routes\\widgets\\index::widgets",
    "language": "typescript",
    "label": "widgets",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\widgets\\index",
    "totalTokens": 340,
    "inDegree": 3,
    "outDegree": 3,
    "code": "const widgets = new Hono()\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst widgets = new Hono()\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgets }",
    "importStatements": [],
    "codeNoBody": "const widgets = new Hono()\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nconst widgets = new Hono()\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgets }",
    "originFile": "\\routes\\widgets\\index.ts"
  },
  {
    "id": "\\routes\\widgets\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\routes\\widgets\\index.ts",
    "type": "file",
    "totalTokens": 222,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { sendError } from '@/lib/utils.ts'\nimport { Hono } from 'hono'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { sql } from '@/lib/db/index.ts'\n\nconst widgets = new Hono()\n\n// Get an Agent by id\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgets }\n",
    "importStatements": [
      "import { sendError } from '@/lib/utils.ts'",
      "import { Hono } from 'hono'",
      "import { uuidSchema } from '@/schemas/index.ts'",
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { sendError } from '@/lib/utils.ts'\nimport { Hono } from 'hono'\nimport { uuidSchema } from '@/schemas/index.ts'\nimport { sql } from '@/lib/db/index.ts'\nconst widgets = new Hono()\n\n// Get an Agent by id\nwidgets.get('/:id/agent', async (c) => {\n  const id = c.req.param('id')\n\n  const { success } = uuidSchema.safeParse(id)\n\n  if (!success) {\n    return c.json({ message: 'Invalid agent id' }, 400)\n  }\n\n  try {\n    const [agent] = await sql`\n      select \n        a.id,\n        a.name,\n        a.image\n      from widgets \n      join agents a on a.id = widgets.agent_id  \n      where widgets.id = ${id}\n    `\n\n    if (!agent) {\n      return c.json({ message: 'Agent not found' }, 404)\n    }\n\n    return c.json(agent)\n  } catch (error) {\n    return sendError(error, c)\n  }\n})\n\nexport { widgets }",
    "originFile": "\\routes\\widgets\\index.ts"
  },
  {
    "id": "\\schemas\\agent::agentDocumentsValidator",
    "language": "typescript",
    "label": "agentDocumentsValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 29,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const agentDocumentsValidator = zValidator(\n  'json',\n  z.object({\n    agent_documents: z.array(z.string()),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const agentDocumentsValidator = zValidator(\n  'json',\n  z.object({\n    agent_documents: z.array(z.string()),\n  }),\n)",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::agentDocumentsSchema",
    "language": "typescript",
    "label": "agentDocumentsSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 19,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const agentDocumentsSchema = z.object({\n  agent_documents: z.array(z.string()),\n})",
    "importStatements": [],
    "codeNoBody": "export const agentDocumentsSchema = z.object({\n  agent_documents: z.array(z.string()),\n})",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::agentCreateValidator",
    "language": "typescript",
    "label": "agentCreateValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 78,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const agentCreateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const agentCreateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n  }),\n)",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::agentCreateSchema",
    "language": "typescript",
    "label": "agentCreateSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 68,
    "inDegree": 3,
    "outDegree": 1,
    "code": "export const agentCreateSchema = z.object({\n  name: z.string(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const agentCreateSchema = z.object({\n  name: z.string(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n})",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::agentUpdateValidator",
    "language": "typescript",
    "label": "agentUpdateValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 98,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const agentUpdateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string().optional(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n    is_public: z.boolean().optional(),\n    pincode: z.string().optional(),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const agentUpdateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string().optional(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n    is_public: z.boolean().optional(),\n    pincode: z.string().optional(),\n  }),\n)",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::agentUpdateSchema",
    "language": "typescript",
    "label": "agentUpdateSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 88,
    "inDegree": 3,
    "outDegree": 1,
    "code": "export const agentUpdateSchema = z.object({\n  name: z.string().optional(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n  is_public: z.boolean().optional(),\n  pincode: z.string().optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const agentUpdateSchema = z.object({\n  name: z.string().optional(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n  is_public: z.boolean().optional(),\n  pincode: z.string().optional(),\n})",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent::premiumModels",
    "language": "typescript",
    "label": "premiumModels",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent",
    "totalTokens": 73,
    "inDegree": 5,
    "outDegree": 0,
    "code": "export const premiumModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'claude-2.1',\n  'claude-instant-1.2',\n  'gpt-4-turbo',\n] as const",
    "importStatements": [],
    "codeNoBody": "export const premiumModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'claude-2.1',\n  'claude-instant-1.2',\n  'gpt-4-turbo',\n] as const",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\agent",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\agent.ts",
    "type": "file",
    "totalTokens": 474,
    "inDegree": 0,
    "outDegree": 7,
    "code": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\n\nexport const premiumModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'claude-2.1',\n  'claude-instant-1.2',\n  'gpt-4-turbo',\n] as const\n\nexport const agentUpdateSchema = z.object({\n  name: z.string().optional(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n  is_public: z.boolean().optional(),\n  pincode: z.string().optional(),\n})\n\nexport const agentUpdateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string().optional(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n    is_public: z.boolean().optional(),\n    pincode: z.string().optional(),\n  }),\n)\n\nexport const agentCreateSchema = z.object({\n  name: z.string(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n})\n\nexport const agentCreateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n  }),\n)\n\nexport const agentDocumentsSchema = z.object({\n  agent_documents: z.array(z.string()),\n})\n\nexport const agentDocumentsValidator = zValidator(\n  'json',\n  z.object({\n    agent_documents: z.array(z.string()),\n  }),\n)\n",
    "importStatements": [
      "import { zValidator } from '@hono/zod-validator'",
      "import z from 'zod'"
    ],
    "codeNoBody": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\nexport const premiumModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'claude-2.1',\n  'claude-instant-1.2',\n  'gpt-4-turbo',\n] as const\n\nexport const agentUpdateSchema = z.object({\n  name: z.string().optional(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n  is_public: z.boolean().optional(),\n  pincode: z.string().optional(),\n})\n\nexport const agentUpdateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string().optional(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n    is_public: z.boolean().optional(),\n    pincode: z.string().optional(),\n  }),\n)\n\nexport const agentCreateSchema = z.object({\n  name: z.string(),\n  model: z.enum(premiumModels).optional(),\n  temperature: z.number().min(0).max(1).optional(),\n  prompt: z.string().optional(),\n  topk: z.number().optional(),\n  welcome: z.string().optional(),\n})\n\nexport const agentCreateValidator = zValidator(\n  'json',\n  z.object({\n    name: z.string(),\n    model: z.enum(premiumModels).optional(),\n    temperature: z.number().min(0).max(1).optional(),\n    prompt: z.string().optional(),\n    topk: z.number().optional(),\n    welcome: z.string().optional(),\n  }),\n)\n\nexport const agentDocumentsSchema = z.object({\n  agent_documents: z.array(z.string()),\n})\n\nexport const agentDocumentsValidator = zValidator(\n  'json',\n  z.object({\n    agent_documents: z.array(z.string()),\n  }),\n)",
    "originFile": "\\schemas\\agent.ts"
  },
  {
    "id": "\\schemas\\chat::autocompleteValidator",
    "language": "typescript",
    "label": "autocompleteValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 110,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const autocompleteValidator = zValidator(\n  'json',\n  z.object({\n    prompt: z.string(),\n    maxTokens: z.number().min(0),\n    temperature: z.number().min(0).max(1),\n    stop: z.array(z.string()).or(z.string().min(1)).optional(),\n    suffix: z.string().optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const autocompleteValidator = zValidator(\n  'json',\n  z.object({\n    prompt: z.string(),\n    maxTokens: z.number().min(0),\n    temperature: z.number().min(0).max(1),\n    stop: z.array(z.string()).or(z.string().min(1)).optional(),\n    suffix: z.string().optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::autocompleteSchema",
    "language": "typescript",
    "label": "autocompleteSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 66,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const autocompleteSchema = z.object({\n  prompt: z.string(),\n  maxTokens: z.number().min(0),\n  temperature: z.number().min(0).max(1),\n  stop: z.array(z.string()).or(z.string().min(1)).optional(),\n  suffix: z.string().optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const autocompleteSchema = z.object({\n  prompt: z.string(),\n  maxTokens: z.number().min(0),\n  temperature: z.number().min(0).max(1),\n  stop: z.array(z.string()).or(z.string().min(1)).optional(),\n  suffix: z.string().optional(),\n})",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::noSessionChatValidator",
    "language": "typescript",
    "label": "noSessionChatValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 149,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const noSessionChatValidator = zValidator(\n  'json',\n  z.object({\n    stream: z.boolean().optional().default(true),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    agentId: z.string().min(1).optional(),\n    userId: z.string().min(1).optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const noSessionChatValidator = zValidator(\n  'json',\n  z.object({\n    stream: z.boolean().optional().default(true),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    agentId: z.string().min(1).optional(),\n    userId: z.string().min(1).optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::noSessionChatSchema",
    "language": "typescript",
    "label": "noSessionChatSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 165,
    "inDegree": 3,
    "outDegree": 1,
    "code": "export const noSessionChatSchema = z.object({\n  stream: z.boolean().optional().default(true),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  agentId: z.string().min(1).optional(),\n  userId: z.string().min(1).optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const noSessionChatSchema = z.object({\n  stream: z.boolean().optional().default(true),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  agentId: z.string().min(1).optional(),\n  userId: z.string().min(1).optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateValidatorWidget",
    "language": "typescript",
    "label": "messageCreateValidatorWidget",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 188,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const messageCreateValidatorWidget = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(true),\n    widgetId: z.string().uuid(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.widgetId,\n      'widgetId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const messageCreateValidatorWidget = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(true),\n    widgetId: z.string().uuid(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.widgetId,\n      'widgetId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateWidgetSchema",
    "language": "typescript",
    "label": "messageCreateWidgetSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 144,
    "inDegree": 3,
    "outDegree": 1,
    "code": "export const messageCreateWidgetSchema = z.object({\n  ip: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(true),\n  widgetId: z.string().uuid(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().min(1),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  statusId: z.string().uuid().optional(),\n}).partial()\n  .refine(\n    (data) => !!data.widgetId,\n    'widgetId should be filled in.',\n  )",
    "importStatements": [],
    "codeNoBody": "export const messageCreateWidgetSchema = z.object({\n  ip: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(true),\n  widgetId: z.string().uuid(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().min(1),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  statusId: z.string().uuid().optional(),\n}).partial()\n  .refine(\n    (data) => !!data.widgetId,\n    'widgetId should be filled in.',\n  )",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateValidatorShareAgent",
    "language": "typescript",
    "label": "messageCreateValidatorShareAgent",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 226,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const messageCreateValidatorShareAgent = zValidator(\n  'json',\n  z.object({\n    channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n      'PLAYGROUND SHARE AGENT',\n    ),\n    ip: z.string().optional(),\n    pincode: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(false),\n    agentId: z.string().uuid().optional(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agentId,\n      'agentId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const messageCreateValidatorShareAgent = zValidator(\n  'json',\n  z.object({\n    channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n      'PLAYGROUND SHARE AGENT',\n    ),\n    ip: z.string().optional(),\n    pincode: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(false),\n    agentId: z.string().uuid().optional(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agentId,\n      'agentId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateShareAgentSchema",
    "language": "typescript",
    "label": "messageCreateShareAgentSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 242,
    "inDegree": 5,
    "outDegree": 1,
    "code": "export const messageCreateShareAgentSchema = z.object({\n  channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n    'PLAYGROUND SHARE AGENT',\n  ),\n  ip: z.string().optional(),\n  pincode: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(false),\n  agentId: z.string().uuid().optional(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agentId,\n    'agentId should be filled in.',\n  )",
    "importStatements": [],
    "codeNoBody": "export const messageCreateShareAgentSchema = z.object({\n  channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n    'PLAYGROUND SHARE AGENT',\n  ),\n  ip: z.string().optional(),\n  pincode: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(false),\n  agentId: z.string().uuid().optional(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agentId,\n    'agentId should be filled in.',\n  )",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::noAgentCompletionValidation",
    "language": "typescript",
    "label": "noAgentCompletionValidation",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 56,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const noAgentCompletionValidation = zValidator(\n  'json',\n  noAgentCompletionValidationSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const noAgentCompletionValidation = zValidator(\n  'json',\n  noAgentCompletionValidationSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::NoAgentCompletionValidationType",
    "language": "typescript",
    "label": "NoAgentCompletionValidationType",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 20,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type NoAgentCompletionValidationType = z.infer<\n  typeof noAgentCompletionValidationSchema\n>",
    "importStatements": [],
    "codeNoBody": "type NoAgentCompletionValidationType = z.infer<\n  typeof noAgentCompletionValidationSchema\n>",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::noAgentCompletionValidationSchema",
    "language": "typescript",
    "label": "noAgentCompletionValidationSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 267,
    "inDegree": 4,
    "outDegree": 2,
    "code": "export const noAgentCompletionValidationSchema = z.object({\n  ip: z.string().optional(),\n  model: z.enum(openaiModels).optional().default('gpt-3.5-turbo'),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.union([\n          z.string().optional(),\n          z.array(\n            z.object({\n              type: z.enum(['text', 'image_url']),\n              text: z.string().optional(),\n              image_url: z.object({\n                url: z.string().optional(),\n                detail: z.enum(['low', 'high']).optional().default('low'),\n              }).optional(),\n            }),\n          ).min(1).optional(),\n        ]).optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  max_tokens: z.number().optional().default(500),\n  stream: z.boolean().optional().default(true),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const noAgentCompletionValidationSchema = z.object({\n  ip: z.string().optional(),\n  model: z.enum(openaiModels).optional().default('gpt-3.5-turbo'),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.union([\n          z.string().optional(),\n          z.array(\n            z.object({\n              type: z.enum(['text', 'image_url']),\n              text: z.string().optional(),\n              image_url: z.object({\n                url: z.string().optional(),\n                detail: z.enum(['low', 'high']).optional().default('low'),\n              }).optional(),\n            }),\n          ).min(1).optional(),\n        ]).optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  max_tokens: z.number().optional().default(500),\n  stream: z.boolean().optional().default(true),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::openaiModels",
    "language": "typescript",
    "label": "openaiModels",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 71,
    "inDegree": 2,
    "outDegree": 0,
    "code": "export const openaiModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'gpt-4-vision',\n  'gpt-4-turbo',\n  'gpt-4o',\n] as const",
    "importStatements": [],
    "codeNoBody": "export const openaiModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'gpt-4-vision',\n  'gpt-4-turbo',\n  'gpt-4o',\n] as const",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateValidator",
    "language": "typescript",
    "label": "messageCreateValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 286,
    "inDegree": 1,
    "outDegree": 2,
    "code": "export const messageCreateValidator = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    stream: z.boolean().optional().default(true),\n    agent: z.string().uuid().optional(),\n    agentId: z.string().uuid().optional(),\n    model: z.string().optional(), // to support openai chat.completion.create\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    channel: z.enum(channels).optional().default(\n      'API',\n    ),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agent || !!data.agentId || !!data.model,\n      'Either agent or agentId should be filled in.',\n    )\n    .transform((data) => { // to support openai chat.completion.create\n      if (!data.agent && !data.agentId && data.model) {\n        data.agent = data.model\n      }\n      return data\n    }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const messageCreateValidator = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    stream: z.boolean().optional().default(true),\n    agent: z.string().uuid().optional(),\n    agentId: z.string().uuid().optional(),\n    model: z.string().optional(), // to support openai chat.completion.create\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    channel: z.enum(channels).optional().default(\n      'API',\n    ),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agent || !!data.agentId || !!data.model,\n      'Either agent or agentId should be filled in.',\n    )\n    .transform((data) => { // to support openai chat.completion.create\n      if (!data.agent && !data.agentId && data.model) {\n        data.agent = data.model\n      }\n      return data\n    }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::messageCreateSchema",
    "language": "typescript",
    "label": "messageCreateSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 302,
    "inDegree": 7,
    "outDegree": 2,
    "code": "export const messageCreateSchema = z.object({\n  ip: z.string().optional(),\n  stream: z.boolean().optional().default(true),\n  agent: z.string().uuid().optional(),\n  agentId: z.string().uuid().optional(),\n  model: z.string().optional(), // to support openai chat.completion.create\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  channel: z.enum(channels).optional().default(\n    'API',\n  ),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agent || !!data.agentId || !!data.model,\n    'Either agent or agentId should be filled in.',\n  )\n  .transform((data) => { // to support openai chat.completion.create\n    if (!data.agent && !data.agentId && data.model) {\n      data.agent = data.model\n    }\n    return data\n  })",
    "importStatements": [],
    "codeNoBody": "export const messageCreateSchema = z.object({\n  ip: z.string().optional(),\n  stream: z.boolean().optional().default(true),\n  agent: z.string().uuid().optional(),\n  agentId: z.string().uuid().optional(),\n  model: z.string().optional(), // to support openai chat.completion.create\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  channel: z.enum(channels).optional().default(\n    'API',\n  ),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agent || !!data.agentId || !!data.model,\n    'Either agent or agentId should be filled in.',\n  )\n  .transform((data) => { // to support openai chat.completion.create\n    if (!data.agent && !data.agentId && data.model) {\n      data.agent = data.model\n    }\n    return data\n  })",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat::roles",
    "language": "typescript",
    "label": "roles",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat",
    "totalTokens": 17,
    "inDegree": 10,
    "outDegree": 0,
    "code": "const roles = ['user', 'assistant', 'system', 'function'] as const",
    "importStatements": [],
    "codeNoBody": "const roles = ['user', 'assistant', 'system', 'function'] as const",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\chat.ts",
    "type": "file",
    "totalTokens": 2345,
    "inDegree": 0,
    "outDegree": 15,
    "code": "import { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\nimport { channels } from '@/lib/consts.ts'\n\nconst roles = ['user', 'assistant', 'system', 'function'] as const\n\nexport const messageCreateSchema = z.object({\n  ip: z.string().optional(),\n  stream: z.boolean().optional().default(true),\n  agent: z.string().uuid().optional(),\n  agentId: z.string().uuid().optional(),\n  model: z.string().optional(), // to support openai chat.completion.create\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  channel: z.enum(channels).optional().default(\n    'API',\n  ),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agent || !!data.agentId || !!data.model,\n    'Either agent or agentId should be filled in.',\n  )\n  .transform((data) => { // to support openai chat.completion.create\n    if (!data.agent && !data.agentId && data.model) {\n      data.agent = data.model\n    }\n    return data\n  })\n\nexport const messageCreateValidator = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    stream: z.boolean().optional().default(true),\n    agent: z.string().uuid().optional(),\n    agentId: z.string().uuid().optional(),\n    model: z.string().optional(), // to support openai chat.completion.create\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    channel: z.enum(channels).optional().default(\n      'API',\n    ),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agent || !!data.agentId || !!data.model,\n      'Either agent or agentId should be filled in.',\n    )\n    .transform((data) => { // to support openai chat.completion.create\n      if (!data.agent && !data.agentId && data.model) {\n        data.agent = data.model\n      }\n      return data\n    }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const openaiModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'gpt-4-vision',\n  'gpt-4-turbo',\n  'gpt-4o',\n] as const\n\nexport const noAgentCompletionValidationSchema = z.object({\n  ip: z.string().optional(),\n  model: z.enum(openaiModels).optional().default('gpt-3.5-turbo'),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.union([\n          z.string().optional(),\n          z.array(\n            z.object({\n              type: z.enum(['text', 'image_url']),\n              text: z.string().optional(),\n              image_url: z.object({\n                url: z.string().optional(),\n                detail: z.enum(['low', 'high']).optional().default('low'),\n              }).optional(),\n            }),\n          ).min(1).optional(),\n        ]).optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  max_tokens: z.number().optional().default(500),\n  stream: z.boolean().optional().default(true),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})\n\nexport type NoAgentCompletionValidationType = z.infer<\n  typeof noAgentCompletionValidationSchema\n>\n\nexport const noAgentCompletionValidation = zValidator(\n  'json',\n  noAgentCompletionValidationSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const messageCreateShareAgentSchema = z.object({\n  channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n    'PLAYGROUND SHARE AGENT',\n  ),\n  ip: z.string().optional(),\n  pincode: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(false),\n  agentId: z.string().uuid().optional(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agentId,\n    'agentId should be filled in.',\n  )\n\nexport const messageCreateValidatorShareAgent = zValidator(\n  'json',\n  z.object({\n    channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n      'PLAYGROUND SHARE AGENT',\n    ),\n    ip: z.string().optional(),\n    pincode: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(false),\n    agentId: z.string().uuid().optional(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agentId,\n      'agentId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const messageCreateWidgetSchema = z.object({\n  ip: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(true),\n  widgetId: z.string().uuid(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().min(1),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  statusId: z.string().uuid().optional(),\n}).partial()\n  .refine(\n    (data) => !!data.widgetId,\n    'widgetId should be filled in.',\n  )\n\nexport const messageCreateValidatorWidget = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(true),\n    widgetId: z.string().uuid(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.widgetId,\n      'widgetId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const noSessionChatSchema = z.object({\n  stream: z.boolean().optional().default(true),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  agentId: z.string().min(1).optional(),\n  userId: z.string().min(1).optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})\n\nexport const noSessionChatValidator = zValidator(\n  'json',\n  z.object({\n    stream: z.boolean().optional().default(true),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    agentId: z.string().min(1).optional(),\n    userId: z.string().min(1).optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const autocompleteSchema = z.object({\n  prompt: z.string(),\n  maxTokens: z.number().min(0),\n  temperature: z.number().min(0).max(1),\n  stop: z.array(z.string()).or(z.string().min(1)).optional(),\n  suffix: z.string().optional(),\n})\n\nexport const autocompleteValidator = zValidator(\n  'json',\n  z.object({\n    prompt: z.string(),\n    maxTokens: z.number().min(0),\n    temperature: z.number().min(0).max(1),\n    stop: z.array(z.string()).or(z.string().min(1)).optional(),\n    suffix: z.string().optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n",
    "importStatements": [
      "import { zValidator } from '@hono/zod-validator'",
      "import { z } from 'zod'",
      "import { channels } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\nimport { channels } from '@/lib/consts.ts'\nconst roles = ['user', 'assistant', 'system', 'function'] as const\n\nexport const messageCreateSchema = z.object({\n  ip: z.string().optional(),\n  stream: z.boolean().optional().default(true),\n  agent: z.string().uuid().optional(),\n  agentId: z.string().uuid().optional(),\n  model: z.string().optional(), // to support openai chat.completion.create\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  channel: z.enum(channels).optional().default(\n    'API',\n  ),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agent || !!data.agentId || !!data.model,\n    'Either agent or agentId should be filled in.',\n  )\n  .transform((data) => { // to support openai chat.completion.create\n    if (!data.agent && !data.agentId && data.model) {\n      data.agent = data.model\n    }\n    return data\n  })\n\nexport const messageCreateValidator = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    stream: z.boolean().optional().default(true),\n    agent: z.string().uuid().optional(),\n    agentId: z.string().uuid().optional(),\n    model: z.string().optional(), // to support openai chat.completion.create\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    channel: z.enum(channels).optional().default(\n      'API',\n    ),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agent || !!data.agentId || !!data.model,\n      'Either agent or agentId should be filled in.',\n    )\n    .transform((data) => { // to support openai chat.completion.create\n      if (!data.agent && !data.agentId && data.model) {\n        data.agent = data.model\n      }\n      return data\n    }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const openaiModels = [\n  'gpt-3.5-turbo',\n  'gpt-3.5-turbo-16k',\n  'gpt-4',\n  'gpt-4-vision',\n  'gpt-4-turbo',\n  'gpt-4o',\n] as const\n\nexport const noAgentCompletionValidationSchema = z.object({\n  ip: z.string().optional(),\n  model: z.enum(openaiModels).optional().default('gpt-3.5-turbo'),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.union([\n          z.string().optional(),\n          z.array(\n            z.object({\n              type: z.enum(['text', 'image_url']),\n              text: z.string().optional(),\n              image_url: z.object({\n                url: z.string().optional(),\n                detail: z.enum(['low', 'high']).optional().default('low'),\n              }).optional(),\n            }),\n          ).min(1).optional(),\n        ]).optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  max_tokens: z.number().optional().default(500),\n  stream: z.boolean().optional().default(true),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})\n\nexport type NoAgentCompletionValidationType = z.infer<\n  typeof noAgentCompletionValidationSchema\n>\n\nexport const noAgentCompletionValidation = zValidator(\n  'json',\n  noAgentCompletionValidationSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const messageCreateShareAgentSchema = z.object({\n  channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n    'PLAYGROUND SHARE AGENT',\n  ),\n  ip: z.string().optional(),\n  pincode: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(false),\n  agentId: z.string().uuid().optional(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('json'),\n  statusId: z.string().uuid().optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n}).partial()\n  .refine(\n    (data) => !!data.agentId,\n    'agentId should be filled in.',\n  )\n\nexport const messageCreateValidatorShareAgent = zValidator(\n  'json',\n  z.object({\n    channel: z.enum(['PLAYGROUND SHARE AGENT']).optional().default(\n      'PLAYGROUND SHARE AGENT',\n    ),\n    ip: z.string().optional(),\n    pincode: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(false),\n    agentId: z.string().uuid().optional(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('json'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.agentId,\n      'agentId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const messageCreateWidgetSchema = z.object({\n  ip: z.string().optional(),\n  sessionId: z.string().uuid(),\n  stream: z.boolean().optional().default(true),\n  widgetId: z.string().uuid(),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().min(1),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  statusId: z.string().uuid().optional(),\n}).partial()\n  .refine(\n    (data) => !!data.widgetId,\n    'widgetId should be filled in.',\n  )\n\nexport const messageCreateValidatorWidget = zValidator(\n  'json',\n  z.object({\n    ip: z.string().optional(),\n    sessionId: z.string().uuid(),\n    stream: z.boolean().optional().default(true),\n    widgetId: z.string().uuid(),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    statusId: z.string().uuid().optional(),\n  }).partial()\n    .refine(\n      (data) => !!data.widgetId,\n      'widgetId should be filled in.',\n    ),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const noSessionChatSchema = z.object({\n  stream: z.boolean().optional().default(true),\n  messages: z\n    .array(\n      z.object({\n        role: z.enum(roles),\n        content: z.string().optional().nullable(),\n        name: z.string().optional(),\n        function_call: z.object({\n          name: z.string().optional(),\n          arguments: z.string().optional(),\n        }).optional(),\n      }),\n    )\n    .min(1),\n  format: z.enum(['text', 'json']).optional().default('text'),\n  agentId: z.string().min(1).optional(),\n  userId: z.string().min(1).optional(),\n  functions: z.any().optional(),\n  function_call: z.object({\n    name: z.string(),\n  }).optional(),\n})\n\nexport const noSessionChatValidator = zValidator(\n  'json',\n  z.object({\n    stream: z.boolean().optional().default(true),\n    messages: z\n      .array(\n        z.object({\n          role: z.enum(roles),\n          content: z.string().min(1),\n        }),\n      )\n      .min(1),\n    format: z.enum(['text', 'json']).optional().default('text'),\n    agentId: z.string().min(1).optional(),\n    userId: z.string().min(1).optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n\nexport const autocompleteSchema = z.object({\n  prompt: z.string(),\n  maxTokens: z.number().min(0),\n  temperature: z.number().min(0).max(1),\n  stop: z.array(z.string()).or(z.string().min(1)).optional(),\n  suffix: z.string().optional(),\n})\n\nexport const autocompleteValidator = zValidator(\n  'json',\n  z.object({\n    prompt: z.string(),\n    maxTokens: z.number().min(0),\n    temperature: z.number().min(0).max(1),\n    stop: z.array(z.string()).or(z.string().min(1)).optional(),\n    suffix: z.string().optional(),\n  }),\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\chat.ts"
  },
  {
    "id": "\\schemas\\document::webLinkValidator",
    "language": "typescript",
    "label": "webLinkValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\document",
    "totalTokens": 28,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const webLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url(),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const webLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url(),\n  }),\n)",
    "originFile": "\\schemas\\document.ts"
  },
  {
    "id": "\\schemas\\document::webLinkSchema",
    "language": "typescript",
    "label": "webLinkSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\document",
    "totalTokens": 18,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const webLinkSchema = z.object({\n  url: z.string().url(),\n})",
    "importStatements": [],
    "codeNoBody": "export const webLinkSchema = z.object({\n  url: z.string().url(),\n})",
    "originFile": "\\schemas\\document.ts"
  },
  {
    "id": "\\schemas\\document::githubLinkValidator",
    "language": "typescript",
    "label": "githubLinkValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\document",
    "totalTokens": 56,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const githubLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url().refine((url: string) => url.includes('github.com'), {\n      message: 'URL must contain \"github.com\"',\n    }),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const githubLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url().refine((url: string) => url.includes('github.com'), {\n      message: 'URL must contain \"github.com\"',\n    }),\n  }),\n)",
    "originFile": "\\schemas\\document.ts"
  },
  {
    "id": "\\schemas\\document::githubLinkSchema",
    "language": "typescript",
    "label": "githubLinkSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\document",
    "totalTokens": 46,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const githubLinkSchema = z.object({\n  url: z.string().url().refine((url: string) => url.includes('github.com'), {\n    message: 'URL must contain \"github.com\"',\n  }),\n})",
    "importStatements": [],
    "codeNoBody": "export const githubLinkSchema = z.object({\n  url: z.string().url().refine((url: string) => url.includes('github.com'), {\n    message: 'URL must contain \"github.com\"',\n  }),\n})",
    "originFile": "\\schemas\\document.ts"
  },
  {
    "id": "\\schemas\\document",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\document.ts",
    "type": "file",
    "totalTokens": 168,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\n\nexport const githubLinkSchema = z.object({\n  url: z.string().url().refine((url: string) => url.includes('github.com'), {\n    message: 'URL must contain \"github.com\"',\n  }),\n})\n\nexport const githubLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url().refine((url: string) => url.includes('github.com'), {\n      message: 'URL must contain \"github.com\"',\n    }),\n  }),\n)\n\nexport const webLinkSchema = z.object({\n  url: z.string().url(),\n})\n\nexport const webLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url(),\n  }),\n)\n",
    "importStatements": [
      "import { zValidator } from '@hono/zod-validator'",
      "import z from 'zod'"
    ],
    "codeNoBody": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\nexport const githubLinkSchema = z.object({\n  url: z.string().url().refine((url: string) => url.includes('github.com'), {\n    message: 'URL must contain \"github.com\"',\n  }),\n})\n\nexport const githubLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url().refine((url: string) => url.includes('github.com'), {\n      message: 'URL must contain \"github.com\"',\n    }),\n  }),\n)\n\nexport const webLinkSchema = z.object({\n  url: z.string().url(),\n})\n\nexport const webLinkValidator = zValidator(\n  'json',\n  z.object({\n    url: z.string().url(),\n  }),\n)",
    "originFile": "\\schemas\\document.ts"
  },
  {
    "id": "\\schemas\\index::uuidSchema",
    "language": "typescript",
    "label": "uuidSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\index",
    "totalTokens": 10,
    "inDegree": 10,
    "outDegree": 0,
    "code": "export const uuidSchema = z.string().uuid()",
    "importStatements": [],
    "codeNoBody": "export const uuidSchema = z.string().uuid()",
    "originFile": "\\schemas\\index.ts"
  },
  {
    "id": "\\schemas\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\index.ts",
    "type": "file",
    "totalTokens": 19,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { z } from 'zod'\n\nexport const uuidSchema = z.string().uuid()\n",
    "importStatements": [
      "import { z } from 'zod'"
    ],
    "codeNoBody": "import { z } from 'zod'\nexport const uuidSchema = z.string().uuid()",
    "originFile": "\\schemas\\index.ts"
  },
  {
    "id": "\\schemas\\metadata::metadataValidator",
    "language": "typescript",
    "label": "metadataValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\metadata",
    "totalTokens": 17,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const metadataValidator = zValidator(\n  'json',\n  metadataSchema,\n)",
    "importStatements": [],
    "codeNoBody": "export const metadataValidator = zValidator(\n  'json',\n  metadataSchema,\n)",
    "originFile": "\\schemas\\metadata.ts"
  },
  {
    "id": "\\schemas\\metadata::extractionFunctionSchema",
    "language": "typescript",
    "label": "extractionFunctionSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\metadata",
    "totalTokens": 41,
    "inDegree": 2,
    "outDegree": 1,
    "code": "export const extractionFunctionSchema = {\n  name: 'extractor',\n  description: 'Extracts relevant information from the content.',\n  parameters: zodToJsonSchema(\n    metadataSchema,\n  ),\n}",
    "importStatements": [],
    "codeNoBody": "export const extractionFunctionSchema = {\n  name: 'extractor',\n  description: 'Extracts relevant information from the content.',\n  parameters: zodToJsonSchema(\n    metadataSchema,\n  ),\n}",
    "originFile": "\\schemas\\metadata.ts"
  },
  {
    "id": "\\schemas\\metadata::metadataSchema",
    "language": "typescript",
    "label": "metadataSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\metadata",
    "totalTokens": 143,
    "inDegree": 5,
    "outDegree": 0,
    "code": "export const metadataSchema = z.object({\n  title: z\n    .string()\n    .describe(\n      'A descriptive representative title about the content 80 character maximun.',\n    ),\n  description: z\n    .string()\n    .describe(\n      'A short description of what kind of content it is, and what it is about 140 character maximum.',\n    ),\n  summary: z.string().describe(\n    'A concise summary of the content 250 character maximum.',\n  ),\n  keywords: z.string().describe(\n    'Extract 3 relevant keywords from the content.',\n  ),\n  language: z.string().describe(\n    'The language of the content in one word maximum.',\n  ),\n})",
    "importStatements": [],
    "codeNoBody": "export const metadataSchema = z.object({\n  title: z\n    .string()\n    .describe(\n      'A descriptive representative title about the content 80 character maximun.',\n    ),\n  description: z\n    .string()\n    .describe(\n      'A short description of what kind of content it is, and what it is about 140 character maximum.',\n    ),\n  summary: z.string().describe(\n    'A concise summary of the content 250 character maximum.',\n  ),\n  keywords: z.string().describe(\n    'Extract 3 relevant keywords from the content.',\n  ),\n  language: z.string().describe(\n    'The language of the content in one word maximum.',\n  ),\n})",
    "originFile": "\\schemas\\metadata.ts"
  },
  {
    "id": "\\schemas\\metadata",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\metadata.ts",
    "type": "file",
    "totalTokens": 238,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { z } from 'zod'\nimport { zodToJsonSchema } from 'zod-to-json-schema'\nimport { zValidator } from '@hono/zod-validator'\n\nexport const metadataSchema = z.object({\n  title: z\n    .string()\n    .describe(\n      'A descriptive representative title about the content 80 character maximun.',\n    ),\n  description: z\n    .string()\n    .describe(\n      'A short description of what kind of content it is, and what it is about 140 character maximum.',\n    ),\n  summary: z.string().describe(\n    'A concise summary of the content 250 character maximum.',\n  ),\n  keywords: z.string().describe(\n    'Extract 3 relevant keywords from the content.',\n  ),\n  language: z.string().describe(\n    'The language of the content in one word maximum.',\n  ),\n})\nexport const extractionFunctionSchema = {\n  name: 'extractor',\n  description: 'Extracts relevant information from the content.',\n  parameters: zodToJsonSchema(\n    metadataSchema,\n  ),\n}\n\nexport const metadataValidator = zValidator(\n  'json',\n  metadataSchema,\n)\n",
    "importStatements": [
      "import { z } from 'zod'",
      "import { zodToJsonSchema } from 'zod-to-json-schema'",
      "import { zValidator } from '@hono/zod-validator'"
    ],
    "codeNoBody": "import { z } from 'zod'\nimport { zodToJsonSchema } from 'zod-to-json-schema'\nimport { zValidator } from '@hono/zod-validator'\nexport const metadataSchema = z.object({\n  title: z\n    .string()\n    .describe(\n      'A descriptive representative title about the content 80 character maximun.',\n    ),\n  description: z\n    .string()\n    .describe(\n      'A short description of what kind of content it is, and what it is about 140 character maximum.',\n    ),\n  summary: z.string().describe(\n    'A concise summary of the content 250 character maximum.',\n  ),\n  keywords: z.string().describe(\n    'Extract 3 relevant keywords from the content.',\n  ),\n  language: z.string().describe(\n    'The language of the content in one word maximum.',\n  ),\n})\nexport const extractionFunctionSchema = {\n  name: 'extractor',\n  description: 'Extracts relevant information from the content.',\n  parameters: zodToJsonSchema(\n    metadataSchema,\n  ),\n}\n\nexport const metadataValidator = zValidator(\n  'json',\n  metadataSchema,\n)",
    "originFile": "\\schemas\\metadata.ts"
  },
  {
    "id": "\\schemas\\models_pricing::modelsPricingTableEventValidation",
    "language": "typescript",
    "label": "modelsPricingTableEventValidation",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\models_pricing",
    "totalTokens": 55,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const modelsPricingTableEventValidation = zValidator(\n  'json',\n  EventSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const modelsPricingTableEventValidation = zValidator(\n  'json',\n  EventSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\models_pricing.ts"
  },
  {
    "id": "\\schemas\\models_pricing::EventSchema",
    "language": "typescript",
    "label": "EventSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\models_pricing",
    "totalTokens": 76,
    "inDegree": 4,
    "outDegree": 1,
    "code": "export const EventSchema = z.object({\n  type: z.union([\n    z.literal('INSERT'),\n    z.literal('UPDATE'),\n    z.literal('DELETE'),\n  ]),\n  table: z.literal('models_pricing'),\n  record: ModelsPricingRecordSchema.nullable(),\n  schema: z.literal('public'),\n  old_record: ModelsPricingRecordSchema.nullable(),\n})",
    "importStatements": [],
    "codeNoBody": "export const EventSchema = z.object({\n  type: z.union([\n    z.literal('INSERT'),\n    z.literal('UPDATE'),\n    z.literal('DELETE'),\n  ]),\n  table: z.literal('models_pricing'),\n  record: ModelsPricingRecordSchema.nullable(),\n  schema: z.literal('public'),\n  old_record: ModelsPricingRecordSchema.nullable(),\n})",
    "originFile": "\\schemas\\models_pricing.ts"
  },
  {
    "id": "\\schemas\\models_pricing::ModelsPricingRecordSchema",
    "language": "typescript",
    "label": "ModelsPricingRecordSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\models_pricing",
    "totalTokens": 54,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const ModelsPricingRecordSchema = z\n  .object({\n    id: z.string().uuid(),\n    updated_at: z.string(),\n    name: z.string(),\n    input: z.number(),\n    output: z.number(),\n    provider: z.string(),\n  })",
    "importStatements": [],
    "codeNoBody": "const ModelsPricingRecordSchema = z\n  .object({\n    id: z.string().uuid(),\n    updated_at: z.string(),\n    name: z.string(),\n    input: z.number(),\n    output: z.number(),\n    provider: z.string(),\n  })",
    "originFile": "\\schemas\\models_pricing.ts"
  },
  {
    "id": "\\schemas\\models_pricing",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\models_pricing.ts",
    "type": "file",
    "totalTokens": 207,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\n\nconst ModelsPricingRecordSchema = z\n  .object({\n    id: z.string().uuid(),\n    updated_at: z.string(),\n    name: z.string(),\n    input: z.number(),\n    output: z.number(),\n    provider: z.string(),\n  })\n\nexport const EventSchema = z.object({\n  type: z.union([\n    z.literal('INSERT'),\n    z.literal('UPDATE'),\n    z.literal('DELETE'),\n  ]),\n  table: z.literal('models_pricing'),\n  record: ModelsPricingRecordSchema.nullable(),\n  schema: z.literal('public'),\n  old_record: ModelsPricingRecordSchema.nullable(),\n})\n\nexport const modelsPricingTableEventValidation = zValidator(\n  'json',\n  EventSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)\n",
    "importStatements": [
      "import { zValidator } from '@hono/zod-validator'",
      "import { z } from 'zod'"
    ],
    "codeNoBody": "import { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\nconst ModelsPricingRecordSchema = z\n  .object({\n    id: z.string().uuid(),\n    updated_at: z.string(),\n    name: z.string(),\n    input: z.number(),\n    output: z.number(),\n    provider: z.string(),\n  })\n\nexport const EventSchema = z.object({\n  type: z.union([\n    z.literal('INSERT'),\n    z.literal('UPDATE'),\n    z.literal('DELETE'),\n  ]),\n  table: z.literal('models_pricing'),\n  record: ModelsPricingRecordSchema.nullable(),\n  schema: z.literal('public'),\n  old_record: ModelsPricingRecordSchema.nullable(),\n})\n\nexport const modelsPricingTableEventValidation = zValidator(\n  'json',\n  EventSchema,\n  (result, c) => {\n    if (!result.success) {\n      return c.json({ error: result.error.issues }, 400)\n    }\n  },\n)",
    "originFile": "\\schemas\\models_pricing.ts"
  },
  {
    "id": "\\schemas\\user::userUpdateValidator",
    "language": "typescript",
    "label": "userUpdateValidator",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\user",
    "totalTokens": 37,
    "inDegree": 1,
    "outDegree": 0,
    "code": "export const userUpdateValidator = zValidator(\n  'json',\n  z.object({\n    username: z.string().optional(),\n    full_name: z.string().optional(),\n  }),\n)",
    "importStatements": [],
    "codeNoBody": "export const userUpdateValidator = zValidator(\n  'json',\n  z.object({\n    username: z.string().optional(),\n    full_name: z.string().optional(),\n  }),\n)",
    "originFile": "\\schemas\\user.ts"
  },
  {
    "id": "\\schemas\\user::userUpdateSchema",
    "language": "typescript",
    "label": "userUpdateSchema",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\user",
    "totalTokens": 27,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const userUpdateSchema = z.object({\n  username: z.string().optional(),\n  full_name: z.string().optional(),\n})",
    "importStatements": [],
    "codeNoBody": "export const userUpdateSchema = z.object({\n  username: z.string().optional(),\n  full_name: z.string().optional(),\n})",
    "originFile": "\\schemas\\user.ts"
  },
  {
    "id": "\\schemas\\user",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\schemas\\user.ts",
    "type": "file",
    "totalTokens": 84,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\n\nexport const userUpdateSchema = z.object({\n  username: z.string().optional(),\n  full_name: z.string().optional(),\n})\n\nexport const userUpdateValidator = zValidator(\n  'json',\n  z.object({\n    username: z.string().optional(),\n    full_name: z.string().optional(),\n  }),\n)\n",
    "importStatements": [
      "import { zValidator } from '@hono/zod-validator'",
      "import z from 'zod'"
    ],
    "codeNoBody": "import { zValidator } from '@hono/zod-validator'\nimport z from 'zod'\nexport const userUpdateSchema = z.object({\n  username: z.string().optional(),\n  full_name: z.string().optional(),\n})\n\nexport const userUpdateValidator = zValidator(\n  'json',\n  z.object({\n    username: z.string().optional(),\n    full_name: z.string().optional(),\n  }),\n)",
    "originFile": "\\schemas\\user.ts"
  },
  {
    "id": "\\server::handler",
    "language": "typescript",
    "label": "handler",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\server",
    "totalTokens": 66,
    "inDegree": 2,
    "outDegree": 1,
    "code": "const handler = (req: Request, conn: Deno.ServeHandlerInfo) => {\n  if (conn?.remoteAddr) {\n    // @ts-expect-error Se necesita pasar la ip con la request\n    req.ip = conn.remoteAddr.hostname\n  }\n\n  return app.fetch(req, Deno.env.toObject())\n}",
    "importStatements": [],
    "codeNoBody": "const handler = (req: Request, conn: Deno.ServeHandlerInfo) => {\n//...\n}",
    "originFile": "\\server.ts"
  },
  {
    "id": "\\server::app",
    "language": "typescript",
    "label": "app",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\server",
    "totalTokens": 627,
    "inDegree": 2,
    "outDegree": 34,
    "code": "const app = new Hono()\napp.use('*', logger())\napp.use('*', prettyJSON())\napp.use('/api/*', cors())\napp.get('/', (c) => {\n  return c.html('<h1>CodeGPT API</h1>')\n})\napp.use(\n  '/openapi.json',\n  serveStatic({ root: './' }) as unknown as MiddlewareHandler,\n)\napp.get(\n  '/api/v1/docs',\n  swaggerUI({\n    url: '/openapi.json',\n  }),\n)\napp.use(\n  '/api/v1/vscode/providers',\n  serveStatic({\n    path: './providers.json',\n  }) as unknown as MiddlewareHandler,\n)\napp.route('/api/v1/agent/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agents/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agent/marketplace', marketplaceAgents)\napp.route('/api/v1/agents/marketplace', marketplaceAgents)\napp.route('/api/v1/agent', agents)\napp.route('/api/v1/agents', agents)\napp.route('/api/v1/agents/widget', widgetAgent)\napp.route('/api/v1/widgets', widgets)\napp.route('/api/v1/chat/playground', chatPlayground)\napp.route('/api/v1/chat/share', chatShare)\napp.route('/api/v1/chat/widget', chatWidget)\napp.route('/api/v1/chat/marketplace/agents', chatMarketplace)\napp.route('/api/v1/chat/completions', chat)\napp.route('/api/v1/chat/extension', chatExtension)\napp.route('/api/v1/chat/model/completions', chatCompletion)\napp.route('/api/v1/chat/completion', chatCompletion)\napp.route('/api/v1/chat/limited', freePlanCompletion)\napp.route('/api/v1/document', documents)\napp.route('/api/v1/document/metadata', metadata)\napp.route('/api/v1/documents/text', text)\napp.route('/api/v1/documents/github', github)\napp.route('/api/v1/documents/web', web)\napp.route('/api/v1/user', user)\napp.route('/api/v1/ip', ip)\napp.route('/api/v1/models/pricing', modelsPricing)\napp.route('/api/v1/telemetry', telemetry)\napp.route('/api/v1/me', me)\napp.route('/api/v1/slack/', slack)\napp.route('/api/v1/discord/', discord)\napp.route('/api/v1/autocomplete', autocomplete)\napp.route('/api/v1/github-app', githubApp)\napp.route('/api/v1/bitbucket', bitbucketApp)\napp.route('/api/v1/gitlab', gitlabApp)\napp.route('/api/v1/vscode', vscode)\napp.route('/api/v1/extensions', extensions)\napp.route('/api/v1/chat/status', chatStatus)\napp.route('/api/v1/apikeys', apiKeys)\napp.route('/api/v1/organizations', organizations)\napp.notFound((c) => c.json({ message: 'Not Found' }, 404))",
    "importStatements": [],
    "codeNoBody": "const app = new Hono()\napp.use('*', logger())\napp.use('*', prettyJSON())\napp.use('/api/*', cors())\napp.get('/', (c) => {\n  return c.html('<h1>CodeGPT API</h1>')\n})\napp.use(\n  '/openapi.json',\n  serveStatic({ root: './' }) as unknown as MiddlewareHandler,\n)\napp.get(\n  '/api/v1/docs',\n  swaggerUI({\n    url: '/openapi.json',\n  }),\n)\napp.use(\n  '/api/v1/vscode/providers',\n  serveStatic({\n    path: './providers.json',\n  }) as unknown as MiddlewareHandler,\n)\napp.route('/api/v1/agent/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agents/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agent/marketplace', marketplaceAgents)\napp.route('/api/v1/agents/marketplace', marketplaceAgents)\napp.route('/api/v1/agent', agents)\napp.route('/api/v1/agents', agents)\napp.route('/api/v1/agents/widget', widgetAgent)\napp.route('/api/v1/widgets', widgets)\napp.route('/api/v1/chat/playground', chatPlayground)\napp.route('/api/v1/chat/share', chatShare)\napp.route('/api/v1/chat/widget', chatWidget)\napp.route('/api/v1/chat/marketplace/agents', chatMarketplace)\napp.route('/api/v1/chat/completions', chat)\napp.route('/api/v1/chat/extension', chatExtension)\napp.route('/api/v1/chat/model/completions', chatCompletion)\napp.route('/api/v1/chat/completion', chatCompletion)\napp.route('/api/v1/chat/limited', freePlanCompletion)\napp.route('/api/v1/document', documents)\napp.route('/api/v1/document/metadata', metadata)\napp.route('/api/v1/documents/text', text)\napp.route('/api/v1/documents/github', github)\napp.route('/api/v1/documents/web', web)\napp.route('/api/v1/user', user)\napp.route('/api/v1/ip', ip)\napp.route('/api/v1/models/pricing', modelsPricing)\napp.route('/api/v1/telemetry', telemetry)\napp.route('/api/v1/me', me)\napp.route('/api/v1/slack/', slack)\napp.route('/api/v1/discord/', discord)\napp.route('/api/v1/autocomplete', autocomplete)\napp.route('/api/v1/github-app', githubApp)\napp.route('/api/v1/bitbucket', bitbucketApp)\napp.route('/api/v1/gitlab', gitlabApp)\napp.route('/api/v1/vscode', vscode)\napp.route('/api/v1/extensions', extensions)\napp.route('/api/v1/chat/status', chatStatus)\napp.route('/api/v1/apikeys', apiKeys)\napp.route('/api/v1/organizations', organizations)\napp.notFound((c) => c.json({ message: 'Not Found' }, 404))",
    "originFile": "\\server.ts"
  },
  {
    "id": "\\server",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\server.ts",
    "type": "file",
    "totalTokens": 1200,
    "inDegree": 0,
    "outDegree": 37,
    "code": "import { Hono, type MiddlewareHandler } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\nimport { prettyJSON } from 'hono/pretty-json'\nimport { agents } from '@/routes/agents/index.ts'\nimport { marketplaceFavoriteAgents } from '@/routes/agents/marketplace-favorites/index.ts'\nimport { marketplaceAgents } from '@/routes/agents/marketplace/index.ts'\nimport { chatExtension } from '@/routes/chat/extension.ts'\nimport { chat } from '@/routes/chat/index.ts'\nimport { chatPlayground } from '@/routes/chat/playground.ts'\nimport { chatShare } from '@/routes/chat/share.ts'\nimport { chatWidget } from '@/routes/chat/widget.ts'\nimport { chatMarketplace } from '@/routes/chat/marketplace/agents.ts'\nimport { documents } from '@/routes/documents.ts'\nimport { text } from '@/routes/text.ts'\nimport { metadata } from '@/routes/metadata.ts'\nimport { user } from '@/routes/user.ts'\nimport { me } from '@/routes/me.ts'\nimport { chatCompletion } from '@/routes/chat/completion.ts'\nimport { freePlanCompletion } from '@/routes/chat/freeplan.ts'\nimport { modelsPricing } from '@/routes/webhooks/models.ts'\nimport { serveStatic } from '@hono/deno'\nimport { swaggerUI } from '@hono/swagger-ui'\nimport { github } from '@/routes/github.ts'\nimport { web } from '@/routes/web.ts'\nimport { telemetry } from '@/routes/telemetry.ts'\nimport { ip } from '@/routes/ip.ts'\nimport { slack } from '@/routes/slack.ts'\nimport { discord } from '@/routes/discord.ts'\nimport { widgets } from '@/routes/widgets/index.ts'\nimport { autocomplete } from '@/routes/chat/autocomplete.ts'\nimport { widgetAgent } from '@/routes/agents/widget/index.ts'\nimport { githubApp } from '@/routes/github-app.ts'\nimport { gitlabApp } from '@/routes/gitlab.ts'\nimport { vscode } from '@/routes/vscode/index.ts'\nimport { extensions } from '@/routes/extensions/index.ts'\nimport { bitbucketApp } from '@/routes/bitbucket.ts'\nimport { chatStatus } from '@/routes/chat/status/index.ts'\nimport { apiKeys } from '@/routes/apikeys/index.ts'\nimport { organizations } from '@/routes/organizations/index.ts'\nimport '@/crons/usage-rds.ts'\n\nconst app = new Hono()\n\napp.use('*', logger())\napp.use('*', prettyJSON())\napp.use('/api/*', cors())\n\napp.get('/', (c) => {\n  return c.html('<h1>CodeGPT API</h1>')\n})\n\napp.use(\n  '/openapi.json',\n  serveStatic({ root: './' }) as unknown as MiddlewareHandler,\n)\n\napp.get(\n  '/api/v1/docs',\n  swaggerUI({\n    url: '/openapi.json',\n  }),\n)\n\napp.use(\n  '/api/v1/vscode/providers',\n  serveStatic({\n    path: './providers.json',\n  }) as unknown as MiddlewareHandler,\n)\n\napp.route('/api/v1/agent/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agents/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agent/marketplace', marketplaceAgents)\napp.route('/api/v1/agents/marketplace', marketplaceAgents)\napp.route('/api/v1/agent', agents)\napp.route('/api/v1/agents', agents)\napp.route('/api/v1/agents/widget', widgetAgent)\napp.route('/api/v1/widgets', widgets)\napp.route('/api/v1/chat/playground', chatPlayground)\napp.route('/api/v1/chat/share', chatShare)\napp.route('/api/v1/chat/widget', chatWidget)\napp.route('/api/v1/chat/marketplace/agents', chatMarketplace)\napp.route('/api/v1/chat/completions', chat)\napp.route('/api/v1/chat/extension', chatExtension)\napp.route('/api/v1/chat/model/completions', chatCompletion)\napp.route('/api/v1/chat/completion', chatCompletion)\napp.route('/api/v1/chat/limited', freePlanCompletion)\napp.route('/api/v1/document', documents)\napp.route('/api/v1/document/metadata', metadata)\napp.route('/api/v1/documents/text', text)\napp.route('/api/v1/documents/github', github)\napp.route('/api/v1/documents/web', web)\napp.route('/api/v1/user', user)\napp.route('/api/v1/ip', ip)\napp.route('/api/v1/models/pricing', modelsPricing)\napp.route('/api/v1/telemetry', telemetry)\napp.route('/api/v1/me', me)\napp.route('/api/v1/slack/', slack)\napp.route('/api/v1/discord/', discord)\napp.route('/api/v1/autocomplete', autocomplete)\napp.route('/api/v1/github-app', githubApp)\napp.route('/api/v1/bitbucket', bitbucketApp)\napp.route('/api/v1/gitlab', gitlabApp)\napp.route('/api/v1/vscode', vscode)\napp.route('/api/v1/extensions', extensions)\napp.route('/api/v1/chat/status', chatStatus)\napp.route('/api/v1/apikeys', apiKeys)\napp.route('/api/v1/organizations', organizations)\n\napp.notFound((c) => c.json({ message: 'Not Found' }, 404))\n\nconst handler = (req: Request, conn: Deno.ServeHandlerInfo) => {\n  if (conn?.remoteAddr) {\n    // @ts-expect-error Se necesita pasar la ip con la request\n    req.ip = conn.remoteAddr.hostname\n  }\n\n  return app.fetch(req, Deno.env.toObject())\n}\n\nDeno.serve(handler)\n",
    "importStatements": [
      "import { Hono, type MiddlewareHandler } from 'hono'",
      "import { cors } from 'hono/cors'",
      "import { logger } from 'hono/logger'",
      "import { prettyJSON } from 'hono/pretty-json'",
      "import { agents } from '@/routes/agents/index.ts'",
      "import { marketplaceFavoriteAgents } from '@/routes/agents/marketplace-favorites/index.ts'",
      "import { marketplaceAgents } from '@/routes/agents/marketplace/index.ts'",
      "import { chatExtension } from '@/routes/chat/extension.ts'",
      "import { chat } from '@/routes/chat/index.ts'",
      "import { chatPlayground } from '@/routes/chat/playground.ts'",
      "import { chatShare } from '@/routes/chat/share.ts'",
      "import { chatWidget } from '@/routes/chat/widget.ts'",
      "import { chatMarketplace } from '@/routes/chat/marketplace/agents.ts'",
      "import { documents } from '@/routes/documents.ts'",
      "import { text } from '@/routes/text.ts'",
      "import { metadata } from '@/routes/metadata.ts'",
      "import { user } from '@/routes/user.ts'",
      "import { me } from '@/routes/me.ts'",
      "import { chatCompletion } from '@/routes/chat/completion.ts'",
      "import { freePlanCompletion } from '@/routes/chat/freeplan.ts'",
      "import { modelsPricing } from '@/routes/webhooks/models.ts'",
      "import { serveStatic } from '@hono/deno'",
      "import { swaggerUI } from '@hono/swagger-ui'",
      "import { github } from '@/routes/github.ts'",
      "import { web } from '@/routes/web.ts'",
      "import { telemetry } from '@/routes/telemetry.ts'",
      "import { ip } from '@/routes/ip.ts'",
      "import { slack } from '@/routes/slack.ts'",
      "import { discord } from '@/routes/discord.ts'",
      "import { widgets } from '@/routes/widgets/index.ts'",
      "import { autocomplete } from '@/routes/chat/autocomplete.ts'",
      "import { widgetAgent } from '@/routes/agents/widget/index.ts'",
      "import { githubApp } from '@/routes/github-app.ts'",
      "import { gitlabApp } from '@/routes/gitlab.ts'",
      "import { vscode } from '@/routes/vscode/index.ts'",
      "import { extensions } from '@/routes/extensions/index.ts'",
      "import { bitbucketApp } from '@/routes/bitbucket.ts'",
      "import { chatStatus } from '@/routes/chat/status/index.ts'",
      "import { apiKeys } from '@/routes/apikeys/index.ts'",
      "import { organizations } from '@/routes/organizations/index.ts'",
      "import '@/crons/usage-rds.ts'"
    ],
    "codeNoBody": "import { Hono, type MiddlewareHandler } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\nimport { prettyJSON } from 'hono/pretty-json'\nimport { agents } from '@/routes/agents/index.ts'\nimport { marketplaceFavoriteAgents } from '@/routes/agents/marketplace-favorites/index.ts'\nimport { marketplaceAgents } from '@/routes/agents/marketplace/index.ts'\nimport { chatExtension } from '@/routes/chat/extension.ts'\nimport { chat } from '@/routes/chat/index.ts'\nimport { chatPlayground } from '@/routes/chat/playground.ts'\nimport { chatShare } from '@/routes/chat/share.ts'\nimport { chatWidget } from '@/routes/chat/widget.ts'\nimport { chatMarketplace } from '@/routes/chat/marketplace/agents.ts'\nimport { documents } from '@/routes/documents.ts'\nimport { text } from '@/routes/text.ts'\nimport { metadata } from '@/routes/metadata.ts'\nimport { user } from '@/routes/user.ts'\nimport { me } from '@/routes/me.ts'\nimport { chatCompletion } from '@/routes/chat/completion.ts'\nimport { freePlanCompletion } from '@/routes/chat/freeplan.ts'\nimport { modelsPricing } from '@/routes/webhooks/models.ts'\nimport { serveStatic } from '@hono/deno'\nimport { swaggerUI } from '@hono/swagger-ui'\nimport { github } from '@/routes/github.ts'\nimport { web } from '@/routes/web.ts'\nimport { telemetry } from '@/routes/telemetry.ts'\nimport { ip } from '@/routes/ip.ts'\nimport { slack } from '@/routes/slack.ts'\nimport { discord } from '@/routes/discord.ts'\nimport { widgets } from '@/routes/widgets/index.ts'\nimport { autocomplete } from '@/routes/chat/autocomplete.ts'\nimport { widgetAgent } from '@/routes/agents/widget/index.ts'\nimport { githubApp } from '@/routes/github-app.ts'\nimport { gitlabApp } from '@/routes/gitlab.ts'\nimport { vscode } from '@/routes/vscode/index.ts'\nimport { extensions } from '@/routes/extensions/index.ts'\nimport { bitbucketApp } from '@/routes/bitbucket.ts'\nimport { chatStatus } from '@/routes/chat/status/index.ts'\nimport { apiKeys } from '@/routes/apikeys/index.ts'\nimport { organizations } from '@/routes/organizations/index.ts'\nimport '@/crons/usage-rds.ts'\nconst app = new Hono()\n\napp.use('*', logger())\napp.use('*', prettyJSON())\napp.use('/api/*', cors())\n\napp.get('/', (c) => {\n  return c.html('<h1>CodeGPT API</h1>')\n})\n\napp.use(\n  '/openapi.json',\n  serveStatic({ root: './' }) as unknown as MiddlewareHandler,\n)\n\napp.get(\n  '/api/v1/docs',\n  swaggerUI({\n    url: '/openapi.json',\n  }),\n)\n\napp.use(\n  '/api/v1/vscode/providers',\n  serveStatic({\n    path: './providers.json',\n  }) as unknown as MiddlewareHandler,\n)\n\napp.route('/api/v1/agent/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agents/marketplace-favorites', marketplaceFavoriteAgents)\napp.route('/api/v1/agent/marketplace', marketplaceAgents)\napp.route('/api/v1/agents/marketplace', marketplaceAgents)\napp.route('/api/v1/agent', agents)\napp.route('/api/v1/agents', agents)\napp.route('/api/v1/agents/widget', widgetAgent)\napp.route('/api/v1/widgets', widgets)\napp.route('/api/v1/chat/playground', chatPlayground)\napp.route('/api/v1/chat/share', chatShare)\napp.route('/api/v1/chat/widget', chatWidget)\napp.route('/api/v1/chat/marketplace/agents', chatMarketplace)\napp.route('/api/v1/chat/completions', chat)\napp.route('/api/v1/chat/extension', chatExtension)\napp.route('/api/v1/chat/model/completions', chatCompletion)\napp.route('/api/v1/chat/completion', chatCompletion)\napp.route('/api/v1/chat/limited', freePlanCompletion)\napp.route('/api/v1/document', documents)\napp.route('/api/v1/document/metadata', metadata)\napp.route('/api/v1/documents/text', text)\napp.route('/api/v1/documents/github', github)\napp.route('/api/v1/documents/web', web)\napp.route('/api/v1/user', user)\napp.route('/api/v1/ip', ip)\napp.route('/api/v1/models/pricing', modelsPricing)\napp.route('/api/v1/telemetry', telemetry)\napp.route('/api/v1/me', me)\napp.route('/api/v1/slack/', slack)\napp.route('/api/v1/discord/', discord)\napp.route('/api/v1/autocomplete', autocomplete)\napp.route('/api/v1/github-app', githubApp)\napp.route('/api/v1/bitbucket', bitbucketApp)\napp.route('/api/v1/gitlab', gitlabApp)\napp.route('/api/v1/vscode', vscode)\napp.route('/api/v1/extensions', extensions)\napp.route('/api/v1/chat/status', chatStatus)\napp.route('/api/v1/apikeys', apiKeys)\napp.route('/api/v1/organizations', organizations)\n\napp.notFound((c) => c.json({ message: 'Not Found' }, 404))\n\nconst handler = (req: Request, conn: Deno.ServeHandlerInfo) => {\n//...\n}\n\nDeno.serve(handler)",
    "originFile": "\\server.ts"
  },
  {
    "id": "\\services\\ai\\aws\\chat::createBedrockResponse",
    "language": "typescript",
    "label": "createBedrockResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\chat",
    "totalTokens": 407,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function createBedrockResponse(\n  { messages, model, stream, systemPrompt, abortSignal, temperature }: Props,\n) {\n  const claudeBody = {\n    system: systemPrompt,\n    messages,\n    max_tokens: 4096,\n    temperature,\n    'anthropic_version': 'bedrock-2023-05-31',\n  }\n\n  const llamaBody = {\n    prompt: formatLlamaPrompt({ messages, systemPrompt }),\n    temperature,\n    top_p: 0.9,\n    max_gen_len: 2048,\n  }\n\n  const body = model.includes('claude')\n    ? JSON.stringify(claudeBody)\n    : JSON.stringify(llamaBody)\n\n  const options = {\n    modelId: BEDROCK_MODELS_MAP[model as keyof typeof BEDROCK_MODELS_MAP],\n    contentType: 'application/json',\n    accept: 'application/json',\n    body,\n  }\n  try {\n    const bedrockClient = ['llama-3.1-70b'].includes(model)\n      ? bedrockClientWest\n      : bedrockClientEast\n\n    if (stream) {\n      const bedrockResponse = await bedrockClient.send(\n        new InvokeModelWithResponseStreamCommand(options),\n        { abortSignal },\n      )\n\n      return bedrockResponse\n    }\n\n    const bedrockResponse = await bedrockClient.send(\n      new InvokeModelCommand(options),\n    )\n    const decoder = new TextDecoder('utf-8')\n    const response = JSON.parse(decoder.decode(bedrockResponse.body)) as {\n      id: string\n      type: string\n      role: string\n      content: {\n        type: string\n        text: string\n      }[]\n      model: string\n      stop_reason: string\n      stop_sequence: string | null\n      usage: { input_tokens: number; output_tokens: number }\n    }\n\n    return response\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createBedrockResponse(\n  { messages, model, stream, systemPrompt, abortSignal, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\aws\\chat.ts"
  },
  {
    "id": "\\services\\ai\\aws\\chat::formatLlamaPrompt",
    "language": "typescript",
    "label": "formatLlamaPrompt",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\chat",
    "totalTokens": 136,
    "inDegree": 2,
    "outDegree": 1,
    "code": "const formatLlamaPrompt = (\n  { messages, systemPrompt }: { messages: ChatMessage[]; systemPrompt: string },\n) => {\n  let prompt =\n    `<|begin_of_text|><|start_header_id|>system<|end_header_id|>${systemPrompt}<|eot_id|>`\n\n  for (const message of messages) {\n    const { role, content } = message\n\n    prompt += `<|start_header_id|>${role}<|end_header_id|>${content}<|eot_id|>`\n  }\n\n  prompt += `<|start_header_id|>assistant<|end_header_id|>`\n\n  return prompt\n}",
    "importStatements": [],
    "codeNoBody": "const formatLlamaPrompt = (\n  { messages, systemPrompt }: { messages: ChatMessage[]; systemPrompt: string },\n) => {\n//...\n}",
    "originFile": "\\services\\ai\\aws\\chat.ts"
  },
  {
    "id": "\\services\\ai\\aws\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\chat",
    "totalTokens": 38,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: ChatMessage[]\n  abortSignal?: AbortSignal\n  model: string\n  stream: boolean\n  systemPrompt: string\n  temperature: number\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\aws\\chat.ts"
  },
  {
    "id": "\\services\\ai\\aws\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\chat.ts",
    "type": "file",
    "totalTokens": 687,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import {\n  bedrockClientEast,\n  bedrockClientWest,\n} from '@/services/ai/aws/index.ts'\nimport { BEDROCK_MODELS_MAP } from '@/services/ai/aws/consts.ts'\nimport {\n  InvokeModelWithResponseStreamCommand,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { ChatMessage } from '@/types/index.ts'\nimport { InvokeModelCommand } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\n\ninterface Props {\n  messages: ChatMessage[]\n  abortSignal?: AbortSignal\n  model: string\n  stream: boolean\n  systemPrompt: string\n  temperature: number\n}\n\nconst formatLlamaPrompt = (\n  { messages, systemPrompt }: { messages: ChatMessage[]; systemPrompt: string },\n) => {\n  let prompt =\n    `<|begin_of_text|><|start_header_id|>system<|end_header_id|>${systemPrompt}<|eot_id|>`\n\n  for (const message of messages) {\n    const { role, content } = message\n\n    prompt += `<|start_header_id|>${role}<|end_header_id|>${content}<|eot_id|>`\n  }\n\n  prompt += `<|start_header_id|>assistant<|end_header_id|>`\n\n  return prompt\n}\n\nexport async function createBedrockResponse(\n  { messages, model, stream, systemPrompt, abortSignal, temperature }: Props,\n) {\n  const claudeBody = {\n    system: systemPrompt,\n    messages,\n    max_tokens: 4096,\n    temperature,\n    'anthropic_version': 'bedrock-2023-05-31',\n  }\n\n  const llamaBody = {\n    prompt: formatLlamaPrompt({ messages, systemPrompt }),\n    temperature,\n    top_p: 0.9,\n    max_gen_len: 2048,\n  }\n\n  const body = model.includes('claude')\n    ? JSON.stringify(claudeBody)\n    : JSON.stringify(llamaBody)\n\n  const options = {\n    modelId: BEDROCK_MODELS_MAP[model as keyof typeof BEDROCK_MODELS_MAP],\n    contentType: 'application/json',\n    accept: 'application/json',\n    body,\n  }\n  try {\n    const bedrockClient = ['llama-3.1-70b'].includes(model)\n      ? bedrockClientWest\n      : bedrockClientEast\n\n    if (stream) {\n      const bedrockResponse = await bedrockClient.send(\n        new InvokeModelWithResponseStreamCommand(options),\n        { abortSignal },\n      )\n\n      return bedrockResponse\n    }\n\n    const bedrockResponse = await bedrockClient.send(\n      new InvokeModelCommand(options),\n    )\n    const decoder = new TextDecoder('utf-8')\n    const response = JSON.parse(decoder.decode(bedrockResponse.body)) as {\n      id: string\n      type: string\n      role: string\n      content: {\n        type: string\n        text: string\n      }[]\n      model: string\n      stop_reason: string\n      stop_sequence: string | null\n      usage: { input_tokens: number; output_tokens: number }\n    }\n\n    return response\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import {\n  bedrockClientEast,\n  bedrockClientWest,\n} from '@/services/ai/aws/index.ts'",
      "import { BEDROCK_MODELS_MAP } from '@/services/ai/aws/consts.ts'",
      "import {\n  InvokeModelWithResponseStreamCommand,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'",
      "import { ChatMessage } from '@/types/index.ts'",
      "import { InvokeModelCommand } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'"
    ],
    "codeNoBody": "import {\n  bedrockClientEast,\n  bedrockClientWest,\n} from '@/services/ai/aws/index.ts'\nimport { BEDROCK_MODELS_MAP } from '@/services/ai/aws/consts.ts'\nimport {\n  InvokeModelWithResponseStreamCommand,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { ChatMessage } from '@/types/index.ts'\nimport { InvokeModelCommand } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\ninterface Props {\n//...\n}\n\nconst formatLlamaPrompt = (\n  { messages, systemPrompt }: { messages: ChatMessage[]; systemPrompt: string },\n) => {\n//...\n}\n\nexport async function createBedrockResponse(\n  { messages, model, stream, systemPrompt, abortSignal, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\aws\\chat.ts"
  },
  {
    "id": "\\services\\ai\\aws\\consts::BEDROCK_MODELS_MAP",
    "language": "typescript",
    "label": "BEDROCK_MODELS_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\consts",
    "totalTokens": 200,
    "inDegree": 2,
    "outDegree": 0,
    "code": "export const BEDROCK_MODELS_MAP = {\n  'claude-2.1': 'anthropic.claude-v2:1',\n  'claude-instant-1.2': 'anthropic.claude-instant-v1',\n  'claude-3-haiku': 'anthropic.claude-3-haiku-20240307-v1:0',\n  'claude-3-sonnet': 'anthropic.claude-3-sonnet-20240229-v1:0',\n  'claude-3.5-sonnet': 'anthropic.claude-3-5-sonnet-20240620-v1:0',\n  'llama3-70b': 'meta.llama3-70b-instruct-v1:0',\n  'llama-3.1-70b': 'meta.llama3-1-70b-instruct-v1:0',\n}",
    "importStatements": [],
    "codeNoBody": "export const BEDROCK_MODELS_MAP = {\n  'claude-2.1': 'anthropic.claude-v2:1',\n  'claude-instant-1.2': 'anthropic.claude-instant-v1',\n  'claude-3-haiku': 'anthropic.claude-3-haiku-20240307-v1:0',\n  'claude-3-sonnet': 'anthropic.claude-3-sonnet-20240229-v1:0',\n  'claude-3.5-sonnet': 'anthropic.claude-3-5-sonnet-20240620-v1:0',\n  'llama3-70b': 'meta.llama3-70b-instruct-v1:0',\n  'llama-3.1-70b': 'meta.llama3-1-70b-instruct-v1:0',\n}",
    "originFile": "\\services\\ai\\aws\\consts.ts"
  },
  {
    "id": "\\services\\ai\\aws\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\consts.ts",
    "type": "file",
    "totalTokens": 200,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export const BEDROCK_MODELS_MAP = {\n  'claude-2.1': 'anthropic.claude-v2:1',\n  'claude-instant-1.2': 'anthropic.claude-instant-v1',\n  'claude-3-haiku': 'anthropic.claude-3-haiku-20240307-v1:0',\n  'claude-3-sonnet': 'anthropic.claude-3-sonnet-20240229-v1:0',\n  'claude-3.5-sonnet': 'anthropic.claude-3-5-sonnet-20240620-v1:0',\n  'llama3-70b': 'meta.llama3-70b-instruct-v1:0',\n  'llama-3.1-70b': 'meta.llama3-1-70b-instruct-v1:0',\n}\n",
    "importStatements": [],
    "codeNoBody": "export const BEDROCK_MODELS_MAP = {\n  'claude-2.1': 'anthropic.claude-v2:1',\n  'claude-instant-1.2': 'anthropic.claude-instant-v1',\n  'claude-3-haiku': 'anthropic.claude-3-haiku-20240307-v1:0',\n  'claude-3-sonnet': 'anthropic.claude-3-sonnet-20240229-v1:0',\n  'claude-3.5-sonnet': 'anthropic.claude-3-5-sonnet-20240620-v1:0',\n  'llama3-70b': 'meta.llama3-70b-instruct-v1:0',\n  'llama-3.1-70b': 'meta.llama3-1-70b-instruct-v1:0',\n}",
    "originFile": "\\services\\ai\\aws\\consts.ts"
  },
  {
    "id": "\\services\\ai\\aws\\index::bedrockClientWest",
    "language": "typescript",
    "label": "bedrockClientWest",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\index",
    "totalTokens": 62,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const bedrockClientWest = new BedrockRuntimeClient({\n  region: 'us-west-2',\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})",
    "importStatements": [],
    "codeNoBody": "export const bedrockClientWest = new BedrockRuntimeClient({\n  region: 'us-west-2',\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})",
    "originFile": "\\services\\ai\\aws\\index.ts"
  },
  {
    "id": "\\services\\ai\\aws\\index::bedrockClientEast",
    "language": "typescript",
    "label": "bedrockClientEast",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\index",
    "totalTokens": 66,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const bedrockClientEast = new BedrockRuntimeClient({\n  region: getEnv('AWS_BEDROCK_REGION'),\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})",
    "importStatements": [],
    "codeNoBody": "export const bedrockClientEast = new BedrockRuntimeClient({\n  region: getEnv('AWS_BEDROCK_REGION'),\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})",
    "originFile": "\\services\\ai\\aws\\index.ts"
  },
  {
    "id": "\\services\\ai\\aws\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\aws\\index.ts",
    "type": "file",
    "totalTokens": 165,
    "inDegree": 0,
    "outDegree": 2,
    "code": "import {\n  BedrockRuntimeClient,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const bedrockClientEast = new BedrockRuntimeClient({\n  region: getEnv('AWS_BEDROCK_REGION'),\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})\n\nexport const bedrockClientWest = new BedrockRuntimeClient({\n  region: 'us-west-2',\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})\n",
    "importStatements": [
      "import {\n  BedrockRuntimeClient,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import {\n  BedrockRuntimeClient,\n} from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { getEnv } from '@/lib/env.ts'\nexport const bedrockClientEast = new BedrockRuntimeClient({\n  region: getEnv('AWS_BEDROCK_REGION'),\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})\n\nexport const bedrockClientWest = new BedrockRuntimeClient({\n  region: 'us-west-2',\n  credentials: {\n    accessKeyId: getEnv('AWS_BEDROCK_ACCESS_KEY_ID'),\n    secretAccessKey: getEnv('AWS_BEDROCK_SECRET_ACCESS_KEY'),\n  },\n})",
    "originFile": "\\services\\ai\\aws\\index.ts"
  },
  {
    "id": "\\services\\ai\\azure\\chat::createOpenaiResponse",
    "language": "typescript",
    "label": "createOpenaiResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\chat",
    "totalTokens": 237,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function createOpenaiResponse(\n  { messages, model, stream, temperature, functions, function_call }: Props,\n) {\n  const apiVersion =\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].apiVersion\n\n  let client = openaiClient({ apiVersion })\n\n  if (model === 'gpt-4-turbo') {\n    client = openaiTurboClient\n  }\n\n  if (model === 'gpt-4-vision') {\n    client = openaiVisionClient\n  }\n\n  const options: [string, ChatRequestMessage[], GetChatCompletionsOptions] = [\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].model,\n    messages,\n    {\n      temperature,\n      functions,\n      function_call,\n    },\n  ] as const\n\n  try {\n    if (stream) {\n      const response = await client.streamChatCompletions(...options)\n\n      return response\n    }\n\n    const response = await client.getChatCompletions(...options)\n\n    return response\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createOpenaiResponse(\n  { messages, model, stream, temperature, functions, function_call }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\azure\\chat.ts"
  },
  {
    "id": "\\services\\ai\\azure\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\chat",
    "totalTokens": 53,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Props {\n  messages: Array<ChatRequestMessage>\n  abortSignal?: AbortSignal\n  model: string\n  stream: boolean\n  temperature: number\n  functions?: FunctionDefinition[]\n  function_call?: FunctionCallPreset | FunctionName\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\azure\\chat.ts"
  },
  {
    "id": "\\services\\ai\\azure\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\chat.ts",
    "type": "file",
    "totalTokens": 390,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import {\n  openaiClient,\n  openaiTurboClient,\n  openaiVisionClient,\n} from '@/services/ai/azure/index.ts'\nimport type {\n  ChatRequestMessage,\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\n\ninterface Props {\n  messages: Array<ChatRequestMessage>\n  abortSignal?: AbortSignal\n  model: string\n  stream: boolean\n  temperature: number\n  functions?: FunctionDefinition[]\n  function_call?: FunctionCallPreset | FunctionName\n}\n\nexport async function createOpenaiResponse(\n  { messages, model, stream, temperature, functions, function_call }: Props,\n) {\n  const apiVersion =\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].apiVersion\n\n  let client = openaiClient({ apiVersion })\n\n  if (model === 'gpt-4-turbo') {\n    client = openaiTurboClient\n  }\n\n  if (model === 'gpt-4-vision') {\n    client = openaiVisionClient\n  }\n\n  const options: [string, ChatRequestMessage[], GetChatCompletionsOptions] = [\n    AZURE_MODELS_MAP[model as keyof typeof AZURE_MODELS_MAP].model,\n    messages,\n    {\n      temperature,\n      functions,\n      function_call,\n    },\n  ] as const\n\n  try {\n    if (stream) {\n      const response = await client.streamChatCompletions(...options)\n\n      return response\n    }\n\n    const response = await client.getChatCompletions(...options)\n\n    return response\n  } catch (error) {\n    console.log(error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import {\n  openaiClient,\n  openaiTurboClient,\n  openaiVisionClient,\n} from '@/services/ai/azure/index.ts'",
      "import type {\n  ChatRequestMessage,\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'",
      "import { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'"
    ],
    "codeNoBody": "import {\n  openaiClient,\n  openaiTurboClient,\n  openaiVisionClient,\n} from '@/services/ai/azure/index.ts'\nimport type {\n  ChatRequestMessage,\n  FunctionCallPreset,\n  FunctionDefinition,\n  FunctionName,\n  GetChatCompletionsOptions,\n} from 'npm:@azure/openai@1.0.0-beta.12/models'\nimport { AZURE_MODELS_MAP } from '@/services/ai/azure/consts.ts'\ninterface Props {\n//...\n}\n\nexport async function createOpenaiResponse(\n  { messages, model, stream, temperature, functions, function_call }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\azure\\chat.ts"
  },
  {
    "id": "\\services\\ai\\azure\\consts::AZURE_MODELS_MAP",
    "language": "typescript",
    "label": "AZURE_MODELS_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\consts",
    "totalTokens": 261,
    "inDegree": 5,
    "outDegree": 0,
    "code": "export const AZURE_MODELS_MAP = {\n  'text-embedding-ada-002': {\n    model: 'embeddingada002',\n    apiVersion: '2023-09-15-preview',\n  },\n  'gpt-4-turbo': {\n    model: 'gpt4turbopreview',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4-vision': {\n    model: 'gpt4vision',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4': {\n    model: 'gpt4',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo-16k': {\n    model: 'gpt3516k',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo': {\n    model: 'gpt350613',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4o': {\n    model: 'gpt-4o',\n    apiVersion: '2024-02-15-preview',\n  },\n} as const",
    "importStatements": [],
    "codeNoBody": "export const AZURE_MODELS_MAP = {\n  'text-embedding-ada-002': {\n    model: 'embeddingada002',\n    apiVersion: '2023-09-15-preview',\n  },\n  'gpt-4-turbo': {\n    model: 'gpt4turbopreview',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4-vision': {\n    model: 'gpt4vision',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4': {\n    model: 'gpt4',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo-16k': {\n    model: 'gpt3516k',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo': {\n    model: 'gpt350613',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4o': {\n    model: 'gpt-4o',\n    apiVersion: '2024-02-15-preview',\n  },\n} as const",
    "originFile": "\\services\\ai\\azure\\consts.ts"
  },
  {
    "id": "\\services\\ai\\azure\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\consts.ts",
    "type": "file",
    "totalTokens": 262,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export const AZURE_MODELS_MAP = {\n  'text-embedding-ada-002': {\n    model: 'embeddingada002',\n    apiVersion: '2023-09-15-preview',\n  },\n  'gpt-4-turbo': {\n    model: 'gpt4turbopreview',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4-vision': {\n    model: 'gpt4vision',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4': {\n    model: 'gpt4',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo-16k': {\n    model: 'gpt3516k',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo': {\n    model: 'gpt350613',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4o': {\n    model: 'gpt-4o',\n    apiVersion: '2024-02-15-preview',\n  },\n} as const\n",
    "importStatements": [],
    "codeNoBody": "export const AZURE_MODELS_MAP = {\n  'text-embedding-ada-002': {\n    model: 'embeddingada002',\n    apiVersion: '2023-09-15-preview',\n  },\n  'gpt-4-turbo': {\n    model: 'gpt4turbopreview',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4-vision': {\n    model: 'gpt4vision',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4': {\n    model: 'gpt4',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo-16k': {\n    model: 'gpt3516k',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-3.5-turbo': {\n    model: 'gpt350613',\n    apiVersion: '2023-07-01-preview',\n  },\n  'gpt-4o': {\n    model: 'gpt-4o',\n    apiVersion: '2024-02-15-preview',\n  },\n} as const",
    "originFile": "\\services\\ai\\azure\\consts.ts"
  },
  {
    "id": "\\services\\ai\\azure\\index::openaiVisionClient",
    "language": "typescript",
    "label": "openaiVisionClient",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\index",
    "totalTokens": 54,
    "inDegree": 2,
    "outDegree": 1,
    "code": "export const openaiVisionClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_VISION'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_VISION')),\n  { apiVersion: '2023-07-01-preview' },\n)",
    "importStatements": [],
    "codeNoBody": "export const openaiVisionClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_VISION'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_VISION')),\n  { apiVersion: '2023-07-01-preview' },\n)",
    "originFile": "\\services\\ai\\azure\\index.ts"
  },
  {
    "id": "\\services\\ai\\azure\\index::openaiTurboClient",
    "language": "typescript",
    "label": "openaiTurboClient",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\index",
    "totalTokens": 59,
    "inDegree": 1,
    "outDegree": 1,
    "code": "export const openaiTurboClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_TURBO'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_TURBO')),\n  {\n    apiVersion: '2023-07-01-preview',\n  },\n)",
    "importStatements": [],
    "codeNoBody": "export const openaiTurboClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_TURBO'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_TURBO')),\n  {\n    apiVersion: '2023-07-01-preview',\n  },\n)",
    "originFile": "\\services\\ai\\azure\\index.ts"
  },
  {
    "id": "\\services\\ai\\azure\\index::openaiClient",
    "language": "typescript",
    "label": "openaiClient",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\index",
    "totalTokens": 66,
    "inDegree": 4,
    "outDegree": 1,
    "code": "const openaiClient = (\n  { apiVersion = '2023-07-01-preview' }: { apiVersion?: string } = {},\n) =>\n  new OpenAIClient(\n    getEnv('AZURE_OPENAI_ENDPOINT'),\n    new AzureKeyCredential(getEnv('AZURE_KEY')),\n    { apiVersion },\n  )",
    "importStatements": [],
    "codeNoBody": "const openaiClient = (\n  { apiVersion = '2023-07-01-preview' }: { apiVersion?: string } = {},\n) =>\n  {\n       //...\n       }",
    "originFile": "\\services\\ai\\azure\\index.ts"
  },
  {
    "id": "\\services\\ai\\azure\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\azure\\index.ts",
    "type": "file",
    "totalTokens": 221,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import {\n  AzureKeyCredential,\n  OpenAIClient,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const openaiClient = (\n  { apiVersion = '2023-07-01-preview' }: { apiVersion?: string } = {},\n) =>\n  new OpenAIClient(\n    getEnv('AZURE_OPENAI_ENDPOINT'),\n    new AzureKeyCredential(getEnv('AZURE_KEY')),\n    { apiVersion },\n  )\n\nexport const openaiTurboClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_TURBO'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_TURBO')),\n  {\n    apiVersion: '2023-07-01-preview',\n  },\n)\n\nexport const openaiVisionClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_VISION'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_VISION')),\n  { apiVersion: '2023-07-01-preview' },\n)\n",
    "importStatements": [
      "import {\n  AzureKeyCredential,\n  OpenAIClient,\n} from 'npm:@azure/openai@1.0.0-beta.12'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import {\n  AzureKeyCredential,\n  OpenAIClient,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { getEnv } from '@/lib/env.ts'\nexport const openaiClient = (\n  { apiVersion = '2023-07-01-preview' }: { apiVersion?: string } = {},\n) =>\n  {\n       //...\n       }\n\nexport const openaiTurboClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_TURBO'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_TURBO')),\n  {\n    apiVersion: '2023-07-01-preview',\n  },\n)\n\nexport const openaiVisionClient = new OpenAIClient(\n  getEnv('AZURE_OPENAI_ENDPOINT_VISION'),\n  new AzureKeyCredential(getEnv('AZURE_KEY_VISION')),\n  { apiVersion: '2023-07-01-preview' },\n)",
    "originFile": "\\services\\ai\\azure\\index.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\chat::createCohereResponse",
    "language": "typescript",
    "label": "createCohereResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\chat",
    "totalTokens": 152,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function createCohereResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n  const chatHistory = messages.map((message: ChatMessage) => ({\n    message: message.content,\n    role: toCohereRole(message.role),\n  }))\n\n  const lastMessage = chatHistory.pop()\n\n  if (stream) {\n    const cohereStream = await cohere.chatStream({\n      message: lastMessage?.message ?? '',\n      chatHistory,\n      model,\n      temperature,\n    })\n\n    return cohereStream\n  }\n\n  const cohereResponse = await cohere.chat({\n    model,\n    message: lastMessage?.message ?? '',\n    chatHistory,\n    temperature,\n  })\n\n  return cohereResponse\n}",
    "importStatements": [],
    "codeNoBody": "async function createCohereResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\cohere\\chat.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\chat::toCohereRole",
    "language": "typescript",
    "label": "toCohereRole",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\chat",
    "totalTokens": 70,
    "inDegree": 2,
    "outDegree": 0,
    "code": "const toCohereRole = (role: string): Cohere.ChatMessageRole => {\n  if (role === 'user') {\n    return Cohere.ChatMessageRole.User\n  }\n  if (role === 'system') {\n    return Cohere.ChatMessageRole.System\n  }\n  return Cohere.ChatMessageRole.Chatbot\n}",
    "importStatements": [],
    "codeNoBody": "const toCohereRole = (role: string): Cohere.ChatMessageRole => {\n//...\n}",
    "originFile": "\\services\\ai\\cohere\\chat.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\chat",
    "totalTokens": 25,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\cohere\\chat.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\chat.ts",
    "type": "file",
    "totalTokens": 295,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import type { ChatMessage } from '@/types/index.ts'\nimport { Cohere } from 'npm:cohere-ai@7.9.5'\nimport { cohere } from '@/services/ai/cohere/index.ts'\n\ninterface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}\n\nconst toCohereRole = (role: string): Cohere.ChatMessageRole => {\n  if (role === 'user') {\n    return Cohere.ChatMessageRole.User\n  }\n  if (role === 'system') {\n    return Cohere.ChatMessageRole.System\n  }\n  return Cohere.ChatMessageRole.Chatbot\n}\n\nexport async function createCohereResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n  const chatHistory = messages.map((message: ChatMessage) => ({\n    message: message.content,\n    role: toCohereRole(message.role),\n  }))\n\n  const lastMessage = chatHistory.pop()\n\n  if (stream) {\n    const cohereStream = await cohere.chatStream({\n      message: lastMessage?.message ?? '',\n      chatHistory,\n      model,\n      temperature,\n    })\n\n    return cohereStream\n  }\n\n  const cohereResponse = await cohere.chat({\n    model,\n    message: lastMessage?.message ?? '',\n    chatHistory,\n    temperature,\n  })\n\n  return cohereResponse\n}\n",
    "importStatements": [
      "import type { ChatMessage } from '@/types/index.ts'",
      "import { Cohere } from 'npm:cohere-ai@7.9.5'",
      "import { cohere } from '@/services/ai/cohere/index.ts'"
    ],
    "codeNoBody": "import type { ChatMessage } from '@/types/index.ts'\nimport { Cohere } from 'npm:cohere-ai@7.9.5'\nimport { cohere } from '@/services/ai/cohere/index.ts'\ninterface Props {\n//...\n}\n\nconst toCohereRole = (role: string): Cohere.ChatMessageRole => {\n//...\n}\n\nexport async function createCohereResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\cohere\\chat.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\index::cohere",
    "language": "typescript",
    "label": "cohere",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\index",
    "totalTokens": 22,
    "inDegree": 2,
    "outDegree": 1,
    "code": "export const cohere = new CohereClient({\n  token: getEnv('COHERE_API_KEY'),\n})",
    "importStatements": [],
    "codeNoBody": "export const cohere = new CohereClient({\n  token: getEnv('COHERE_API_KEY'),\n})",
    "originFile": "\\services\\ai\\cohere\\index.ts"
  },
  {
    "id": "\\services\\ai\\cohere\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\cohere\\index.ts",
    "type": "file",
    "totalTokens": 54,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { CohereClient } from 'npm:cohere-ai@7.9.5'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const cohere = new CohereClient({\n  token: getEnv('COHERE_API_KEY'),\n})\n",
    "importStatements": [
      "import { CohereClient } from 'npm:cohere-ai@7.9.5'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { CohereClient } from 'npm:cohere-ai@7.9.5'\nimport { getEnv } from '@/lib/env.ts'\nexport const cohere = new CohereClient({\n  token: getEnv('COHERE_API_KEY'),\n})",
    "originFile": "\\services\\ai\\cohere\\index.ts"
  },
  {
    "id": "\\services\\ai\\google\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\chat.ts",
    "type": "file",
    "totalTokens": 513,
    "inDegree": 0,
    "outDegree": 0,
    "code": "// import { genAI } from '@/services/ai/google/index.ts'\n// import type { ChatMessage } from '@/types/index.ts'\n// import type { ModelParams } from 'npm:@google/generative-ai@0.8.0'\n\n// interface Props {\n//   messages: ChatMessage[]\n//   model: string\n//   stream: boolean\n//   temperature: number\n// }\n\n// const buildGoogleGenAIPrompt = ({ messages, temperature }: {\n//   messages: ChatMessage[]\n//   temperature: number\n// }) => ({\n//   contents: messages\n//     .filter((message) =>\n//       message.role === 'user' || message.role === 'assistant'\n//     )\n//     .map((message) => ({\n//       role: message.role === 'user' ? 'user' : 'model',\n//       parts: [{ text: message.content }],\n//     })),\n//   generationConfig: {\n//     temperature,\n//   },\n//   safetySettings: [\n//     {\n//       'category': 'HARM_CATEGORY_HARASSMENT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_HATE_SPEECH',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//   ],\n// })\n\n// export async function createGenAIResponse(\n//   { model, messages, stream, temperature }: Props,\n// ) {\n//   try {\n//     console.log('createGenAIResponse', { model, messages, stream, temperature })\n//     const options: ModelParams = {\n//       model,\n//     }\n\n//     if (stream) {\n//       const geminiStream = await genAI.getGenerativeModel(options)\n//         .generateContentStream(\n//           buildGoogleGenAIPrompt({ messages, temperature }),\n//         )\n\n//       return geminiStream\n//     }\n\n//     const geminiResponse = await genAI.getGenerativeModel(options)\n//       .generateContent(buildGoogleGenAIPrompt({ messages, temperature }))\n\n//     return geminiResponse\n//   } catch (error) {\n//     console.error(error)\n//     throw error\n//   }\n// }\n",
    "importStatements": [],
    "codeNoBody": "// import { genAI } from '@/services/ai/google/index.ts'\n// import type { ChatMessage } from '@/types/index.ts'\n// import type { ModelParams } from 'npm:@google/generative-ai@0.8.0'\n// interface Props {\n//   messages: ChatMessage[]\n//   model: string\n//   stream: boolean\n//   temperature: number\n// }\n\n// const buildGoogleGenAIPrompt = ({ messages, temperature }: {\n//   messages: ChatMessage[]\n//   temperature: number\n// }) => ({\n//   contents: messages\n//     .filter((message) =>\n//       message.role === 'user' || message.role === 'assistant'\n//     )\n//     .map((message) => ({\n//       role: message.role === 'user' ? 'user' : 'model',\n//       parts: [{ text: message.content }],\n//     })),\n//   generationConfig: {\n//     temperature,\n//   },\n//   safetySettings: [\n//     {\n//       'category': 'HARM_CATEGORY_HARASSMENT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_HATE_SPEECH',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//     {\n//       'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',\n//       'threshold': 'BLOCK_NONE',\n//     },\n//   ],\n// })\n\n// export async function createGenAIResponse(\n//   { model, messages, stream, temperature }: Props,\n// ) {\n//   try {\n//     console.log('createGenAIResponse', { model, messages, stream, temperature })\n//     const options: ModelParams = {\n//       model,\n//     }\n\n//     if (stream) {\n//       const geminiStream = await genAI.getGenerativeModel(options)\n//         .generateContentStream(\n//           buildGoogleGenAIPrompt({ messages, temperature }),\n//         )\n\n//       return geminiStream\n//     }\n\n//     const geminiResponse = await genAI.getGenerativeModel(options)\n//       .generateContent(buildGoogleGenAIPrompt({ messages, temperature }))\n\n//     return geminiResponse\n//   } catch (error) {\n//     console.error(error)\n//     throw error\n//   }\n// }",
    "originFile": "\\services\\ai\\google\\chat.ts"
  },
  {
    "id": "\\services\\ai\\google\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\index.ts",
    "type": "file",
    "totalTokens": 58,
    "inDegree": 0,
    "outDegree": 0,
    "code": "// import { GoogleGenerativeAI } from 'npm:@google/generative-ai@0.8.0'\n// import { getEnv } from '@/lib/env.ts'\n\n// export const genAI = new GoogleGenerativeAI(getEnv('GOOGLE_GEMINI_APIKEY'))\n",
    "importStatements": [],
    "codeNoBody": "// import { GoogleGenerativeAI } from 'npm:@google/generative-ai@0.8.0'\n// import { getEnv } from '@/lib/env.ts'\n// export const genAI = new GoogleGenerativeAI(getEnv('GOOGLE_GEMINI_APIKEY'))",
    "originFile": "\\services\\ai\\google\\index.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\chat::createVertexAIResponse",
    "language": "typescript",
    "label": "createVertexAIResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\chat",
    "totalTokens": 456,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function createVertexAIResponse(\n  { model, messages, stream, temperature }: Props,\n) {\n  try {\n    const generativeModel = vertexAI.getGenerativeModel(\n      {\n        model: VERTEX_MODELS_MAP[model as keyof typeof VERTEX_MODELS_MAP],\n        /*\n          Gus si lees esto, lo desactive porque tiraba error los safetySettings,\n          dice que revisemos la cuenta de google pero no tengo acceso atte. yo el igna todo fue mi culpa\n        */\n        // safetySettings: [\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_UNSPECIFIED,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        // ],\n        generationConfig: {\n          temperature,\n          maxOutputTokens: 8192,\n        },\n      },\n    )\n\n    const request: GenerateContentRequest = {\n      contents: messages\n        .filter((message) =>\n          message.role === 'user' || message.role === 'assistant'\n        )\n        .map((message) => ({\n          role: message.role === 'user' ? 'USER' : 'MODEL',\n          parts: [{ text: message.content }],\n        })),\n    }\n\n    if (stream) {\n      const vertexStream = await generativeModel.generateContentStream(request)\n\n      return vertexStream\n    }\n\n    const vertexResponse = await generativeModel.generateContent(request)\n\n    return vertexResponse\n  } catch (error) {\n    console.error(error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createVertexAIResponse(\n  { model, messages, stream, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\google\\vertex\\chat.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\chat",
    "totalTokens": 25,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\google\\vertex\\chat.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\chat.ts",
    "type": "file",
    "totalTokens": 584,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { vertexAI } from '@/services/ai/google/vertex/index.ts'\nimport type { ChatMessage } from '@/types/index.ts'\n// import {\n//   HarmBlockThreshold,\n//   HarmCategory,\n// } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { GenerateContentRequest } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'\n\ninterface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}\n\nexport async function createVertexAIResponse(\n  { model, messages, stream, temperature }: Props,\n) {\n  try {\n    const generativeModel = vertexAI.getGenerativeModel(\n      {\n        model: VERTEX_MODELS_MAP[model as keyof typeof VERTEX_MODELS_MAP],\n        /*\n          Gus si lees esto, lo desactive porque tiraba error los safetySettings,\n          dice que revisemos la cuenta de google pero no tengo acceso atte. yo el igna todo fue mi culpa\n        */\n        // safetySettings: [\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        //   {\n        //     category: HarmCategory.HARM_CATEGORY_UNSPECIFIED,\n        //     'threshold': HarmBlockThreshold.BLOCK_NONE,\n        //   },\n        // ],\n        generationConfig: {\n          temperature,\n          maxOutputTokens: 8192,\n        },\n      },\n    )\n\n    const request: GenerateContentRequest = {\n      contents: messages\n        .filter((message) =>\n          message.role === 'user' || message.role === 'assistant'\n        )\n        .map((message) => ({\n          role: message.role === 'user' ? 'USER' : 'MODEL',\n          parts: [{ text: message.content }],\n        })),\n    }\n\n    if (stream) {\n      const vertexStream = await generativeModel.generateContentStream(request)\n\n      return vertexStream\n    }\n\n    const vertexResponse = await generativeModel.generateContent(request)\n\n    return vertexResponse\n  } catch (error) {\n    console.error(error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import { vertexAI } from '@/services/ai/google/vertex/index.ts'",
      "import type { ChatMessage } from '@/types/index.ts'",
      "import { GenerateContentRequest } from 'npm:@google-cloud/vertexai@1.1.0'",
      "import { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'"
    ],
    "codeNoBody": "import { vertexAI } from '@/services/ai/google/vertex/index.ts'\nimport type { ChatMessage } from '@/types/index.ts'\n// import {\n//   HarmBlockThreshold,\n//   HarmCategory,\n// } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { GenerateContentRequest } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { VERTEX_MODELS_MAP } from '@/services/ai/google/vertex/consts.ts'\ninterface Props {\n//...\n}\n\nexport async function createVertexAIResponse(\n  { model, messages, stream, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\google\\vertex\\chat.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\consts::VERTEX_MODELS_MAP",
    "language": "typescript",
    "label": "VERTEX_MODELS_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\consts",
    "totalTokens": 81,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const VERTEX_MODELS_MAP = {\n  'gemini-1.5-pro-latest': 'gemini-1.5-pro-preview-0409',\n  'gemini-1.0-pro': 'gemini-1.0-pro-002',\n  'gemini-1.5-flash': 'gemini-1.5-flash-preview-0514',\n} as const",
    "importStatements": [],
    "codeNoBody": "export const VERTEX_MODELS_MAP = {\n  'gemini-1.5-pro-latest': 'gemini-1.5-pro-preview-0409',\n  'gemini-1.0-pro': 'gemini-1.0-pro-002',\n  'gemini-1.5-flash': 'gemini-1.5-flash-preview-0514',\n} as const",
    "originFile": "\\services\\ai\\google\\vertex\\consts.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\consts.ts",
    "type": "file",
    "totalTokens": 82,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export const VERTEX_MODELS_MAP = {\n  'gemini-1.5-pro-latest': 'gemini-1.5-pro-preview-0409',\n  'gemini-1.0-pro': 'gemini-1.0-pro-002',\n  'gemini-1.5-flash': 'gemini-1.5-flash-preview-0514',\n} as const\n",
    "importStatements": [],
    "codeNoBody": "export const VERTEX_MODELS_MAP = {\n  'gemini-1.5-pro-latest': 'gemini-1.5-pro-preview-0409',\n  'gemini-1.0-pro': 'gemini-1.0-pro-002',\n  'gemini-1.5-flash': 'gemini-1.5-flash-preview-0514',\n} as const",
    "originFile": "\\services\\ai\\google\\vertex\\consts.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\index::vertexAI",
    "language": "typescript",
    "label": "vertexAI",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\index",
    "totalTokens": 64,
    "inDegree": 3,
    "outDegree": 1,
    "code": "export const vertexAI = new VertexAI({\n  project: getEnv('VERTEX_PROJECT_ID'),\n  location: 'us-central1',\n  googleAuthOptions: {\n    credentials: {\n      client_email: getEnv('VERTEX_CLIENT_EMAIL'),\n      private_key: getEnv('VERTEX_PRIVATE_KEY'),\n    },\n  },\n})",
    "importStatements": [],
    "codeNoBody": "export const vertexAI = new VertexAI({\n  project: getEnv('VERTEX_PROJECT_ID'),\n  location: 'us-central1',\n  googleAuthOptions: {\n    credentials: {\n      client_email: getEnv('VERTEX_CLIENT_EMAIL'),\n      private_key: getEnv('VERTEX_PRIVATE_KEY'),\n    },\n  },\n})",
    "originFile": "\\services\\ai\\google\\vertex\\index.ts"
  },
  {
    "id": "\\services\\ai\\google\\vertex\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\google\\vertex\\index.ts",
    "type": "file",
    "totalTokens": 96,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { VertexAI } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const vertexAI = new VertexAI({\n  project: getEnv('VERTEX_PROJECT_ID'),\n  location: 'us-central1',\n  googleAuthOptions: {\n    credentials: {\n      client_email: getEnv('VERTEX_CLIENT_EMAIL'),\n      private_key: getEnv('VERTEX_PRIVATE_KEY'),\n    },\n  },\n})\n",
    "importStatements": [
      "import { VertexAI } from 'npm:@google-cloud/vertexai@1.1.0'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { VertexAI } from 'npm:@google-cloud/vertexai@1.1.0'\nimport { getEnv } from '@/lib/env.ts'\nexport const vertexAI = new VertexAI({\n  project: getEnv('VERTEX_PROJECT_ID'),\n  location: 'us-central1',\n  googleAuthOptions: {\n    credentials: {\n      client_email: getEnv('VERTEX_CLIENT_EMAIL'),\n      private_key: getEnv('VERTEX_PRIVATE_KEY'),\n    },\n  },\n})",
    "originFile": "\\services\\ai\\google\\vertex\\index.ts"
  },
  {
    "id": "\\services\\ai\\groq\\chat::createGroqResponse",
    "language": "typescript",
    "label": "createGroqResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\chat",
    "totalTokens": 149,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function createGroqResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n  try {\n    if (stream) {\n      const groqResponse = await groq.chat.completions.create({\n        messages,\n        model: GROQ_MODELS_MAP[model as keyof typeof GROQ_MODELS_MAP],\n        temperature,\n        stream: true,\n      })\n\n      return groqResponse\n    }\n\n    const groqResponse = await groq.chat.completions.create({\n      messages,\n      model,\n      temperature,\n      stream: false,\n    })\n\n    return groqResponse\n  } catch (error) {\n    console.log('Error creating groq response', error)\n    throw error\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createGroqResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\groq\\chat.ts"
  },
  {
    "id": "\\services\\ai\\groq\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\chat",
    "totalTokens": 25,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\groq\\chat.ts"
  },
  {
    "id": "\\services\\ai\\groq\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\chat.ts",
    "type": "file",
    "totalTokens": 223,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { ChatMessage } from '@/types/index.ts'\nimport { groq } from '@/services/ai/groq/index.ts'\nimport { GROQ_MODELS_MAP } from '@/services/ai/groq/consts.ts'\n\ninterface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n}\n\nexport async function createGroqResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n  try {\n    if (stream) {\n      const groqResponse = await groq.chat.completions.create({\n        messages,\n        model: GROQ_MODELS_MAP[model as keyof typeof GROQ_MODELS_MAP],\n        temperature,\n        stream: true,\n      })\n\n      return groqResponse\n    }\n\n    const groqResponse = await groq.chat.completions.create({\n      messages,\n      model,\n      temperature,\n      stream: false,\n    })\n\n    return groqResponse\n  } catch (error) {\n    console.log('Error creating groq response', error)\n    throw error\n  }\n}\n",
    "importStatements": [
      "import { ChatMessage } from '@/types/index.ts'",
      "import { groq } from '@/services/ai/groq/index.ts'",
      "import { GROQ_MODELS_MAP } from '@/services/ai/groq/consts.ts'"
    ],
    "codeNoBody": "import { ChatMessage } from '@/types/index.ts'\nimport { groq } from '@/services/ai/groq/index.ts'\nimport { GROQ_MODELS_MAP } from '@/services/ai/groq/consts.ts'\ninterface Props {\n//...\n}\n\nexport async function createGroqResponse(\n  { messages, stream, model, temperature }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\groq\\chat.ts"
  },
  {
    "id": "\\services\\ai\\groq\\consts::GROQ_MODELS_MAP",
    "language": "typescript",
    "label": "GROQ_MODELS_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\consts",
    "totalTokens": 86,
    "inDegree": 2,
    "outDegree": 0,
    "code": "export const GROQ_MODELS_MAP = {\n  'llama3.1-70b': 'llama-3.1-70b-versatile',\n  'llama3-70b-8192': 'llama-3-70b-8192',\n  'mixtral-8x7b-32768': 'mixtral-8x7b-32768',\n}",
    "importStatements": [],
    "codeNoBody": "export const GROQ_MODELS_MAP = {\n  'llama3.1-70b': 'llama-3.1-70b-versatile',\n  'llama3-70b-8192': 'llama-3-70b-8192',\n  'mixtral-8x7b-32768': 'mixtral-8x7b-32768',\n}",
    "originFile": "\\services\\ai\\groq\\consts.ts"
  },
  {
    "id": "\\services\\ai\\groq\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\consts.ts",
    "type": "file",
    "totalTokens": 86,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export const GROQ_MODELS_MAP = {\n  'llama3.1-70b': 'llama-3.1-70b-versatile',\n  'llama3-70b-8192': 'llama-3-70b-8192',\n  'mixtral-8x7b-32768': 'mixtral-8x7b-32768',\n}\n",
    "importStatements": [],
    "codeNoBody": "export const GROQ_MODELS_MAP = {\n  'llama3.1-70b': 'llama-3.1-70b-versatile',\n  'llama3-70b-8192': 'llama-3-70b-8192',\n  'mixtral-8x7b-32768': 'mixtral-8x7b-32768',\n}",
    "originFile": "\\services\\ai\\groq\\consts.ts"
  },
  {
    "id": "\\services\\ai\\groq\\index::groq",
    "language": "typescript",
    "label": "groq",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\index",
    "totalTokens": 21,
    "inDegree": 2,
    "outDegree": 1,
    "code": "export const groq = new Groq({ apiKey: getEnv('GROQ_API_KEY') })",
    "importStatements": [],
    "codeNoBody": "export const groq = new Groq({ apiKey: getEnv('GROQ_API_KEY') })",
    "originFile": "\\services\\ai\\groq\\index.ts"
  },
  {
    "id": "\\services\\ai\\groq\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\groq\\index.ts",
    "type": "file",
    "totalTokens": 49,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import Groq from 'npm:groq-sdk@0.3.2'\nimport { getEnv } from '@/lib/env.ts'\n\nexport const groq = new Groq({ apiKey: getEnv('GROQ_API_KEY') })\n",
    "importStatements": [
      "import Groq from 'npm:groq-sdk@0.3.2'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import Groq from 'npm:groq-sdk@0.3.2'\nimport { getEnv } from '@/lib/env.ts'\nexport const groq = new Groq({ apiKey: getEnv('GROQ_API_KEY') })",
    "originFile": "\\services\\ai\\groq\\index.ts"
  },
  {
    "id": "\\services\\ai\\index::onFinal",
    "language": "typescript",
    "label": "onFinal",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\index::createModelResponse",
    "totalTokens": 16,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async onFinal(completion) {\n          await onFinal?.({ completion })\n        }",
    "importStatements": [],
    "codeNoBody": "async onFinal(completion) {\n        //...\n        }",
    "originFile": "\\services\\ai\\index.ts"
  },
  {
    "id": "\\services\\ai\\index::createModelResponse",
    "language": "typescript",
    "label": "createModelResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\index",
    "totalTokens": 2641,
    "inDegree": 2,
    "outDegree": 9,
    "code": "async function createModelResponse(\n  {\n    messages: userMessages,\n    agentName,\n    model,\n    abortSignal,\n    format,\n    stream,\n    temperature = 0.7,\n    c,\n    systemPrompt,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  }: Props,\n) {\n  if (model.includes('gpt')) {\n    const openaiMessages: any[] = userMessages.map(\n      ({ content, role, name, function_call }) => {\n        const obj: Record<string, any> = {\n          role,\n          content,\n        }\n\n        if (function_call) obj.function_call = function_call\n\n        if (name) obj.name = name\n\n        return obj\n      },\n    )\n    const openaiResponse = await createOpenaiResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      abortSignal,\n      stream,\n      temperature,\n      functions,\n      function_call,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n\n        for await (\n          const event of openaiResponse as EventStream<ChatCompletions>\n        ) {\n          for (const choice of event.choices) {\n            const {\n              delta = { content: '', functionCall: null, finishRease: null },\n            } = choice\n            const content = delta.content ?? ''\n            completion += content\n            const obj: Record<string, any> = {\n              agentName: agentName ?? model,\n              choices: [{\n                delta: { role: 'assistant', content },\n                finish_reason: choice.finishReason,\n              }],\n            }\n            if (delta.functionCall) {\n              obj.choices[0].delta.function_call = delta.functionCall\n            }\n            const json = JSON.stringify(obj)\n\n            onToken?.(content)\n            await stream.write(\n              format === 'text' ? content : `data: ${json}\\n\\n`,\n            )\n            await stream.sleep(100)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = openaiResponse as ChatCompletions\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.promptTokens ?? 0,\n        completionTokens: res.usage?.completionTokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const bedrockMessages = userMessages.map(({ content, role }) => {\n    return {\n      role,\n      content,\n    }\n  })\n\n  if (\n    model.includes('claude') || ['llama3-70b', 'llama-3.1-70b'].includes(model)\n  ) {\n    const bedrockResponse = await createBedrockResponse({\n      model,\n      messages: bedrockMessages,\n      abortSignal,\n      stream,\n      systemPrompt,\n      temperature,\n    })\n\n    if (\n      stream\n    ) {\n      return streamText(c, async (stream) => {\n        const iterable =\n          (bedrockResponse as InvokeModelWithResponseStreamCommandOutput).body\n\n        if (!iterable) return stream.close()\n        const decoder = new TextDecoder()\n        let completion = ''\n        for await (const responseStream of iterable) {\n          const chunk = responseStream.chunk?.bytes\n          if (chunk) {\n            const res = JSON.parse(decoder.decode(chunk))\n\n            const content = model.includes('claude')\n              ? res?.delta?.text ?? ''\n              : res.generation ?? ''\n\n            completion += content\n            onToken?.(content)\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n            stream.write(format === 'text' ? content : json)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = bedrockResponse as {\n      id: string\n      type: string\n      role: string\n      content: {\n        type: string\n        text: string\n      }[]\n      model: string\n      stop_reason: string\n      stop_sequence: string | null\n      usage: { input_tokens: number; output_tokens: number }\n    }\n    const content = res.content[0].text\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.usage.input_tokens,\n        completionTokens: res.usage.output_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (model.includes('command')) {\n    const cohereResponse = await createCohereResponse({\n      model,\n      messages: [{\n        role: 'system',\n        content: systemPrompt,\n      }, ...userMessages],\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n        for await (const chat of cohereResponse as any) {\n          if (chat.eventType === 'text-generation') {\n            const content = chat.text\n\n            completion += content\n            onToken?.(content)\n\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n\n            const chunk = format === 'text' ? content : json\n\n            await stream.write(chunk)\n          }\n        }\n\n        await onFinal?.({ completion })\n        stream.close()\n      })\n    }\n\n    const res = cohereResponse as Cohere.NonStreamedChatResponse\n    const content = res.text\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.meta?.tokens?.inputTokens ?? 0,\n        completionTokens: res.meta?.tokens?.outputTokens ?? 0,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (\n    ['llama3-70b-8192', 'mixtral-8x7b-32768', 'llama3.1-70b'].includes(model)\n  ) {\n    const openaiMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const groqResponse = await createGroqResponse({\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      model,\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      const groqStream = OpenAIStream(groqResponse as any, {\n        onToken,\n        async onFinal(completion) {\n          await onFinal?.({ completion })\n        },\n      })\n\n      return streamText(c, async (stream) => {\n        for await (const content of streamReader(groqStream)) {\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          const chunk = format === 'text' ? content : json\n          await stream.write(chunk)\n        }\n\n        stream.close()\n      })\n    }\n\n    const res = groqResponse as ChatCompletion\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.prompt_tokens ?? 0,\n        completionTokens: res.usage?.completion_tokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (['codestral'].includes(model)) {\n    const codestralMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const codestralResponse = await createMistralResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...codestralMessages as any,\n      ],\n      stream,\n      temperature,\n      abortSignal,\n    })\n\n    const { res } = codestralResponse\n\n    if (!res) {\n      return c.json({ error: 'Error calling mistral' }, { status: 400 })\n    }\n\n    if (stream) {\n      let completion = ''\n      let promptTokens = 0\n      let completionTokens = 0\n\n      return streamText(c, async (stream) => {\n        for await (const chunk of streamReader(res.body as ReadableStream)) {\n          if (chunk.includes('[DONE]')) break\n          if (!chunk.includes('data: ')) continue\n          const data = JSON.parse(chunk.split('data: ')[1])\n\n          if (data.choices[0].finish_reason === 'stop') {\n            promptTokens = data.usage.prompt_tokens\n            completionTokens = data.usage.completion_tokens\n            break\n          }\n\n          const content = data.choices[0].delta.content\n          completion += content\n          onToken?.(content)\n\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          await stream.write(format === 'text' ? content : json)\n        }\n\n        await onFinal?.({\n          completion,\n          tokens: {\n            promptTokens,\n            completionTokens,\n          },\n        })\n\n        await stream.close()\n      })\n    }\n\n    const data = await res.json()\n    const content = data.choices[0].message.content\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        completionTokens: data.usage.prompt_tokens,\n        promptTokens: data.usage.completion_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const vertexResponse = await createVertexAIResponse({\n    model,\n    messages: [{ role: 'user', content: systemPrompt }, {\n      role: 'assistant',\n      content: 'OK. I will follow your instructions.',\n    }, ...userMessages],\n    stream,\n    temperature,\n  })\n\n  if (stream) {\n    const response = vertexResponse as StreamGenerateContentResult\n\n    return streamText(c, async (stream) => {\n      let completion = ''\n      for await (const item of response.stream) {\n        let content = ''\n\n        const isBlockList = item?.candidates?.[0].finishReason === 'BLOCKLIST'\n\n        if (isBlockList) {\n          content =\n            \"Google Alert\\nSomething went wrong with my safety ratings system.\\nI can't continue this conversation.\\nPlease start a new one with a different topic using the button below.\"\n        } else {\n          content = item?.candidates?.[0].content.parts[0].text ?? ''\n        }\n\n        completion += content\n        onToken?.(content)\n\n        const json = JSON.stringify({\n          agentName: agentName ?? model,\n          choices: [{ delta: { role: 'assistant', content } }],\n        })\n\n        const chunk = format === 'text' ? content : json\n\n        await stream.write(chunk)\n      }\n\n      await onFinal?.({ completion })\n      stream.close()\n    })\n  }\n\n  const response = vertexResponse as GenerateContentResult\n\n  const content = response.response.candidates?.[0].content.parts[0].text ?? ''\n  const json = {\n    agentName: agentName ?? model,\n    choices: [{ message: { role: 'assistant', content } }],\n  }\n\n  await onFinal?.({\n    completion: content,\n    tokens: {\n      completionTokens: response.response.usageMetadata?.candidatesTokenCount ??\n        0,\n      promptTokens: response.response.usageMetadata?.promptTokenCount ?? 0,\n    },\n  })\n\n  return c.json(format === 'text' ? content : json)\n}",
    "importStatements": [],
    "codeNoBody": "async function createModelResponse(\n  {\n    messages: userMessages,\n    agentName,\n    model,\n    abortSignal,\n    format,\n    stream,\n    temperature = 0.7,\n    c,\n    systemPrompt,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  }: Props,\n) {\n  if (model.includes('gpt')) {\n    const openaiMessages: any[] = userMessages.map(\n      ({ content, role, name, function_call }) => {\n        const obj: Record<string, any> = {\n          role,\n          content,\n        }\n        if (function_call) obj.function_call = function_call\n\n        if (name) obj.name = name\n\n        return obj\n      },\n    )\n    const openaiResponse = await createOpenaiResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      abortSignal,\n      stream,\n      temperature,\n      functions,\n      function_call,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n\n        for await (\n          const event of openaiResponse as EventStream<ChatCompletions>\n        ) {\n          for (const choice of event.choices) {\n            const {\n              delta = { content: '', functionCall: null, finishRease: null },\n            } = choice\n            const content = delta.content ?? ''\n            completion += content\n            const obj: Record<string, any> = {\n              agentName: agentName ?? model,\n              choices: [{\n                delta: { role: 'assistant', content },\n                finish_reason: choice.finishReason,\n              }],\n            }\n            if (delta.functionCall) {\n              obj.choices[0].delta.function_call = delta.functionCall\n            }\n            const json = JSON.stringify(obj)\n\n            onToken?.(content)\n            await stream.write(\n              format === 'text' ? content : `data: ${json}\\n\\n`,\n            )\n            await stream.sleep(100)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = openaiResponse as ChatCompletions\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.promptTokens ?? 0,\n        completionTokens: res.usage?.completionTokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const bedrockMessages = userMessages.map(({ content, role }) => {\n    return {\n      role,\n      content,\n    }\n  })\n\n  if (\n    model.includes('claude') || ['llama3-70b', 'llama-3.1-70b'].includes(model)\n  ) {\n    const bedrockResponse = await createBedrockResponse({\n      model,\n      messages: bedrockMessages,\n      abortSignal,\n      stream,\n      systemPrompt,\n      temperature,\n    })\n\n    if (\n      stream\n    ) {\n      return streamText(c, async (stream) => {\n        const iterable =\n          (bedrockResponse as InvokeModelWithResponseStreamCommandOutput).body\n\n        if (!iterable) return stream.close()\n        const decoder = new TextDecoder()\n        let completion = ''\n        for await (const responseStream of iterable) {\n          const chunk = responseStream.chunk?.bytes\n          if (chunk) {\n            const res = JSON.parse(decoder.decode(chunk))\n\n            const content = model.includes('claude')\n              ? res?.delta?.text ?? ''\n              : res.generation ?? ''\n\n            completion += content\n            onToken?.(content)\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n            stream.write(format === 'text' ? content : json)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = bedrockResponse as {\n      id: string\n      type: string\n      role: string\n      content: {\n        type: string\n        text: string\n      }[]\n      model: string\n      stop_reason: string\n      stop_sequence: string | null\n      usage: { input_tokens: number; output_tokens: number }\n    }\n    const content = res.content[0].text\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.usage.input_tokens,\n        completionTokens: res.usage.output_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (model.includes('command')) {\n    const cohereResponse = await createCohereResponse({\n      model,\n      messages: [{\n        role: 'system',\n        content: systemPrompt,\n      }, ...userMessages],\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n        for await (const chat of cohereResponse as any) {\n          if (chat.eventType === 'text-generation') {\n            const content = chat.text\n\n            completion += content\n            onToken?.(content)\n\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n\n            const chunk = format === 'text' ? content : json\n\n            await stream.write(chunk)\n          }\n        }\n\n        await onFinal?.({ completion })\n        stream.close()\n      })\n    }\n\n    const res = cohereResponse as Cohere.NonStreamedChatResponse\n    const content = res.text\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.meta?.tokens?.inputTokens ?? 0,\n        completionTokens: res.meta?.tokens?.outputTokens ?? 0,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (\n    ['llama3-70b-8192', 'mixtral-8x7b-32768', 'llama3.1-70b'].includes(model)\n  ) {\n    const openaiMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const groqResponse = await createGroqResponse({\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      model,\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      const groqStream = OpenAIStream(groqResponse as any, {\n        onToken,\n        async onFinal(completion) {\n          await onFinal?.({ completion })\n        },\n      })\n\n      return streamText(c, async (stream) => {\n        for await (const content of streamReader(groqStream)) {\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          const chunk = format === 'text' ? content : json\n          await stream.write(chunk)\n        }\n\n        stream.close()\n      })\n    }\n\n    const res = groqResponse as ChatCompletion\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.prompt_tokens ?? 0,\n        completionTokens: res.usage?.completion_tokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (['codestral'].includes(model)) {\n    const codestralMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const codestralResponse = await createMistralResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...codestralMessages as any,\n      ],\n      stream,\n      temperature,\n      abortSignal,\n    })\n\n    const { res } = codestralResponse\n\n    if (!res) {\n      return c.json({ error: 'Error calling mistral' }, { status: 400 })\n    }\n\n    if (stream) {\n      let completion = ''\n      let promptTokens = 0\n      let completionTokens = 0\n\n      return streamText(c, async (stream) => {\n        for await (const chunk of streamReader(res.body as ReadableStream)) {\n          if (chunk.includes('[DONE]')) break\n          if (!chunk.includes('data: ')) continue\n          const data = JSON.parse(chunk.split('data: ')[1])\n\n          if (data.choices[0].finish_reason === 'stop') {\n            promptTokens = data.usage.prompt_tokens\n            completionTokens = data.usage.completion_tokens\n            break\n          }\n\n          const content = data.choices[0].delta.content\n          completion += content\n          onToken?.(content)\n\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          await stream.write(format === 'text' ? content : json)\n        }\n\n        await onFinal?.({\n          completion,\n          tokens: {\n            promptTokens,\n            completionTokens,\n          },\n        })\n\n        await stream.close()\n      })\n    }\n\n    const data = await res.json()\n    const content = data.choices[0].message.content\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        completionTokens: data.usage.prompt_tokens,\n        promptTokens: data.usage.completion_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const vertexResponse = await createVertexAIResponse({\n    model,\n    messages: [{ role: 'user', content: systemPrompt }, {\n      role: 'assistant',\n      content: 'OK. I will follow your instructions.',\n    }, ...userMessages],\n    stream,\n    temperature,\n  })\n\n  if (stream) {\n    const response = vertexResponse as StreamGenerateContentResult\n\n    return streamText(c, async (stream) => {\n      let completion = ''\n      for await (const item of response.stream) {\n        let content = ''\n\n        const isBlockList = item?.candidates?.[0].finishReason === 'BLOCKLIST'\n\n        if (isBlockList) {\n          content =\n            \"Google Alert\\nSomething went wrong with my safety ratings system.\\nI can't continue this conversation.\\nPlease start a new one with a different topic using the button below.\"\n        } else {\n          content = item?.candidates?.[0].content.parts[0].text ?? ''\n        }\n\n        completion += content\n        onToken?.(content)\n\n        const json = JSON.stringify({\n          agentName: agentName ?? model,\n          choices: [{ delta: { role: 'assistant', content } }],\n        })\n\n        const chunk = format === 'text' ? content : json\n\n        await stream.write(chunk)\n      }\n\n      await onFinal?.({ completion })\n      stream.close()\n    })\n  }\n\n  const response = vertexResponse as GenerateContentResult\n\n  const content = response.response.candidates?.[0].content.parts[0].text ?? ''\n  const json = {\n    agentName: agentName ?? model,\n    choices: [{ message: { role: 'assistant', content } }],\n  }\n\n  await onFinal?.({\n    completion: content,\n    tokens: {\n      completionTokens: response.response.usageMetadata?.candidatesTokenCount ??\n        0,\n      promptTokens: response.response.usageMetadata?.promptTokenCount ?? 0,\n    },\n  })\n\n  return c.json(format === 'text' ? content : json)\n}",
    "originFile": "\\services\\ai\\index.ts"
  },
  {
    "id": "\\services\\ai\\index::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\index",
    "totalTokens": 97,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: any[]\n  agentName?: string\n  temperature?: number\n  model: string\n  abortSignal?: AbortSignal\n  stream: boolean\n  format: 'text' | 'json'\n  c: Context\n  systemPrompt: string\n  onToken?: (token: string) => void\n  onFinal?: (props: onFinalObject) => Promise<void>\n  functions?: FunctionDefinition[]\n  function_call?: any\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\index.ts"
  },
  {
    "id": "\\services\\ai\\index::onFinalObject",
    "language": "typescript",
    "label": "onFinalObject",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\index",
    "totalTokens": 30,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type onFinalObject = {\n  completion: string\n  tokens?: {\n    promptTokens: number\n    completionTokens: number\n  }\n}",
    "importStatements": [],
    "codeNoBody": "type onFinalObject = {\n  completion: string\n  tokens?: {\n    promptTokens: number\n    completionTokens: number\n  }\n}",
    "originFile": "\\services\\ai\\index.ts"
  },
  {
    "id": "\\services\\ai\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\index.ts",
    "type": "file",
    "totalTokens": 3074,
    "inDegree": 0,
    "outDegree": 4,
    "code": "// deno-lint-ignore-file no-explicit-any\nimport type { InvokeModelWithResponseStreamCommandOutput } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { createOpenaiResponse } from '@/services/ai/azure/chat.ts'\nimport { createBedrockResponse } from '@/services/ai/aws/chat.ts'\nimport { OpenAIStream } from 'ai'\nimport type {\n  ChatCompletions,\n  EventStream,\n  FunctionDefinition,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { Context } from 'hono'\nimport { streamReader } from '@/lib/chat/stream-reader.ts'\nimport { createCohereResponse } from '@/services/ai/cohere/chat.ts'\nimport type { Cohere } from 'npm:cohere-ai@7.9.5'\nimport { createGroqResponse } from '@/services/ai/groq/chat.ts'\nimport { ChatCompletion } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'\nimport { createVertexAIResponse } from '@/services/ai/google/vertex/chat.ts'\nimport {\n  GenerateContentResult,\n  StreamGenerateContentResult,\n} from 'npm:@google-cloud/vertexai@1.1.0'\nimport { streamText } from 'hono/streaming'\nimport { createMistralResponse } from '@/services/ai/mistral/chat.ts'\n\ntype onFinalObject = {\n  completion: string\n  tokens?: {\n    promptTokens: number\n    completionTokens: number\n  }\n}\n\ninterface Props {\n  messages: any[]\n  agentName?: string\n  temperature?: number\n  model: string\n  abortSignal?: AbortSignal\n  stream: boolean\n  format: 'text' | 'json'\n  c: Context\n  systemPrompt: string\n  onToken?: (token: string) => void\n  onFinal?: (props: onFinalObject) => Promise<void>\n  functions?: FunctionDefinition[]\n  function_call?: any\n}\n\nexport async function createModelResponse(\n  {\n    messages: userMessages,\n    agentName,\n    model,\n    abortSignal,\n    format,\n    stream,\n    temperature = 0.7,\n    c,\n    systemPrompt,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  }: Props,\n) {\n  if (model.includes('gpt')) {\n    const openaiMessages: any[] = userMessages.map(\n      ({ content, role, name, function_call }) => {\n        const obj: Record<string, any> = {\n          role,\n          content,\n        }\n\n        if (function_call) obj.function_call = function_call\n\n        if (name) obj.name = name\n\n        return obj\n      },\n    )\n    const openaiResponse = await createOpenaiResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      abortSignal,\n      stream,\n      temperature,\n      functions,\n      function_call,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n\n        for await (\n          const event of openaiResponse as EventStream<ChatCompletions>\n        ) {\n          for (const choice of event.choices) {\n            const {\n              delta = { content: '', functionCall: null, finishRease: null },\n            } = choice\n            const content = delta.content ?? ''\n            completion += content\n            const obj: Record<string, any> = {\n              agentName: agentName ?? model,\n              choices: [{\n                delta: { role: 'assistant', content },\n                finish_reason: choice.finishReason,\n              }],\n            }\n            if (delta.functionCall) {\n              obj.choices[0].delta.function_call = delta.functionCall\n            }\n            const json = JSON.stringify(obj)\n\n            onToken?.(content)\n            await stream.write(\n              format === 'text' ? content : `data: ${json}\\n\\n`,\n            )\n            await stream.sleep(100)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = openaiResponse as ChatCompletions\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.promptTokens ?? 0,\n        completionTokens: res.usage?.completionTokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const bedrockMessages = userMessages.map(({ content, role }) => {\n    return {\n      role,\n      content,\n    }\n  })\n\n  if (\n    model.includes('claude') || ['llama3-70b', 'llama-3.1-70b'].includes(model)\n  ) {\n    const bedrockResponse = await createBedrockResponse({\n      model,\n      messages: bedrockMessages,\n      abortSignal,\n      stream,\n      systemPrompt,\n      temperature,\n    })\n\n    if (\n      stream\n    ) {\n      return streamText(c, async (stream) => {\n        const iterable =\n          (bedrockResponse as InvokeModelWithResponseStreamCommandOutput).body\n\n        if (!iterable) return stream.close()\n        const decoder = new TextDecoder()\n        let completion = ''\n        for await (const responseStream of iterable) {\n          const chunk = responseStream.chunk?.bytes\n          if (chunk) {\n            const res = JSON.parse(decoder.decode(chunk))\n\n            const content = model.includes('claude')\n              ? res?.delta?.text ?? ''\n              : res.generation ?? ''\n\n            completion += content\n            onToken?.(content)\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n            stream.write(format === 'text' ? content : json)\n          }\n        }\n\n        await onFinal?.({ completion })\n\n        stream.close()\n      })\n    }\n    const res = bedrockResponse as {\n      id: string\n      type: string\n      role: string\n      content: {\n        type: string\n        text: string\n      }[]\n      model: string\n      stop_reason: string\n      stop_sequence: string | null\n      usage: { input_tokens: number; output_tokens: number }\n    }\n    const content = res.content[0].text\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.usage.input_tokens,\n        completionTokens: res.usage.output_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (model.includes('command')) {\n    const cohereResponse = await createCohereResponse({\n      model,\n      messages: [{\n        role: 'system',\n        content: systemPrompt,\n      }, ...userMessages],\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      return streamText(c, async (stream) => {\n        let completion = ''\n        for await (const chat of cohereResponse as any) {\n          if (chat.eventType === 'text-generation') {\n            const content = chat.text\n\n            completion += content\n            onToken?.(content)\n\n            const json = JSON.stringify({\n              agentName: agentName ?? model,\n              choices: [{ delta: { role: 'assistant', content } }],\n            })\n\n            const chunk = format === 'text' ? content : json\n\n            await stream.write(chunk)\n          }\n        }\n\n        await onFinal?.({ completion })\n        stream.close()\n      })\n    }\n\n    const res = cohereResponse as Cohere.NonStreamedChatResponse\n    const content = res.text\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        promptTokens: res.meta?.tokens?.inputTokens ?? 0,\n        completionTokens: res.meta?.tokens?.outputTokens ?? 0,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (\n    ['llama3-70b-8192', 'mixtral-8x7b-32768', 'llama3.1-70b'].includes(model)\n  ) {\n    const openaiMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const groqResponse = await createGroqResponse({\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...openaiMessages,\n      ],\n      model,\n      stream,\n      temperature,\n    })\n\n    if (stream) {\n      const groqStream = OpenAIStream(groqResponse as any, {\n        onToken,\n        async onFinal(completion) {\n          await onFinal?.({ completion })\n        },\n      })\n\n      return streamText(c, async (stream) => {\n        for await (const content of streamReader(groqStream)) {\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          const chunk = format === 'text' ? content : json\n          await stream.write(chunk)\n        }\n\n        stream.close()\n      })\n    }\n\n    const res = groqResponse as ChatCompletion\n    const content = res.choices[0].message?.content\n\n    await onFinal?.({\n      completion: content ?? '',\n      tokens: {\n        promptTokens: res.usage?.prompt_tokens ?? 0,\n        completionTokens: res.usage?.completion_tokens ?? 0,\n      },\n    })\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  if (['codestral'].includes(model)) {\n    const codestralMessages = userMessages.map(({ content, role }) => {\n      return {\n        role,\n        content,\n      }\n    })\n\n    const codestralResponse = await createMistralResponse({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        ...codestralMessages as any,\n      ],\n      stream,\n      temperature,\n      abortSignal,\n    })\n\n    const { res } = codestralResponse\n\n    if (!res) {\n      return c.json({ error: 'Error calling mistral' }, { status: 400 })\n    }\n\n    if (stream) {\n      let completion = ''\n      let promptTokens = 0\n      let completionTokens = 0\n\n      return streamText(c, async (stream) => {\n        for await (const chunk of streamReader(res.body as ReadableStream)) {\n          if (chunk.includes('[DONE]')) break\n          if (!chunk.includes('data: ')) continue\n          const data = JSON.parse(chunk.split('data: ')[1])\n\n          if (data.choices[0].finish_reason === 'stop') {\n            promptTokens = data.usage.prompt_tokens\n            completionTokens = data.usage.completion_tokens\n            break\n          }\n\n          const content = data.choices[0].delta.content\n          completion += content\n          onToken?.(content)\n\n          const json = JSON.stringify({\n            agentName: agentName ?? model,\n            choices: [{ delta: { role: 'assistant', content } }],\n          })\n\n          await stream.write(format === 'text' ? content : json)\n        }\n\n        await onFinal?.({\n          completion,\n          tokens: {\n            promptTokens,\n            completionTokens,\n          },\n        })\n\n        await stream.close()\n      })\n    }\n\n    const data = await res.json()\n    const content = data.choices[0].message.content\n\n    const json = {\n      agentName: agentName ?? model,\n      choices: [{ message: { role: 'assistant', content } }],\n    }\n\n    await onFinal?.({\n      completion: content,\n      tokens: {\n        completionTokens: data.usage.prompt_tokens,\n        promptTokens: data.usage.completion_tokens,\n      },\n    })\n\n    return c.json(format === 'text' ? content : json)\n  }\n\n  const vertexResponse = await createVertexAIResponse({\n    model,\n    messages: [{ role: 'user', content: systemPrompt }, {\n      role: 'assistant',\n      content: 'OK. I will follow your instructions.',\n    }, ...userMessages],\n    stream,\n    temperature,\n  })\n\n  if (stream) {\n    const response = vertexResponse as StreamGenerateContentResult\n\n    return streamText(c, async (stream) => {\n      let completion = ''\n      for await (const item of response.stream) {\n        let content = ''\n\n        const isBlockList = item?.candidates?.[0].finishReason === 'BLOCKLIST'\n\n        if (isBlockList) {\n          content =\n            \"Google Alert\\nSomething went wrong with my safety ratings system.\\nI can't continue this conversation.\\nPlease start a new one with a different topic using the button below.\"\n        } else {\n          content = item?.candidates?.[0].content.parts[0].text ?? ''\n        }\n\n        completion += content\n        onToken?.(content)\n\n        const json = JSON.stringify({\n          agentName: agentName ?? model,\n          choices: [{ delta: { role: 'assistant', content } }],\n        })\n\n        const chunk = format === 'text' ? content : json\n\n        await stream.write(chunk)\n      }\n\n      await onFinal?.({ completion })\n      stream.close()\n    })\n  }\n\n  const response = vertexResponse as GenerateContentResult\n\n  const content = response.response.candidates?.[0].content.parts[0].text ?? ''\n  const json = {\n    agentName: agentName ?? model,\n    choices: [{ message: { role: 'assistant', content } }],\n  }\n\n  await onFinal?.({\n    completion: content,\n    tokens: {\n      completionTokens: response.response.usageMetadata?.candidatesTokenCount ??\n        0,\n      promptTokens: response.response.usageMetadata?.promptTokenCount ?? 0,\n    },\n  })\n\n  return c.json(format === 'text' ? content : json)\n}\n",
    "importStatements": [
      "import type { InvokeModelWithResponseStreamCommandOutput } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'",
      "import { createOpenaiResponse } from '@/services/ai/azure/chat.ts'",
      "import { createBedrockResponse } from '@/services/ai/aws/chat.ts'",
      "import { OpenAIStream } from 'ai'",
      "import type {\n  ChatCompletions,\n  EventStream,\n  FunctionDefinition,\n} from 'npm:@azure/openai@1.0.0-beta.12'",
      "import { Context } from 'hono'",
      "import { streamReader } from '@/lib/chat/stream-reader.ts'",
      "import { createCohereResponse } from '@/services/ai/cohere/chat.ts'",
      "import type { Cohere } from 'npm:cohere-ai@7.9.5'",
      "import { createGroqResponse } from '@/services/ai/groq/chat.ts'",
      "import { ChatCompletion } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'",
      "import { createVertexAIResponse } from '@/services/ai/google/vertex/chat.ts'",
      "import {\n  GenerateContentResult,\n  StreamGenerateContentResult,\n} from 'npm:@google-cloud/vertexai@1.1.0'",
      "import { streamText } from 'hono/streaming'",
      "import { createMistralResponse } from '@/services/ai/mistral/chat.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\nimport type { InvokeModelWithResponseStreamCommandOutput } from 'npm:@aws-sdk/client-bedrock-runtime@3.525.0'\nimport { createOpenaiResponse } from '@/services/ai/azure/chat.ts'\nimport { createBedrockResponse } from '@/services/ai/aws/chat.ts'\nimport { OpenAIStream } from 'ai'\nimport type {\n  ChatCompletions,\n  EventStream,\n  FunctionDefinition,\n} from 'npm:@azure/openai@1.0.0-beta.12'\nimport { Context } from 'hono'\nimport { streamReader } from '@/lib/chat/stream-reader.ts'\nimport { createCohereResponse } from '@/services/ai/cohere/chat.ts'\nimport type { Cohere } from 'npm:cohere-ai@7.9.5'\nimport { createGroqResponse } from '@/services/ai/groq/chat.ts'\nimport { ChatCompletion } from 'https://deno.land/x/openai@v4.24.1/resources/chat/completions.ts'\nimport { createVertexAIResponse } from '@/services/ai/google/vertex/chat.ts'\nimport {\n  GenerateContentResult,\n  StreamGenerateContentResult,\n} from 'npm:@google-cloud/vertexai@1.1.0'\nimport { streamText } from 'hono/streaming'\nimport { createMistralResponse } from '@/services/ai/mistral/chat.ts'\ntype onFinalObject = {\n  completion: string\n  tokens?: {\n    promptTokens: number\n    completionTokens: number\n  }\n}\n\ninterface Props {\n//...\n}\n\nexport async function createModelResponse(\n  {\n    messages: userMessages,\n    agentName,\n    model,\n    abortSignal,\n    format,\n    stream,\n    temperature = 0.7,\n    c,\n    systemPrompt,\n    onToken,\n    onFinal,\n    functions,\n    function_call,\n  }: Props,\n) {\n       //...\n       }",
    "originFile": "\\services\\ai\\index.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\autocomplete::createMistralFIMResponse",
    "language": "typescript",
    "label": "createMistralFIMResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\autocomplete",
    "totalTokens": 256,
    "inDegree": 2,
    "outDegree": 4,
    "code": "async function createMistralFIMResponse(\n  { model, prompt, suffix, maxTokens, temperature, stop, abortSignal }:\n    AutocompleteProps,\n): Promise<{ response: null | AutocompleteResponse }> {\n  try {\n    const res = await fetch(\n      'https://api.mistral.ai/v1/fim/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getEnv('MISTRAL_API_KEY')}`,\n        },\n        signal: abortSignal,\n        body: JSON.stringify({\n          model: MISTRAL_MODELS_MAP[model as keyof typeof MISTRAL_MODELS_MAP],\n          prompt,\n          suffix,\n          temperature,\n          max_tokens: maxTokens,\n          stop,\n        }),\n      },\n    )\n\n    if (!res.ok) {\n      const error = await res.json()\n      console.log(`Failed to get Codestral response: ${error.message}`)\n      return { response: null }\n    }\n\n    const response: AutocompleteResponse = await res.json()\n    return { response }\n  } catch (error) {\n    console.log('Error creating mistral response', error)\n    return { response: null }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createMistralFIMResponse(\n  { model, prompt, suffix, maxTokens, temperature, stop, abortSignal }:\n    AutocompleteProps,\n): Promise<{ response: null | AutocompleteResponse }> {\n       //...\n       }",
    "originFile": "\\services\\ai\\mistral\\autocomplete.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\autocomplete::AutocompleteResponse",
    "language": "typescript",
    "label": "AutocompleteResponse",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\autocomplete",
    "totalTokens": 102,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface AutocompleteResponse {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: {\n    index: number\n    message: {\n      content: string\n      role: string\n      tool_calls?: string // this needs a fix\n    }\n    finish_reason: string\n    logprobs?: number\n  }[]\n  usage: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface AutocompleteResponse {\n//...\n}",
    "originFile": "\\services\\ai\\mistral\\autocomplete.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\autocomplete::AutocompleteProps",
    "language": "typescript",
    "label": "AutocompleteProps",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\autocomplete",
    "totalTokens": 47,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface AutocompleteProps {\n  model: string\n  prompt: string\n  suffix?: string\n  stop?: string[] | string\n  temperature: number\n  maxTokens: number\n  abortSignal?: AbortSignal\n}",
    "importStatements": [],
    "codeNoBody": "interface AutocompleteProps {\n//...\n}",
    "originFile": "\\services\\ai\\mistral\\autocomplete.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\autocomplete",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\autocomplete.ts",
    "type": "file",
    "totalTokens": 438,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { getEnv } from '@/lib/env.ts'\nimport { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'\n\ninterface AutocompleteProps {\n  model: string\n  prompt: string\n  suffix?: string\n  stop?: string[] | string\n  temperature: number\n  maxTokens: number\n  abortSignal?: AbortSignal\n}\n\ninterface AutocompleteResponse {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: {\n    index: number\n    message: {\n      content: string\n      role: string\n      tool_calls?: string // this needs a fix\n    }\n    finish_reason: string\n    logprobs?: number\n  }[]\n  usage: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n  }\n}\n\nexport async function createMistralFIMResponse(\n  { model, prompt, suffix, maxTokens, temperature, stop, abortSignal }:\n    AutocompleteProps,\n): Promise<{ response: null | AutocompleteResponse }> {\n  try {\n    const res = await fetch(\n      'https://api.mistral.ai/v1/fim/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getEnv('MISTRAL_API_KEY')}`,\n        },\n        signal: abortSignal,\n        body: JSON.stringify({\n          model: MISTRAL_MODELS_MAP[model as keyof typeof MISTRAL_MODELS_MAP],\n          prompt,\n          suffix,\n          temperature,\n          max_tokens: maxTokens,\n          stop,\n        }),\n      },\n    )\n\n    if (!res.ok) {\n      const error = await res.json()\n      console.log(`Failed to get Codestral response: ${error.message}`)\n      return { response: null }\n    }\n\n    const response: AutocompleteResponse = await res.json()\n    return { response }\n  } catch (error) {\n    console.log('Error creating mistral response', error)\n    return { response: null }\n  }\n}\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nimport { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'\ninterface AutocompleteProps {\n//...\n}\n\ninterface AutocompleteResponse {\n//...\n}\n\nexport async function createMistralFIMResponse(\n  { model, prompt, suffix, maxTokens, temperature, stop, abortSignal }:\n    AutocompleteProps,\n): Promise<{ response: null | AutocompleteResponse }> {\n       //...\n       }",
    "originFile": "\\services\\ai\\mistral\\autocomplete.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\chat::createMistralResponse",
    "language": "typescript",
    "label": "createMistralResponse",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\chat",
    "totalTokens": 210,
    "inDegree": 2,
    "outDegree": 3,
    "code": "async function createMistralResponse(\n  { messages, stream, model, temperature, abortSignal }: Props,\n): Promise<{ res: null | Response }> {\n  try {\n    const res = await fetch(\n      'https://api.mistral.ai/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getEnv('MISTRAL_API_KEY')}`,\n        },\n        signal: abortSignal,\n        body: JSON.stringify({\n          model: MISTRAL_MODELS_MAP[model as keyof typeof MISTRAL_MODELS_MAP],\n          messages,\n          temperature,\n          stream,\n        }),\n      },\n    )\n\n    if (!res.ok) {\n      const error = await res.json()\n      console.log({ error })\n      return { res: null }\n    }\n\n    return { res }\n  } catch (error) {\n    console.log('Error creating mistral response', error)\n    return { res: null }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createMistralResponse(\n  { messages, stream, model, temperature, abortSignal }: Props,\n): Promise<{ res: null | Response }> {\n       //...\n       }",
    "originFile": "\\services\\ai\\mistral\\chat.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\chat::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\chat",
    "totalTokens": 32,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n  abortSignal?: AbortSignal\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\ai\\mistral\\chat.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\chat",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\chat.ts",
    "type": "file",
    "totalTokens": 287,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'\nimport type { ChatMessage } from '@/types/index.ts'\nimport { getEnv } from '@/lib/env.ts'\n\ninterface Props {\n  messages: ChatMessage[]\n  model: string\n  stream: boolean\n  temperature: number\n  abortSignal?: AbortSignal\n}\n\nexport async function createMistralResponse(\n  { messages, stream, model, temperature, abortSignal }: Props,\n): Promise<{ res: null | Response }> {\n  try {\n    const res = await fetch(\n      'https://api.mistral.ai/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${getEnv('MISTRAL_API_KEY')}`,\n        },\n        signal: abortSignal,\n        body: JSON.stringify({\n          model: MISTRAL_MODELS_MAP[model as keyof typeof MISTRAL_MODELS_MAP],\n          messages,\n          temperature,\n          stream,\n        }),\n      },\n    )\n\n    if (!res.ok) {\n      const error = await res.json()\n      console.log({ error })\n      return { res: null }\n    }\n\n    return { res }\n  } catch (error) {\n    console.log('Error creating mistral response', error)\n    return { res: null }\n  }\n}\n",
    "importStatements": [
      "import { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'",
      "import type { ChatMessage } from '@/types/index.ts'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { MISTRAL_MODELS_MAP } from '@/services/ai/mistral/consts.ts'\nimport type { ChatMessage } from '@/types/index.ts'\nimport { getEnv } from '@/lib/env.ts'\ninterface Props {\n//...\n}\n\nexport async function createMistralResponse(\n  { messages, stream, model, temperature, abortSignal }: Props,\n): Promise<{ res: null | Response }> {\n       //...\n       }",
    "originFile": "\\services\\ai\\mistral\\chat.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\consts::MISTRAL_MODELS_MAP",
    "language": "typescript",
    "label": "MISTRAL_MODELS_MAP",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\consts",
    "totalTokens": 24,
    "inDegree": 3,
    "outDegree": 0,
    "code": "export const MISTRAL_MODELS_MAP = {\n  'codestral': 'codestral-latest',\n}",
    "importStatements": [],
    "codeNoBody": "export const MISTRAL_MODELS_MAP = {\n  'codestral': 'codestral-latest',\n}",
    "originFile": "\\services\\ai\\mistral\\consts.ts"
  },
  {
    "id": "\\services\\ai\\mistral\\consts",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\ai\\mistral\\consts.ts",
    "type": "file",
    "totalTokens": 24,
    "inDegree": 0,
    "outDegree": 1,
    "code": "export const MISTRAL_MODELS_MAP = {\n  'codestral': 'codestral-latest',\n}\n",
    "importStatements": [],
    "codeNoBody": "export const MISTRAL_MODELS_MAP = {\n  'codestral': 'codestral-latest',\n}",
    "originFile": "\\services\\ai\\mistral\\consts.ts"
  },
  {
    "id": "\\services\\db\\mixpanel::getOwnerInfoByAgentId",
    "language": "typescript",
    "label": "getOwnerInfoByAgentId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\db\\mixpanel",
    "totalTokens": 221,
    "inDegree": 17,
    "outDegree": 1,
    "code": "async function getOwnerInfoByAgentId({ agentId }: { agentId: string }) {\n  try {\n    const rows = await sql<OwnerInfo[]>`\n      SELECT\n        p.id,\n        p.name,\n        s.org_id,\n        u.email,\n        profiles.distinct_id\n      FROM subscriptions s\n      JOIN agents a ON a.id = ${agentId}\n      JOIN organization_user ou ON a.org_id = ou.org_id AND ou.role = 'owner'\n      JOIN auth.users u ON u.id = ou.user_id\n      JOIN profiles ON profiles.id = u.id\n      JOIN plan p ON p.id = s.plan_id \n      WHERE s.org_id = a.org_id\n      ORDER BY s.created_at DESC\n      LIMIT 1\n    `\n\n    if (rows.length === 0) {\n      return null\n    }\n\n    return rows[0]\n  } catch (error) {\n    console.log(\n      'Error getting owner info by agent id in db (services/db/mixpanel):',\n      error,\n    )\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getOwnerInfoByAgentId({ agentId }: { agentId: string }) {\n       //...\n       }",
    "originFile": "\\services\\db\\mixpanel.ts"
  },
  {
    "id": "\\services\\db\\mixpanel::OwnerInfo",
    "language": "typescript",
    "label": "OwnerInfo",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\db\\mixpanel",
    "totalTokens": 32,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface OwnerInfo {\n  id: string\n  name: string\n  org_id: string\n  email: string\n  distinct_id: string\n}",
    "importStatements": [],
    "codeNoBody": "interface OwnerInfo {\n//...\n}",
    "originFile": "\\services\\db\\mixpanel.ts"
  },
  {
    "id": "\\services\\db\\mixpanel",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\db\\mixpanel.ts",
    "type": "file",
    "totalTokens": 265,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { sql } from '@/lib/db/index.ts'\n\ninterface OwnerInfo {\n  id: string\n  name: string\n  org_id: string\n  email: string\n  distinct_id: string\n}\n\nexport async function getOwnerInfoByAgentId({ agentId }: { agentId: string }) {\n  try {\n    const rows = await sql<OwnerInfo[]>`\n      SELECT\n        p.id,\n        p.name,\n        s.org_id,\n        u.email,\n        profiles.distinct_id\n      FROM subscriptions s\n      JOIN agents a ON a.id = ${agentId}\n      JOIN organization_user ou ON a.org_id = ou.org_id AND ou.role = 'owner'\n      JOIN auth.users u ON u.id = ou.user_id\n      JOIN profiles ON profiles.id = u.id\n      JOIN plan p ON p.id = s.plan_id \n      WHERE s.org_id = a.org_id\n      ORDER BY s.created_at DESC\n      LIMIT 1\n    `\n\n    if (rows.length === 0) {\n      return null\n    }\n\n    return rows[0]\n  } catch (error) {\n    console.log(\n      'Error getting owner info by agent id in db (services/db/mixpanel):',\n      error,\n    )\n    return null\n  }\n}\n",
    "importStatements": [
      "import { sql } from '@/lib/db/index.ts'"
    ],
    "codeNoBody": "import { sql } from '@/lib/db/index.ts'\ninterface OwnerInfo {\n//...\n}\n\nexport async function getOwnerInfoByAgentId({ agentId }: { agentId: string }) {\n       //...\n       }",
    "originFile": "\\services\\db\\mixpanel.ts"
  },
  {
    "id": "\\services\\supabase\\agents::getMarketplaceAgentAsAnonymous",
    "language": "typescript",
    "label": "getMarketplaceAgentAsAnonymous",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents",
    "totalTokens": 89,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function getMarketplaceAgentAsAnonymous({ id }: { id: string }) {\n  const { data, error } = await supabase.rpc(\n    'get_marketplace_agent_as_anonymous',\n    {\n      agentid: id,\n      secret_key: getEnv('PLAYGROUND_SECRET_KEY'),\n    },\n  ).single()\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return data ?? null\n}",
    "importStatements": [],
    "codeNoBody": "async function getMarketplaceAgentAsAnonymous({ id }: { id: string }) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\agents::getMarketplaceAgentById",
    "language": "typescript",
    "label": "getMarketplaceAgentById",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents",
    "totalTokens": 106,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getMarketplaceAgentById(\n  { id, userId }: { id: string; userId: string },\n) {\n  const { data, error } = await supabase.rpc(\n    'get_marketplace_favorite_agent_by_id',\n    {\n      agentid: id,\n      userid: userId,\n    },\n  )\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  if (!data || data.length === 0) {\n    return null\n  }\n\n  return data[0]\n}",
    "importStatements": [],
    "codeNoBody": "async function getMarketplaceAgentById(\n  { id, userId }: { id: string; userId: string },\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\agents::getPublicAgentById",
    "language": "typescript",
    "label": "getPublicAgentById",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents",
    "totalTokens": 175,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getPublicAgentById({\n  agentId,\n  pincode,\n}: {\n  agentId: string\n  pincode: string\n}) {\n  try {\n    const { data, error } = await supabase\n      .from('agents')\n      .select('*, organization:organizations(*)')\n      .eq('id', agentId)\n      .eq('is_public', true)\n      .eq('pincode', pincode)\n      .single()\n\n    if (error) {\n      console.log(error)\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      return null\n    }\n\n    return data\n  } catch (error) {\n    console.log(\n      'Error getting agent by id in supabase (services/supabase (public)):',\n      error,\n    )\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getPublicAgentById({\n  agentId,\n  pincode,\n}: {\n  agentId: string\n  pincode: string\n}) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\agents::updateAgentImageByAgentId",
    "language": "typescript",
    "label": "updateAgentImageByAgentId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents",
    "totalTokens": 492,
    "inDegree": 3,
    "outDegree": 3,
    "code": "async function updateAgentImageByAgentId(\n  imageFile: File,\n  agentId: string,\n  orgId: string,\n  userId: string,\n) {\n  const [{ image, is_frozen: isFrozen }] =\n    await sql`SELECT image, is_frozen FROM agents WHERE agents.id = ${agentId} AND agents.org_id = ${orgId}`\n\n  if (isFrozen) {\n    throw new Error(\n      `Agent with ID ${agentId} is inactive because of plan limits and cannot be modified.`,\n    )\n  }\n\n  let oldImagePath\n  if (image) {\n    // Extraer la ruta del archivo de la URL de la imagen\n    const url = new URL(image)\n    oldImagePath = url.pathname.split('/').slice(-2).join('/')\n  }\n\n  const fileExtension = imageFile.name.split('.').pop() as File['type']\n\n  const imagePath = `${userId}/${agentId}.${fileExtension}`\n\n  const resizedImage = await modifyImage(imageFile, {\n    width: 256,\n    mode: 'resize',\n  })\n\n  const img = fileExtension === 'gif'\n    ? imageFile\n    : new Blob([resizedImage], { type: imageFile.type })\n\n  const { error: uploadError } = await supabase.storage.from('agents').upload(\n    imagePath,\n    img,\n    {\n      cacheControl: '60',\n      upsert: true,\n    },\n  )\n\n  if (uploadError) throw new Error(uploadError.message)\n\n  if (oldImagePath && oldImagePath !== imagePath) {\n    // Borrar imagen anterior\n    const { error: deletionError } = await supabase.storage.from('agents')\n      .remove([oldImagePath])\n\n    if (deletionError) {\n      console.log('Error deleting old agent image ==>', deletionError)\n    }\n  }\n\n  // Obtener URL de la imagen\n  const { data: signedURL } = supabase.storage\n    .from('agents')\n    .getPublicUrl(imagePath)\n\n  // Actualizar la URL de la imagen en la base de datos\n  const { error } = await supabase.from('agents').update({\n    image: signedURL.publicUrl,\n  }).eq('id', agentId)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return { url: signedURL.publicUrl }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateAgentImageByAgentId(\n  imageFile: File,\n  agentId: string,\n  orgId: string,\n  userId: string,\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\agents::getUserAgentById",
    "language": "typescript",
    "label": "getUserAgentById",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents",
    "totalTokens": 106,
    "inDegree": 9,
    "outDegree": 2,
    "code": "async function getUserAgentById(id: string): Promise<Agent | null> {\n  try {\n    const result = await sql`SELECT * FROM agents WHERE agents.id = ${id}`\n\n    if (!result || !result[0]) {\n      return null\n    }\n\n    return result[0] as Agent\n  } catch (error) {\n    console.log(\n      'Error getting agent by id in supabase (services/supabase):',\n      error,\n    )\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserAgentById(id: string): Promise<Agent | null> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\agents",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\agents.ts",
    "type": "file",
    "totalTokens": 1032,
    "inDegree": 0,
    "outDegree": 6,
    "code": "import { sql } from '@/lib/db/index.ts'\nimport { Agent } from '@/types/index.ts'\nimport { supabase } from '@/services/supabase/index.ts'\nimport { modifyImage } from '@/lib/image.ts'\nimport { getEnv } from '@/lib/env.ts'\n\nexport async function getUserAgentById(id: string): Promise<Agent | null> {\n  try {\n    const result = await sql`SELECT * FROM agents WHERE agents.id = ${id}`\n\n    if (!result || !result[0]) {\n      return null\n    }\n\n    return result[0] as Agent\n  } catch (error) {\n    console.log(\n      'Error getting agent by id in supabase (services/supabase):',\n      error,\n    )\n    return null\n  }\n}\n\nexport async function updateAgentImageByAgentId(\n  imageFile: File,\n  agentId: string,\n  orgId: string,\n  userId: string,\n) {\n  const [{ image, is_frozen: isFrozen }] =\n    await sql`SELECT image, is_frozen FROM agents WHERE agents.id = ${agentId} AND agents.org_id = ${orgId}`\n\n  if (isFrozen) {\n    throw new Error(\n      `Agent with ID ${agentId} is inactive because of plan limits and cannot be modified.`,\n    )\n  }\n\n  let oldImagePath\n  if (image) {\n    // Extraer la ruta del archivo de la URL de la imagen\n    const url = new URL(image)\n    oldImagePath = url.pathname.split('/').slice(-2).join('/')\n  }\n\n  const fileExtension = imageFile.name.split('.').pop() as File['type']\n\n  const imagePath = `${userId}/${agentId}.${fileExtension}`\n\n  const resizedImage = await modifyImage(imageFile, {\n    width: 256,\n    mode: 'resize',\n  })\n\n  const img = fileExtension === 'gif'\n    ? imageFile\n    : new Blob([resizedImage], { type: imageFile.type })\n\n  const { error: uploadError } = await supabase.storage.from('agents').upload(\n    imagePath,\n    img,\n    {\n      cacheControl: '60',\n      upsert: true,\n    },\n  )\n\n  if (uploadError) throw new Error(uploadError.message)\n\n  if (oldImagePath && oldImagePath !== imagePath) {\n    // Borrar imagen anterior\n    const { error: deletionError } = await supabase.storage.from('agents')\n      .remove([oldImagePath])\n\n    if (deletionError) {\n      console.log('Error deleting old agent image ==>', deletionError)\n    }\n  }\n\n  // Obtener URL de la imagen\n  const { data: signedURL } = supabase.storage\n    .from('agents')\n    .getPublicUrl(imagePath)\n\n  // Actualizar la URL de la imagen en la base de datos\n  const { error } = await supabase.from('agents').update({\n    image: signedURL.publicUrl,\n  }).eq('id', agentId)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return { url: signedURL.publicUrl }\n}\n\nexport async function getPublicAgentById({\n  agentId,\n  pincode,\n}: {\n  agentId: string\n  pincode: string\n}) {\n  try {\n    const { data, error } = await supabase\n      .from('agents')\n      .select('*, organization:organizations(*)')\n      .eq('id', agentId)\n      .eq('is_public', true)\n      .eq('pincode', pincode)\n      .single()\n\n    if (error) {\n      console.log(error)\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      return null\n    }\n\n    return data\n  } catch (error) {\n    console.log(\n      'Error getting agent by id in supabase (services/supabase (public)):',\n      error,\n    )\n    return null\n  }\n}\n\nexport async function getMarketplaceAgentById(\n  { id, userId }: { id: string; userId: string },\n) {\n  const { data, error } = await supabase.rpc(\n    'get_marketplace_favorite_agent_by_id',\n    {\n      agentid: id,\n      userid: userId,\n    },\n  )\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  if (!data || data.length === 0) {\n    return null\n  }\n\n  return data[0]\n}\n\nexport async function getMarketplaceAgentAsAnonymous({ id }: { id: string }) {\n  const { data, error } = await supabase.rpc(\n    'get_marketplace_agent_as_anonymous',\n    {\n      agentid: id,\n      secret_key: getEnv('PLAYGROUND_SECRET_KEY'),\n    },\n  ).single()\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return data ?? null\n}\n",
    "importStatements": [
      "import { sql } from '@/lib/db/index.ts'",
      "import { Agent } from '@/types/index.ts'",
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { modifyImage } from '@/lib/image.ts'",
      "import { getEnv } from '@/lib/env.ts'"
    ],
    "codeNoBody": "import { sql } from '@/lib/db/index.ts'\nimport { Agent } from '@/types/index.ts'\nimport { supabase } from '@/services/supabase/index.ts'\nimport { modifyImage } from '@/lib/image.ts'\nimport { getEnv } from '@/lib/env.ts'\nexport async function getUserAgentById(id: string): Promise<Agent | null> {\n       //...\n       }\n\nexport async function updateAgentImageByAgentId(\n  imageFile: File,\n  agentId: string,\n  orgId: string,\n  userId: string,\n) {\n       //...\n       }\n\nexport async function getPublicAgentById({\n  agentId,\n  pincode,\n}: {\n  agentId: string\n  pincode: string\n}) {\n       //...\n       }\n\nexport async function getMarketplaceAgentById(\n  { id, userId }: { id: string; userId: string },\n) {\n       //...\n       }\n\nexport async function getMarketplaceAgentAsAnonymous({ id }: { id: string }) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\agents.ts"
  },
  {
    "id": "\\services\\supabase\\chat-log::saveChatLog",
    "language": "typescript",
    "label": "saveChatLog",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\chat-log",
    "totalTokens": 184,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function saveChatLog({ log, messages, chunks }: Props) {\n  const { error, data } = await supabase.from('chat_log').insert(log).select()\n\n  if (data) {\n    const insertChunks = chunks.map((chunk) => {\n      return {\n        chat_log_id: data[0].id,\n        ...chunk,\n      }\n    })\n\n    const insertMessages = messages.map((message) => {\n      return {\n        chat_log_id: data[0].id,\n        ...message,\n      }\n    })\n\n    const [{ error }, { error: chunksError }] = await Promise.all([\n      supabase.from('chat_log_chunks').insert(insertChunks),\n      supabase.from('chat_log_messages').insert(insertMessages),\n    ])\n\n    console.log({ error, chunksError })\n  }\n\n  if (error) {\n    throw new Error(error.message)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function saveChatLog({ log, messages, chunks }: Props) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\chat-log.ts"
  },
  {
    "id": "\\services\\supabase\\chat-log::Props",
    "language": "typescript",
    "label": "Props",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\chat-log",
    "totalTokens": 52,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface Props {\n  log: ChatLogInsert\n  messages: {\n    role: string\n    content: string\n    created_at?: string\n  }[]\n  chunks: {\n    chunk_id: string\n    score: number\n  }[]\n}",
    "importStatements": [],
    "codeNoBody": "interface Props {\n//...\n}",
    "originFile": "\\services\\supabase\\chat-log.ts"
  },
  {
    "id": "\\services\\supabase\\chat-log::ChatLogInsert",
    "language": "typescript",
    "label": "ChatLogInsert",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\chat-log",
    "totalTokens": 16,
    "inDegree": 5,
    "outDegree": 2,
    "code": "type ChatLogInsert = Database['public']['Tables']['chat_log']['Insert']",
    "importStatements": [],
    "codeNoBody": "type ChatLogInsert = Database['public']['Tables']['chat_log']['Insert']",
    "originFile": "\\services\\supabase\\chat-log.ts"
  },
  {
    "id": "\\services\\supabase\\chat-log",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\chat-log.ts",
    "type": "file",
    "totalTokens": 291,
    "inDegree": 0,
    "outDegree": 4,
    "code": "// deno-lint-ignore-file\nimport { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\n\nexport type ChatLogInsert = Database['public']['Tables']['chat_log']['Insert']\n\ninterface Props {\n  log: ChatLogInsert\n  messages: {\n    role: string\n    content: string\n    created_at?: string\n  }[]\n  chunks: {\n    chunk_id: string\n    score: number\n  }[]\n}\n\nexport async function saveChatLog({ log, messages, chunks }: Props) {\n  const { error, data } = await supabase.from('chat_log').insert(log).select()\n\n  if (data) {\n    const insertChunks = chunks.map((chunk) => {\n      return {\n        chat_log_id: data[0].id,\n        ...chunk,\n      }\n    })\n\n    const insertMessages = messages.map((message) => {\n      return {\n        chat_log_id: data[0].id,\n        ...message,\n      }\n    })\n\n    const [{ error }, { error: chunksError }] = await Promise.all([\n      supabase.from('chat_log_chunks').insert(insertChunks),\n      supabase.from('chat_log_messages').insert(insertMessages),\n    ])\n\n    console.log({ error, chunksError })\n  }\n\n  if (error) {\n    throw new Error(error.message)\n  }\n}\n",
    "importStatements": [
      "import { Database } from '@/types/supabase.ts'",
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "// deno-lint-ignore-file\nimport { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\nexport type ChatLogInsert = Database['public']['Tables']['chat_log']['Insert']\n\ninterface Props {\n//...\n}\n\nexport async function saveChatLog({ log, messages, chunks }: Props) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\chat-log.ts"
  },
  {
    "id": "\\services\\supabase\\documents::getDocumentsWithStorage",
    "language": "typescript",
    "label": "getDocumentsWithStorage",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 284,
    "inDegree": 5,
    "outDegree": 2,
    "code": "async function getDocumentsWithStorage({ orgId }: { orgId: string }) {\n  try {\n    const [{ data: documents, error }, { data: files, error: errorStorage }] =\n      await Promise.all([\n        await supabase\n          .from('documents')\n          .select('*')\n          .eq('org_id', orgId),\n        await supabase.storage\n          .from('files')\n          .list(orgId, { limit: 1000 }),\n      ])\n\n    if (files === undefined) {\n      throw new Error('Error getting documents')\n    }\n\n    if (error ?? errorStorage) {\n      throw new Error(error?.message ?? errorStorage?.message)\n    }\n\n    const documentsWithStorage = documents?.map(\n      (document: Document) => {\n        const file = files?.find((file) =>\n          file.name === document?.file_id?.split('/')[1]\n        )\n\n        return {\n          ...document,\n          type: file?.name.split('.').pop() ?? document?.file_type,\n          size: file?.metadata.size ?? 0,\n          mimetype: file?.metadata.mimetype ?? 'text/plain',\n          bPath: document.file_id,\n          tokens: document.tokens,\n        }\n      },\n    )\n\n    return documentsWithStorage\n  } catch (error) {\n    console.log('Error getting documents:', error)\n    return []\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getDocumentsWithStorage({ orgId }: { orgId: string }) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::getDocumentsByAgentId",
    "language": "typescript",
    "label": "getDocumentsByAgentId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 142,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getDocumentsByAgentId(agentId: string) {\n  try {\n    const { data, error } = await supabase\n      .from('agents_documents')\n      .select('documents(*)')\n      .eq('agent_id', agentId)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error(\"Agent's documents not found\")\n    }\n\n    const documents = data.map(({ documents }) => documents)\n\n    return documents\n  } catch (error) {\n    console.log(\n      'Error getting documents in supabase (services/supabase):',\n      error,\n    )\n    return []\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getDocumentsByAgentId(agentId: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::deleteDocumentBucket",
    "language": "typescript",
    "label": "deleteDocumentBucket",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 67,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function deleteDocumentBucket(path: string) {\n  try {\n    const { error } = await supabase.storage.from('files').remove([path])\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error deleting file:', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function deleteDocumentBucket(path: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::deleteDocumentById",
    "language": "typescript",
    "label": "deleteDocumentById",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 70,
    "inDegree": 5,
    "outDegree": 1,
    "code": "async function deleteDocumentById(id: string) {\n  try {\n    const { error } = await supabase.from('documents').delete().eq('id', id)\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error deleting document:', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function deleteDocumentById(id: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::retrieveDocumentContentsFromBucket",
    "language": "typescript",
    "label": "retrieveDocumentContentsFromBucket",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 107,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function retrieveDocumentContentsFromBucket(id: string) {\n  try {\n    const { data, error } = await supabase.storage.from('files').download(id)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error('Document not found')\n    }\n\n    const text = await data.text()\n    return text\n  } catch (error) {\n    console.log('Error retrieving document:', error)\n    throw new Error(error?.message)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function retrieveDocumentContentsFromBucket(id: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::createDocumentBucket",
    "language": "typescript",
    "label": "createDocumentBucket",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 140,
    "inDegree": 3,
    "outDegree": 2,
    "code": "async function createDocumentBucket(file: File, id: string) {\n  try {\n    const { data, error } = await supabase.storage.from('files').upload(\n      id,\n      file,\n      {\n        contentType: 'text/plain;charset=UTF-8',\n      },\n    )\n\n    if (error) {\n      reportError(error)\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      console.log('Error uploading document, no data')\n      throw new Error('Error uploading document')\n    }\n\n    return data.path\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    throw new Error(error?.message)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createDocumentBucket(file: File, id: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents::createDocument",
    "language": "typescript",
    "label": "createDocument",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents",
    "totalTokens": 241,
    "inDegree": 5,
    "outDegree": 3,
    "code": "async function createDocument({\n  fileName,\n  fileId,\n  userId,\n  documentId,\n  orgId,\n  fileType,\n  tokens,\n  metadata,\n}: {\n  fileId?: string\n  fileName: string\n  userId: string\n  documentId: string\n  orgId: string\n  fileType?: Document['file_type']\n  tokens?: number\n  metadata?: Document['metadata']\n}) {\n  try {\n    const { data, error } = await supabase\n      .from('documents')\n      .insert({\n        id: documentId,\n        user_id: userId,\n        file_id: fileId,\n        name: fileName,\n        org_id: orgId,\n        file_type: fileType,\n        ...(tokens ? { tokens } : {}),\n        ...(metadata ? { metadata } : {}),\n      })\n      .select()\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error('Error uploading document')\n    }\n\n    return data[0]\n  } catch (error) {\n    reportError(error, userId)\n    console.log('Error uploading document:', error)\n    throw new Error(error?.message)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function createDocument({\n  fileName,\n  fileId,\n  userId,\n  documentId,\n  orgId,\n  fileType,\n  tokens,\n  metadata,\n}: {\n  fileId?: string\n  fileName: string\n  userId: string\n  documentId: string\n  orgId: string\n  fileType?: Document['file_type']\n  tokens?: number\n  metadata?: Document['metadata']\n}) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\documents",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\documents.ts",
    "type": "file",
    "totalTokens": 1099,
    "inDegree": 0,
    "outDegree": 8,
    "code": "import { supabase } from '@/services/supabase/index.ts'\nimport type { Document } from '@/types/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\n\nexport async function createDocument({\n  fileName,\n  fileId,\n  userId,\n  documentId,\n  orgId,\n  fileType,\n  tokens,\n  metadata,\n}: {\n  fileId?: string\n  fileName: string\n  userId: string\n  documentId: string\n  orgId: string\n  fileType?: Document['file_type']\n  tokens?: number\n  metadata?: Document['metadata']\n}) {\n  try {\n    const { data, error } = await supabase\n      .from('documents')\n      .insert({\n        id: documentId,\n        user_id: userId,\n        file_id: fileId,\n        name: fileName,\n        org_id: orgId,\n        file_type: fileType,\n        ...(tokens ? { tokens } : {}),\n        ...(metadata ? { metadata } : {}),\n      })\n      .select()\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error('Error uploading document')\n    }\n\n    return data[0]\n  } catch (error) {\n    reportError(error, userId)\n    console.log('Error uploading document:', error)\n    throw new Error(error?.message)\n  }\n}\n\nexport async function createDocumentBucket(file: File, id: string) {\n  try {\n    const { data, error } = await supabase.storage.from('files').upload(\n      id,\n      file,\n      {\n        contentType: 'text/plain;charset=UTF-8',\n      },\n    )\n\n    if (error) {\n      reportError(error)\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      console.log('Error uploading document, no data')\n      throw new Error('Error uploading document')\n    }\n\n    return data.path\n  } catch (error) {\n    console.log('Error uploading document:', error)\n    throw new Error(error?.message)\n  }\n}\n\nexport async function retrieveDocumentContentsFromBucket(id: string) {\n  try {\n    const { data, error } = await supabase.storage.from('files').download(id)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error('Document not found')\n    }\n\n    const text = await data.text()\n    return text\n  } catch (error) {\n    console.log('Error retrieving document:', error)\n    throw new Error(error?.message)\n  }\n}\n\nexport async function deleteDocumentById(id: string) {\n  try {\n    const { error } = await supabase.from('documents').delete().eq('id', id)\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error deleting document:', error)\n  }\n}\n\nexport async function deleteDocumentBucket(path: string) {\n  try {\n    const { error } = await supabase.storage.from('files').remove([path])\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error deleting file:', error)\n  }\n}\n\nexport async function getDocumentsByAgentId(agentId: string) {\n  try {\n    const { data, error } = await supabase\n      .from('agents_documents')\n      .select('documents(*)')\n      .eq('agent_id', agentId)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n\n    if (!data) {\n      throw new Error(\"Agent's documents not found\")\n    }\n\n    const documents = data.map(({ documents }) => documents)\n\n    return documents\n  } catch (error) {\n    console.log(\n      'Error getting documents in supabase (services/supabase):',\n      error,\n    )\n    return []\n  }\n}\n\nexport async function getDocumentsWithStorage({ orgId }: { orgId: string }) {\n  try {\n    const [{ data: documents, error }, { data: files, error: errorStorage }] =\n      await Promise.all([\n        await supabase\n          .from('documents')\n          .select('*')\n          .eq('org_id', orgId),\n        await supabase.storage\n          .from('files')\n          .list(orgId, { limit: 1000 }),\n      ])\n\n    if (files === undefined) {\n      throw new Error('Error getting documents')\n    }\n\n    if (error ?? errorStorage) {\n      throw new Error(error?.message ?? errorStorage?.message)\n    }\n\n    const documentsWithStorage = documents?.map(\n      (document: Document) => {\n        const file = files?.find((file) =>\n          file.name === document?.file_id?.split('/')[1]\n        )\n\n        return {\n          ...document,\n          type: file?.name.split('.').pop() ?? document?.file_type,\n          size: file?.metadata.size ?? 0,\n          mimetype: file?.metadata.mimetype ?? 'text/plain',\n          bPath: document.file_id,\n          tokens: document.tokens,\n        }\n      },\n    )\n\n    return documentsWithStorage\n  } catch (error) {\n    console.log('Error getting documents:', error)\n    return []\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import type { Document } from '@/types/index.ts'",
      "import { reportError } from '@/lib/bugsnag.ts'"
    ],
    "codeNoBody": "import { supabase } from '@/services/supabase/index.ts'\nimport type { Document } from '@/types/index.ts'\nimport { reportError } from '@/lib/bugsnag.ts'\nexport async function createDocument({\n  fileName,\n  fileId,\n  userId,\n  documentId,\n  orgId,\n  fileType,\n  tokens,\n  metadata,\n}: {\n  fileId?: string\n  fileName: string\n  userId: string\n  documentId: string\n  orgId: string\n  fileType?: Document['file_type']\n  tokens?: number\n  metadata?: Document['metadata']\n}) {\n       //...\n       }\n\nexport async function createDocumentBucket(file: File, id: string) {\n       //...\n       }\n\nexport async function retrieveDocumentContentsFromBucket(id: string) {\n       //...\n       }\n\nexport async function deleteDocumentById(id: string) {\n       //...\n       }\n\nexport async function deleteDocumentBucket(path: string) {\n       //...\n       }\n\nexport async function getDocumentsByAgentId(agentId: string) {\n       //...\n       }\n\nexport async function getDocumentsWithStorage({ orgId }: { orgId: string }) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\documents.ts"
  },
  {
    "id": "\\services\\supabase\\index::supabase",
    "language": "typescript",
    "label": "supabase",
    "type": "assignment",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\index",
    "totalTokens": 30,
    "inDegree": 38,
    "outDegree": 2,
    "code": "export const supabase = createClient<Database>(\n  getEnv('SUPABASE_URL'),\n  getEnv('SUPABASE_KEY'),\n)",
    "importStatements": [],
    "codeNoBody": "export const supabase = createClient<Database>(\n  getEnv('SUPABASE_URL'),\n  getEnv('SUPABASE_KEY'),\n)",
    "originFile": "\\services\\supabase\\index.ts"
  },
  {
    "id": "\\services\\supabase\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\index.ts",
    "type": "file",
    "totalTokens": 70,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { getEnv } from '@/lib/env.ts'\nimport { Database } from '@/types/supabase.ts'\nimport { createClient } from '@supabase/supabase-js'\n\nexport const supabase = createClient<Database>(\n  getEnv('SUPABASE_URL'),\n  getEnv('SUPABASE_KEY'),\n)\n",
    "importStatements": [
      "import { getEnv } from '@/lib/env.ts'",
      "import { Database } from '@/types/supabase.ts'",
      "import { createClient } from '@supabase/supabase-js'"
    ],
    "codeNoBody": "import { getEnv } from '@/lib/env.ts'\nimport { Database } from '@/types/supabase.ts'\nimport { createClient } from '@supabase/supabase-js'\nexport const supabase = createClient<Database>(\n  getEnv('SUPABASE_URL'),\n  getEnv('SUPABASE_KEY'),\n)",
    "originFile": "\\services\\supabase\\index.ts"
  },
  {
    "id": "\\services\\supabase\\messages::updateLastAssistantMessage",
    "language": "typescript",
    "label": "updateLastAssistantMessage",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\messages",
    "totalTokens": 199,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function updateLastAssistantMessage(\n  agentId: string,\n  content: string,\n) {\n  try {\n    const { data: lastMessage, error: lastMessageError } = await supabase\n      .from('messages')\n      .select('id')\n      .eq('agent_id', agentId)\n      .eq('role', 'assistant')\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .single()\n    if (lastMessageError) {\n      throw new Error(lastMessageError.message)\n    }\n\n    const { id: lastMessageId } = lastMessage\n    const { error } = await supabase.from('messages').update({ content }).eq(\n      'id',\n      lastMessageId,\n    )\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error updating last message in supabase:', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateLastAssistantMessage(\n  agentId: string,\n  content: string,\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\messages.ts"
  },
  {
    "id": "\\services\\supabase\\messages::saveMessages",
    "language": "typescript",
    "label": "saveMessages",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\messages",
    "totalTokens": 80,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function saveMessages(\n  messages: Database['public']['Tables']['messages']['Insert'][],\n) {\n  try {\n    const { error } = await supabase.from('messages').insert(messages)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error saving messages in supabase:', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function saveMessages(\n  messages: Database['public']['Tables']['messages']['Insert'][],\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\messages.ts"
  },
  {
    "id": "\\services\\supabase\\messages",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\messages.ts",
    "type": "file",
    "totalTokens": 310,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { supabase } from '@/services/supabase/index.ts'\nimport { Database } from '@/types/supabase.ts'\n\nexport async function saveMessages(\n  messages: Database['public']['Tables']['messages']['Insert'][],\n) {\n  try {\n    const { error } = await supabase.from('messages').insert(messages)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error saving messages in supabase:', error)\n  }\n}\n\nexport async function updateLastAssistantMessage(\n  agentId: string,\n  content: string,\n) {\n  try {\n    const { data: lastMessage, error: lastMessageError } = await supabase\n      .from('messages')\n      .select('id')\n      .eq('agent_id', agentId)\n      .eq('role', 'assistant')\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .single()\n    if (lastMessageError) {\n      throw new Error(lastMessageError.message)\n    }\n\n    const { id: lastMessageId } = lastMessage\n    const { error } = await supabase.from('messages').update({ content }).eq(\n      'id',\n      lastMessageId,\n    )\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error updating last message in supabase:', error)\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { Database } from '@/types/supabase.ts'"
    ],
    "codeNoBody": "import { supabase } from '@/services/supabase/index.ts'\nimport { Database } from '@/types/supabase.ts'\nexport async function saveMessages(\n  messages: Database['public']['Tables']['messages']['Insert'][],\n) {\n       //...\n       }\n\nexport async function updateLastAssistantMessage(\n  agentId: string,\n  content: string,\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\messages.ts"
  },
  {
    "id": "\\services\\supabase\\organizations::getOrganizationOwnerDistinctId",
    "language": "typescript",
    "label": "getOrganizationOwnerDistinctId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\organizations",
    "totalTokens": 154,
    "inDegree": 5,
    "outDegree": 1,
    "code": "async function getOrganizationOwnerDistinctId({\n  orgId,\n}: {\n  orgId: string\n}): Promise<string | undefined> {\n  if (!orgId) {\n    throw new Error('Organization id is required')\n  }\n  try {\n    const result = await sql`\n      SELECT profiles.distinct_id\n      FROM organizations\n      LEFT JOIN organization_user ON organization_user.org_id = organizations.id\n      LEFT JOIN profiles ON profiles.id = organization_user.user_id\n      WHERE organization_user.role = 'owner' AND organizations.id = ${orgId};\n    `\n\n    return result[0].distinct_id\n  } catch (error) {\n    console.error(`Error searching for organization's owner's distinct id: `, {\n      error,\n    })\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getOrganizationOwnerDistinctId({\n  orgId,\n}: {\n  orgId: string\n}): Promise<string | undefined> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\organizations.ts"
  },
  {
    "id": "\\services\\supabase\\organizations::getOrganization",
    "language": "typescript",
    "label": "getOrganization",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\organizations",
    "totalTokens": 248,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getOrganization({\n  orgId,\n}: {\n  orgId: string\n}): Promise<\n  {\n    name: string\n    image: string\n    planName: string\n    dailyCompletionCount: number\n    dailyInteractions: number\n  } | undefined\n> {\n  if (!orgId) {\n    throw new Error('Organization id is required')\n  }\n  try {\n    const result = await sql`\n      SELECT organizations.name, organizations.image, plan.name as planName, plan.daily_completion_count as daily_completion_count, organizations.daily_interactions as daily_interactions\n      FROM organizations \n      LEFT JOIN subscriptions ON organizations.id = subscriptions.org_id\n      LEFT JOIN plan ON subscriptions.plan_id = plan.id\n      WHERE organizations.id = ${orgId}\n    `\n\n    console.log({ result })\n\n    return {\n      name: result[0].name,\n      image: result[0].image,\n      planName: result[0].planname,\n      dailyCompletionCount: result[0].daily_completion_count,\n      dailyInteractions: result[0].daily_interactions,\n    }\n  } catch (error) {\n    console.error('Error searching for organization ', { error })\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getOrganization({\n  orgId,\n}: {\n  orgId: string\n}): Promise<\n  {\n    name: string\n    image: string\n    planName: string\n    dailyCompletionCount: number\n    dailyInteractions: number\n  } | undefined\n> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\organizations.ts"
  },
  {
    "id": "\\services\\supabase\\organizations::addOrgDailyTokens",
    "language": "typescript",
    "label": "addOrgDailyTokens",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\organizations",
    "totalTokens": 113,
    "inDegree": 6,
    "outDegree": 2,
    "code": "async function addOrgDailyTokens({\n  orgId,\n  inputTokens,\n  outputTokens,\n  model,\n}: {\n  orgId: string\n  inputTokens: number\n  outputTokens: number\n  model: ModelsEnum\n}) {\n  console.log({ orgId, inputTokens, outputTokens, model })\n  try {\n    await sql`SELECT update_daily_usage(${orgId}, ${inputTokens}, ${outputTokens}, ${model})`\n  } catch (error) {\n    console.error('Error updating interactions ', { error })\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function addOrgDailyTokens({\n  orgId,\n  inputTokens,\n  outputTokens,\n  model,\n}: {\n  orgId: string\n  inputTokens: number\n  outputTokens: number\n  model: ModelsEnum\n}) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\organizations.ts"
  },
  {
    "id": "\\services\\supabase\\organizations::updateOrganizationsInteractions",
    "language": "typescript",
    "label": "updateOrganizationsInteractions",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\organizations",
    "totalTokens": 71,
    "inDegree": 17,
    "outDegree": 1,
    "code": "async function updateOrganizationsInteractions(\n  orgId: string,\n) {\n  try {\n    await sql`\n      UPDATE organizations\n      SET daily_interactions = daily_interactions + 1\n      WHERE id = ${orgId}\n    `\n  } catch (error) {\n    console.error('Error updating interactions ', { error })\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateOrganizationsInteractions(\n  orgId: string,\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\organizations.ts"
  },
  {
    "id": "\\services\\supabase\\organizations",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\organizations.ts",
    "type": "file",
    "totalTokens": 612,
    "inDegree": 0,
    "outDegree": 5,
    "code": "import { sql } from '@/lib/db/index.ts'\nimport { ModelsEnum } from '@/types/index.ts'\n\nexport async function updateOrganizationsInteractions(\n  orgId: string,\n) {\n  try {\n    await sql`\n      UPDATE organizations\n      SET daily_interactions = daily_interactions + 1\n      WHERE id = ${orgId}\n    `\n  } catch (error) {\n    console.error('Error updating interactions ', { error })\n  }\n}\n\nexport async function addOrgDailyTokens({\n  orgId,\n  inputTokens,\n  outputTokens,\n  model,\n}: {\n  orgId: string\n  inputTokens: number\n  outputTokens: number\n  model: ModelsEnum\n}) {\n  console.log({ orgId, inputTokens, outputTokens, model })\n  try {\n    await sql`SELECT update_daily_usage(${orgId}, ${inputTokens}, ${outputTokens}, ${model})`\n  } catch (error) {\n    console.error('Error updating interactions ', { error })\n  }\n}\n\nexport async function getOrganization({\n  orgId,\n}: {\n  orgId: string\n}): Promise<\n  {\n    name: string\n    image: string\n    planName: string\n    dailyCompletionCount: number\n    dailyInteractions: number\n  } | undefined\n> {\n  if (!orgId) {\n    throw new Error('Organization id is required')\n  }\n  try {\n    const result = await sql`\n      SELECT organizations.name, organizations.image, plan.name as planName, plan.daily_completion_count as daily_completion_count, organizations.daily_interactions as daily_interactions\n      FROM organizations \n      LEFT JOIN subscriptions ON organizations.id = subscriptions.org_id\n      LEFT JOIN plan ON subscriptions.plan_id = plan.id\n      WHERE organizations.id = ${orgId}\n    `\n\n    console.log({ result })\n\n    return {\n      name: result[0].name,\n      image: result[0].image,\n      planName: result[0].planname,\n      dailyCompletionCount: result[0].daily_completion_count,\n      dailyInteractions: result[0].daily_interactions,\n    }\n  } catch (error) {\n    console.error('Error searching for organization ', { error })\n  }\n}\n\nexport async function getOrganizationOwnerDistinctId({\n  orgId,\n}: {\n  orgId: string\n}): Promise<string | undefined> {\n  if (!orgId) {\n    throw new Error('Organization id is required')\n  }\n  try {\n    const result = await sql`\n      SELECT profiles.distinct_id\n      FROM organizations\n      LEFT JOIN organization_user ON organization_user.org_id = organizations.id\n      LEFT JOIN profiles ON profiles.id = organization_user.user_id\n      WHERE organization_user.role = 'owner' AND organizations.id = ${orgId};\n    `\n\n    return result[0].distinct_id\n  } catch (error) {\n    console.error(`Error searching for organization's owner's distinct id: `, {\n      error,\n    })\n  }\n}\n",
    "importStatements": [
      "import { sql } from '@/lib/db/index.ts'",
      "import { ModelsEnum } from '@/types/index.ts'"
    ],
    "codeNoBody": "import { sql } from '@/lib/db/index.ts'\nimport { ModelsEnum } from '@/types/index.ts'\nexport async function updateOrganizationsInteractions(\n  orgId: string,\n) {\n       //...\n       }\n\nexport async function addOrgDailyTokens({\n  orgId,\n  inputTokens,\n  outputTokens,\n  model,\n}: {\n  orgId: string\n  inputTokens: number\n  outputTokens: number\n  model: ModelsEnum\n}) {\n       //...\n       }\n\nexport async function getOrganization({\n  orgId,\n}: {\n  orgId: string\n}): Promise<\n  {\n    name: string\n    image: string\n    planName: string\n    dailyCompletionCount: number\n    dailyInteractions: number\n  } | undefined\n> {\n       //...\n       }\n\nexport async function getOrganizationOwnerDistinctId({\n  orgId,\n}: {\n  orgId: string\n}): Promise<string | undefined> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\organizations.ts"
  },
  {
    "id": "\\services\\supabase\\plan::getFreePlan",
    "language": "typescript",
    "label": "getFreePlan",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\plan",
    "totalTokens": 91,
    "inDegree": 9,
    "outDegree": 2,
    "code": "async function getFreePlan() {\n  try {\n    const { data, error } = await supabase.from('plan').select('*').eq(\n      'id',\n      freePlanId,\n    ).single()\n\n    if (error) {\n      throw error\n    }\n\n    return data\n  } catch (e) {\n    console.log(`There was an error getting the Free Plan data: ${e}`)\n    return null\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function getFreePlan() {\n       //...\n       }",
    "originFile": "\\services\\supabase\\plan.ts"
  },
  {
    "id": "\\services\\supabase\\plan",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\plan.ts",
    "type": "file",
    "totalTokens": 121,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { supabase } from '@/services/supabase/index.ts'\nimport { freePlanId } from '@/lib/consts.ts'\n\nexport async function getFreePlan() {\n  try {\n    const { data, error } = await supabase.from('plan').select('*').eq(\n      'id',\n      freePlanId,\n    ).single()\n\n    if (error) {\n      throw error\n    }\n\n    return data\n  } catch (e) {\n    console.log(`There was an error getting the Free Plan data: ${e}`)\n    return null\n  }\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { freePlanId } from '@/lib/consts.ts'"
    ],
    "codeNoBody": "import { supabase } from '@/services/supabase/index.ts'\nimport { freePlanId } from '@/lib/consts.ts'\nexport async function getFreePlan() {\n       //...\n       }",
    "originFile": "\\services\\supabase\\plan.ts"
  },
  {
    "id": "\\services\\supabase\\profiles::getUserProfile",
    "language": "typescript",
    "label": "getUserProfile",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\profiles",
    "totalTokens": 86,
    "inDegree": 3,
    "outDegree": 1,
    "code": "async function getUserProfile(\n  { userId }: { userId: string },\n) {\n  const { data, error } = await supabase\n    .from('profiles')\n    .select('username, full_name, avatar_url, org_sel_id, distinct_id, status')\n    .eq('id', userId)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n  return data[0]\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserProfile(\n  { userId }: { userId: string },\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\profiles.ts"
  },
  {
    "id": "\\services\\supabase\\profiles::getUserEmail",
    "language": "typescript",
    "label": "getUserEmail",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\profiles",
    "totalTokens": 68,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getUserEmail(\n  { userid }: { userid: string },\n) {\n  const { data, error } = await supabase.rpc(\n    'get_email_by_user_id',\n    { userid },\n  )\n  if (error) {\n    throw new Error(error.message)\n  }\n  return data[0].email\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserEmail(\n  { userid }: { userid: string },\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\profiles.ts"
  },
  {
    "id": "\\services\\supabase\\profiles::updateAvatar",
    "language": "typescript",
    "label": "updateAvatar",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\profiles",
    "totalTokens": 375,
    "inDegree": 1,
    "outDegree": 3,
    "code": "async function updateAvatar(\n  imageFile: File,\n  userId: string,\n) {\n  const [{ avatar_url }] =\n    await sql`SELECT avatar_url FROM profiles WHERE profiles.id = ${userId}`\n\n  let oldImagePath\n  if (avatar_url) {\n    // Extraer la ruta del archivo de la URL de la imagen\n    const url = new URL(avatar_url)\n    oldImagePath = url.pathname.split('/').slice(-1).join('/')\n  }\n\n  const fileExtension = imageFile.name.split('.').pop() as File['type']\n  const imagePath = `${userId}.${fileExtension}`\n\n  const img = await modifyImage(imageFile, {\n    width: 256,\n    mode: 'resize',\n  })\n\n  const { error: uploadError } = await supabase.storage\n    .from('avatars')\n    .upload(imagePath, new Blob([img], { type: imageFile.type }), {\n      cacheControl: '60',\n      upsert: true,\n    })\n\n  if (!uploadError && oldImagePath && oldImagePath !== imagePath) {\n    // Borrar imagen anterior\n    const { error: deletionError } = await supabase.storage.from('avatars')\n      .remove([oldImagePath])\n\n    if (deletionError) {\n      console.log('Error deleting old profile image ==>', deletionError)\n    }\n  }\n\n  const { data: signedURL } = supabase.storage\n    .from('avatars')\n    .getPublicUrl(imagePath)\n\n  // Update avatar_url in profiles\n  const { error } = await supabase.from('profiles').update({\n    avatar_url: signedURL.publicUrl,\n  }).eq('id', userId as string)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return { url: signedURL.publicUrl }\n}",
    "importStatements": [],
    "codeNoBody": "async function updateAvatar(\n  imageFile: File,\n  userId: string,\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\profiles.ts"
  },
  {
    "id": "\\services\\supabase\\profiles::getUserSelectedOrgId",
    "language": "typescript",
    "label": "getUserSelectedOrgId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\profiles",
    "totalTokens": 148,
    "inDegree": 1,
    "outDegree": 1,
    "code": "async function getUserSelectedOrgId(\n  userId: string | null,\n  apiKey: string | null,\n): Promise<string> {\n  let query = sql`SELECT \n  profiles.org_sel_id\nFROM profiles\nLEFT JOIN api_keys on api_keys.key = ${apiKey}\nWHERE profiles.id = api_keys.user_id`\n\n  if (userId) {\n    query =\n      sql`SELECT profiles.org_sel_id FROM profiles WHERE profiles.id = ${userId}`\n  }\n\n  const result = await query\n\n  if (result.length === 0 || !result[0].org_sel_id) {\n    throw new HTTPException(400, { message: 'Missing org id' })\n  }\n\n  return result[0].org_sel_id\n}",
    "importStatements": [],
    "codeNoBody": "async function getUserSelectedOrgId(\n  userId: string | null,\n  apiKey: string | null,\n): Promise<string> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\profiles.ts"
  },
  {
    "id": "\\services\\supabase\\profiles",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\profiles.ts",
    "type": "file",
    "totalTokens": 732,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import { sql } from '@/lib/db/index.ts'\nimport { HTTPException } from 'hono/http-exception'\nimport { supabase } from '@/services/supabase/index.ts'\nimport { modifyImage } from '@/lib/image.ts'\n\nexport async function getUserSelectedOrgId(\n  userId: string | null,\n  apiKey: string | null,\n): Promise<string> {\n  let query = sql`SELECT \n  profiles.org_sel_id\nFROM profiles\nLEFT JOIN api_keys on api_keys.key = ${apiKey}\nWHERE profiles.id = api_keys.user_id`\n\n  if (userId) {\n    query =\n      sql`SELECT profiles.org_sel_id FROM profiles WHERE profiles.id = ${userId}`\n  }\n\n  const result = await query\n\n  if (result.length === 0 || !result[0].org_sel_id) {\n    throw new HTTPException(400, { message: 'Missing org id' })\n  }\n\n  return result[0].org_sel_id\n}\n\nexport async function updateAvatar(\n  imageFile: File,\n  userId: string,\n) {\n  const [{ avatar_url }] =\n    await sql`SELECT avatar_url FROM profiles WHERE profiles.id = ${userId}`\n\n  let oldImagePath\n  if (avatar_url) {\n    // Extraer la ruta del archivo de la URL de la imagen\n    const url = new URL(avatar_url)\n    oldImagePath = url.pathname.split('/').slice(-1).join('/')\n  }\n\n  const fileExtension = imageFile.name.split('.').pop() as File['type']\n  const imagePath = `${userId}.${fileExtension}`\n\n  const img = await modifyImage(imageFile, {\n    width: 256,\n    mode: 'resize',\n  })\n\n  const { error: uploadError } = await supabase.storage\n    .from('avatars')\n    .upload(imagePath, new Blob([img], { type: imageFile.type }), {\n      cacheControl: '60',\n      upsert: true,\n    })\n\n  if (!uploadError && oldImagePath && oldImagePath !== imagePath) {\n    // Borrar imagen anterior\n    const { error: deletionError } = await supabase.storage.from('avatars')\n      .remove([oldImagePath])\n\n    if (deletionError) {\n      console.log('Error deleting old profile image ==>', deletionError)\n    }\n  }\n\n  const { data: signedURL } = supabase.storage\n    .from('avatars')\n    .getPublicUrl(imagePath)\n\n  // Update avatar_url in profiles\n  const { error } = await supabase.from('profiles').update({\n    avatar_url: signedURL.publicUrl,\n  }).eq('id', userId as string)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n\n  return { url: signedURL.publicUrl }\n}\n\nexport async function getUserEmail(\n  { userid }: { userid: string },\n) {\n  const { data, error } = await supabase.rpc(\n    'get_email_by_user_id',\n    { userid },\n  )\n  if (error) {\n    throw new Error(error.message)\n  }\n  return data[0].email\n}\n\nexport async function getUserProfile(\n  { userId }: { userId: string },\n) {\n  const { data, error } = await supabase\n    .from('profiles')\n    .select('username, full_name, avatar_url, org_sel_id, distinct_id, status')\n    .eq('id', userId)\n\n  if (error) {\n    throw new Error(error.message)\n  }\n  return data[0]\n}\n",
    "importStatements": [
      "import { sql } from '@/lib/db/index.ts'",
      "import { HTTPException } from 'hono/http-exception'",
      "import { supabase } from '@/services/supabase/index.ts'",
      "import { modifyImage } from '@/lib/image.ts'"
    ],
    "codeNoBody": "import { sql } from '@/lib/db/index.ts'\nimport { HTTPException } from 'hono/http-exception'\nimport { supabase } from '@/services/supabase/index.ts'\nimport { modifyImage } from '@/lib/image.ts'\nexport async function getUserSelectedOrgId(\n  userId: string | null,\n  apiKey: string | null,\n): Promise<string> {\n       //...\n       }\n\nexport async function updateAvatar(\n  imageFile: File,\n  userId: string,\n) {\n       //...\n       }\n\nexport async function getUserEmail(\n  { userid }: { userid: string },\n) {\n       //...\n       }\n\nexport async function getUserProfile(\n  { userId }: { userId: string },\n) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\profiles.ts"
  },
  {
    "id": "\\services\\supabase\\subscription::getActiveSubscriptionByOrgId",
    "language": "typescript",
    "label": "getActiveSubscriptionByOrgId",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\subscription",
    "totalTokens": 134,
    "inDegree": 9,
    "outDegree": 1,
    "code": "async function getActiveSubscriptionByOrgId(orgId: string) {\n  const { data, error } = await supabase\n    .from('subscriptions')\n    .select(\n      '*, plan: plan(id, name, max_agents, files, text_storage, daily_completion_count, daily_max_usage,temp_usage), organization: organizations(daily_interactions, daily_usage)',\n    )\n    .eq('org_id', orgId)\n    .in('status', ['active', 'trialing'])\n  // .maybeSingle()\n\n  if (error) {\n    console.log(error)\n    throw new Error(error.message)\n  }\n\n  return data[0]\n}",
    "importStatements": [],
    "codeNoBody": "async function getActiveSubscriptionByOrgId(orgId: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\subscription.ts"
  },
  {
    "id": "\\services\\supabase\\subscription",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\subscription.ts",
    "type": "file",
    "totalTokens": 151,
    "inDegree": 0,
    "outDegree": 1,
    "code": "import { supabase } from '@/services/supabase/index.ts'\n\nexport async function getActiveSubscriptionByOrgId(orgId: string) {\n  const { data, error } = await supabase\n    .from('subscriptions')\n    .select(\n      '*, plan: plan(id, name, max_agents, files, text_storage, daily_completion_count, daily_max_usage,temp_usage), organization: organizations(daily_interactions, daily_usage)',\n    )\n    .eq('org_id', orgId)\n    .in('status', ['active', 'trialing'])\n  // .maybeSingle()\n\n  if (error) {\n    console.log(error)\n    throw new Error(error.message)\n  }\n\n  return data[0]\n}\n",
    "importStatements": [
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "import { supabase } from '@/services/supabase/index.ts'\nexport async function getActiveSubscriptionByOrgId(orgId: string) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\subscription.ts"
  },
  {
    "id": "\\services\\supabase\\usage-log::saveUsageLog",
    "language": "typescript",
    "label": "saveUsageLog",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage-log",
    "totalTokens": 190,
    "inDegree": 1,
    "outDegree": 2,
    "code": "async function saveUsageLog({ usage, chunksIds }: SaveUsageLogProps) {\n  try {\n    const { error, data } = await supabase.from('usage_log').insert({\n      ...usage,\n    }).select('id')\n\n    if (error || data.length === 0) {\n      throw new Error(error?.message)\n    }\n\n    const usageChunks = chunksIds.map(({ chunk_id, score }) => {\n      return {\n        usage_id: data[0].id,\n        chunk_id,\n        score,\n      }\n    })\n\n    if (usageChunks.length > 0) {\n      const { error: chunksError } = await supabase.from('usage_chunks').insert(\n        usageChunks,\n      )\n      if (chunksError) {\n        throw new Error(chunksError.message)\n      }\n    }\n  } catch (err) {\n    console.log('Error saving usage log =>', err)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function saveUsageLog({ usage, chunksIds }: SaveUsageLogProps) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\usage-log.ts"
  },
  {
    "id": "\\services\\supabase\\usage-log::UsageLogInsert",
    "language": "typescript",
    "label": "UsageLogInsert",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage-log",
    "totalTokens": 16,
    "inDegree": 3,
    "outDegree": 2,
    "code": "type UsageLogInsert = Database['public']['Tables']['usage_log']['Insert']",
    "importStatements": [],
    "codeNoBody": "type UsageLogInsert = Database['public']['Tables']['usage_log']['Insert']",
    "originFile": "\\services\\supabase\\usage-log.ts"
  },
  {
    "id": "\\services\\supabase\\usage-log::SaveUsageLogProps",
    "language": "typescript",
    "label": "SaveUsageLogProps",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage-log",
    "totalTokens": 33,
    "inDegree": 4,
    "outDegree": 2,
    "code": "interface SaveUsageLogProps {\n  usage: UsageLogInsert\n  chunksIds: {\n    chunk_id: string\n    score: number\n  }[]\n}",
    "importStatements": [],
    "codeNoBody": "interface SaveUsageLogProps {\n//...\n}",
    "originFile": "\\services\\supabase\\usage-log.ts"
  },
  {
    "id": "\\services\\supabase\\usage-log",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage-log.ts",
    "type": "file",
    "totalTokens": 271,
    "inDegree": 0,
    "outDegree": 4,
    "code": "import type { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\n\ninterface SaveUsageLogProps {\n  usage: UsageLogInsert\n  chunksIds: {\n    chunk_id: string\n    score: number\n  }[]\n}\nexport type UsageLogInsert = Database['public']['Tables']['usage_log']['Insert']\n\nexport async function saveUsageLog({ usage, chunksIds }: SaveUsageLogProps) {\n  try {\n    const { error, data } = await supabase.from('usage_log').insert({\n      ...usage,\n    }).select('id')\n\n    if (error || data.length === 0) {\n      throw new Error(error?.message)\n    }\n\n    const usageChunks = chunksIds.map(({ chunk_id, score }) => {\n      return {\n        usage_id: data[0].id,\n        chunk_id,\n        score,\n      }\n    })\n\n    if (usageChunks.length > 0) {\n      const { error: chunksError } = await supabase.from('usage_chunks').insert(\n        usageChunks,\n      )\n      if (chunksError) {\n        throw new Error(chunksError.message)\n      }\n    }\n  } catch (err) {\n    console.log('Error saving usage log =>', err)\n  }\n}\n",
    "importStatements": [
      "import type { Database } from '@/types/supabase.ts'",
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "import type { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\ninterface SaveUsageLogProps {\n//...\n}\nexport type UsageLogInsert = Database['public']['Tables']['usage_log']['Insert']\n\nexport async function saveUsageLog({ usage, chunksIds }: SaveUsageLogProps) {\n       //...\n       }",
    "originFile": "\\services\\supabase\\usage-log.ts"
  },
  {
    "id": "\\services\\supabase\\usage::saveUsage",
    "language": "typescript",
    "label": "saveUsage",
    "type": "function",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage",
    "totalTokens": 72,
    "inDegree": 9,
    "outDegree": 2,
    "code": "async function saveUsage(usage: UsageInsert[]): Promise<void> {\n  try {\n    const { error } = await supabase.from('usage').insert(usage)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error while saving usage: ', error)\n  }\n}",
    "importStatements": [],
    "codeNoBody": "async function saveUsage(usage: UsageInsert[]): Promise<void> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\usage.ts"
  },
  {
    "id": "\\services\\supabase\\usage::UsageInsert",
    "language": "typescript",
    "label": "UsageInsert",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage",
    "totalTokens": 14,
    "inDegree": 10,
    "outDegree": 2,
    "code": "type UsageInsert = Database['public']['Tables']['usage']['Insert']",
    "importStatements": [],
    "codeNoBody": "type UsageInsert = Database['public']['Tables']['usage']['Insert']",
    "originFile": "\\services\\supabase\\usage.ts"
  },
  {
    "id": "\\services\\supabase\\usage",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\services\\supabase\\usage.ts",
    "type": "file",
    "totalTokens": 117,
    "inDegree": 0,
    "outDegree": 3,
    "code": "import { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\n\nexport type UsageInsert = Database['public']['Tables']['usage']['Insert']\n\nexport async function saveUsage(usage: UsageInsert[]): Promise<void> {\n  try {\n    const { error } = await supabase.from('usage').insert(usage)\n\n    if (error) {\n      throw new Error(error.message)\n    }\n  } catch (error) {\n    console.log('Error while saving usage: ', error)\n  }\n}\n",
    "importStatements": [
      "import { Database } from '@/types/supabase.ts'",
      "import { supabase } from '@/services/supabase/index.ts'"
    ],
    "codeNoBody": "import { Database } from '@/types/supabase.ts'\nimport { supabase } from '@/services/supabase/index.ts'\nexport type UsageInsert = Database['public']['Tables']['usage']['Insert']\n\nexport async function saveUsage(usage: UsageInsert[]): Promise<void> {\n       //...\n       }",
    "originFile": "\\services\\supabase\\usage.ts"
  },
  {
    "id": "\\types\\env::Env",
    "language": "typescript",
    "label": "Env",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\env",
    "totalTokens": 574,
    "inDegree": 5,
    "outDegree": 1,
    "code": "interface Env {\n  DATABASE_USERNAME: string\n  DATABASE_PASSWORD: string\n  DATABASE_HOST: string\n  DATABASE_PORT: string\n  DATABASE_NAME: string\n  REDIS_URL: string\n  REDIS_TOKEN: string\n  SUPABASE_URL: string\n  SUPABASE_KEY: string\n  SUPABASE_JWT: string\n  AZURE_35: string\n  AZURE_35_0613: string\n  AZURE_35_16K: string\n  AZURE_4: string\n  AZURE_4_32K: string\n  AZURE_EMBEDDING: string\n  AZURE_KEY: string\n  AZURE_4_TURBO: string\n  AZURE_KEY_TURBO: string\n  AZURE_4_VISION: string\n  AZURE_KEY_VISION: string\n  AZURE_INSTRUCT: string\n  ANTHROPIC_API_KEY: string\n  OPENAI_API_KEY: string\n  OPENAI_ORGANIZATION_ID: string\n  CONVERT_API_SECRET: string\n  CODEGPT_API_URL: string\n  MIXPANEL_PROJECT_TOKEN: string\n  MIXPANEL_PROJECT_ID: string\n  BUGSNAG_APIKEY: string\n  PLAYGROUND_URL: string\n  PLAYGROUND_SECRET_KEY: string\n  AWS_BEDROCK_REGION: string\n  AWS_BEDROCK_ACCESS_KEY_ID: string\n  AWS_BEDROCK_SECRET_ACCESS_KEY: string\n  GOOGLE_GEMINI_APIKEY: string\n  SUPABASE_CA_CERTIFICATE: string\n  AZURE_OPENAI_ENDPOINT: string\n  AZURE_OPENAI_ENDPOINT_TURBO: string\n  AZURE_OPENAI_ENDPOINT_VISION: string\n  SLACK_SIGNING_SECRET: string\n  SLACK_APP_TOKEN: string\n  SLACK_REDIRECT_URI: string\n  SLACK_CLIENT_ID: string\n  SLACK_CLIENT_SECRET: string\n  TURSO_TOKEN_API: string\n  TURSO_DATABASE_URL: string\n  DISCORD_BOT_TOKEN: string\n  DISCORD_APPLICATION_ID: string\n  DISCORD_PUBLIC_KEY: string\n  DISCORD_CLIENT_SECRET: string\n  COHERE_API_KEY: string\n  GROQ_API_KEY: string\n  VERTEX_PROJECT_ID: string\n  VERTEX_CLIENT_EMAIL: string\n  VERTEX_PRIVATE_KEY: string\n  E2B_API_KEY: string\n  GITHUB_CLIENT_ID: string\n  GITHUB_CLIENT_SECRET: string\n  GITHUB_APP_ID: string\n  GITHUB_REDIRECT_URI: string\n  BITBUCKET_KEY: string\n  BITBUCKET_SECRET: string\n  GITLAB_APP_ID: string\n  GITLAB_SECRET_ID: string\n  MISTRAL_API_KEY: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Env {\n       //...\n       }",
    "originFile": "\\types\\env.ts"
  },
  {
    "id": "\\types\\env",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\env.ts",
    "type": "file",
    "totalTokens": 575,
    "inDegree": 0,
    "outDegree": 2,
    "code": "export interface Env {\n  DATABASE_USERNAME: string\n  DATABASE_PASSWORD: string\n  DATABASE_HOST: string\n  DATABASE_PORT: string\n  DATABASE_NAME: string\n  REDIS_URL: string\n  REDIS_TOKEN: string\n  SUPABASE_URL: string\n  SUPABASE_KEY: string\n  SUPABASE_JWT: string\n  AZURE_35: string\n  AZURE_35_0613: string\n  AZURE_35_16K: string\n  AZURE_4: string\n  AZURE_4_32K: string\n  AZURE_EMBEDDING: string\n  AZURE_KEY: string\n  AZURE_4_TURBO: string\n  AZURE_KEY_TURBO: string\n  AZURE_4_VISION: string\n  AZURE_KEY_VISION: string\n  AZURE_INSTRUCT: string\n  ANTHROPIC_API_KEY: string\n  OPENAI_API_KEY: string\n  OPENAI_ORGANIZATION_ID: string\n  CONVERT_API_SECRET: string\n  CODEGPT_API_URL: string\n  MIXPANEL_PROJECT_TOKEN: string\n  MIXPANEL_PROJECT_ID: string\n  BUGSNAG_APIKEY: string\n  PLAYGROUND_URL: string\n  PLAYGROUND_SECRET_KEY: string\n  AWS_BEDROCK_REGION: string\n  AWS_BEDROCK_ACCESS_KEY_ID: string\n  AWS_BEDROCK_SECRET_ACCESS_KEY: string\n  GOOGLE_GEMINI_APIKEY: string\n  SUPABASE_CA_CERTIFICATE: string\n  AZURE_OPENAI_ENDPOINT: string\n  AZURE_OPENAI_ENDPOINT_TURBO: string\n  AZURE_OPENAI_ENDPOINT_VISION: string\n  SLACK_SIGNING_SECRET: string\n  SLACK_APP_TOKEN: string\n  SLACK_REDIRECT_URI: string\n  SLACK_CLIENT_ID: string\n  SLACK_CLIENT_SECRET: string\n  TURSO_TOKEN_API: string\n  TURSO_DATABASE_URL: string\n  DISCORD_BOT_TOKEN: string\n  DISCORD_APPLICATION_ID: string\n  DISCORD_PUBLIC_KEY: string\n  DISCORD_CLIENT_SECRET: string\n  COHERE_API_KEY: string\n  GROQ_API_KEY: string\n  VERTEX_PROJECT_ID: string\n  VERTEX_CLIENT_EMAIL: string\n  VERTEX_PRIVATE_KEY: string\n  E2B_API_KEY: string\n  GITHUB_CLIENT_ID: string\n  GITHUB_CLIENT_SECRET: string\n  GITHUB_APP_ID: string\n  GITHUB_REDIRECT_URI: string\n  BITBUCKET_KEY: string\n  BITBUCKET_SECRET: string\n  GITLAB_APP_ID: string\n  GITLAB_SECRET_ID: string\n  MISTRAL_API_KEY: string\n}\n",
    "importStatements": [],
    "codeNoBody": "export interface Env {\n       //...\n       }",
    "originFile": "\\types\\env.ts"
  },
  {
    "id": "\\types\\index::MixpanelProperties",
    "language": "typescript",
    "label": "MixpanelProperties",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 55,
    "inDegree": 4,
    "outDegree": 3,
    "code": "interface MixpanelProperties {\n  email: string\n  plan: Plan['name']\n  ip: string\n  time?: number\n  $insert_id?: string\n  source?: string\n  isFree?: boolean\n  distinct_id: Profile['distinct_id']\n}",
    "importStatements": [],
    "codeNoBody": "interface MixpanelProperties {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::MixPanelEvent",
    "language": "typescript",
    "label": "MixPanelEvent",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 18,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface MixPanelEvent {\n  event: string\n  properties: MixpanelProperties\n}",
    "importStatements": [],
    "codeNoBody": "interface MixPanelEvent {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::ChatMessage",
    "language": "typescript",
    "label": "ChatMessage",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 31,
    "inDegree": 14,
    "outDegree": 1,
    "code": "interface ChatMessage {\n  id?: string\n  content: string\n  createdAt?: string\n  role: Database['public']['Enums']['role']\n}",
    "importStatements": [],
    "codeNoBody": "interface ChatMessage {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::UpcomingPayment",
    "language": "typescript",
    "label": "UpcomingPayment",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 21,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface UpcomingPayment {\n  amount: number\n  currency: string\n  date: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UpcomingPayment {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::CountryData",
    "language": "typescript",
    "label": "CountryData",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 31,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface CountryData {\n  code: string\n  name: {\n    es: string\n    en: string\n    default: string\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface CountryData {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::CurrentPlan",
    "language": "typescript",
    "label": "CurrentPlan",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 26,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface CurrentPlan {\n  selOrgId: string\n  orgInteractions: number\n  plan: Profile_Plan\n}",
    "importStatements": [],
    "codeNoBody": "interface CurrentPlan {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Profile_Plan",
    "language": "typescript",
    "label": "Profile_Plan",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 82,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Profile_Plan {\n  sub_id: string\n  plan_id: string\n  name: string\n  status: Database['public']['Enums']['subscription_status']\n  start_date: string\n  expiration: string\n  cancel_at_period_end: boolean\n  limits: {\n    daily_completion: number\n    agents: number\n    files: number\n    text_storage: number\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface Profile_Plan {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Organization_user",
    "language": "typescript",
    "label": "Organization_user",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 51,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface Organization_user {\n  role: Database['public']['Enums']['org_role']\n  details: {\n    created_at: Date\n    customer_id: string\n    org_id: string\n    id: string\n    name: string\n  }\n}",
    "importStatements": [],
    "codeNoBody": "interface Organization_user {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Features",
    "language": "typescript",
    "label": "Features",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 15,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface Features {\n  github_sync: boolean\n  scraping: boolean\n}",
    "importStatements": [],
    "codeNoBody": "interface Features {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::ActiveSuscriptionPlan",
    "language": "typescript",
    "label": "ActiveSuscriptionPlan",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 72,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface ActiveSuscriptionPlan {\n  plan_id: string\n  plan: string\n  daily_completion_count: number\n  files: number\n  max_agents: number\n  text_storage: number\n  status: Database['public']['Enums']['subscription_status']\n  created_at: string\n  begin_date: string\n  finish_date: string\n}",
    "importStatements": [],
    "codeNoBody": "interface ActiveSuscriptionPlan {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::BillingAddress",
    "language": "typescript",
    "label": "BillingAddress",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 43,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface BillingAddress {\n  id?: string\n  country: string\n  state?: string\n  city: string\n  line1: string\n  line2?: string\n  postal_code: string\n}",
    "importStatements": [],
    "codeNoBody": "interface BillingAddress {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::PlanWithPricing",
    "language": "typescript",
    "label": "PlanWithPricing",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 16,
    "inDegree": 3,
    "outDegree": 3,
    "code": "interface PlanWithPricing extends Plan {\n  pricing: PlanPricing[]\n}",
    "importStatements": [],
    "codeNoBody": "interface PlanWithPricing extends Plan {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::FileObject",
    "language": "typescript",
    "label": "FileObject",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 71,
    "inDegree": 3,
    "outDegree": 2,
    "code": "interface FileObject {\n  name: string\n  bucket_id: string\n  owner: string\n  id: string\n  updated_at: string\n  created_at: string\n  last_accessed_at: string\n  // deno-lint-ignore no-explicit-any\n  metadata: Record<string, any>\n  buckets: Bucket\n}",
    "importStatements": [],
    "codeNoBody": "interface FileObject {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Bucket",
    "language": "typescript",
    "label": "Bucket",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 50,
    "inDegree": 3,
    "outDegree": 1,
    "code": "interface Bucket {\n  id: string\n  name: string\n  owner: string\n  file_size_limit?: number\n  allowed_mime_types?: string[]\n  created_at: string\n  updated_at: string\n  public: boolean\n}",
    "importStatements": [],
    "codeNoBody": "interface Bucket {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Channels",
    "language": "typescript",
    "label": "Channels",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 7,
    "inDegree": 6,
    "outDegree": 1,
    "code": "type Channels = typeof channels[number]",
    "importStatements": [],
    "codeNoBody": "type Channels = typeof channels[number]",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::ModelsEnum",
    "language": "typescript",
    "label": "ModelsEnum",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 12,
    "inDegree": 6,
    "outDegree": 1,
    "code": "type ModelsEnum = Database['public']['Enums']['models']",
    "importStatements": [],
    "codeNoBody": "type ModelsEnum = Database['public']['Enums']['models']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::ModelPricing",
    "language": "typescript",
    "label": "ModelPricing",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 17,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type ModelPricing = Database['public']['Tables']['models_pricing']['Row']",
    "importStatements": [],
    "codeNoBody": "type ModelPricing = Database['public']['Tables']['models_pricing']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::UsageType",
    "language": "typescript",
    "label": "UsageType",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type UsageType = Database['public']['Enums']['usage_type']",
    "importStatements": [],
    "codeNoBody": "type UsageType = Database['public']['Enums']['usage_type']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Organization",
    "language": "typescript",
    "label": "Organization",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type Organization = Database['public']['Tables']['organizations']['Row']",
    "importStatements": [],
    "codeNoBody": "type Organization = Database['public']['Tables']['organizations']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::GetColleagues",
    "language": "typescript",
    "label": "GetColleagues",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 20,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type GetColleagues =\n  Database['public']['Functions']['get_colleagues']['Returns']",
    "importStatements": [],
    "codeNoBody": "type GetColleagues =\n  Database['public']['Functions']['get_colleagues']['Returns']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::BillingIntervals",
    "language": "typescript",
    "label": "BillingIntervals",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 14,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type BillingIntervals = Database['public']['Enums']['billing_interval']",
    "importStatements": [],
    "codeNoBody": "type BillingIntervals = Database['public']['Enums']['billing_interval']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Subscription",
    "language": "typescript",
    "label": "Subscription",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type Subscription = Database['public']['Tables']['subscriptions']['Row']",
    "importStatements": [],
    "codeNoBody": "type Subscription = Database['public']['Tables']['subscriptions']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::PlanPricing",
    "language": "typescript",
    "label": "PlanPricing",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 17,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type PlanPricing = Database['public']['Tables']['plan_pricing']['Row']",
    "importStatements": [],
    "codeNoBody": "type PlanPricing = Database['public']['Tables']['plan_pricing']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Plan",
    "language": "typescript",
    "label": "Plan",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 4,
    "outDegree": 1,
    "code": "type Plan = Database['public']['Tables']['plan']['Row']",
    "importStatements": [],
    "codeNoBody": "type Plan = Database['public']['Tables']['plan']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Profile",
    "language": "typescript",
    "label": "Profile",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 3,
    "outDegree": 1,
    "code": "type Profile = Database['public']['Tables']['profiles']['Row']",
    "importStatements": [],
    "codeNoBody": "type Profile = Database['public']['Tables']['profiles']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::UsageLog",
    "language": "typescript",
    "label": "UsageLog",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 15,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type UsageLog = Database['public']['Tables']['usage_log']['Row']",
    "importStatements": [],
    "codeNoBody": "type UsageLog = Database['public']['Tables']['usage_log']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::NewUsage",
    "language": "typescript",
    "label": "NewUsage",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 14,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type NewUsage = Database['public']['Tables']['usage']['Insert'][]",
    "importStatements": [],
    "codeNoBody": "type NewUsage = Database['public']['Tables']['usage']['Insert'][]",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::ApiKey",
    "language": "typescript",
    "label": "ApiKey",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 15,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type ApiKey = Database['public']['Tables']['api_keys']['Row']",
    "importStatements": [],
    "codeNoBody": "type ApiKey = Database['public']['Tables']['api_keys']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::UserProfiling",
    "language": "typescript",
    "label": "UserProfiling",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 19,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type UserProfiling =\n  Database['public']['Tables']['user_profilings']['Row']",
    "importStatements": [],
    "codeNoBody": "type UserProfiling =\n  Database['public']['Tables']['user_profilings']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Agreement",
    "language": "typescript",
    "label": "Agreement",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 14,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type Agreement = Database['public']['Tables']['agreements']['Row']",
    "importStatements": [],
    "codeNoBody": "type Agreement = Database['public']['Tables']['agreements']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Message",
    "language": "typescript",
    "label": "Message",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type Message = Database['public']['Tables']['messages']['Row']",
    "importStatements": [],
    "codeNoBody": "type Message = Database['public']['Tables']['messages']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::AgentSelectedDocument",
    "language": "typescript",
    "label": "AgentSelectedDocument",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 17,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type AgentSelectedDocument =\n  Database['public']['Tables']['agents_documents']['Row']",
    "importStatements": [],
    "codeNoBody": "type AgentSelectedDocument =\n  Database['public']['Tables']['agents_documents']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Document",
    "language": "typescript",
    "label": "Document",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 7,
    "outDegree": 1,
    "code": "type Document = Database['public']['Tables']['documents']['Row']",
    "importStatements": [],
    "codeNoBody": "type Document = Database['public']['Tables']['documents']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Agent",
    "language": "typescript",
    "label": "Agent",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 4,
    "outDegree": 1,
    "code": "type Agent = Database['public']['Tables']['agents']['Row']",
    "importStatements": [],
    "codeNoBody": "type Agent = Database['public']['Tables']['agents']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index::Usage",
    "language": "typescript",
    "label": "Usage",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index",
    "totalTokens": 13,
    "inDegree": 2,
    "outDegree": 1,
    "code": "type Usage = Database['public']['Tables']['usage']['Row']",
    "importStatements": [],
    "codeNoBody": "type Usage = Database['public']['Tables']['usage']['Row']",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\index",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\index.ts",
    "type": "file",
    "totalTokens": 939,
    "inDegree": 0,
    "outDegree": 48,
    "code": "import { channels } from '@/lib/consts.ts'\nimport type { Database } from './supabase.ts'\n\nexport type Usage = Database['public']['Tables']['usage']['Row']\nexport type Agent = Database['public']['Tables']['agents']['Row']\nexport type Document = Database['public']['Tables']['documents']['Row']\nexport type AgentSelectedDocument =\n  Database['public']['Tables']['agents_documents']['Row']\nexport type Message = Database['public']['Tables']['messages']['Row']\nexport type Agreement = Database['public']['Tables']['agreements']['Row']\nexport type UserProfiling =\n  Database['public']['Tables']['user_profilings']['Row']\nexport type ApiKey = Database['public']['Tables']['api_keys']['Row']\nexport type NewUsage = Database['public']['Tables']['usage']['Insert'][]\nexport type UsageLog = Database['public']['Tables']['usage_log']['Row']\nexport type Profile = Database['public']['Tables']['profiles']['Row']\nexport type Plan = Database['public']['Tables']['plan']['Row']\nexport type PlanPricing = Database['public']['Tables']['plan_pricing']['Row']\nexport type Subscription = Database['public']['Tables']['subscriptions']['Row']\nexport type BillingIntervals = Database['public']['Enums']['billing_interval']\nexport type GetColleagues =\n  Database['public']['Functions']['get_colleagues']['Returns']\nexport type Organization = Database['public']['Tables']['organizations']['Row']\nexport type UsageType = Database['public']['Enums']['usage_type']\nexport type ModelPricing = Database['public']['Tables']['models_pricing']['Row']\nexport type ModelsEnum = Database['public']['Enums']['models']\nexport type Channels = typeof channels[number]\n\nexport interface Bucket {\n  id: string\n  name: string\n  owner: string\n  file_size_limit?: number\n  allowed_mime_types?: string[]\n  created_at: string\n  updated_at: string\n  public: boolean\n}\nexport interface FileObject {\n  name: string\n  bucket_id: string\n  owner: string\n  id: string\n  updated_at: string\n  created_at: string\n  last_accessed_at: string\n  // deno-lint-ignore no-explicit-any\n  metadata: Record<string, any>\n  buckets: Bucket\n}\n\nexport interface PlanWithPricing extends Plan {\n  pricing: PlanPricing[]\n}\n\nexport interface BillingAddress {\n  id?: string\n  country: string\n  state?: string\n  city: string\n  line1: string\n  line2?: string\n  postal_code: string\n}\n\nexport interface ActiveSuscriptionPlan {\n  plan_id: string\n  plan: string\n  daily_completion_count: number\n  files: number\n  max_agents: number\n  text_storage: number\n  status: Database['public']['Enums']['subscription_status']\n  created_at: string\n  begin_date: string\n  finish_date: string\n}\n\nexport interface Features {\n  github_sync: boolean\n  scraping: boolean\n}\n\nexport interface Organization_user {\n  role: Database['public']['Enums']['org_role']\n  details: {\n    created_at: Date\n    customer_id: string\n    org_id: string\n    id: string\n    name: string\n  }\n}\n\nexport interface Profile_Plan {\n  sub_id: string\n  plan_id: string\n  name: string\n  status: Database['public']['Enums']['subscription_status']\n  start_date: string\n  expiration: string\n  cancel_at_period_end: boolean\n  limits: {\n    daily_completion: number\n    agents: number\n    files: number\n    text_storage: number\n  }\n}\n\nexport interface CurrentPlan {\n  selOrgId: string\n  orgInteractions: number\n  plan: Profile_Plan\n}\n\nexport interface CountryData {\n  code: string\n  name: {\n    es: string\n    en: string\n    default: string\n  }\n}\n\nexport interface UpcomingPayment {\n  amount: number\n  currency: string\n  date: string\n}\n\nexport interface ChatMessage {\n  id?: string\n  content: string\n  createdAt?: string\n  role: Database['public']['Enums']['role']\n}\n\nexport interface MixPanelEvent {\n  event: string\n  properties: MixpanelProperties\n}\n\nexport interface MixpanelProperties {\n  email: string\n  plan: Plan['name']\n  ip: string\n  time?: number\n  $insert_id?: string\n  source?: string\n  isFree?: boolean\n  distinct_id: Profile['distinct_id']\n}\n",
    "importStatements": [
      "import { channels } from '@/lib/consts.ts'",
      "import type { Database } from './supabase.ts'"
    ],
    "codeNoBody": "import { channels } from '@/lib/consts.ts'\nimport type { Database } from './supabase.ts'\nexport type Usage = Database['public']['Tables']['usage']['Row']\nexport type Agent = Database['public']['Tables']['agents']['Row']\nexport type Document = Database['public']['Tables']['documents']['Row']\nexport type AgentSelectedDocument =\n  Database['public']['Tables']['agents_documents']['Row']\nexport type Message = Database['public']['Tables']['messages']['Row']\nexport type Agreement = Database['public']['Tables']['agreements']['Row']\nexport type UserProfiling =\n  Database['public']['Tables']['user_profilings']['Row']\nexport type ApiKey = Database['public']['Tables']['api_keys']['Row']\nexport type NewUsage = Database['public']['Tables']['usage']['Insert'][]\nexport type UsageLog = Database['public']['Tables']['usage_log']['Row']\nexport type Profile = Database['public']['Tables']['profiles']['Row']\nexport type Plan = Database['public']['Tables']['plan']['Row']\nexport type PlanPricing = Database['public']['Tables']['plan_pricing']['Row']\nexport type Subscription = Database['public']['Tables']['subscriptions']['Row']\nexport type BillingIntervals = Database['public']['Enums']['billing_interval']\nexport type GetColleagues =\n  Database['public']['Functions']['get_colleagues']['Returns']\nexport type Organization = Database['public']['Tables']['organizations']['Row']\nexport type UsageType = Database['public']['Enums']['usage_type']\nexport type ModelPricing = Database['public']['Tables']['models_pricing']['Row']\nexport type ModelsEnum = Database['public']['Enums']['models']\nexport type Channels = typeof channels[number]\n\nexport interface Bucket {\n       //...\n       }\nexport interface FileObject {\n       //...\n       }\n\nexport interface PlanWithPricing extends Plan {\n       //...\n       }\n\nexport interface BillingAddress {\n       //...\n       }\n\nexport interface ActiveSuscriptionPlan {\n       //...\n       }\n\nexport interface Features {\n       //...\n       }\n\nexport interface Organization_user {\n       //...\n       }\n\nexport interface Profile_Plan {\n       //...\n       }\n\nexport interface CurrentPlan {\n       //...\n       }\n\nexport interface CountryData {\n       //...\n       }\n\nexport interface UpcomingPayment {\n       //...\n       }\n\nexport interface ChatMessage {\n       //...\n       }\n\nexport interface MixPanelEvent {\n       //...\n       }\n\nexport interface MixpanelProperties {\n       //...\n       }",
    "originFile": "\\types\\index.ts"
  },
  {
    "id": "\\types\\supabase::Enums",
    "language": "typescript",
    "label": "Enums",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 124,
    "inDegree": 2,
    "outDegree": 3,
    "code": "type Enums<\n  PublicEnumNameOrOptions extends keyof PublicSchema['Enums'] | {\n    schema: keyof Database\n  },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never,\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n    ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never",
    "importStatements": [],
    "codeNoBody": "type Enums<\n  PublicEnumNameOrOptions extends keyof PublicSchema['Enums'] | {\n    schema: keyof Database\n  },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never,\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n    ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::TablesUpdate",
    "language": "typescript",
    "label": "TablesUpdate",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 150,
    "inDegree": 2,
    "outDegree": 3,
    "code": "type TablesUpdate<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Update: infer U\n  } ? U\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    } ? U\n    : never\n  : never",
    "importStatements": [],
    "codeNoBody": "type TablesUpdate<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Update: infer U\n  } ? U\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    } ? U\n    : never\n  : never",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::TablesInsert",
    "language": "typescript",
    "label": "TablesInsert",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 150,
    "inDegree": 2,
    "outDegree": 3,
    "code": "type TablesInsert<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Insert: infer I\n  } ? I\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    } ? I\n    : never\n  : never",
    "importStatements": [],
    "codeNoBody": "type TablesInsert<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Insert: infer I\n  } ? I\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    } ? I\n    : never\n  : never",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::Tables",
    "language": "typescript",
    "label": "Tables",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 212,
    "inDegree": 2,
    "outDegree": 3,
    "code": "type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (\n      & Database[PublicTableNameOrOptions['schema']]['Tables']\n      & Database[PublicTableNameOrOptions['schema']]['Views']\n    )\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database } ? (\n    & Database[PublicTableNameOrOptions['schema']]['Tables']\n    & Database[PublicTableNameOrOptions['schema']]['Views']\n  )[TableName] extends {\n    Row: infer R\n  } ? R\n  : never\n  : PublicTableNameOrOptions extends\n    keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    ? (PublicSchema['Tables'] & PublicSchema['Views'])[\n      PublicTableNameOrOptions\n    ] extends {\n      Row: infer R\n    } ? R\n    : never\n  : never",
    "importStatements": [],
    "codeNoBody": "type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (\n      & Database[PublicTableNameOrOptions['schema']]['Tables']\n      & Database[PublicTableNameOrOptions['schema']]['Views']\n    )\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database } ? (\n    & Database[PublicTableNameOrOptions['schema']]['Tables']\n    & Database[PublicTableNameOrOptions['schema']]['Views']\n  )[TableName] extends {\n    Row: infer R\n  } ? R\n  : never\n  : PublicTableNameOrOptions extends\n    keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    ? (PublicSchema['Tables'] & PublicSchema['Views'])[\n      PublicTableNameOrOptions\n    ] extends {\n      Row: infer R\n    } ? R\n    : never\n  : never",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::PublicSchema",
    "language": "typescript",
    "label": "PublicSchema",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 16,
    "inDegree": 6,
    "outDegree": 2,
    "code": "type PublicSchema = Database[Extract<keyof Database, 'public'>]",
    "importStatements": [],
    "codeNoBody": "type PublicSchema = Database[Extract<keyof Database, 'public'>]",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::Database",
    "language": "typescript",
    "label": "Database",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 27860,
    "inDegree": 16,
    "outDegree": 2,
    "code": "type Database = {\n  public: {\n    Tables: {\n      agent_categories: {\n        Row: {\n          description: string | null\n          id: string\n          name: string\n        }\n        Insert: {\n          description?: string | null\n          id?: string\n          name: string\n        }\n        Update: {\n          description?: string | null\n          id?: string\n          name?: string\n        }\n        Relationships: []\n      }\n      agent_templates: {\n        Row: {\n          agent_category_id: string\n          created_at: string\n          description: string | null\n          id: string\n          image: string | null\n          link: string | null\n          model: string\n          name: string\n          order: number | null\n          original_agent_id: string | null\n          prompt: string | null\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          type: string | null\n          user_id: string | null\n          welcome: string | null\n        }\n        Insert: {\n          agent_category_id: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Update: {\n          agent_category_id?: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agent_templates_agent_category_id_fkey'\n            columns: ['agent_category_id']\n            isOneToOne: false\n            referencedRelation: 'agent_categories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_original_agent_id_fkey'\n            columns: ['original_agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents: {\n        Row: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n        Insert: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Update: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id?: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_share_agent_type_id_fkey'\n            columns: ['share_agent_type_id']\n            isOneToOne: false\n            referencedRelation: 'share_agent_types'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_documents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          document_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          document_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          document_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_graphs: {\n        Row: {\n          agent_id: string\n          created_at: string\n          graph_id: string\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_graphs_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_graph_id_fkey'\n            columns: ['graph_id']\n            isOneToOne: false\n            referencedRelation: 'graphs'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_rating: {\n        Row: {\n          agent_id: string\n          created_at: string | null\n          rating: number\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string | null\n          rating: number\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string | null\n          rating?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_rating_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_rating_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_semantic_routes: {\n        Row: {\n          agent_id: string\n          created_at: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_routes_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_tags: {\n        Row: {\n          agent_id: string\n          tag_id: number\n        }\n        Insert: {\n          agent_id: string\n          tag_id: number\n        }\n        Update: {\n          agent_id?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_tags_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'agents_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agreements: {\n        Row: {\n          created_at: string\n          id: number\n          privacy: string\n          status: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          privacy: string\n          status?: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          privacy?: string\n          status?: Database['public']['Enums']['status']\n          tos?: string\n          version?: number\n        }\n        Relationships: []\n      }\n      agreements_users: {\n        Row: {\n          agreement_id: number\n          email_notifications: boolean\n          signed_at: string\n          user_id: string\n        }\n        Insert: {\n          agreement_id: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Update: {\n          agreement_id?: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agreements_users_agreement_id_fkey'\n            columns: ['agreement_id']\n            isOneToOne: false\n            referencedRelation: 'agreements'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agreements_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      api_keys: {\n        Row: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string | null\n          id?: string\n          key: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Update: {\n          created_at?: string | null\n          id?: string\n          key?: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'api_keys_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_connections: {\n        Row: {\n          app_id: number | null\n          created_at: string\n          id: string\n          org_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'apps_connections_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_tags: {\n        Row: {\n          app_id: number\n          created_at: string\n          tag_id: number\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          tag_id: number\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_apps_tags_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_apps_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      bitbucket_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_bitbucket_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log: {\n        Row: {\n          agent_documents_verification_time: number\n          agent_id: string | null\n          completion_tokens: number\n          created_at: string\n          embbedding_tokens: number\n          embedding_time: number\n          end_time: string | null\n          first_token_response_time: number\n          id: string\n          message_embedding: string | null\n          model: string\n          org_id: string\n          plan_agent_time: number\n          prompt_tokens: number\n          semantic_search_time: number\n          session_id: string | null\n          start_time: string | null\n          system_prompt: string\n          tags: string[] | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model: string\n          org_id: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model?: string\n          org_id?: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_chunks: {\n        Row: {\n          chat_log_id: string\n          chunk_id: string\n          created_at: string\n          id: number\n          score: number\n        }\n        Insert: {\n          chat_log_id: string\n          chunk_id: string\n          created_at?: string\n          id?: number\n          score: number\n        }\n        Update: {\n          chat_log_id?: string\n          chunk_id?: string\n          created_at?: string\n          id?: number\n          score?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chat_log_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_chunks_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_messages: {\n        Row: {\n          chat_log_id: string\n          content: string\n          created_at: string\n          id: number\n          role: Database['public']['Enums']['role']\n        }\n        Insert: {\n          chat_log_id: string\n          content: string\n          created_at?: string\n          id?: number\n          role: Database['public']['Enums']['role']\n        }\n        Update: {\n          chat_log_id?: string\n          content?: string\n          created_at?: string\n          id?: number\n          role?: Database['public']['Enums']['role']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_messages_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_cohere: {\n        Row: {\n          content: string\n          document_id: string\n          embedding: string\n          id: number\n          metadata: Json | null\n        }\n        Insert: {\n          content: string\n          document_id: string\n          embedding: string\n          id?: number\n          metadata?: Json | null\n        }\n        Update: {\n          content?: string\n          document_id?: string\n          embedding?: string\n          id?: number\n          metadata?: Json | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_cohere_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_llama: {\n        Row: {\n          created_at: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Insert: {\n          created_at?: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Update: {\n          created_at?: string | null\n          document_id?: string\n          id?: string\n          metadata?: Json\n          vec?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_llama_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_semantic_routes: {\n        Row: {\n          embedding: string | null\n          id: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_semantic_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      countries: {\n        Row: {\n          code: string\n          id: string\n          name: Json\n          tax_id: string | null\n        }\n        Insert: {\n          code: string\n          id?: string\n          name: Json\n          tax_id?: string | null\n        }\n        Update: {\n          code?: string\n          id?: string\n          name?: Json\n          tax_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: number\n          name: string | null\n          server_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_channels_server_id_fkey'\n            columns: ['server_id']\n            isOneToOne: false\n            referencedRelation: 'discord_servers'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      discord_servers: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_servers_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_servers_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents: {\n        Row: {\n          chunk_count: number | null\n          created_at: string\n          documents_folders_id: string | null\n          file_id: string | null\n          file_type: Database['public']['Enums']['file_type'] | null\n          id: string\n          is_frozen: boolean | null\n          metadata: Json | null\n          name: string\n          org_id: string | null\n          tokens: number | null\n          user_id: string\n        }\n        Insert: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Update: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name?: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_documents_folders_id_fkey'\n            columns: ['documents_folders_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents_folders: {\n        Row: {\n          created_at: string\n          folder_id: string | null\n          id: string\n          name: string\n          org_id: string\n        }\n        Insert: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name: string\n          org_id: string\n        }\n        Update: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_folders_folder_id_fkey'\n            columns: ['folder_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_folders_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      features: {\n        Row: {\n          agent_debugging: boolean | null\n          agent_faq: boolean | null\n          agent_skin: boolean | null\n          ai_prompt: boolean | null\n          create_marketplace: boolean | null\n          created_at: string\n          github_sync: boolean | null\n          id: string\n          scraping: boolean\n          user_id: string\n        }\n        Insert: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id: string\n        }\n        Update: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'features_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      github_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_github_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      gitlab_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          email: string | null\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_gitlab_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      graphs: {\n        Row: {\n          bitbucket_connection_id: string | null\n          created_at: string\n          github_connection_id: number | null\n          gitlab_connection_id: number | null\n          id: string\n          org_id: string | null\n          repo_id: string\n          status: string\n          user_id: string | null\n        }\n        Insert: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Update: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'graphs_bitbucket_connection_id_fkey'\n            columns: ['bitbucket_connection_id']\n            isOneToOne: false\n            referencedRelation: 'bitbucket_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_github_connection_id_fkey'\n            columns: ['github_connection_id']\n            isOneToOne: false\n            referencedRelation: 'github_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_gitlab_connection_id_fkey'\n            columns: ['gitlab_connection_id']\n            isOneToOne: false\n            referencedRelation: 'gitlab_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      ingestor_github_log: {\n        Row: {\n          created_at: string\n          database: string | null\n          document_id: string | null\n          final_size: number | null\n          id: number\n          register_id: string | null\n          repository: string | null\n          size: number | null\n          status: boolean | null\n          total_tokens: number | null\n          updated_at: string | null\n          user_created: string | null\n        }\n        Insert: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Update: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'ingestor_github_log_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      invoker_org_id: {\n        Row: {\n          org_sel_id: string | null\n        }\n        Insert: {\n          org_sel_id?: string | null\n        }\n        Update: {\n          org_sel_id?: string | null\n        }\n        Relationships: []\n      }\n      licenses: {\n        Row: {\n          active: boolean | null\n          created_at: string\n          id: string\n          org_id: string\n          quantity: number\n          sub_id: string\n        }\n        Insert: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id: string\n          quantity?: number\n          sub_id: string\n        }\n        Update: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id?: string\n          quantity?: number\n          sub_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'licenses_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'licenses_sub_id_fkey'\n            columns: ['sub_id']\n            isOneToOne: false\n            referencedRelation: 'subscriptions'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      links: {\n        Row: {\n          created_at: string\n          id: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          label?: string\n          node_source_id?: string\n          node_target_id?: string\n          repo_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'links_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          featured: boolean | null\n          org_id: string\n          product_details_id: number | null\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          featured?: boolean | null\n          org_id: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          featured?: boolean | null\n          org_id?: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: true\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents_favorites: {\n        Row: {\n          agent_id: string\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_favorites_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps: {\n        Row: {\n          created_at: string\n          featured: boolean | null\n          id: number\n          image: string | null\n          name: string\n          org_id: string\n          product_details_id: number | null\n          slug: string\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name: string\n          org_id: string\n          product_details_id?: number | null\n          slug: string\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name?: string\n          org_id?: string\n          product_details_id?: number | null\n          slug?: string\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps_favorites: {\n        Row: {\n          app_id: number\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      messages: {\n        Row: {\n          agent_id: string\n          content: string\n          created_at: string\n          id: string\n          role: Database['public']['Enums']['role']\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          content: string\n          created_at?: string\n          id?: string\n          role: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          content?: string\n          created_at?: string\n          id?: string\n          role?: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'messages_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'messages_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      models_pricing: {\n        Row: {\n          id: string\n          input: number\n          name: Database['public']['Enums']['models']\n          output: number\n          provider: string\n          updated_at: string\n        }\n        Insert: {\n          id?: string\n          input: number\n          name?: Database['public']['Enums']['models']\n          output: number\n          provider?: string\n          updated_at?: string\n        }\n        Update: {\n          id?: string\n          input?: number\n          name?: Database['public']['Enums']['models']\n          output?: number\n          provider?: string\n          updated_at?: string\n        }\n        Relationships: []\n      }\n      nodes: {\n        Row: {\n          code: string\n          code_no_body: string\n          created_at: string\n          documentation: string\n          full_name: string\n          id: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens: number\n          type: string\n        }\n        Insert: {\n          code: string\n          code_no_body: string\n          created_at?: string\n          documentation: string\n          full_name: string\n          id?: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens?: number\n          type: string\n        }\n        Update: {\n          code?: string\n          code_no_body?: string\n          created_at?: string\n          documentation?: string\n          full_name?: string\n          id?: string\n          in_degree?: number\n          label?: string\n          language?: string\n          out_degree?: number\n          repo_id?: string\n          total_tokens?: number\n          type?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_call: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_call_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_call_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_child: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_child_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_child_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_import_statement: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_import_statement_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_import_statement_node_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      notifications: {\n        Row: {\n          created_at: string\n          description: string | null\n          email: string | null\n          id: string\n          scope: string | null\n          status: string\n          title: string\n          type: string\n          updated_at: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title: string\n          type: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title?: string\n          type?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'notifications_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      onboarding: {\n        Row: {\n          created_at: string\n          invitation: boolean\n          org_id: string\n          org_img: boolean\n          org_personalization: boolean\n          user_img: boolean\n          user_personalization: boolean\n        }\n        Insert: {\n          created_at?: string\n          invitation?: boolean\n          org_id: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Update: {\n          created_at?: string\n          invitation?: boolean\n          org_id?: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'onboarding_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organization_user: {\n        Row: {\n          created_at: string\n          id: string\n          is_frozen: boolean\n          org_id: string | null\n          role: Database['public']['Enums']['org_role'] | null\n          status: Database['public']['Enums']['org_member_status']\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organization_user_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'organization_user_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organizations: {\n        Row: {\n          created_at: string\n          customer_id: string | null\n          daily_interactions: number\n          daily_tokens: number\n          daily_usage: number\n          id: string\n          image: string | null\n          name: string | null\n          status: Database['public']['Enums']['entity_status']\n          verified: boolean\n        }\n        Insert: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Update: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Relationships: []\n      }\n      organizations_billing: {\n        Row: {\n          billing_address: Json | null\n          created_at: string\n          id: string\n          org_id: string\n        }\n        Insert: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id: string\n        }\n        Update: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organizations_billing_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan: {\n        Row: {\n          agent_history_limit: number\n          allow_agent_chat_skins: boolean | null\n          allow_agent_share: boolean\n          allow_apikey_creation: boolean\n          allow_marketplace_publish: boolean\n          allow_premium_models: boolean\n          daily_completion_count: number\n          daily_max_tokens: number\n          daily_max_usage: number | null\n          description: string | null\n          files: number | null\n          id: string\n          max_agents: number | null\n          max_marketplace_agents: number\n          name: string\n          organization_member_limit: number\n          status: boolean | null\n          text_storage: number | null\n          trial_daily_interaction_limit: number\n          trial_period_days: number | null\n          vision: boolean | null\n        }\n        Insert: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Update: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name?: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Relationships: []\n      }\n      plan_features: {\n        Row: {\n          created_at: string\n          feature: string | null\n          id: string\n          locale: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Insert: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Update: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_features_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan_pricing: {\n        Row: {\n          active: boolean\n          amount: number\n          created_at: string\n          currency: string\n          id: string\n          interval: Database['public']['Enums']['billing_interval']\n          interval_count: number\n          plan_id: string\n          related_price: string | null\n          source: Database['public']['Enums']['plan_data_source']\n          type: Database['public']['Enums']['price_type']\n        }\n        Insert: {\n          active?: boolean\n          amount: number\n          created_at?: string\n          currency?: string\n          id: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Update: {\n          active?: boolean\n          amount?: number\n          created_at?: string\n          currency?: string\n          id?: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id?: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_pricing_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      product_details: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          tagline: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Relationships: []\n      }\n      profiles: {\n        Row: {\n          avatar_url: string | null\n          distinct_id: string\n          full_name: string | null\n          id: string\n          org_sel_id: string | null\n          signup: boolean\n          status: Database['public']['Enums']['entity_status']\n          updated_at: string | null\n          username: string | null\n        }\n        Insert: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Update: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id?: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'profiles_org_sel_id_fkey'\n            columns: ['org_sel_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      questions: {\n        Row: {\n          created_at: string | null\n          description: string | null\n          id: number\n          survey_id: number\n          title: string\n          type: Database['public']['Enums']['question_type']\n        }\n        Insert: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id: number\n          title: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Update: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id?: number\n          title?: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'questions_survey_id_fkey'\n            columns: ['survey_id']\n            isOneToOne: false\n            referencedRelation: 'surveys'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals: {\n        Row: {\n          code: string\n          created_at: string\n          id: number\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          code: string\n          created_at?: string\n          id?: number\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          code?: string\n          created_at?: string\n          id?: number\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_claims: {\n        Row: {\n          created_at: string\n          end_date: string\n          id: number\n          org_id: string\n          plan_id: string\n          referral_id: number | null\n          start_date: string\n        }\n        Insert: {\n          created_at?: string\n          end_date: string\n          id?: number\n          org_id: string\n          plan_id: string\n          referral_id?: number | null\n          start_date: string\n        }\n        Update: {\n          created_at?: string\n          end_date?: string\n          id?: number\n          org_id?: string\n          plan_id?: string\n          referral_id?: number | null\n          start_date?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_claims_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_users: {\n        Row: {\n          created_at: string\n          id: number\n          redeemed: boolean\n          referral_id: number\n          subscribed_at: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id: number\n          subscribed_at?: string | null\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id?: number\n          subscribed_at?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_users_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      repositories: {\n        Row: {\n          branch: string\n          commit_hash: string | null\n          created_at: string\n          git_provider: Database['public']['Enums']['git_provider']\n          gitlab_repo_id: number | null\n          id: string\n          repo_name: string\n          repo_org: string\n        }\n        Insert: {\n          branch: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name: string\n          repo_org: string\n        }\n        Update: {\n          branch?: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name?: string\n          repo_org?: string\n        }\n        Relationships: []\n      }\n      responses: {\n        Row: {\n          created_at: string\n          id: number\n          question_id: number\n          response: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          question_id: number\n          response: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          question_id?: number\n          response?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'responses_question_id_fkey'\n            columns: ['question_id']\n            isOneToOne: false\n            referencedRelation: 'questions'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'responses_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes: {\n        Row: {\n          created_at: string\n          id: string\n          name: string\n          org_id: string\n          response: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          name: string\n          org_id: string\n          response: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          name?: string\n          org_id?: string\n          response?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes_words: {\n        Row: {\n          created_at: string\n          id: number\n          org_id: string\n          semantic_routes_id: string\n          user_id: string | null\n          word: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          org_id: string\n          semantic_routes_id: string\n          user_id?: string | null\n          word: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          org_id?: string\n          semantic_routes_id?: string\n          user_id?: string | null\n          word?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_words_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      share_agent_types: {\n        Row: {\n          id: number\n          name: string | null\n        }\n        Insert: {\n          id?: number\n          name?: string | null\n        }\n        Update: {\n          id?: number\n          name?: string | null\n        }\n        Relationships: []\n      }\n      slack_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          workspace_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_channels_workspace_id_fkey'\n            columns: ['workspace_id']\n            isOneToOne: false\n            referencedRelation: 'slack_workspaces'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      slack_workspaces: {\n        Row: {\n          access_token: string | null\n          agent_id: string | null\n          agent_settings: number | null\n          bot_user_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_workspaces_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_workspaces_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      subscriptions: {\n        Row: {\n          begin_date: string\n          cancel_at_period_end: boolean\n          canceled_at: string | null\n          created_at: string\n          finish_date: string | null\n          id: string\n          last_payment_id: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end: string | null\n        }\n        Insert: {\n          begin_date: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Update: {\n          begin_date?: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id?: string\n          plan_id?: string\n          status?: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'subscriptions_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'subscriptions_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      surveys: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          status: boolean\n          title: string\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title: string\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title?: string\n        }\n        Relationships: []\n      }\n      tags: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n        }\n        Relationships: []\n      }\n      teams_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'teams_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'teams_channels_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      threads: {\n        Row: {\n          created_at: string\n          id: string\n          public: boolean | null\n          status: string | null\n          updated_at: string | null\n          user_created: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'threads_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage: {\n        Row: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          channel: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model: string\n          org_id?: string | null\n          plan_name: string\n          prompt_token?: number\n          session_id?: string | null\n          source: string\n          start_date?: string\n          type: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          channel?: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model?: string\n          org_id?: string | null\n          plan_name?: string\n          prompt_token?: number\n          session_id?: string | null\n          source?: string\n          start_date?: string\n          type?: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      usage_chunks: {\n        Row: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Insert: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Update: {\n          chunk_id?: string\n          score?: number\n          usage_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_chunks_usage_id_fkey'\n            columns: ['usage_id']\n            isOneToOne: false\n            referencedRelation: 'usage_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage_log: {\n        Row: {\n          agent_id: string | null\n          child_run_ids: Json | null\n          completion_token: number | null\n          created_at: string\n          doted_order: string | null\n          end_time: string | null\n          error: Json | null\n          extra: Json | null\n          id: string\n          inputs: Json | null\n          manifest_id: Json | null\n          message_embedding: string | null\n          name: string | null\n          outputs: Json | null\n          parent_run_ids: Json | null\n          prompt_token: number | null\n          run_type: string | null\n          session_id: string | null\n          start_time: string | null\n          status: string | null\n          tags: Json | null\n          total_tokens: number | null\n          trace_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user: {\n        Row: {\n          account_deletion_request: string | null\n          auth_data: string | null\n          avatar: string | null\n          avatar_url: string | null\n          azure_authTag: string | null\n          azure_iv: string | null\n          azureapikey: string | null\n          azureembedding: string | null\n          azureurl: string | null\n          billingData: Json | null\n          bot: Json | null\n          completionCount: Json | null\n          convertapi: string | null\n          created_at: string | null\n          date_created: string | null\n          description: string | null\n          email: string\n          email_notifications: boolean | null\n          emailNotifications: boolean | null\n          external_identifier: string | null\n          first_name: string | null\n          githubId: number | null\n          githubUser: string | null\n          gravatar_id: string | null\n          id: string\n          indexname: string | null\n          isFree: boolean | null\n          isTester: boolean | null\n          langsmith_langchain_api_key: string | null\n          langsmith_langchain_endpoint: string | null\n          langsmith_langchain_project: string | null\n          language: string | null\n          last_access: string | null\n          last_name: string | null\n          last_page: string | null\n          location: string | null\n          namespace: string | null\n          openai_authTag: string | null\n          openai_iv: string | null\n          openaiapikey: string | null\n          openaiorganization: string | null\n          password: string | null\n          pinecone_authTag: string | null\n          pinecone_iv: string | null\n          pineconeenv: string | null\n          pineconekey: string | null\n          plan_id: string | null\n          plan_name: string | null\n          provider: string | null\n          referred_by: string | null\n          role: string | null\n          searchbyuser: string | null\n          status: string | null\n          tags: string | null\n          tasks: Json | null\n          tfa_secret: string | null\n          theme: string | null\n          title: string | null\n          token: string | null\n          username: string | null\n        }\n        Insert: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Update: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email?: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id?: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user_profilings: {\n        Row: {\n          created_at: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          industry_profile?: string\n          organization?: string\n          profile?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_profilings_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widget_domains: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n          widget_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n          widget_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n          widget_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widget_domains_widget_id_fkey'\n            columns: ['widget_id']\n            isOneToOne: false\n            referencedRelation: 'widgets'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widgets: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          enabled: boolean\n          id: string\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id: string\n          user_id: string\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widgets_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n    }\n    Views: {\n      chat_log_model_summary_30: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_60: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_7: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_90: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      accept_invitation: {\n        Args: {\n          notification_id: string\n        }\n        Returns: boolean\n      }\n      add_user_to_organization: {\n        Args: {\n          target_email: string\n        }\n        Returns: boolean\n      }\n      admin_cancel_deletion: {\n        Args: {\n          marked_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_delete_user: {\n        Args: {\n          param_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_get_latest_subscription_by_org_id: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          id: string\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n          last_payment_id: string\n          org_id: string\n          trial_end: string\n          cancel_at_period_end: boolean\n          canceled_at: string\n          plan_id: string\n        }[]\n      }\n      admin_get_marketplace_agents: {\n        Args: {\n          page?: number\n          row_count?: number\n          sort_by?: string\n        }\n        Returns:\n          Database['public']['CompositeTypes']['marketplace_agents_result']\n      }\n      admin_get_organization_data: {\n        Args: {\n          user_email: string\n          orgid: string\n        }\n        Returns: {\n          organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n        }[]\n      }\n      admin_get_organization_owner_data: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          user_id: string\n          email: string\n        }[]\n      }\n      admin_get_recent_user_ip: {\n        Args: {\n          user_id: string\n        }\n        Returns: string\n      }\n      admin_search_users_by_email_or_userid: {\n        Args: {\n          search?: string\n          userid?: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      admin_search_users_by_email_or_userid_test: {\n        Args: {\n          search?: string\n          userid?: string\n          page?: number\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n          total_records: number\n          total_pages: number\n        }[]\n      }\n      admin_search_users_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      append_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_tier_subscription: {\n        Args: {\n          param_customer_id?: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_trial: {\n        Args: {\n          param_customer_id: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_non_stripe_subscription:\n        | {\n          Args: {\n            param_customer_id: string\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n        | {\n          Args: {\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n      change_organization_image: {\n        Args: {\n          orgid: string\n          image_url: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_agent_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_document_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_email_registered: {\n        Args: {\n          email: string\n        }\n        Returns: boolean\n      }\n      create_agent: {\n        Args: {\n          template_id?: string\n          custom_name?: string\n          custom_prompt?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n      }\n      create_apikey: {\n        Args: {\n          apikey_name: string\n        }\n        Returns: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n      }\n      create_documents_folder: {\n        Args: {\n          name: string\n          parent_folder_id?: string\n        }\n        Returns: undefined\n      }\n      delete_agent_by_agent_id_and_org_id_and_user_id: {\n        Args: {\n          agentid: string\n          orgid: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n        }[]\n      }\n      delete_marked_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_marketplace_agent: {\n        Args: {\n          agentid: string\n        }\n        Returns: undefined\n      }\n      delete_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_user_from_org: {\n        Args: {\n          ou_id_to_delete: string\n        }\n        Returns: boolean\n      }\n      deselect_organization_for_frozen_members: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: undefined\n      }\n      generate_agent_slug: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_active_organization_subscription: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_organization_subscription_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_plans_with_pricing: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_active_plans_with_pricing_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_agent_and_selected_documents:\n        | {\n          Args: {\n            agentid: string\n            orgid: string\n            apikey?: string\n            userid?: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n        | {\n          Args: {\n            apikey: string\n            orgid: string\n            agentid: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n      get_agent_by_id_chat: {\n        Args: {\n          agentid: string\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          model: string\n          name: string\n          temperature: number\n          prompt: string\n          plan_name: string\n          daily_completion_count: number\n          user_id: string\n          user_email: string\n        }[]\n      }\n      get_agent_with_documents: {\n        Args: {\n          agentid: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          share_agent_type_id: number\n          selecteddocuments: Json\n          is_marketplace: boolean\n          tagline: string\n          description: string\n          tags: string[]\n        }[]\n      }\n      get_agent_with_documents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n          agent_documents: Json\n        }[]\n      }\n      get_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          slug: string\n          is_frozen: boolean\n          memory: number\n          is_marketplace: boolean\n        }[]\n      }\n      get_agents_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n          agentid?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }[]\n      }\n      get_agents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n        }[]\n      }\n      get_auth_credentials: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          inputuserid?: string\n        }\n        Returns: {\n          org_id: string\n          user_id: string\n        }[]\n      }\n      get_chunks: {\n        Args: {\n          org_id_in: string\n          api_key_in: string\n          user_id_in: string\n          searchquery: string\n          agentid: string\n        }\n        Returns: Json\n      }\n      get_colleagues: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_colleagues_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n          status: Database['public']['Enums']['org_member_status']\n        }[]\n      }\n      get_crew_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          slug: string\n          image: string\n          description: string\n          tagline: string\n          tags: string[]\n        }[]\n      }\n      get_current_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          sel_org_id: string\n          daily_interactions: number\n          plan: Json\n        }[]\n      }\n      get_documents_from_api: {\n        Args: {\n          apikey?: string\n          userid?: string\n          orgid?: string\n          documentid?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_email_by_user_id: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          email: string\n        }[]\n      }\n      get_last_user_session_ip: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          ip: string\n        }[]\n      }\n      get_latest_plan_by_customer_id: {\n        Args: {\n          customer_id_param: string\n        }\n        Returns: {\n          org_id: string\n          id: string\n          name: string\n          status: Database['public']['Enums']['subscription_status']\n          description: string\n          files: number\n          max_agents: number\n          max_marketplace_agents: number\n          organization_member_limit: number\n        }[]\n      }\n      get_limits_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n        }[]\n      }\n      get_marketplace_agent_as_anonymous: {\n        Args: {\n          agentid: string\n          secret_key?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          is_frozen: boolean\n          prompt: string\n          org_id: string\n          memory: number\n        }[]\n      }\n      get_marketplace_agent_by_slug: {\n        Args: {\n          agent_slug: string\n        }\n        Returns: {\n          id: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          organization_image: string\n          organization_name: string\n          total_favorite_users: number\n          tags: string[]\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          user_rating: number\n        }[]\n      }\n      get_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_testo: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorite_agent_by_id: {\n        Args: {\n          agentid: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          memory: number\n          is_frozen: boolean\n          prompt: string\n          original_org_id: string\n          org_id: string\n          is_installed: boolean\n        }[]\n      }\n      get_marketplace_favorites_agents: {\n        Args: {\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorites_agents_by_org_id_and_api_key_or_user_: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_organization_owner_email: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          email: string\n        }[]\n      }\n      get_owned_organization_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          owned_org_id: string\n          daily_interactions: number\n          email: string\n          plan: Json\n        }[]\n      }\n      get_personal_organization: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          user_id: string\n          id: string\n          customer_id: string\n          name: string\n          created_at: string\n          image: string\n          daily_interactions: number\n          status: Database['public']['Enums']['entity_status']\n        }[]\n      }\n      get_plan_limits: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n          id: string\n          daily_max_tokens: number\n          daily_tokens: number\n          daily_max_usage: number\n          daily_usage: number\n          vision: boolean\n          user_org_id: string\n          plan_user_id: string\n          daily_interactions: number\n          user_email: string\n          distinct_id: string\n        }[]\n      }\n      get_plan_name_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: string\n      }\n      get_plan_trial_days_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: number\n      }\n      get_refresh_tokens: {\n        Args: Record<PropertyKey, never>\n        Returns: unknown[]\n      }\n      get_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }[]\n      }\n      get_user_data_by_api_key_or_user_id: {\n        Args: {\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n          organizations: Json\n        }[]\n      }\n      get_user_profile: {\n        Args: {\n          user_id_param?: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_by_email: {\n        Args: {\n          user_email: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      has_had_free_trial: {\n        Args: {\n          user_id_param?: string\n          org_id_param?: string\n        }\n        Returns: boolean\n      }\n      insert_tags_and_associate_with_agent: {\n        Args: {\n          tag_names: string[]\n          agentid: string\n        }\n        Returns: undefined\n      }\n      is_owner_or_admin: {\n        Args: {\n          orgid: string\n        }\n        Returns: boolean\n      }\n      mark_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      match_agent_chunks: {\n        Args: {\n          embedding_input: string\n          match_threshold: number\n          match_count: number\n          min_content_length: number\n          agent_id_input: string\n        }\n        Returns: {\n          id: string\n          document_name: string\n          content: string\n          similarity: number\n        }[]\n      }\n      match_agent_semantic_routes: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          semantic_routes_id: string\n          response: string\n          name: string\n          similarity: number\n        }[]\n      }\n      match_documents: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          content: string\n          metadata: Json\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_cohere: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n        }\n        Returns: {\n          id: number\n          metadata: Json\n          content: string\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_llama: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          similarity: number\n        }[]\n      }\n      match_documents_llama_v2: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          document_metadata: Json\n          document_tokens: number\n          similarity: number\n        }[]\n      }\n      rename_organization: {\n        Args: {\n          new_name: string\n        }\n        Returns: boolean\n      }\n      reset_daily_interactions: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      set_agent_documents: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n        }\n        Returns: undefined\n      }\n      set_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      update_agent_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey: string\n          userid: string\n          agentid: string\n          agent: Json\n        }\n        Returns: {\n          id: string\n          name: string\n          model: string\n          temperature: number\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          image: string\n        }[]\n      }\n      update_daily_usage: {\n        Args: {\n          orgid: string\n          inputtokens: number\n          outputtokens: number\n          model: Database['public']['Enums']['models']\n        }\n        Returns: undefined\n      }\n      update_document_metada_from_api: {\n        Args: {\n          documentid: string\n          metadata_param: Json\n          apikey?: string\n          userid?: string\n          orgid?: string\n        }\n        Returns: undefined\n      }\n      update_subscriptions_status: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      update_user_data_by_api_key_or_user_id: {\n        Args: {\n          user_data: Json\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n        }[]\n      }\n      update_user_role: {\n        Args: {\n          ou_id: string\n          new_role: string\n        }\n        Returns: boolean\n      }\n      upsert_product_details: {\n        Args: {\n          v_agent_id: string\n          v_tagline: string\n          v_description: string\n        }\n        Returns: undefined\n      }\n      validate_document_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n        }[]\n      }\n      validate_document_ownership_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          file_id: string\n        }[]\n      }\n      validate_max_agents: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: Json\n      }\n    }\n    Enums: {\n      agent_type: 'qa' | 'other' | 'repository'\n      billing_interval: 'day' | 'week' | 'month' | 'year'\n      entity_status: 'active' | 'deleted'\n      file_type: 'text' | 'table' | 'repository'\n      git_provider: 'github' | 'gitlab' | 'bitbucket'\n      locale: 'es' | 'en'\n      models:\n        | 'gpt-4-turbo'\n        | 'gpt-4'\n        | 'gpt-4-vision'\n        | 'gpt-3.5-turbo-16k'\n        | 'gpt-3.5-turbo'\n        | 'claude-2.1'\n        | 'claude-instant-1.2'\n        | 'gemini-1.0-pro'\n        | 'text-embedding-ada-002'\n        | 'claude-3-sonnet'\n        | 'claude-3-haiku'\n        | 'command-r-plus'\n        | 'llama3-70b-8192'\n        | 'gemini-1.5-pro-latest'\n        | 'llama3-70b'\n        | 'gemini-1.5-flash'\n        | 'gpt-4o'\n        | 'codestral'\n        | 'claude-3.5-sonnet'\n      org_member_status: 'active' | 'pending' | 'invited' | 'frozen'\n      org_role: 'owner' | 'admin' | 'moderator' | 'member'\n      plan_data_source: 'stripe' | 'manual'\n      price_type: 'recurring' | 'one_time'\n      question_type: 'score' | 'comment' | 'like'\n      role: 'function' | 'system' | 'user' | 'assistant'\n      status: 'published' | 'draft'\n      subscription_status:\n        | 'active'\n        | 'past_due'\n        | 'unpaid'\n        | 'canceled'\n        | 'incomplete'\n        | 'incomplete_expired'\n        | 'trialing'\n        | 'paused'\n        | 'free_trial'\n      usage_type: 'TRAINING' | 'SEMANTIC_SEARCH' | 'CHAT' | 'FUNCTION'\n    }\n    CompositeTypes: {\n      agent_data: {\n        agent: unknown\n        agent_selected_documents:\n          | Database['public']['Tables']['agents_documents']['Row'][]\n          | null\n        documents: Database['public']['Tables']['documents']['Row'][] | null\n        messages: Database['public']['Tables']['messages']['Row'][] | null\n      }\n      get_chunks_result: {\n        constant_data: Json | null\n        matching_documents: Json[] | null\n      }\n      marketplace_agent_data: {\n        id: string | null\n        name: string | null\n        image: string | null\n        slug: string | null\n        welcome: string | null\n        description: string | null\n        agent_install_count: number | null\n        agent_message_count: number | null\n      }\n      marketplace_agents_result: {\n        total: number | null\n        total_installations: number | null\n        total_messages: number | null\n        agents_data:\n          | Database['public']['CompositeTypes']['marketplace_agent_data'][]\n          | null\n      }\n    }\n  }\n}",
    "importStatements": [],
    "codeNoBody": "type Database = {\n  public: {\n    Tables: {\n      agent_categories: {\n        Row: {\n          description: string | null\n          id: string\n          name: string\n        }\n        Insert: {\n          description?: string | null\n          id?: string\n          name: string\n        }\n        Update: {\n          description?: string | null\n          id?: string\n          name?: string\n        }\n        Relationships: []\n      }\n      agent_templates: {\n        Row: {\n          agent_category_id: string\n          created_at: string\n          description: string | null\n          id: string\n          image: string | null\n          link: string | null\n          model: string\n          name: string\n          order: number | null\n          original_agent_id: string | null\n          prompt: string | null\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          type: string | null\n          user_id: string | null\n          welcome: string | null\n        }\n        Insert: {\n          agent_category_id: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Update: {\n          agent_category_id?: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agent_templates_agent_category_id_fkey'\n            columns: ['agent_category_id']\n            isOneToOne: false\n            referencedRelation: 'agent_categories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_original_agent_id_fkey'\n            columns: ['original_agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents: {\n        Row: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n        Insert: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Update: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id?: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_share_agent_type_id_fkey'\n            columns: ['share_agent_type_id']\n            isOneToOne: false\n            referencedRelation: 'share_agent_types'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_documents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          document_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          document_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          document_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_graphs: {\n        Row: {\n          agent_id: string\n          created_at: string\n          graph_id: string\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_graphs_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_graph_id_fkey'\n            columns: ['graph_id']\n            isOneToOne: false\n            referencedRelation: 'graphs'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_rating: {\n        Row: {\n          agent_id: string\n          created_at: string | null\n          rating: number\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string | null\n          rating: number\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string | null\n          rating?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_rating_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_rating_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_semantic_routes: {\n        Row: {\n          agent_id: string\n          created_at: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_routes_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_tags: {\n        Row: {\n          agent_id: string\n          tag_id: number\n        }\n        Insert: {\n          agent_id: string\n          tag_id: number\n        }\n        Update: {\n          agent_id?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_tags_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'agents_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agreements: {\n        Row: {\n          created_at: string\n          id: number\n          privacy: string\n          status: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          privacy: string\n          status?: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          privacy?: string\n          status?: Database['public']['Enums']['status']\n          tos?: string\n          version?: number\n        }\n        Relationships: []\n      }\n      agreements_users: {\n        Row: {\n          agreement_id: number\n          email_notifications: boolean\n          signed_at: string\n          user_id: string\n        }\n        Insert: {\n          agreement_id: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Update: {\n          agreement_id?: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agreements_users_agreement_id_fkey'\n            columns: ['agreement_id']\n            isOneToOne: false\n            referencedRelation: 'agreements'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agreements_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      api_keys: {\n        Row: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string | null\n          id?: string\n          key: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Update: {\n          created_at?: string | null\n          id?: string\n          key?: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'api_keys_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_connections: {\n        Row: {\n          app_id: number | null\n          created_at: string\n          id: string\n          org_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'apps_connections_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_tags: {\n        Row: {\n          app_id: number\n          created_at: string\n          tag_id: number\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          tag_id: number\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_apps_tags_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_apps_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      bitbucket_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_bitbucket_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log: {\n        Row: {\n          agent_documents_verification_time: number\n          agent_id: string | null\n          completion_tokens: number\n          created_at: string\n          embbedding_tokens: number\n          embedding_time: number\n          end_time: string | null\n          first_token_response_time: number\n          id: string\n          message_embedding: string | null\n          model: string\n          org_id: string\n          plan_agent_time: number\n          prompt_tokens: number\n          semantic_search_time: number\n          session_id: string | null\n          start_time: string | null\n          system_prompt: string\n          tags: string[] | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model: string\n          org_id: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model?: string\n          org_id?: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_chunks: {\n        Row: {\n          chat_log_id: string\n          chunk_id: string\n          created_at: string\n          id: number\n          score: number\n        }\n        Insert: {\n          chat_log_id: string\n          chunk_id: string\n          created_at?: string\n          id?: number\n          score: number\n        }\n        Update: {\n          chat_log_id?: string\n          chunk_id?: string\n          created_at?: string\n          id?: number\n          score?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chat_log_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_chunks_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_messages: {\n        Row: {\n          chat_log_id: string\n          content: string\n          created_at: string\n          id: number\n          role: Database['public']['Enums']['role']\n        }\n        Insert: {\n          chat_log_id: string\n          content: string\n          created_at?: string\n          id?: number\n          role: Database['public']['Enums']['role']\n        }\n        Update: {\n          chat_log_id?: string\n          content?: string\n          created_at?: string\n          id?: number\n          role?: Database['public']['Enums']['role']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_messages_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_cohere: {\n        Row: {\n          content: string\n          document_id: string\n          embedding: string\n          id: number\n          metadata: Json | null\n        }\n        Insert: {\n          content: string\n          document_id: string\n          embedding: string\n          id?: number\n          metadata?: Json | null\n        }\n        Update: {\n          content?: string\n          document_id?: string\n          embedding?: string\n          id?: number\n          metadata?: Json | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_cohere_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_llama: {\n        Row: {\n          created_at: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Insert: {\n          created_at?: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Update: {\n          created_at?: string | null\n          document_id?: string\n          id?: string\n          metadata?: Json\n          vec?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_llama_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_semantic_routes: {\n        Row: {\n          embedding: string | null\n          id: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_semantic_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      countries: {\n        Row: {\n          code: string\n          id: string\n          name: Json\n          tax_id: string | null\n        }\n        Insert: {\n          code: string\n          id?: string\n          name: Json\n          tax_id?: string | null\n        }\n        Update: {\n          code?: string\n          id?: string\n          name?: Json\n          tax_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: number\n          name: string | null\n          server_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_channels_server_id_fkey'\n            columns: ['server_id']\n            isOneToOne: false\n            referencedRelation: 'discord_servers'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      discord_servers: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_servers_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_servers_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents: {\n        Row: {\n          chunk_count: number | null\n          created_at: string\n          documents_folders_id: string | null\n          file_id: string | null\n          file_type: Database['public']['Enums']['file_type'] | null\n          id: string\n          is_frozen: boolean | null\n          metadata: Json | null\n          name: string\n          org_id: string | null\n          tokens: number | null\n          user_id: string\n        }\n        Insert: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Update: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name?: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_documents_folders_id_fkey'\n            columns: ['documents_folders_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents_folders: {\n        Row: {\n          created_at: string\n          folder_id: string | null\n          id: string\n          name: string\n          org_id: string\n        }\n        Insert: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name: string\n          org_id: string\n        }\n        Update: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_folders_folder_id_fkey'\n            columns: ['folder_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_folders_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      features: {\n        Row: {\n          agent_debugging: boolean | null\n          agent_faq: boolean | null\n          agent_skin: boolean | null\n          ai_prompt: boolean | null\n          create_marketplace: boolean | null\n          created_at: string\n          github_sync: boolean | null\n          id: string\n          scraping: boolean\n          user_id: string\n        }\n        Insert: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id: string\n        }\n        Update: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'features_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      github_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_github_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      gitlab_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          email: string | null\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_gitlab_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      graphs: {\n        Row: {\n          bitbucket_connection_id: string | null\n          created_at: string\n          github_connection_id: number | null\n          gitlab_connection_id: number | null\n          id: string\n          org_id: string | null\n          repo_id: string\n          status: string\n          user_id: string | null\n        }\n        Insert: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Update: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'graphs_bitbucket_connection_id_fkey'\n            columns: ['bitbucket_connection_id']\n            isOneToOne: false\n            referencedRelation: 'bitbucket_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_github_connection_id_fkey'\n            columns: ['github_connection_id']\n            isOneToOne: false\n            referencedRelation: 'github_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_gitlab_connection_id_fkey'\n            columns: ['gitlab_connection_id']\n            isOneToOne: false\n            referencedRelation: 'gitlab_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      ingestor_github_log: {\n        Row: {\n          created_at: string\n          database: string | null\n          document_id: string | null\n          final_size: number | null\n          id: number\n          register_id: string | null\n          repository: string | null\n          size: number | null\n          status: boolean | null\n          total_tokens: number | null\n          updated_at: string | null\n          user_created: string | null\n        }\n        Insert: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Update: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'ingestor_github_log_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      invoker_org_id: {\n        Row: {\n          org_sel_id: string | null\n        }\n        Insert: {\n          org_sel_id?: string | null\n        }\n        Update: {\n          org_sel_id?: string | null\n        }\n        Relationships: []\n      }\n      licenses: {\n        Row: {\n          active: boolean | null\n          created_at: string\n          id: string\n          org_id: string\n          quantity: number\n          sub_id: string\n        }\n        Insert: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id: string\n          quantity?: number\n          sub_id: string\n        }\n        Update: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id?: string\n          quantity?: number\n          sub_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'licenses_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'licenses_sub_id_fkey'\n            columns: ['sub_id']\n            isOneToOne: false\n            referencedRelation: 'subscriptions'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      links: {\n        Row: {\n          created_at: string\n          id: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          label?: string\n          node_source_id?: string\n          node_target_id?: string\n          repo_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'links_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          featured: boolean | null\n          org_id: string\n          product_details_id: number | null\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          featured?: boolean | null\n          org_id: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          featured?: boolean | null\n          org_id?: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: true\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents_favorites: {\n        Row: {\n          agent_id: string\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_favorites_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps: {\n        Row: {\n          created_at: string\n          featured: boolean | null\n          id: number\n          image: string | null\n          name: string\n          org_id: string\n          product_details_id: number | null\n          slug: string\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name: string\n          org_id: string\n          product_details_id?: number | null\n          slug: string\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name?: string\n          org_id?: string\n          product_details_id?: number | null\n          slug?: string\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps_favorites: {\n        Row: {\n          app_id: number\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      messages: {\n        Row: {\n          agent_id: string\n          content: string\n          created_at: string\n          id: string\n          role: Database['public']['Enums']['role']\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          content: string\n          created_at?: string\n          id?: string\n          role: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          content?: string\n          created_at?: string\n          id?: string\n          role?: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'messages_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'messages_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      models_pricing: {\n        Row: {\n          id: string\n          input: number\n          name: Database['public']['Enums']['models']\n          output: number\n          provider: string\n          updated_at: string\n        }\n        Insert: {\n          id?: string\n          input: number\n          name?: Database['public']['Enums']['models']\n          output: number\n          provider?: string\n          updated_at?: string\n        }\n        Update: {\n          id?: string\n          input?: number\n          name?: Database['public']['Enums']['models']\n          output?: number\n          provider?: string\n          updated_at?: string\n        }\n        Relationships: []\n      }\n      nodes: {\n        Row: {\n          code: string\n          code_no_body: string\n          created_at: string\n          documentation: string\n          full_name: string\n          id: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens: number\n          type: string\n        }\n        Insert: {\n          code: string\n          code_no_body: string\n          created_at?: string\n          documentation: string\n          full_name: string\n          id?: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens?: number\n          type: string\n        }\n        Update: {\n          code?: string\n          code_no_body?: string\n          created_at?: string\n          documentation?: string\n          full_name?: string\n          id?: string\n          in_degree?: number\n          label?: string\n          language?: string\n          out_degree?: number\n          repo_id?: string\n          total_tokens?: number\n          type?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_call: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_call_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_call_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_child: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_child_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_child_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_import_statement: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_import_statement_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_import_statement_node_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      notifications: {\n        Row: {\n          created_at: string\n          description: string | null\n          email: string | null\n          id: string\n          scope: string | null\n          status: string\n          title: string\n          type: string\n          updated_at: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title: string\n          type: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title?: string\n          type?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'notifications_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      onboarding: {\n        Row: {\n          created_at: string\n          invitation: boolean\n          org_id: string\n          org_img: boolean\n          org_personalization: boolean\n          user_img: boolean\n          user_personalization: boolean\n        }\n        Insert: {\n          created_at?: string\n          invitation?: boolean\n          org_id: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Update: {\n          created_at?: string\n          invitation?: boolean\n          org_id?: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'onboarding_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organization_user: {\n        Row: {\n          created_at: string\n          id: string\n          is_frozen: boolean\n          org_id: string | null\n          role: Database['public']['Enums']['org_role'] | null\n          status: Database['public']['Enums']['org_member_status']\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organization_user_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'organization_user_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organizations: {\n        Row: {\n          created_at: string\n          customer_id: string | null\n          daily_interactions: number\n          daily_tokens: number\n          daily_usage: number\n          id: string\n          image: string | null\n          name: string | null\n          status: Database['public']['Enums']['entity_status']\n          verified: boolean\n        }\n        Insert: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Update: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Relationships: []\n      }\n      organizations_billing: {\n        Row: {\n          billing_address: Json | null\n          created_at: string\n          id: string\n          org_id: string\n        }\n        Insert: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id: string\n        }\n        Update: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organizations_billing_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan: {\n        Row: {\n          agent_history_limit: number\n          allow_agent_chat_skins: boolean | null\n          allow_agent_share: boolean\n          allow_apikey_creation: boolean\n          allow_marketplace_publish: boolean\n          allow_premium_models: boolean\n          daily_completion_count: number\n          daily_max_tokens: number\n          daily_max_usage: number | null\n          description: string | null\n          files: number | null\n          id: string\n          max_agents: number | null\n          max_marketplace_agents: number\n          name: string\n          organization_member_limit: number\n          status: boolean | null\n          text_storage: number | null\n          trial_daily_interaction_limit: number\n          trial_period_days: number | null\n          vision: boolean | null\n        }\n        Insert: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Update: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name?: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Relationships: []\n      }\n      plan_features: {\n        Row: {\n          created_at: string\n          feature: string | null\n          id: string\n          locale: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Insert: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Update: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_features_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan_pricing: {\n        Row: {\n          active: boolean\n          amount: number\n          created_at: string\n          currency: string\n          id: string\n          interval: Database['public']['Enums']['billing_interval']\n          interval_count: number\n          plan_id: string\n          related_price: string | null\n          source: Database['public']['Enums']['plan_data_source']\n          type: Database['public']['Enums']['price_type']\n        }\n        Insert: {\n          active?: boolean\n          amount: number\n          created_at?: string\n          currency?: string\n          id: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Update: {\n          active?: boolean\n          amount?: number\n          created_at?: string\n          currency?: string\n          id?: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id?: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_pricing_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      product_details: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          tagline: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Relationships: []\n      }\n      profiles: {\n        Row: {\n          avatar_url: string | null\n          distinct_id: string\n          full_name: string | null\n          id: string\n          org_sel_id: string | null\n          signup: boolean\n          status: Database['public']['Enums']['entity_status']\n          updated_at: string | null\n          username: string | null\n        }\n        Insert: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Update: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id?: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'profiles_org_sel_id_fkey'\n            columns: ['org_sel_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      questions: {\n        Row: {\n          created_at: string | null\n          description: string | null\n          id: number\n          survey_id: number\n          title: string\n          type: Database['public']['Enums']['question_type']\n        }\n        Insert: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id: number\n          title: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Update: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id?: number\n          title?: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'questions_survey_id_fkey'\n            columns: ['survey_id']\n            isOneToOne: false\n            referencedRelation: 'surveys'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals: {\n        Row: {\n          code: string\n          created_at: string\n          id: number\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          code: string\n          created_at?: string\n          id?: number\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          code?: string\n          created_at?: string\n          id?: number\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_claims: {\n        Row: {\n          created_at: string\n          end_date: string\n          id: number\n          org_id: string\n          plan_id: string\n          referral_id: number | null\n          start_date: string\n        }\n        Insert: {\n          created_at?: string\n          end_date: string\n          id?: number\n          org_id: string\n          plan_id: string\n          referral_id?: number | null\n          start_date: string\n        }\n        Update: {\n          created_at?: string\n          end_date?: string\n          id?: number\n          org_id?: string\n          plan_id?: string\n          referral_id?: number | null\n          start_date?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_claims_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_users: {\n        Row: {\n          created_at: string\n          id: number\n          redeemed: boolean\n          referral_id: number\n          subscribed_at: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id: number\n          subscribed_at?: string | null\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id?: number\n          subscribed_at?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_users_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      repositories: {\n        Row: {\n          branch: string\n          commit_hash: string | null\n          created_at: string\n          git_provider: Database['public']['Enums']['git_provider']\n          gitlab_repo_id: number | null\n          id: string\n          repo_name: string\n          repo_org: string\n        }\n        Insert: {\n          branch: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name: string\n          repo_org: string\n        }\n        Update: {\n          branch?: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name?: string\n          repo_org?: string\n        }\n        Relationships: []\n      }\n      responses: {\n        Row: {\n          created_at: string\n          id: number\n          question_id: number\n          response: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          question_id: number\n          response: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          question_id?: number\n          response?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'responses_question_id_fkey'\n            columns: ['question_id']\n            isOneToOne: false\n            referencedRelation: 'questions'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'responses_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes: {\n        Row: {\n          created_at: string\n          id: string\n          name: string\n          org_id: string\n          response: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          name: string\n          org_id: string\n          response: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          name?: string\n          org_id?: string\n          response?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes_words: {\n        Row: {\n          created_at: string\n          id: number\n          org_id: string\n          semantic_routes_id: string\n          user_id: string | null\n          word: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          org_id: string\n          semantic_routes_id: string\n          user_id?: string | null\n          word: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          org_id?: string\n          semantic_routes_id?: string\n          user_id?: string | null\n          word?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_words_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      share_agent_types: {\n        Row: {\n          id: number\n          name: string | null\n        }\n        Insert: {\n          id?: number\n          name?: string | null\n        }\n        Update: {\n          id?: number\n          name?: string | null\n        }\n        Relationships: []\n      }\n      slack_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          workspace_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_channels_workspace_id_fkey'\n            columns: ['workspace_id']\n            isOneToOne: false\n            referencedRelation: 'slack_workspaces'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      slack_workspaces: {\n        Row: {\n          access_token: string | null\n          agent_id: string | null\n          agent_settings: number | null\n          bot_user_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_workspaces_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_workspaces_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      subscriptions: {\n        Row: {\n          begin_date: string\n          cancel_at_period_end: boolean\n          canceled_at: string | null\n          created_at: string\n          finish_date: string | null\n          id: string\n          last_payment_id: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end: string | null\n        }\n        Insert: {\n          begin_date: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Update: {\n          begin_date?: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id?: string\n          plan_id?: string\n          status?: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'subscriptions_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'subscriptions_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      surveys: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          status: boolean\n          title: string\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title: string\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title?: string\n        }\n        Relationships: []\n      }\n      tags: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n        }\n        Relationships: []\n      }\n      teams_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'teams_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'teams_channels_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      threads: {\n        Row: {\n          created_at: string\n          id: string\n          public: boolean | null\n          status: string | null\n          updated_at: string | null\n          user_created: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'threads_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage: {\n        Row: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          channel: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model: string\n          org_id?: string | null\n          plan_name: string\n          prompt_token?: number\n          session_id?: string | null\n          source: string\n          start_date?: string\n          type: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          channel?: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model?: string\n          org_id?: string | null\n          plan_name?: string\n          prompt_token?: number\n          session_id?: string | null\n          source?: string\n          start_date?: string\n          type?: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      usage_chunks: {\n        Row: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Insert: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Update: {\n          chunk_id?: string\n          score?: number\n          usage_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_chunks_usage_id_fkey'\n            columns: ['usage_id']\n            isOneToOne: false\n            referencedRelation: 'usage_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage_log: {\n        Row: {\n          agent_id: string | null\n          child_run_ids: Json | null\n          completion_token: number | null\n          created_at: string\n          doted_order: string | null\n          end_time: string | null\n          error: Json | null\n          extra: Json | null\n          id: string\n          inputs: Json | null\n          manifest_id: Json | null\n          message_embedding: string | null\n          name: string | null\n          outputs: Json | null\n          parent_run_ids: Json | null\n          prompt_token: number | null\n          run_type: string | null\n          session_id: string | null\n          start_time: string | null\n          status: string | null\n          tags: Json | null\n          total_tokens: number | null\n          trace_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user: {\n        Row: {\n          account_deletion_request: string | null\n          auth_data: string | null\n          avatar: string | null\n          avatar_url: string | null\n          azure_authTag: string | null\n          azure_iv: string | null\n          azureapikey: string | null\n          azureembedding: string | null\n          azureurl: string | null\n          billingData: Json | null\n          bot: Json | null\n          completionCount: Json | null\n          convertapi: string | null\n          created_at: string | null\n          date_created: string | null\n          description: string | null\n          email: string\n          email_notifications: boolean | null\n          emailNotifications: boolean | null\n          external_identifier: string | null\n          first_name: string | null\n          githubId: number | null\n          githubUser: string | null\n          gravatar_id: string | null\n          id: string\n          indexname: string | null\n          isFree: boolean | null\n          isTester: boolean | null\n          langsmith_langchain_api_key: string | null\n          langsmith_langchain_endpoint: string | null\n          langsmith_langchain_project: string | null\n          language: string | null\n          last_access: string | null\n          last_name: string | null\n          last_page: string | null\n          location: string | null\n          namespace: string | null\n          openai_authTag: string | null\n          openai_iv: string | null\n          openaiapikey: string | null\n          openaiorganization: string | null\n          password: string | null\n          pinecone_authTag: string | null\n          pinecone_iv: string | null\n          pineconeenv: string | null\n          pineconekey: string | null\n          plan_id: string | null\n          plan_name: string | null\n          provider: string | null\n          referred_by: string | null\n          role: string | null\n          searchbyuser: string | null\n          status: string | null\n          tags: string | null\n          tasks: Json | null\n          tfa_secret: string | null\n          theme: string | null\n          title: string | null\n          token: string | null\n          username: string | null\n        }\n        Insert: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Update: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email?: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id?: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user_profilings: {\n        Row: {\n          created_at: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          industry_profile?: string\n          organization?: string\n          profile?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_profilings_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widget_domains: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n          widget_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n          widget_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n          widget_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widget_domains_widget_id_fkey'\n            columns: ['widget_id']\n            isOneToOne: false\n            referencedRelation: 'widgets'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widgets: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          enabled: boolean\n          id: string\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id: string\n          user_id: string\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widgets_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n    }\n    Views: {\n      chat_log_model_summary_30: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_60: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_7: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_90: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      accept_invitation: {\n        Args: {\n          notification_id: string\n        }\n        Returns: boolean\n      }\n      add_user_to_organization: {\n        Args: {\n          target_email: string\n        }\n        Returns: boolean\n      }\n      admin_cancel_deletion: {\n        Args: {\n          marked_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_delete_user: {\n        Args: {\n          param_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_get_latest_subscription_by_org_id: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          id: string\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n          last_payment_id: string\n          org_id: string\n          trial_end: string\n          cancel_at_period_end: boolean\n          canceled_at: string\n          plan_id: string\n        }[]\n      }\n      admin_get_marketplace_agents: {\n        Args: {\n          page?: number\n          row_count?: number\n          sort_by?: string\n        }\n        Returns:\n          Database['public']['CompositeTypes']['marketplace_agents_result']\n      }\n      admin_get_organization_data: {\n        Args: {\n          user_email: string\n          orgid: string\n        }\n        Returns: {\n          organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n        }[]\n      }\n      admin_get_organization_owner_data: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          user_id: string\n          email: string\n        }[]\n      }\n      admin_get_recent_user_ip: {\n        Args: {\n          user_id: string\n        }\n        Returns: string\n      }\n      admin_search_users_by_email_or_userid: {\n        Args: {\n          search?: string\n          userid?: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      admin_search_users_by_email_or_userid_test: {\n        Args: {\n          search?: string\n          userid?: string\n          page?: number\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n          total_records: number\n          total_pages: number\n        }[]\n      }\n      admin_search_users_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      append_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_tier_subscription: {\n        Args: {\n          param_customer_id?: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_trial: {\n        Args: {\n          param_customer_id: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_non_stripe_subscription:\n        | {\n          Args: {\n            param_customer_id: string\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n        | {\n          Args: {\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n      change_organization_image: {\n        Args: {\n          orgid: string\n          image_url: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_agent_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_document_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_email_registered: {\n        Args: {\n          email: string\n        }\n        Returns: boolean\n      }\n      create_agent: {\n        Args: {\n          template_id?: string\n          custom_name?: string\n          custom_prompt?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n      }\n      create_apikey: {\n        Args: {\n          apikey_name: string\n        }\n        Returns: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n      }\n      create_documents_folder: {\n        Args: {\n          name: string\n          parent_folder_id?: string\n        }\n        Returns: undefined\n      }\n      delete_agent_by_agent_id_and_org_id_and_user_id: {\n        Args: {\n          agentid: string\n          orgid: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n        }[]\n      }\n      delete_marked_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_marketplace_agent: {\n        Args: {\n          agentid: string\n        }\n        Returns: undefined\n      }\n      delete_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_user_from_org: {\n        Args: {\n          ou_id_to_delete: string\n        }\n        Returns: boolean\n      }\n      deselect_organization_for_frozen_members: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: undefined\n      }\n      generate_agent_slug: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_active_organization_subscription: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_organization_subscription_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_plans_with_pricing: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_active_plans_with_pricing_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_agent_and_selected_documents:\n        | {\n          Args: {\n            agentid: string\n            orgid: string\n            apikey?: string\n            userid?: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n        | {\n          Args: {\n            apikey: string\n            orgid: string\n            agentid: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n      get_agent_by_id_chat: {\n        Args: {\n          agentid: string\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          model: string\n          name: string\n          temperature: number\n          prompt: string\n          plan_name: string\n          daily_completion_count: number\n          user_id: string\n          user_email: string\n        }[]\n      }\n      get_agent_with_documents: {\n        Args: {\n          agentid: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          share_agent_type_id: number\n          selecteddocuments: Json\n          is_marketplace: boolean\n          tagline: string\n          description: string\n          tags: string[]\n        }[]\n      }\n      get_agent_with_documents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n          agent_documents: Json\n        }[]\n      }\n      get_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          slug: string\n          is_frozen: boolean\n          memory: number\n          is_marketplace: boolean\n        }[]\n      }\n      get_agents_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n          agentid?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }[]\n      }\n      get_agents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n        }[]\n      }\n      get_auth_credentials: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          inputuserid?: string\n        }\n        Returns: {\n          org_id: string\n          user_id: string\n        }[]\n      }\n      get_chunks: {\n        Args: {\n          org_id_in: string\n          api_key_in: string\n          user_id_in: string\n          searchquery: string\n          agentid: string\n        }\n        Returns: Json\n      }\n      get_colleagues: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_colleagues_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n          status: Database['public']['Enums']['org_member_status']\n        }[]\n      }\n      get_crew_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          slug: string\n          image: string\n          description: string\n          tagline: string\n          tags: string[]\n        }[]\n      }\n      get_current_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          sel_org_id: string\n          daily_interactions: number\n          plan: Json\n        }[]\n      }\n      get_documents_from_api: {\n        Args: {\n          apikey?: string\n          userid?: string\n          orgid?: string\n          documentid?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_email_by_user_id: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          email: string\n        }[]\n      }\n      get_last_user_session_ip: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          ip: string\n        }[]\n      }\n      get_latest_plan_by_customer_id: {\n        Args: {\n          customer_id_param: string\n        }\n        Returns: {\n          org_id: string\n          id: string\n          name: string\n          status: Database['public']['Enums']['subscription_status']\n          description: string\n          files: number\n          max_agents: number\n          max_marketplace_agents: number\n          organization_member_limit: number\n        }[]\n      }\n      get_limits_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n        }[]\n      }\n      get_marketplace_agent_as_anonymous: {\n        Args: {\n          agentid: string\n          secret_key?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          is_frozen: boolean\n          prompt: string\n          org_id: string\n          memory: number\n        }[]\n      }\n      get_marketplace_agent_by_slug: {\n        Args: {\n          agent_slug: string\n        }\n        Returns: {\n          id: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          organization_image: string\n          organization_name: string\n          total_favorite_users: number\n          tags: string[]\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          user_rating: number\n        }[]\n      }\n      get_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_testo: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorite_agent_by_id: {\n        Args: {\n          agentid: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          memory: number\n          is_frozen: boolean\n          prompt: string\n          original_org_id: string\n          org_id: string\n          is_installed: boolean\n        }[]\n      }\n      get_marketplace_favorites_agents: {\n        Args: {\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorites_agents_by_org_id_and_api_key_or_user_: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_organization_owner_email: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          email: string\n        }[]\n      }\n      get_owned_organization_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          owned_org_id: string\n          daily_interactions: number\n          email: string\n          plan: Json\n        }[]\n      }\n      get_personal_organization: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          user_id: string\n          id: string\n          customer_id: string\n          name: string\n          created_at: string\n          image: string\n          daily_interactions: number\n          status: Database['public']['Enums']['entity_status']\n        }[]\n      }\n      get_plan_limits: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n          id: string\n          daily_max_tokens: number\n          daily_tokens: number\n          daily_max_usage: number\n          daily_usage: number\n          vision: boolean\n          user_org_id: string\n          plan_user_id: string\n          daily_interactions: number\n          user_email: string\n          distinct_id: string\n        }[]\n      }\n      get_plan_name_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: string\n      }\n      get_plan_trial_days_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: number\n      }\n      get_refresh_tokens: {\n        Args: Record<PropertyKey, never>\n        Returns: unknown[]\n      }\n      get_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }[]\n      }\n      get_user_data_by_api_key_or_user_id: {\n        Args: {\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n          organizations: Json\n        }[]\n      }\n      get_user_profile: {\n        Args: {\n          user_id_param?: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_by_email: {\n        Args: {\n          user_email: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      has_had_free_trial: {\n        Args: {\n          user_id_param?: string\n          org_id_param?: string\n        }\n        Returns: boolean\n      }\n      insert_tags_and_associate_with_agent: {\n        Args: {\n          tag_names: string[]\n          agentid: string\n        }\n        Returns: undefined\n      }\n      is_owner_or_admin: {\n        Args: {\n          orgid: string\n        }\n        Returns: boolean\n      }\n      mark_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      match_agent_chunks: {\n        Args: {\n          embedding_input: string\n          match_threshold: number\n          match_count: number\n          min_content_length: number\n          agent_id_input: string\n        }\n        Returns: {\n          id: string\n          document_name: string\n          content: string\n          similarity: number\n        }[]\n      }\n      match_agent_semantic_routes: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          semantic_routes_id: string\n          response: string\n          name: string\n          similarity: number\n        }[]\n      }\n      match_documents: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          content: string\n          metadata: Json\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_cohere: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n        }\n        Returns: {\n          id: number\n          metadata: Json\n          content: string\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_llama: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          similarity: number\n        }[]\n      }\n      match_documents_llama_v2: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          document_metadata: Json\n          document_tokens: number\n          similarity: number\n        }[]\n      }\n      rename_organization: {\n        Args: {\n          new_name: string\n        }\n        Returns: boolean\n      }\n      reset_daily_interactions: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      set_agent_documents: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n        }\n        Returns: undefined\n      }\n      set_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      update_agent_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey: string\n          userid: string\n          agentid: string\n          agent: Json\n        }\n        Returns: {\n          id: string\n          name: string\n          model: string\n          temperature: number\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          image: string\n        }[]\n      }\n      update_daily_usage: {\n        Args: {\n          orgid: string\n          inputtokens: number\n          outputtokens: number\n          model: Database['public']['Enums']['models']\n        }\n        Returns: undefined\n      }\n      update_document_metada_from_api: {\n        Args: {\n          documentid: string\n          metadata_param: Json\n          apikey?: string\n          userid?: string\n          orgid?: string\n        }\n        Returns: undefined\n      }\n      update_subscriptions_status: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      update_user_data_by_api_key_or_user_id: {\n        Args: {\n          user_data: Json\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n        }[]\n      }\n      update_user_role: {\n        Args: {\n          ou_id: string\n          new_role: string\n        }\n        Returns: boolean\n      }\n      upsert_product_details: {\n        Args: {\n          v_agent_id: string\n          v_tagline: string\n          v_description: string\n        }\n        Returns: undefined\n      }\n      validate_document_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n        }[]\n      }\n      validate_document_ownership_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          file_id: string\n        }[]\n      }\n      validate_max_agents: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: Json\n      }\n    }\n    Enums: {\n      agent_type: 'qa' | 'other' | 'repository'\n      billing_interval: 'day' | 'week' | 'month' | 'year'\n      entity_status: 'active' | 'deleted'\n      file_type: 'text' | 'table' | 'repository'\n      git_provider: 'github' | 'gitlab' | 'bitbucket'\n      locale: 'es' | 'en'\n      models:\n        | 'gpt-4-turbo'\n        | 'gpt-4'\n        | 'gpt-4-vision'\n        | 'gpt-3.5-turbo-16k'\n        | 'gpt-3.5-turbo'\n        | 'claude-2.1'\n        | 'claude-instant-1.2'\n        | 'gemini-1.0-pro'\n        | 'text-embedding-ada-002'\n        | 'claude-3-sonnet'\n        | 'claude-3-haiku'\n        | 'command-r-plus'\n        | 'llama3-70b-8192'\n        | 'gemini-1.5-pro-latest'\n        | 'llama3-70b'\n        | 'gemini-1.5-flash'\n        | 'gpt-4o'\n        | 'codestral'\n        | 'claude-3.5-sonnet'\n      org_member_status: 'active' | 'pending' | 'invited' | 'frozen'\n      org_role: 'owner' | 'admin' | 'moderator' | 'member'\n      plan_data_source: 'stripe' | 'manual'\n      price_type: 'recurring' | 'one_time'\n      question_type: 'score' | 'comment' | 'like'\n      role: 'function' | 'system' | 'user' | 'assistant'\n      status: 'published' | 'draft'\n      subscription_status:\n        | 'active'\n        | 'past_due'\n        | 'unpaid'\n        | 'canceled'\n        | 'incomplete'\n        | 'incomplete_expired'\n        | 'trialing'\n        | 'paused'\n        | 'free_trial'\n      usage_type: 'TRAINING' | 'SEMANTIC_SEARCH' | 'CHAT' | 'FUNCTION'\n    }\n    CompositeTypes: {\n      agent_data: {\n        agent: unknown\n        agent_selected_documents:\n          | Database['public']['Tables']['agents_documents']['Row'][]\n          | null\n        documents: Database['public']['Tables']['documents']['Row'][] | null\n        messages: Database['public']['Tables']['messages']['Row'][] | null\n      }\n      get_chunks_result: {\n        constant_data: Json | null\n        matching_documents: Json[] | null\n      }\n      marketplace_agent_data: {\n        id: string | null\n        name: string | null\n        image: string | null\n        slug: string | null\n        welcome: string | null\n        description: string | null\n        agent_install_count: number | null\n        agent_message_count: number | null\n      }\n      marketplace_agents_result: {\n        total: number | null\n        total_installations: number | null\n        total_messages: number | null\n        agents_data:\n          | Database['public']['CompositeTypes']['marketplace_agent_data'][]\n          | null\n      }\n    }\n  }\n}",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase::Json",
    "language": "typescript",
    "label": "Json",
    "type": "type",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase",
    "totalTokens": 26,
    "inDegree": 4,
    "outDegree": 1,
    "code": "type Json = string | number | boolean | null | {\n  [key: string]: Json | undefined\n} | Json[]",
    "importStatements": [],
    "codeNoBody": "type Json = string | number | boolean | null | {\n  [key: string]: Json | undefined\n} | Json[]",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\supabase",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\supabase.ts",
    "type": "file",
    "totalTokens": 28549,
    "inDegree": 0,
    "outDegree": 7,
    "code": "export type Json = string | number | boolean | null | {\n  [key: string]: Json | undefined\n} | Json[]\n\nexport type Database = {\n  public: {\n    Tables: {\n      agent_categories: {\n        Row: {\n          description: string | null\n          id: string\n          name: string\n        }\n        Insert: {\n          description?: string | null\n          id?: string\n          name: string\n        }\n        Update: {\n          description?: string | null\n          id?: string\n          name?: string\n        }\n        Relationships: []\n      }\n      agent_templates: {\n        Row: {\n          agent_category_id: string\n          created_at: string\n          description: string | null\n          id: string\n          image: string | null\n          link: string | null\n          model: string\n          name: string\n          order: number | null\n          original_agent_id: string | null\n          prompt: string | null\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          type: string | null\n          user_id: string | null\n          welcome: string | null\n        }\n        Insert: {\n          agent_category_id: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Update: {\n          agent_category_id?: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agent_templates_agent_category_id_fkey'\n            columns: ['agent_category_id']\n            isOneToOne: false\n            referencedRelation: 'agent_categories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_original_agent_id_fkey'\n            columns: ['original_agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents: {\n        Row: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n        Insert: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Update: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id?: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_share_agent_type_id_fkey'\n            columns: ['share_agent_type_id']\n            isOneToOne: false\n            referencedRelation: 'share_agent_types'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_documents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          document_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          document_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          document_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_graphs: {\n        Row: {\n          agent_id: string\n          created_at: string\n          graph_id: string\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_graphs_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_graph_id_fkey'\n            columns: ['graph_id']\n            isOneToOne: false\n            referencedRelation: 'graphs'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_rating: {\n        Row: {\n          agent_id: string\n          created_at: string | null\n          rating: number\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string | null\n          rating: number\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string | null\n          rating?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_rating_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_rating_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_semantic_routes: {\n        Row: {\n          agent_id: string\n          created_at: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_routes_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_tags: {\n        Row: {\n          agent_id: string\n          tag_id: number\n        }\n        Insert: {\n          agent_id: string\n          tag_id: number\n        }\n        Update: {\n          agent_id?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_tags_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'agents_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agreements: {\n        Row: {\n          created_at: string\n          id: number\n          privacy: string\n          status: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          privacy: string\n          status?: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          privacy?: string\n          status?: Database['public']['Enums']['status']\n          tos?: string\n          version?: number\n        }\n        Relationships: []\n      }\n      agreements_users: {\n        Row: {\n          agreement_id: number\n          email_notifications: boolean\n          signed_at: string\n          user_id: string\n        }\n        Insert: {\n          agreement_id: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Update: {\n          agreement_id?: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agreements_users_agreement_id_fkey'\n            columns: ['agreement_id']\n            isOneToOne: false\n            referencedRelation: 'agreements'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agreements_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      api_keys: {\n        Row: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string | null\n          id?: string\n          key: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Update: {\n          created_at?: string | null\n          id?: string\n          key?: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'api_keys_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_connections: {\n        Row: {\n          app_id: number | null\n          created_at: string\n          id: string\n          org_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'apps_connections_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_tags: {\n        Row: {\n          app_id: number\n          created_at: string\n          tag_id: number\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          tag_id: number\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_apps_tags_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_apps_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      bitbucket_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_bitbucket_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log: {\n        Row: {\n          agent_documents_verification_time: number\n          agent_id: string | null\n          completion_tokens: number\n          created_at: string\n          embbedding_tokens: number\n          embedding_time: number\n          end_time: string | null\n          first_token_response_time: number\n          id: string\n          message_embedding: string | null\n          model: string\n          org_id: string\n          plan_agent_time: number\n          prompt_tokens: number\n          semantic_search_time: number\n          session_id: string | null\n          start_time: string | null\n          system_prompt: string\n          tags: string[] | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model: string\n          org_id: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model?: string\n          org_id?: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_chunks: {\n        Row: {\n          chat_log_id: string\n          chunk_id: string\n          created_at: string\n          id: number\n          score: number\n        }\n        Insert: {\n          chat_log_id: string\n          chunk_id: string\n          created_at?: string\n          id?: number\n          score: number\n        }\n        Update: {\n          chat_log_id?: string\n          chunk_id?: string\n          created_at?: string\n          id?: number\n          score?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chat_log_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_chunks_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_messages: {\n        Row: {\n          chat_log_id: string\n          content: string\n          created_at: string\n          id: number\n          role: Database['public']['Enums']['role']\n        }\n        Insert: {\n          chat_log_id: string\n          content: string\n          created_at?: string\n          id?: number\n          role: Database['public']['Enums']['role']\n        }\n        Update: {\n          chat_log_id?: string\n          content?: string\n          created_at?: string\n          id?: number\n          role?: Database['public']['Enums']['role']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_messages_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_cohere: {\n        Row: {\n          content: string\n          document_id: string\n          embedding: string\n          id: number\n          metadata: Json | null\n        }\n        Insert: {\n          content: string\n          document_id: string\n          embedding: string\n          id?: number\n          metadata?: Json | null\n        }\n        Update: {\n          content?: string\n          document_id?: string\n          embedding?: string\n          id?: number\n          metadata?: Json | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_cohere_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_llama: {\n        Row: {\n          created_at: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Insert: {\n          created_at?: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Update: {\n          created_at?: string | null\n          document_id?: string\n          id?: string\n          metadata?: Json\n          vec?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_llama_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_semantic_routes: {\n        Row: {\n          embedding: string | null\n          id: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_semantic_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      countries: {\n        Row: {\n          code: string\n          id: string\n          name: Json\n          tax_id: string | null\n        }\n        Insert: {\n          code: string\n          id?: string\n          name: Json\n          tax_id?: string | null\n        }\n        Update: {\n          code?: string\n          id?: string\n          name?: Json\n          tax_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: number\n          name: string | null\n          server_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_channels_server_id_fkey'\n            columns: ['server_id']\n            isOneToOne: false\n            referencedRelation: 'discord_servers'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      discord_servers: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_servers_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_servers_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents: {\n        Row: {\n          chunk_count: number | null\n          created_at: string\n          documents_folders_id: string | null\n          file_id: string | null\n          file_type: Database['public']['Enums']['file_type'] | null\n          id: string\n          is_frozen: boolean | null\n          metadata: Json | null\n          name: string\n          org_id: string | null\n          tokens: number | null\n          user_id: string\n        }\n        Insert: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Update: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name?: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_documents_folders_id_fkey'\n            columns: ['documents_folders_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents_folders: {\n        Row: {\n          created_at: string\n          folder_id: string | null\n          id: string\n          name: string\n          org_id: string\n        }\n        Insert: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name: string\n          org_id: string\n        }\n        Update: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_folders_folder_id_fkey'\n            columns: ['folder_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_folders_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      features: {\n        Row: {\n          agent_debugging: boolean | null\n          agent_faq: boolean | null\n          agent_skin: boolean | null\n          ai_prompt: boolean | null\n          create_marketplace: boolean | null\n          created_at: string\n          github_sync: boolean | null\n          id: string\n          scraping: boolean\n          user_id: string\n        }\n        Insert: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id: string\n        }\n        Update: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'features_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      github_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_github_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      gitlab_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          email: string | null\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_gitlab_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      graphs: {\n        Row: {\n          bitbucket_connection_id: string | null\n          created_at: string\n          github_connection_id: number | null\n          gitlab_connection_id: number | null\n          id: string\n          org_id: string | null\n          repo_id: string\n          status: string\n          user_id: string | null\n        }\n        Insert: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Update: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'graphs_bitbucket_connection_id_fkey'\n            columns: ['bitbucket_connection_id']\n            isOneToOne: false\n            referencedRelation: 'bitbucket_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_github_connection_id_fkey'\n            columns: ['github_connection_id']\n            isOneToOne: false\n            referencedRelation: 'github_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_gitlab_connection_id_fkey'\n            columns: ['gitlab_connection_id']\n            isOneToOne: false\n            referencedRelation: 'gitlab_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      ingestor_github_log: {\n        Row: {\n          created_at: string\n          database: string | null\n          document_id: string | null\n          final_size: number | null\n          id: number\n          register_id: string | null\n          repository: string | null\n          size: number | null\n          status: boolean | null\n          total_tokens: number | null\n          updated_at: string | null\n          user_created: string | null\n        }\n        Insert: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Update: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'ingestor_github_log_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      invoker_org_id: {\n        Row: {\n          org_sel_id: string | null\n        }\n        Insert: {\n          org_sel_id?: string | null\n        }\n        Update: {\n          org_sel_id?: string | null\n        }\n        Relationships: []\n      }\n      licenses: {\n        Row: {\n          active: boolean | null\n          created_at: string\n          id: string\n          org_id: string\n          quantity: number\n          sub_id: string\n        }\n        Insert: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id: string\n          quantity?: number\n          sub_id: string\n        }\n        Update: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id?: string\n          quantity?: number\n          sub_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'licenses_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'licenses_sub_id_fkey'\n            columns: ['sub_id']\n            isOneToOne: false\n            referencedRelation: 'subscriptions'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      links: {\n        Row: {\n          created_at: string\n          id: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          label?: string\n          node_source_id?: string\n          node_target_id?: string\n          repo_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'links_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          featured: boolean | null\n          org_id: string\n          product_details_id: number | null\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          featured?: boolean | null\n          org_id: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          featured?: boolean | null\n          org_id?: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: true\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents_favorites: {\n        Row: {\n          agent_id: string\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_favorites_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps: {\n        Row: {\n          created_at: string\n          featured: boolean | null\n          id: number\n          image: string | null\n          name: string\n          org_id: string\n          product_details_id: number | null\n          slug: string\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name: string\n          org_id: string\n          product_details_id?: number | null\n          slug: string\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name?: string\n          org_id?: string\n          product_details_id?: number | null\n          slug?: string\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps_favorites: {\n        Row: {\n          app_id: number\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      messages: {\n        Row: {\n          agent_id: string\n          content: string\n          created_at: string\n          id: string\n          role: Database['public']['Enums']['role']\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          content: string\n          created_at?: string\n          id?: string\n          role: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          content?: string\n          created_at?: string\n          id?: string\n          role?: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'messages_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'messages_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      models_pricing: {\n        Row: {\n          id: string\n          input: number\n          name: Database['public']['Enums']['models']\n          output: number\n          provider: string\n          updated_at: string\n        }\n        Insert: {\n          id?: string\n          input: number\n          name?: Database['public']['Enums']['models']\n          output: number\n          provider?: string\n          updated_at?: string\n        }\n        Update: {\n          id?: string\n          input?: number\n          name?: Database['public']['Enums']['models']\n          output?: number\n          provider?: string\n          updated_at?: string\n        }\n        Relationships: []\n      }\n      nodes: {\n        Row: {\n          code: string\n          code_no_body: string\n          created_at: string\n          documentation: string\n          full_name: string\n          id: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens: number\n          type: string\n        }\n        Insert: {\n          code: string\n          code_no_body: string\n          created_at?: string\n          documentation: string\n          full_name: string\n          id?: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens?: number\n          type: string\n        }\n        Update: {\n          code?: string\n          code_no_body?: string\n          created_at?: string\n          documentation?: string\n          full_name?: string\n          id?: string\n          in_degree?: number\n          label?: string\n          language?: string\n          out_degree?: number\n          repo_id?: string\n          total_tokens?: number\n          type?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_call: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_call_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_call_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_child: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_child_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_child_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_import_statement: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_import_statement_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_import_statement_node_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      notifications: {\n        Row: {\n          created_at: string\n          description: string | null\n          email: string | null\n          id: string\n          scope: string | null\n          status: string\n          title: string\n          type: string\n          updated_at: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title: string\n          type: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title?: string\n          type?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'notifications_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      onboarding: {\n        Row: {\n          created_at: string\n          invitation: boolean\n          org_id: string\n          org_img: boolean\n          org_personalization: boolean\n          user_img: boolean\n          user_personalization: boolean\n        }\n        Insert: {\n          created_at?: string\n          invitation?: boolean\n          org_id: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Update: {\n          created_at?: string\n          invitation?: boolean\n          org_id?: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'onboarding_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organization_user: {\n        Row: {\n          created_at: string\n          id: string\n          is_frozen: boolean\n          org_id: string | null\n          role: Database['public']['Enums']['org_role'] | null\n          status: Database['public']['Enums']['org_member_status']\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organization_user_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'organization_user_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organizations: {\n        Row: {\n          created_at: string\n          customer_id: string | null\n          daily_interactions: number\n          daily_tokens: number\n          daily_usage: number\n          id: string\n          image: string | null\n          name: string | null\n          status: Database['public']['Enums']['entity_status']\n          verified: boolean\n        }\n        Insert: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Update: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Relationships: []\n      }\n      organizations_billing: {\n        Row: {\n          billing_address: Json | null\n          created_at: string\n          id: string\n          org_id: string\n        }\n        Insert: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id: string\n        }\n        Update: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organizations_billing_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan: {\n        Row: {\n          agent_history_limit: number\n          allow_agent_chat_skins: boolean | null\n          allow_agent_share: boolean\n          allow_apikey_creation: boolean\n          allow_marketplace_publish: boolean\n          allow_premium_models: boolean\n          daily_completion_count: number\n          daily_max_tokens: number\n          daily_max_usage: number | null\n          description: string | null\n          files: number | null\n          id: string\n          max_agents: number | null\n          max_marketplace_agents: number\n          name: string\n          organization_member_limit: number\n          status: boolean | null\n          text_storage: number | null\n          trial_daily_interaction_limit: number\n          trial_period_days: number | null\n          vision: boolean | null\n        }\n        Insert: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Update: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name?: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Relationships: []\n      }\n      plan_features: {\n        Row: {\n          created_at: string\n          feature: string | null\n          id: string\n          locale: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Insert: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Update: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_features_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan_pricing: {\n        Row: {\n          active: boolean\n          amount: number\n          created_at: string\n          currency: string\n          id: string\n          interval: Database['public']['Enums']['billing_interval']\n          interval_count: number\n          plan_id: string\n          related_price: string | null\n          source: Database['public']['Enums']['plan_data_source']\n          type: Database['public']['Enums']['price_type']\n        }\n        Insert: {\n          active?: boolean\n          amount: number\n          created_at?: string\n          currency?: string\n          id: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Update: {\n          active?: boolean\n          amount?: number\n          created_at?: string\n          currency?: string\n          id?: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id?: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_pricing_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      product_details: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          tagline: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Relationships: []\n      }\n      profiles: {\n        Row: {\n          avatar_url: string | null\n          distinct_id: string\n          full_name: string | null\n          id: string\n          org_sel_id: string | null\n          signup: boolean\n          status: Database['public']['Enums']['entity_status']\n          updated_at: string | null\n          username: string | null\n        }\n        Insert: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Update: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id?: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'profiles_org_sel_id_fkey'\n            columns: ['org_sel_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      questions: {\n        Row: {\n          created_at: string | null\n          description: string | null\n          id: number\n          survey_id: number\n          title: string\n          type: Database['public']['Enums']['question_type']\n        }\n        Insert: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id: number\n          title: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Update: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id?: number\n          title?: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'questions_survey_id_fkey'\n            columns: ['survey_id']\n            isOneToOne: false\n            referencedRelation: 'surveys'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals: {\n        Row: {\n          code: string\n          created_at: string\n          id: number\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          code: string\n          created_at?: string\n          id?: number\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          code?: string\n          created_at?: string\n          id?: number\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_claims: {\n        Row: {\n          created_at: string\n          end_date: string\n          id: number\n          org_id: string\n          plan_id: string\n          referral_id: number | null\n          start_date: string\n        }\n        Insert: {\n          created_at?: string\n          end_date: string\n          id?: number\n          org_id: string\n          plan_id: string\n          referral_id?: number | null\n          start_date: string\n        }\n        Update: {\n          created_at?: string\n          end_date?: string\n          id?: number\n          org_id?: string\n          plan_id?: string\n          referral_id?: number | null\n          start_date?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_claims_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_users: {\n        Row: {\n          created_at: string\n          id: number\n          redeemed: boolean\n          referral_id: number\n          subscribed_at: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id: number\n          subscribed_at?: string | null\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id?: number\n          subscribed_at?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_users_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      repositories: {\n        Row: {\n          branch: string\n          commit_hash: string | null\n          created_at: string\n          git_provider: Database['public']['Enums']['git_provider']\n          gitlab_repo_id: number | null\n          id: string\n          repo_name: string\n          repo_org: string\n        }\n        Insert: {\n          branch: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name: string\n          repo_org: string\n        }\n        Update: {\n          branch?: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name?: string\n          repo_org?: string\n        }\n        Relationships: []\n      }\n      responses: {\n        Row: {\n          created_at: string\n          id: number\n          question_id: number\n          response: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          question_id: number\n          response: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          question_id?: number\n          response?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'responses_question_id_fkey'\n            columns: ['question_id']\n            isOneToOne: false\n            referencedRelation: 'questions'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'responses_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes: {\n        Row: {\n          created_at: string\n          id: string\n          name: string\n          org_id: string\n          response: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          name: string\n          org_id: string\n          response: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          name?: string\n          org_id?: string\n          response?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes_words: {\n        Row: {\n          created_at: string\n          id: number\n          org_id: string\n          semantic_routes_id: string\n          user_id: string | null\n          word: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          org_id: string\n          semantic_routes_id: string\n          user_id?: string | null\n          word: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          org_id?: string\n          semantic_routes_id?: string\n          user_id?: string | null\n          word?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_words_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      share_agent_types: {\n        Row: {\n          id: number\n          name: string | null\n        }\n        Insert: {\n          id?: number\n          name?: string | null\n        }\n        Update: {\n          id?: number\n          name?: string | null\n        }\n        Relationships: []\n      }\n      slack_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          workspace_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_channels_workspace_id_fkey'\n            columns: ['workspace_id']\n            isOneToOne: false\n            referencedRelation: 'slack_workspaces'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      slack_workspaces: {\n        Row: {\n          access_token: string | null\n          agent_id: string | null\n          agent_settings: number | null\n          bot_user_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_workspaces_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_workspaces_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      subscriptions: {\n        Row: {\n          begin_date: string\n          cancel_at_period_end: boolean\n          canceled_at: string | null\n          created_at: string\n          finish_date: string | null\n          id: string\n          last_payment_id: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end: string | null\n        }\n        Insert: {\n          begin_date: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Update: {\n          begin_date?: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id?: string\n          plan_id?: string\n          status?: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'subscriptions_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'subscriptions_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      surveys: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          status: boolean\n          title: string\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title: string\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title?: string\n        }\n        Relationships: []\n      }\n      tags: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n        }\n        Relationships: []\n      }\n      teams_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'teams_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'teams_channels_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      threads: {\n        Row: {\n          created_at: string\n          id: string\n          public: boolean | null\n          status: string | null\n          updated_at: string | null\n          user_created: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'threads_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage: {\n        Row: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          channel: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model: string\n          org_id?: string | null\n          plan_name: string\n          prompt_token?: number\n          session_id?: string | null\n          source: string\n          start_date?: string\n          type: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          channel?: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model?: string\n          org_id?: string | null\n          plan_name?: string\n          prompt_token?: number\n          session_id?: string | null\n          source?: string\n          start_date?: string\n          type?: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      usage_chunks: {\n        Row: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Insert: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Update: {\n          chunk_id?: string\n          score?: number\n          usage_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_chunks_usage_id_fkey'\n            columns: ['usage_id']\n            isOneToOne: false\n            referencedRelation: 'usage_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage_log: {\n        Row: {\n          agent_id: string | null\n          child_run_ids: Json | null\n          completion_token: number | null\n          created_at: string\n          doted_order: string | null\n          end_time: string | null\n          error: Json | null\n          extra: Json | null\n          id: string\n          inputs: Json | null\n          manifest_id: Json | null\n          message_embedding: string | null\n          name: string | null\n          outputs: Json | null\n          parent_run_ids: Json | null\n          prompt_token: number | null\n          run_type: string | null\n          session_id: string | null\n          start_time: string | null\n          status: string | null\n          tags: Json | null\n          total_tokens: number | null\n          trace_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user: {\n        Row: {\n          account_deletion_request: string | null\n          auth_data: string | null\n          avatar: string | null\n          avatar_url: string | null\n          azure_authTag: string | null\n          azure_iv: string | null\n          azureapikey: string | null\n          azureembedding: string | null\n          azureurl: string | null\n          billingData: Json | null\n          bot: Json | null\n          completionCount: Json | null\n          convertapi: string | null\n          created_at: string | null\n          date_created: string | null\n          description: string | null\n          email: string\n          email_notifications: boolean | null\n          emailNotifications: boolean | null\n          external_identifier: string | null\n          first_name: string | null\n          githubId: number | null\n          githubUser: string | null\n          gravatar_id: string | null\n          id: string\n          indexname: string | null\n          isFree: boolean | null\n          isTester: boolean | null\n          langsmith_langchain_api_key: string | null\n          langsmith_langchain_endpoint: string | null\n          langsmith_langchain_project: string | null\n          language: string | null\n          last_access: string | null\n          last_name: string | null\n          last_page: string | null\n          location: string | null\n          namespace: string | null\n          openai_authTag: string | null\n          openai_iv: string | null\n          openaiapikey: string | null\n          openaiorganization: string | null\n          password: string | null\n          pinecone_authTag: string | null\n          pinecone_iv: string | null\n          pineconeenv: string | null\n          pineconekey: string | null\n          plan_id: string | null\n          plan_name: string | null\n          provider: string | null\n          referred_by: string | null\n          role: string | null\n          searchbyuser: string | null\n          status: string | null\n          tags: string | null\n          tasks: Json | null\n          tfa_secret: string | null\n          theme: string | null\n          title: string | null\n          token: string | null\n          username: string | null\n        }\n        Insert: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Update: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email?: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id?: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user_profilings: {\n        Row: {\n          created_at: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          industry_profile?: string\n          organization?: string\n          profile?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_profilings_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widget_domains: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n          widget_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n          widget_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n          widget_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widget_domains_widget_id_fkey'\n            columns: ['widget_id']\n            isOneToOne: false\n            referencedRelation: 'widgets'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widgets: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          enabled: boolean\n          id: string\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id: string\n          user_id: string\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widgets_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n    }\n    Views: {\n      chat_log_model_summary_30: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_60: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_7: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_90: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      accept_invitation: {\n        Args: {\n          notification_id: string\n        }\n        Returns: boolean\n      }\n      add_user_to_organization: {\n        Args: {\n          target_email: string\n        }\n        Returns: boolean\n      }\n      admin_cancel_deletion: {\n        Args: {\n          marked_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_delete_user: {\n        Args: {\n          param_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_get_latest_subscription_by_org_id: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          id: string\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n          last_payment_id: string\n          org_id: string\n          trial_end: string\n          cancel_at_period_end: boolean\n          canceled_at: string\n          plan_id: string\n        }[]\n      }\n      admin_get_marketplace_agents: {\n        Args: {\n          page?: number\n          row_count?: number\n          sort_by?: string\n        }\n        Returns:\n          Database['public']['CompositeTypes']['marketplace_agents_result']\n      }\n      admin_get_organization_data: {\n        Args: {\n          user_email: string\n          orgid: string\n        }\n        Returns: {\n          organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n        }[]\n      }\n      admin_get_organization_owner_data: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          user_id: string\n          email: string\n        }[]\n      }\n      admin_get_recent_user_ip: {\n        Args: {\n          user_id: string\n        }\n        Returns: string\n      }\n      admin_search_users_by_email_or_userid: {\n        Args: {\n          search?: string\n          userid?: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      admin_search_users_by_email_or_userid_test: {\n        Args: {\n          search?: string\n          userid?: string\n          page?: number\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n          total_records: number\n          total_pages: number\n        }[]\n      }\n      admin_search_users_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      append_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_tier_subscription: {\n        Args: {\n          param_customer_id?: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_trial: {\n        Args: {\n          param_customer_id: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_non_stripe_subscription:\n        | {\n          Args: {\n            param_customer_id: string\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n        | {\n          Args: {\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n      change_organization_image: {\n        Args: {\n          orgid: string\n          image_url: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_agent_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_document_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_email_registered: {\n        Args: {\n          email: string\n        }\n        Returns: boolean\n      }\n      create_agent: {\n        Args: {\n          template_id?: string\n          custom_name?: string\n          custom_prompt?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n      }\n      create_apikey: {\n        Args: {\n          apikey_name: string\n        }\n        Returns: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n      }\n      create_documents_folder: {\n        Args: {\n          name: string\n          parent_folder_id?: string\n        }\n        Returns: undefined\n      }\n      delete_agent_by_agent_id_and_org_id_and_user_id: {\n        Args: {\n          agentid: string\n          orgid: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n        }[]\n      }\n      delete_marked_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_marketplace_agent: {\n        Args: {\n          agentid: string\n        }\n        Returns: undefined\n      }\n      delete_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_user_from_org: {\n        Args: {\n          ou_id_to_delete: string\n        }\n        Returns: boolean\n      }\n      deselect_organization_for_frozen_members: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: undefined\n      }\n      generate_agent_slug: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_active_organization_subscription: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_organization_subscription_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_plans_with_pricing: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_active_plans_with_pricing_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_agent_and_selected_documents:\n        | {\n          Args: {\n            agentid: string\n            orgid: string\n            apikey?: string\n            userid?: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n        | {\n          Args: {\n            apikey: string\n            orgid: string\n            agentid: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n      get_agent_by_id_chat: {\n        Args: {\n          agentid: string\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          model: string\n          name: string\n          temperature: number\n          prompt: string\n          plan_name: string\n          daily_completion_count: number\n          user_id: string\n          user_email: string\n        }[]\n      }\n      get_agent_with_documents: {\n        Args: {\n          agentid: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          share_agent_type_id: number\n          selecteddocuments: Json\n          is_marketplace: boolean\n          tagline: string\n          description: string\n          tags: string[]\n        }[]\n      }\n      get_agent_with_documents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n          agent_documents: Json\n        }[]\n      }\n      get_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          slug: string\n          is_frozen: boolean\n          memory: number\n          is_marketplace: boolean\n        }[]\n      }\n      get_agents_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n          agentid?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }[]\n      }\n      get_agents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n        }[]\n      }\n      get_auth_credentials: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          inputuserid?: string\n        }\n        Returns: {\n          org_id: string\n          user_id: string\n        }[]\n      }\n      get_chunks: {\n        Args: {\n          org_id_in: string\n          api_key_in: string\n          user_id_in: string\n          searchquery: string\n          agentid: string\n        }\n        Returns: Json\n      }\n      get_colleagues: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_colleagues_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n          status: Database['public']['Enums']['org_member_status']\n        }[]\n      }\n      get_crew_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          slug: string\n          image: string\n          description: string\n          tagline: string\n          tags: string[]\n        }[]\n      }\n      get_current_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          sel_org_id: string\n          daily_interactions: number\n          plan: Json\n        }[]\n      }\n      get_documents_from_api: {\n        Args: {\n          apikey?: string\n          userid?: string\n          orgid?: string\n          documentid?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_email_by_user_id: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          email: string\n        }[]\n      }\n      get_last_user_session_ip: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          ip: string\n        }[]\n      }\n      get_latest_plan_by_customer_id: {\n        Args: {\n          customer_id_param: string\n        }\n        Returns: {\n          org_id: string\n          id: string\n          name: string\n          status: Database['public']['Enums']['subscription_status']\n          description: string\n          files: number\n          max_agents: number\n          max_marketplace_agents: number\n          organization_member_limit: number\n        }[]\n      }\n      get_limits_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n        }[]\n      }\n      get_marketplace_agent_as_anonymous: {\n        Args: {\n          agentid: string\n          secret_key?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          is_frozen: boolean\n          prompt: string\n          org_id: string\n          memory: number\n        }[]\n      }\n      get_marketplace_agent_by_slug: {\n        Args: {\n          agent_slug: string\n        }\n        Returns: {\n          id: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          organization_image: string\n          organization_name: string\n          total_favorite_users: number\n          tags: string[]\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          user_rating: number\n        }[]\n      }\n      get_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_testo: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorite_agent_by_id: {\n        Args: {\n          agentid: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          memory: number\n          is_frozen: boolean\n          prompt: string\n          original_org_id: string\n          org_id: string\n          is_installed: boolean\n        }[]\n      }\n      get_marketplace_favorites_agents: {\n        Args: {\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorites_agents_by_org_id_and_api_key_or_user_: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_organization_owner_email: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          email: string\n        }[]\n      }\n      get_owned_organization_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          owned_org_id: string\n          daily_interactions: number\n          email: string\n          plan: Json\n        }[]\n      }\n      get_personal_organization: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          user_id: string\n          id: string\n          customer_id: string\n          name: string\n          created_at: string\n          image: string\n          daily_interactions: number\n          status: Database['public']['Enums']['entity_status']\n        }[]\n      }\n      get_plan_limits: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n          id: string\n          daily_max_tokens: number\n          daily_tokens: number\n          daily_max_usage: number\n          daily_usage: number\n          vision: boolean\n          user_org_id: string\n          plan_user_id: string\n          daily_interactions: number\n          user_email: string\n          distinct_id: string\n        }[]\n      }\n      get_plan_name_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: string\n      }\n      get_plan_trial_days_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: number\n      }\n      get_refresh_tokens: {\n        Args: Record<PropertyKey, never>\n        Returns: unknown[]\n      }\n      get_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }[]\n      }\n      get_user_data_by_api_key_or_user_id: {\n        Args: {\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n          organizations: Json\n        }[]\n      }\n      get_user_profile: {\n        Args: {\n          user_id_param?: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_by_email: {\n        Args: {\n          user_email: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      has_had_free_trial: {\n        Args: {\n          user_id_param?: string\n          org_id_param?: string\n        }\n        Returns: boolean\n      }\n      insert_tags_and_associate_with_agent: {\n        Args: {\n          tag_names: string[]\n          agentid: string\n        }\n        Returns: undefined\n      }\n      is_owner_or_admin: {\n        Args: {\n          orgid: string\n        }\n        Returns: boolean\n      }\n      mark_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      match_agent_chunks: {\n        Args: {\n          embedding_input: string\n          match_threshold: number\n          match_count: number\n          min_content_length: number\n          agent_id_input: string\n        }\n        Returns: {\n          id: string\n          document_name: string\n          content: string\n          similarity: number\n        }[]\n      }\n      match_agent_semantic_routes: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          semantic_routes_id: string\n          response: string\n          name: string\n          similarity: number\n        }[]\n      }\n      match_documents: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          content: string\n          metadata: Json\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_cohere: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n        }\n        Returns: {\n          id: number\n          metadata: Json\n          content: string\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_llama: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          similarity: number\n        }[]\n      }\n      match_documents_llama_v2: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          document_metadata: Json\n          document_tokens: number\n          similarity: number\n        }[]\n      }\n      rename_organization: {\n        Args: {\n          new_name: string\n        }\n        Returns: boolean\n      }\n      reset_daily_interactions: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      set_agent_documents: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n        }\n        Returns: undefined\n      }\n      set_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      update_agent_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey: string\n          userid: string\n          agentid: string\n          agent: Json\n        }\n        Returns: {\n          id: string\n          name: string\n          model: string\n          temperature: number\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          image: string\n        }[]\n      }\n      update_daily_usage: {\n        Args: {\n          orgid: string\n          inputtokens: number\n          outputtokens: number\n          model: Database['public']['Enums']['models']\n        }\n        Returns: undefined\n      }\n      update_document_metada_from_api: {\n        Args: {\n          documentid: string\n          metadata_param: Json\n          apikey?: string\n          userid?: string\n          orgid?: string\n        }\n        Returns: undefined\n      }\n      update_subscriptions_status: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      update_user_data_by_api_key_or_user_id: {\n        Args: {\n          user_data: Json\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n        }[]\n      }\n      update_user_role: {\n        Args: {\n          ou_id: string\n          new_role: string\n        }\n        Returns: boolean\n      }\n      upsert_product_details: {\n        Args: {\n          v_agent_id: string\n          v_tagline: string\n          v_description: string\n        }\n        Returns: undefined\n      }\n      validate_document_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n        }[]\n      }\n      validate_document_ownership_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          file_id: string\n        }[]\n      }\n      validate_max_agents: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: Json\n      }\n    }\n    Enums: {\n      agent_type: 'qa' | 'other' | 'repository'\n      billing_interval: 'day' | 'week' | 'month' | 'year'\n      entity_status: 'active' | 'deleted'\n      file_type: 'text' | 'table' | 'repository'\n      git_provider: 'github' | 'gitlab' | 'bitbucket'\n      locale: 'es' | 'en'\n      models:\n        | 'gpt-4-turbo'\n        | 'gpt-4'\n        | 'gpt-4-vision'\n        | 'gpt-3.5-turbo-16k'\n        | 'gpt-3.5-turbo'\n        | 'claude-2.1'\n        | 'claude-instant-1.2'\n        | 'gemini-1.0-pro'\n        | 'text-embedding-ada-002'\n        | 'claude-3-sonnet'\n        | 'claude-3-haiku'\n        | 'command-r-plus'\n        | 'llama3-70b-8192'\n        | 'gemini-1.5-pro-latest'\n        | 'llama3-70b'\n        | 'gemini-1.5-flash'\n        | 'gpt-4o'\n        | 'codestral'\n        | 'claude-3.5-sonnet'\n      org_member_status: 'active' | 'pending' | 'invited' | 'frozen'\n      org_role: 'owner' | 'admin' | 'moderator' | 'member'\n      plan_data_source: 'stripe' | 'manual'\n      price_type: 'recurring' | 'one_time'\n      question_type: 'score' | 'comment' | 'like'\n      role: 'function' | 'system' | 'user' | 'assistant'\n      status: 'published' | 'draft'\n      subscription_status:\n        | 'active'\n        | 'past_due'\n        | 'unpaid'\n        | 'canceled'\n        | 'incomplete'\n        | 'incomplete_expired'\n        | 'trialing'\n        | 'paused'\n        | 'free_trial'\n      usage_type: 'TRAINING' | 'SEMANTIC_SEARCH' | 'CHAT' | 'FUNCTION'\n    }\n    CompositeTypes: {\n      agent_data: {\n        agent: unknown\n        agent_selected_documents:\n          | Database['public']['Tables']['agents_documents']['Row'][]\n          | null\n        documents: Database['public']['Tables']['documents']['Row'][] | null\n        messages: Database['public']['Tables']['messages']['Row'][] | null\n      }\n      get_chunks_result: {\n        constant_data: Json | null\n        matching_documents: Json[] | null\n      }\n      marketplace_agent_data: {\n        id: string | null\n        name: string | null\n        image: string | null\n        slug: string | null\n        welcome: string | null\n        description: string | null\n        agent_install_count: number | null\n        agent_message_count: number | null\n      }\n      marketplace_agents_result: {\n        total: number | null\n        total_installations: number | null\n        total_messages: number | null\n        agents_data:\n          | Database['public']['CompositeTypes']['marketplace_agent_data'][]\n          | null\n      }\n    }\n  }\n}\n\ntype PublicSchema = Database[Extract<keyof Database, 'public'>]\n\nexport type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (\n      & Database[PublicTableNameOrOptions['schema']]['Tables']\n      & Database[PublicTableNameOrOptions['schema']]['Views']\n    )\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database } ? (\n    & Database[PublicTableNameOrOptions['schema']]['Tables']\n    & Database[PublicTableNameOrOptions['schema']]['Views']\n  )[TableName] extends {\n    Row: infer R\n  } ? R\n  : never\n  : PublicTableNameOrOptions extends\n    keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    ? (PublicSchema['Tables'] & PublicSchema['Views'])[\n      PublicTableNameOrOptions\n    ] extends {\n      Row: infer R\n    } ? R\n    : never\n  : never\n\nexport type TablesInsert<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Insert: infer I\n  } ? I\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    } ? I\n    : never\n  : never\n\nexport type TablesUpdate<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Update: infer U\n  } ? U\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    } ? U\n    : never\n  : never\n\nexport type Enums<\n  PublicEnumNameOrOptions extends keyof PublicSchema['Enums'] | {\n    schema: keyof Database\n  },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never,\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n    ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never\n",
    "importStatements": [],
    "codeNoBody": "export type Json = string | number | boolean | null | {\n  [key: string]: Json | undefined\n} | Json[]\nexport type Database = {\n  public: {\n    Tables: {\n      agent_categories: {\n        Row: {\n          description: string | null\n          id: string\n          name: string\n        }\n        Insert: {\n          description?: string | null\n          id?: string\n          name: string\n        }\n        Update: {\n          description?: string | null\n          id?: string\n          name?: string\n        }\n        Relationships: []\n      }\n      agent_templates: {\n        Row: {\n          agent_category_id: string\n          created_at: string\n          description: string | null\n          id: string\n          image: string | null\n          link: string | null\n          model: string\n          name: string\n          order: number | null\n          original_agent_id: string | null\n          prompt: string | null\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          type: string | null\n          user_id: string | null\n          welcome: string | null\n        }\n        Insert: {\n          agent_category_id: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Update: {\n          agent_category_id?: string\n          created_at?: string\n          description?: string | null\n          id?: string\n          image?: string | null\n          link?: string | null\n          model?: string\n          name?: string\n          order?: number | null\n          original_agent_id?: string | null\n          prompt?: string | null\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          type?: string | null\n          user_id?: string | null\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agent_templates_agent_category_id_fkey'\n            columns: ['agent_category_id']\n            isOneToOne: false\n            referencedRelation: 'agent_categories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_original_agent_id_fkey'\n            columns: ['original_agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agent_templates_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents: {\n        Row: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n        Insert: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Update: {\n          agent_type?: Database['public']['Enums']['agent_type'] | null\n          created_at?: string\n          description?: string | null\n          font?: string | null\n          id?: string\n          image?: string | null\n          is_frozen?: boolean\n          is_public?: boolean\n          memory?: number\n          model?: string\n          name?: string\n          org_id?: string\n          palette?: string | null\n          pincode?: string | null\n          prompt?: string | null\n          prompt_library?: Json | null\n          share_agent_type_id?: number | null\n          slug?: string\n          status?: Database['public']['Enums']['status']\n          temperature?: number\n          topk?: number\n          welcome?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_share_agent_type_id_fkey'\n            columns: ['share_agent_type_id']\n            isOneToOne: false\n            referencedRelation: 'share_agent_types'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_documents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          document_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          document_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          document_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_graphs: {\n        Row: {\n          agent_id: string\n          created_at: string\n          graph_id: string\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          graph_id?: string\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_graphs_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_graph_id_fkey'\n            columns: ['graph_id']\n            isOneToOne: false\n            referencedRelation: 'graphs'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_rating: {\n        Row: {\n          agent_id: string\n          created_at: string | null\n          rating: number\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string | null\n          rating: number\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string | null\n          rating?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_rating_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_rating_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_semantic_routes: {\n        Row: {\n          agent_id: string\n          created_at: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_documents_routes_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agents_documents_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agents_tags: {\n        Row: {\n          agent_id: string\n          tag_id: number\n        }\n        Insert: {\n          agent_id: string\n          tag_id: number\n        }\n        Update: {\n          agent_id?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agents_tags_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'agents_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      agreements: {\n        Row: {\n          created_at: string\n          id: number\n          privacy: string\n          status: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          privacy: string\n          status?: Database['public']['Enums']['status']\n          tos: string\n          version: number\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          privacy?: string\n          status?: Database['public']['Enums']['status']\n          tos?: string\n          version?: number\n        }\n        Relationships: []\n      }\n      agreements_users: {\n        Row: {\n          agreement_id: number\n          email_notifications: boolean\n          signed_at: string\n          user_id: string\n        }\n        Insert: {\n          agreement_id: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Update: {\n          agreement_id?: number\n          email_notifications?: boolean\n          signed_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'agreements_users_agreement_id_fkey'\n            columns: ['agreement_id']\n            isOneToOne: false\n            referencedRelation: 'agreements'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'agreements_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      api_keys: {\n        Row: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string | null\n          id?: string\n          key: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Update: {\n          created_at?: string | null\n          id?: string\n          key?: string\n          last_used_at?: string | null\n          name?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'api_keys_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_connections: {\n        Row: {\n          app_id: number | null\n          created_at: string\n          id: string\n          org_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          app_id?: number | null\n          created_at?: string\n          id?: string\n          org_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'apps_connections_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'apps_connections_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      apps_tags: {\n        Row: {\n          app_id: number\n          created_at: string\n          tag_id: number\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          tag_id: number\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          tag_id?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_apps_tags_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_apps_tags_tag_id_fkey'\n            columns: ['tag_id']\n            isOneToOne: false\n            referencedRelation: 'tags'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      bitbucket_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_bitbucket_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log: {\n        Row: {\n          agent_documents_verification_time: number\n          agent_id: string | null\n          completion_tokens: number\n          created_at: string\n          embbedding_tokens: number\n          embedding_time: number\n          end_time: string | null\n          first_token_response_time: number\n          id: string\n          message_embedding: string | null\n          model: string\n          org_id: string\n          plan_agent_time: number\n          prompt_tokens: number\n          semantic_search_time: number\n          session_id: string | null\n          start_time: string | null\n          system_prompt: string\n          tags: string[] | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model: string\n          org_id: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_documents_verification_time?: number\n          agent_id?: string | null\n          completion_tokens?: number\n          created_at?: string\n          embbedding_tokens?: number\n          embedding_time?: number\n          end_time?: string | null\n          first_token_response_time?: number\n          id?: string\n          message_embedding?: string | null\n          model?: string\n          org_id?: string\n          plan_agent_time?: number\n          prompt_tokens?: number\n          semantic_search_time?: number\n          session_id?: string | null\n          start_time?: string | null\n          system_prompt?: string\n          tags?: string[] | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_chunks: {\n        Row: {\n          chat_log_id: string\n          chunk_id: string\n          created_at: string\n          id: number\n          score: number\n        }\n        Insert: {\n          chat_log_id: string\n          chunk_id: string\n          created_at?: string\n          id?: number\n          score: number\n        }\n        Update: {\n          chat_log_id?: string\n          chunk_id?: string\n          created_at?: string\n          id?: number\n          score?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chat_log_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_chat_log_chunks_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chat_log_messages: {\n        Row: {\n          chat_log_id: string\n          content: string\n          created_at: string\n          id: number\n          role: Database['public']['Enums']['role']\n        }\n        Insert: {\n          chat_log_id: string\n          content: string\n          created_at?: string\n          id?: number\n          role: Database['public']['Enums']['role']\n        }\n        Update: {\n          chat_log_id?: string\n          content?: string\n          created_at?: string\n          id?: number\n          role?: Database['public']['Enums']['role']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_chat_log_messages_chat_log_id_fkey'\n            columns: ['chat_log_id']\n            isOneToOne: false\n            referencedRelation: 'chat_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_cohere: {\n        Row: {\n          content: string\n          document_id: string\n          embedding: string\n          id: number\n          metadata: Json | null\n        }\n        Insert: {\n          content: string\n          document_id: string\n          embedding: string\n          id?: number\n          metadata?: Json | null\n        }\n        Update: {\n          content?: string\n          document_id?: string\n          embedding?: string\n          id?: number\n          metadata?: Json | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_cohere_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_llama: {\n        Row: {\n          created_at: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Insert: {\n          created_at?: string | null\n          document_id: string\n          id: string\n          metadata: Json\n          vec: string\n        }\n        Update: {\n          created_at?: string | null\n          document_id?: string\n          id?: string\n          metadata?: Json\n          vec?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_llama_document_id_fkey'\n            columns: ['document_id']\n            isOneToOne: false\n            referencedRelation: 'documents'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      chunks_semantic_routes: {\n        Row: {\n          embedding: string | null\n          id: string\n          semantic_routes_id: string\n        }\n        Insert: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id: string\n        }\n        Update: {\n          embedding?: string | null\n          id?: string\n          semantic_routes_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'chunks_semantic_routes_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      countries: {\n        Row: {\n          code: string\n          id: string\n          name: Json\n          tax_id: string | null\n        }\n        Insert: {\n          code: string\n          id?: string\n          name: Json\n          tax_id?: string | null\n        }\n        Update: {\n          code?: string\n          id?: string\n          name?: Json\n          tax_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: number\n          name: string | null\n          server_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          server_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_channels_server_id_fkey'\n            columns: ['server_id']\n            isOneToOne: false\n            referencedRelation: 'discord_servers'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      discord_servers: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_discord_servers_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_discord_servers_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents: {\n        Row: {\n          chunk_count: number | null\n          created_at: string\n          documents_folders_id: string | null\n          file_id: string | null\n          file_type: Database['public']['Enums']['file_type'] | null\n          id: string\n          is_frozen: boolean | null\n          metadata: Json | null\n          name: string\n          org_id: string | null\n          tokens: number | null\n          user_id: string\n        }\n        Insert: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Update: {\n          chunk_count?: number | null\n          created_at?: string\n          documents_folders_id?: string | null\n          file_id?: string | null\n          file_type?: Database['public']['Enums']['file_type'] | null\n          id?: string\n          is_frozen?: boolean | null\n          metadata?: Json | null\n          name?: string\n          org_id?: string | null\n          tokens?: number | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_documents_folders_id_fkey'\n            columns: ['documents_folders_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      documents_folders: {\n        Row: {\n          created_at: string\n          folder_id: string | null\n          id: string\n          name: string\n          org_id: string\n        }\n        Insert: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name: string\n          org_id: string\n        }\n        Update: {\n          created_at?: string\n          folder_id?: string | null\n          id?: string\n          name?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'documents_folders_folder_id_fkey'\n            columns: ['folder_id']\n            isOneToOne: false\n            referencedRelation: 'documents_folders'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'documents_folders_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      features: {\n        Row: {\n          agent_debugging: boolean | null\n          agent_faq: boolean | null\n          agent_skin: boolean | null\n          ai_prompt: boolean | null\n          create_marketplace: boolean | null\n          created_at: string\n          github_sync: boolean | null\n          id: string\n          scraping: boolean\n          user_id: string\n        }\n        Insert: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id: string\n        }\n        Update: {\n          agent_debugging?: boolean | null\n          agent_faq?: boolean | null\n          agent_skin?: boolean | null\n          ai_prompt?: boolean | null\n          create_marketplace?: boolean | null\n          created_at?: string\n          github_sync?: boolean | null\n          id?: string\n          scraping?: boolean\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'features_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      github_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_github_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      gitlab_connections: {\n        Row: {\n          access_token: string | null\n          created_at: string\n          email: string | null\n          id: number\n          name: string | null\n          org_id: string | null\n          refresh_token: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          created_at?: string\n          email?: string | null\n          id?: number\n          name?: string | null\n          org_id?: string | null\n          refresh_token?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_gitlab_connections_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      graphs: {\n        Row: {\n          bitbucket_connection_id: string | null\n          created_at: string\n          github_connection_id: number | null\n          gitlab_connection_id: number | null\n          id: string\n          org_id: string | null\n          repo_id: string\n          status: string\n          user_id: string | null\n        }\n        Insert: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Update: {\n          bitbucket_connection_id?: string | null\n          created_at?: string\n          github_connection_id?: number | null\n          gitlab_connection_id?: number | null\n          id?: string\n          org_id?: string | null\n          repo_id?: string\n          status?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'graphs_bitbucket_connection_id_fkey'\n            columns: ['bitbucket_connection_id']\n            isOneToOne: false\n            referencedRelation: 'bitbucket_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_github_connection_id_fkey'\n            columns: ['github_connection_id']\n            isOneToOne: false\n            referencedRelation: 'github_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_gitlab_connection_id_fkey'\n            columns: ['gitlab_connection_id']\n            isOneToOne: false\n            referencedRelation: 'gitlab_connections'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'graphs_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      ingestor_github_log: {\n        Row: {\n          created_at: string\n          database: string | null\n          document_id: string | null\n          final_size: number | null\n          id: number\n          register_id: string | null\n          repository: string | null\n          size: number | null\n          status: boolean | null\n          total_tokens: number | null\n          updated_at: string | null\n          user_created: string | null\n        }\n        Insert: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Update: {\n          created_at?: string\n          database?: string | null\n          document_id?: string | null\n          final_size?: number | null\n          id?: number\n          register_id?: string | null\n          repository?: string | null\n          size?: number | null\n          status?: boolean | null\n          total_tokens?: number | null\n          updated_at?: string | null\n          user_created?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'ingestor_github_log_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      invoker_org_id: {\n        Row: {\n          org_sel_id: string | null\n        }\n        Insert: {\n          org_sel_id?: string | null\n        }\n        Update: {\n          org_sel_id?: string | null\n        }\n        Relationships: []\n      }\n      licenses: {\n        Row: {\n          active: boolean | null\n          created_at: string\n          id: string\n          org_id: string\n          quantity: number\n          sub_id: string\n        }\n        Insert: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id: string\n          quantity?: number\n          sub_id: string\n        }\n        Update: {\n          active?: boolean | null\n          created_at?: string\n          id?: string\n          org_id?: string\n          quantity?: number\n          sub_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'licenses_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'licenses_sub_id_fkey'\n            columns: ['sub_id']\n            isOneToOne: false\n            referencedRelation: 'subscriptions'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      links: {\n        Row: {\n          created_at: string\n          id: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          label: string\n          node_source_id: string\n          node_target_id: string\n          repo_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          label?: string\n          node_source_id?: string\n          node_target_id?: string\n          repo_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'links_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents: {\n        Row: {\n          agent_id: string\n          created_at: string\n          featured: boolean | null\n          org_id: string\n          product_details_id: number | null\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          featured?: boolean | null\n          org_id: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          featured?: boolean | null\n          org_id?: string\n          product_details_id?: number | null\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: true\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_agents_favorites: {\n        Row: {\n          agent_id: string\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'marketplace_agents_favorites_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_agents'\n            referencedColumns: ['agent_id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'marketplace_agents_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps: {\n        Row: {\n          created_at: string\n          featured: boolean | null\n          id: number\n          image: string | null\n          name: string\n          org_id: string\n          product_details_id: number | null\n          slug: string\n          updated_at: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name: string\n          org_id: string\n          product_details_id?: number | null\n          slug: string\n          updated_at?: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          featured?: boolean | null\n          id?: number\n          image?: string | null\n          name?: string\n          org_id?: string\n          product_details_id?: number | null\n          slug?: string\n          updated_at?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_product_details_id_fkey'\n            columns: ['product_details_id']\n            isOneToOne: false\n            referencedRelation: 'product_details'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      marketplace_apps_favorites: {\n        Row: {\n          app_id: number\n          created_at: string\n          is_frozen: boolean\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          app_id: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id: string\n          user_id?: string\n        }\n        Update: {\n          app_id?: number\n          created_at?: string\n          is_frozen?: boolean\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_app_id_fkey'\n            columns: ['app_id']\n            isOneToOne: false\n            referencedRelation: 'marketplace_apps'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_marketplace_apps_favorites_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      messages: {\n        Row: {\n          agent_id: string\n          content: string\n          created_at: string\n          id: string\n          role: Database['public']['Enums']['role']\n          user_id: string\n        }\n        Insert: {\n          agent_id: string\n          content: string\n          created_at?: string\n          id?: string\n          role: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Update: {\n          agent_id?: string\n          content?: string\n          created_at?: string\n          id?: string\n          role?: Database['public']['Enums']['role']\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'messages_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'messages_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      models_pricing: {\n        Row: {\n          id: string\n          input: number\n          name: Database['public']['Enums']['models']\n          output: number\n          provider: string\n          updated_at: string\n        }\n        Insert: {\n          id?: string\n          input: number\n          name?: Database['public']['Enums']['models']\n          output: number\n          provider?: string\n          updated_at?: string\n        }\n        Update: {\n          id?: string\n          input?: number\n          name?: Database['public']['Enums']['models']\n          output?: number\n          provider?: string\n          updated_at?: string\n        }\n        Relationships: []\n      }\n      nodes: {\n        Row: {\n          code: string\n          code_no_body: string\n          created_at: string\n          documentation: string\n          full_name: string\n          id: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens: number\n          type: string\n        }\n        Insert: {\n          code: string\n          code_no_body: string\n          created_at?: string\n          documentation: string\n          full_name: string\n          id?: string\n          in_degree: number\n          label: string\n          language: string\n          out_degree: number\n          repo_id: string\n          total_tokens?: number\n          type: string\n        }\n        Update: {\n          code?: string\n          code_no_body?: string\n          created_at?: string\n          documentation?: string\n          full_name?: string\n          id?: string\n          in_degree?: number\n          label?: string\n          language?: string\n          out_degree?: number\n          repo_id?: string\n          total_tokens?: number\n          type?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_repo_id_fkey'\n            columns: ['repo_id']\n            isOneToOne: false\n            referencedRelation: 'repositories'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_call: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_call_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_call_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_child: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_child_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_child_parent_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      nodes_import_statement: {\n        Row: {\n          id: string\n          node_id: string\n        }\n        Insert: {\n          id: string\n          node_id: string\n        }\n        Update: {\n          id?: string\n          node_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'nodes_import_statement_id_fkey'\n            columns: ['id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'nodes_import_statement_node_id_fkey'\n            columns: ['node_id']\n            isOneToOne: false\n            referencedRelation: 'nodes'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      notifications: {\n        Row: {\n          created_at: string\n          description: string | null\n          email: string | null\n          id: string\n          scope: string | null\n          status: string\n          title: string\n          type: string\n          updated_at: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title: string\n          type: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          email?: string | null\n          id?: string\n          scope?: string | null\n          status?: string\n          title?: string\n          type?: string\n          updated_at?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'notifications_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      onboarding: {\n        Row: {\n          created_at: string\n          invitation: boolean\n          org_id: string\n          org_img: boolean\n          org_personalization: boolean\n          user_img: boolean\n          user_personalization: boolean\n        }\n        Insert: {\n          created_at?: string\n          invitation?: boolean\n          org_id: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Update: {\n          created_at?: string\n          invitation?: boolean\n          org_id?: string\n          org_img?: boolean\n          org_personalization?: boolean\n          user_img?: boolean\n          user_personalization?: boolean\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'onboarding_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organization_user: {\n        Row: {\n          created_at: string\n          id: string\n          is_frozen: boolean\n          org_id: string | null\n          role: Database['public']['Enums']['org_role'] | null\n          status: Database['public']['Enums']['org_member_status']\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          is_frozen?: boolean\n          org_id?: string | null\n          role?: Database['public']['Enums']['org_role'] | null\n          status?: Database['public']['Enums']['org_member_status']\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organization_user_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'organization_user_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      organizations: {\n        Row: {\n          created_at: string\n          customer_id: string | null\n          daily_interactions: number\n          daily_tokens: number\n          daily_usage: number\n          id: string\n          image: string | null\n          name: string | null\n          status: Database['public']['Enums']['entity_status']\n          verified: boolean\n        }\n        Insert: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Update: {\n          created_at?: string\n          customer_id?: string | null\n          daily_interactions?: number\n          daily_tokens?: number\n          daily_usage?: number\n          id?: string\n          image?: string | null\n          name?: string | null\n          status?: Database['public']['Enums']['entity_status']\n          verified?: boolean\n        }\n        Relationships: []\n      }\n      organizations_billing: {\n        Row: {\n          billing_address: Json | null\n          created_at: string\n          id: string\n          org_id: string\n        }\n        Insert: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id: string\n        }\n        Update: {\n          billing_address?: Json | null\n          created_at?: string\n          id?: string\n          org_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'organizations_billing_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan: {\n        Row: {\n          agent_history_limit: number\n          allow_agent_chat_skins: boolean | null\n          allow_agent_share: boolean\n          allow_apikey_creation: boolean\n          allow_marketplace_publish: boolean\n          allow_premium_models: boolean\n          daily_completion_count: number\n          daily_max_tokens: number\n          daily_max_usage: number | null\n          description: string | null\n          files: number | null\n          id: string\n          max_agents: number | null\n          max_marketplace_agents: number\n          name: string\n          organization_member_limit: number\n          status: boolean | null\n          text_storage: number | null\n          trial_daily_interaction_limit: number\n          trial_period_days: number | null\n          vision: boolean | null\n        }\n        Insert: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Update: {\n          agent_history_limit?: number\n          allow_agent_chat_skins?: boolean | null\n          allow_agent_share?: boolean\n          allow_apikey_creation?: boolean\n          allow_marketplace_publish?: boolean\n          allow_premium_models?: boolean\n          daily_completion_count?: number\n          daily_max_tokens?: number\n          daily_max_usage?: number | null\n          description?: string | null\n          files?: number | null\n          id?: string\n          max_agents?: number | null\n          max_marketplace_agents?: number\n          name?: string\n          organization_member_limit?: number\n          status?: boolean | null\n          text_storage?: number | null\n          trial_daily_interaction_limit?: number\n          trial_period_days?: number | null\n          vision?: boolean | null\n        }\n        Relationships: []\n      }\n      plan_features: {\n        Row: {\n          created_at: string\n          feature: string | null\n          id: string\n          locale: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Insert: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id: string\n        }\n        Update: {\n          created_at?: string\n          feature?: string | null\n          id?: string\n          locale?: Database['public']['Enums']['locale']\n          plan_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_features_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      plan_pricing: {\n        Row: {\n          active: boolean\n          amount: number\n          created_at: string\n          currency: string\n          id: string\n          interval: Database['public']['Enums']['billing_interval']\n          interval_count: number\n          plan_id: string\n          related_price: string | null\n          source: Database['public']['Enums']['plan_data_source']\n          type: Database['public']['Enums']['price_type']\n        }\n        Insert: {\n          active?: boolean\n          amount: number\n          created_at?: string\n          currency?: string\n          id: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Update: {\n          active?: boolean\n          amount?: number\n          created_at?: string\n          currency?: string\n          id?: string\n          interval?: Database['public']['Enums']['billing_interval']\n          interval_count?: number\n          plan_id?: string\n          related_price?: string | null\n          source?: Database['public']['Enums']['plan_data_source']\n          type?: Database['public']['Enums']['price_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'plan_pricing_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      product_details: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          tagline: string | null\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          tagline?: string | null\n        }\n        Relationships: []\n      }\n      profiles: {\n        Row: {\n          avatar_url: string | null\n          distinct_id: string\n          full_name: string | null\n          id: string\n          org_sel_id: string | null\n          signup: boolean\n          status: Database['public']['Enums']['entity_status']\n          updated_at: string | null\n          username: string | null\n        }\n        Insert: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Update: {\n          avatar_url?: string | null\n          distinct_id?: string\n          full_name?: string | null\n          id?: string\n          org_sel_id?: string | null\n          signup?: boolean\n          status?: Database['public']['Enums']['entity_status']\n          updated_at?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'profiles_org_sel_id_fkey'\n            columns: ['org_sel_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      questions: {\n        Row: {\n          created_at: string | null\n          description: string | null\n          id: number\n          survey_id: number\n          title: string\n          type: Database['public']['Enums']['question_type']\n        }\n        Insert: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id: number\n          title: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Update: {\n          created_at?: string | null\n          description?: string | null\n          id?: number\n          survey_id?: number\n          title?: string\n          type?: Database['public']['Enums']['question_type']\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'questions_survey_id_fkey'\n            columns: ['survey_id']\n            isOneToOne: false\n            referencedRelation: 'surveys'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals: {\n        Row: {\n          code: string\n          created_at: string\n          id: number\n          org_id: string\n          user_id: string | null\n        }\n        Insert: {\n          code: string\n          created_at?: string\n          id?: number\n          org_id: string\n          user_id?: string | null\n        }\n        Update: {\n          code?: string\n          created_at?: string\n          id?: number\n          org_id?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: true\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_claims: {\n        Row: {\n          created_at: string\n          end_date: string\n          id: number\n          org_id: string\n          plan_id: string\n          referral_id: number | null\n          start_date: string\n        }\n        Insert: {\n          created_at?: string\n          end_date: string\n          id?: number\n          org_id: string\n          plan_id: string\n          referral_id?: number | null\n          start_date: string\n        }\n        Update: {\n          created_at?: string\n          end_date?: string\n          id?: number\n          org_id?: string\n          plan_id?: string\n          referral_id?: number | null\n          start_date?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_claims_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_claims_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      referrals_users: {\n        Row: {\n          created_at: string\n          id: number\n          redeemed: boolean\n          referral_id: number\n          subscribed_at: string | null\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id: number\n          subscribed_at?: string | null\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          redeemed?: boolean\n          referral_id?: number\n          subscribed_at?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_referrals_users_referral_id_fkey'\n            columns: ['referral_id']\n            isOneToOne: false\n            referencedRelation: 'referrals'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_referrals_users_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      repositories: {\n        Row: {\n          branch: string\n          commit_hash: string | null\n          created_at: string\n          git_provider: Database['public']['Enums']['git_provider']\n          gitlab_repo_id: number | null\n          id: string\n          repo_name: string\n          repo_org: string\n        }\n        Insert: {\n          branch: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name: string\n          repo_org: string\n        }\n        Update: {\n          branch?: string\n          commit_hash?: string | null\n          created_at?: string\n          git_provider?: Database['public']['Enums']['git_provider']\n          gitlab_repo_id?: number | null\n          id?: string\n          repo_name?: string\n          repo_org?: string\n        }\n        Relationships: []\n      }\n      responses: {\n        Row: {\n          created_at: string\n          id: number\n          question_id: number\n          response: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          question_id: number\n          response: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          question_id?: number\n          response?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'responses_question_id_fkey'\n            columns: ['question_id']\n            isOneToOne: false\n            referencedRelation: 'questions'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'responses_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes: {\n        Row: {\n          created_at: string\n          id: string\n          name: string\n          org_id: string\n          response: string\n          user_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          name: string\n          org_id: string\n          response: string\n          user_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          name?: string\n          org_id?: string\n          response?: string\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      semantic_routes_words: {\n        Row: {\n          created_at: string\n          id: number\n          org_id: string\n          semantic_routes_id: string\n          user_id: string | null\n          word: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          org_id: string\n          semantic_routes_id: string\n          user_id?: string | null\n          word: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          org_id?: string\n          semantic_routes_id?: string\n          user_id?: string | null\n          word?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'semantic_routes_words_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_semantic_routes_id_fkey'\n            columns: ['semantic_routes_id']\n            isOneToOne: false\n            referencedRelation: 'semantic_routes'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'semantic_routes_words_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      share_agent_types: {\n        Row: {\n          id: number\n          name: string | null\n        }\n        Insert: {\n          id?: number\n          name?: string | null\n        }\n        Update: {\n          id?: number\n          name?: string | null\n        }\n        Relationships: []\n      }\n      slack_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          workspace_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          workspace_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_channels_workspace_id_fkey'\n            columns: ['workspace_id']\n            isOneToOne: false\n            referencedRelation: 'slack_workspaces'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      slack_workspaces: {\n        Row: {\n          access_token: string | null\n          agent_id: string | null\n          agent_settings: number | null\n          bot_user_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          access_token?: string | null\n          agent_id?: string | null\n          agent_settings?: number | null\n          bot_user_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_slack_workspaces_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_slack_workspaces_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      subscriptions: {\n        Row: {\n          begin_date: string\n          cancel_at_period_end: boolean\n          canceled_at: string | null\n          created_at: string\n          finish_date: string | null\n          id: string\n          last_payment_id: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end: string | null\n        }\n        Insert: {\n          begin_date: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id: string\n          plan_id: string\n          status: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Update: {\n          begin_date?: string\n          cancel_at_period_end?: boolean\n          canceled_at?: string | null\n          created_at?: string\n          finish_date?: string | null\n          id?: string\n          last_payment_id?: string | null\n          org_id?: string\n          plan_id?: string\n          status?: Database['public']['Enums']['subscription_status']\n          trial_end?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'subscriptions_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'subscriptions_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      surveys: {\n        Row: {\n          created_at: string\n          description: string | null\n          id: number\n          status: boolean\n          title: string\n        }\n        Insert: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title: string\n        }\n        Update: {\n          created_at?: string\n          description?: string | null\n          id?: number\n          status?: boolean\n          title?: string\n        }\n        Relationships: []\n      }\n      tags: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n        }\n        Relationships: []\n      }\n      teams_channels: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          id: string\n          name: string | null\n          org_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          id: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          id?: string\n          name?: string | null\n          org_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'teams_channels_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'teams_channels_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      threads: {\n        Row: {\n          created_at: string\n          id: string\n          public: boolean | null\n          status: string | null\n          updated_at: string | null\n          user_created: string\n        }\n        Insert: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created: string\n        }\n        Update: {\n          created_at?: string\n          id?: string\n          public?: boolean | null\n          status?: string | null\n          updated_at?: string | null\n          user_created?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'threads_user_created_fkey'\n            columns: ['user_created']\n            isOneToOne: false\n            referencedRelation: 'user'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage: {\n        Row: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          channel: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model: string\n          org_id?: string | null\n          plan_name: string\n          prompt_token?: number\n          session_id?: string | null\n          source: string\n          start_date?: string\n          type: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          channel?: string\n          completion_token?: number\n          embeddings_tokens?: number\n          id?: string\n          model?: string\n          org_id?: string | null\n          plan_name?: string\n          prompt_token?: number\n          session_id?: string | null\n          source?: string\n          start_date?: string\n          type?: Database['public']['Enums']['usage_type']\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      usage_chunks: {\n        Row: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Insert: {\n          chunk_id: string\n          score: number\n          usage_id: string\n        }\n        Update: {\n          chunk_id?: string\n          score?: number\n          usage_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_chunks_chunk_id_fkey'\n            columns: ['chunk_id']\n            isOneToOne: false\n            referencedRelation: 'chunks_llama'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_chunks_usage_id_fkey'\n            columns: ['usage_id']\n            isOneToOne: false\n            referencedRelation: 'usage_log'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      usage_log: {\n        Row: {\n          agent_id: string | null\n          child_run_ids: Json | null\n          completion_token: number | null\n          created_at: string\n          doted_order: string | null\n          end_time: string | null\n          error: Json | null\n          extra: Json | null\n          id: string\n          inputs: Json | null\n          manifest_id: Json | null\n          message_embedding: string | null\n          name: string | null\n          outputs: Json | null\n          parent_run_ids: Json | null\n          prompt_token: number | null\n          run_type: string | null\n          session_id: string | null\n          start_time: string | null\n          status: string | null\n          tags: Json | null\n          total_tokens: number | null\n          trace_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          agent_id?: string | null\n          child_run_ids?: Json | null\n          completion_token?: number | null\n          created_at?: string\n          doted_order?: string | null\n          end_time?: string | null\n          error?: Json | null\n          extra?: Json | null\n          id?: string\n          inputs?: Json | null\n          manifest_id?: Json | null\n          message_embedding?: string | null\n          name?: string | null\n          outputs?: Json | null\n          parent_run_ids?: Json | null\n          prompt_token?: number | null\n          run_type?: string | null\n          session_id?: string | null\n          start_time?: string | null\n          status?: string | null\n          tags?: Json | null\n          total_tokens?: number | null\n          trace_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'usage_log_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'usage_log_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user: {\n        Row: {\n          account_deletion_request: string | null\n          auth_data: string | null\n          avatar: string | null\n          avatar_url: string | null\n          azure_authTag: string | null\n          azure_iv: string | null\n          azureapikey: string | null\n          azureembedding: string | null\n          azureurl: string | null\n          billingData: Json | null\n          bot: Json | null\n          completionCount: Json | null\n          convertapi: string | null\n          created_at: string | null\n          date_created: string | null\n          description: string | null\n          email: string\n          email_notifications: boolean | null\n          emailNotifications: boolean | null\n          external_identifier: string | null\n          first_name: string | null\n          githubId: number | null\n          githubUser: string | null\n          gravatar_id: string | null\n          id: string\n          indexname: string | null\n          isFree: boolean | null\n          isTester: boolean | null\n          langsmith_langchain_api_key: string | null\n          langsmith_langchain_endpoint: string | null\n          langsmith_langchain_project: string | null\n          language: string | null\n          last_access: string | null\n          last_name: string | null\n          last_page: string | null\n          location: string | null\n          namespace: string | null\n          openai_authTag: string | null\n          openai_iv: string | null\n          openaiapikey: string | null\n          openaiorganization: string | null\n          password: string | null\n          pinecone_authTag: string | null\n          pinecone_iv: string | null\n          pineconeenv: string | null\n          pineconekey: string | null\n          plan_id: string | null\n          plan_name: string | null\n          provider: string | null\n          referred_by: string | null\n          role: string | null\n          searchbyuser: string | null\n          status: string | null\n          tags: string | null\n          tasks: Json | null\n          tfa_secret: string | null\n          theme: string | null\n          title: string | null\n          token: string | null\n          username: string | null\n        }\n        Insert: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Update: {\n          account_deletion_request?: string | null\n          auth_data?: string | null\n          avatar?: string | null\n          avatar_url?: string | null\n          azure_authTag?: string | null\n          azure_iv?: string | null\n          azureapikey?: string | null\n          azureembedding?: string | null\n          azureurl?: string | null\n          billingData?: Json | null\n          bot?: Json | null\n          completionCount?: Json | null\n          convertapi?: string | null\n          created_at?: string | null\n          date_created?: string | null\n          description?: string | null\n          email?: string\n          email_notifications?: boolean | null\n          emailNotifications?: boolean | null\n          external_identifier?: string | null\n          first_name?: string | null\n          githubId?: number | null\n          githubUser?: string | null\n          gravatar_id?: string | null\n          id?: string\n          indexname?: string | null\n          isFree?: boolean | null\n          isTester?: boolean | null\n          langsmith_langchain_api_key?: string | null\n          langsmith_langchain_endpoint?: string | null\n          langsmith_langchain_project?: string | null\n          language?: string | null\n          last_access?: string | null\n          last_name?: string | null\n          last_page?: string | null\n          location?: string | null\n          namespace?: string | null\n          openai_authTag?: string | null\n          openai_iv?: string | null\n          openaiapikey?: string | null\n          openaiorganization?: string | null\n          password?: string | null\n          pinecone_authTag?: string | null\n          pinecone_iv?: string | null\n          pineconeenv?: string | null\n          pineconekey?: string | null\n          plan_id?: string | null\n          plan_name?: string | null\n          provider?: string | null\n          referred_by?: string | null\n          role?: string | null\n          searchbyuser?: string | null\n          status?: string | null\n          tags?: string | null\n          tasks?: Json | null\n          tfa_secret?: string | null\n          theme?: string | null\n          title?: string | null\n          token?: string | null\n          username?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_plan_id_fkey'\n            columns: ['plan_id']\n            isOneToOne: false\n            referencedRelation: 'plan'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      user_profilings: {\n        Row: {\n          created_at: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          industry_profile: string\n          organization: string\n          profile: string\n          user_id?: string\n        }\n        Update: {\n          created_at?: string\n          industry_profile?: string\n          organization?: string\n          profile?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_profilings_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widget_domains: {\n        Row: {\n          created_at: string\n          id: number\n          name: string\n          widget_id: string | null\n        }\n        Insert: {\n          created_at?: string\n          id?: number\n          name: string\n          widget_id?: string | null\n        }\n        Update: {\n          created_at?: string\n          id?: number\n          name?: string\n          widget_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widget_domains_widget_id_fkey'\n            columns: ['widget_id']\n            isOneToOne: false\n            referencedRelation: 'widgets'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n      widgets: {\n        Row: {\n          agent_id: string | null\n          created_at: string\n          enabled: boolean\n          id: string\n          org_id: string\n          user_id: string\n        }\n        Insert: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id: string\n          user_id: string\n        }\n        Update: {\n          agent_id?: string | null\n          created_at?: string\n          enabled?: boolean\n          id?: string\n          org_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_widgets_agents_agent_id_fkey'\n            columns: ['agent_id']\n            isOneToOne: false\n            referencedRelation: 'agents'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_org_id_fkey'\n            columns: ['org_id']\n            isOneToOne: false\n            referencedRelation: 'organizations'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_widgets_agents_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'profiles'\n            referencedColumns: ['id']\n          },\n        ]\n      }\n    }\n    Views: {\n      chat_log_model_summary_30: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_60: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_7: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n      chat_log_model_summary_90: {\n        Row: {\n          average_first_token_response_time: number | null\n          hour: string | null\n          model: string | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      accept_invitation: {\n        Args: {\n          notification_id: string\n        }\n        Returns: boolean\n      }\n      add_user_to_organization: {\n        Args: {\n          target_email: string\n        }\n        Returns: boolean\n      }\n      admin_cancel_deletion: {\n        Args: {\n          marked_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_delete_user: {\n        Args: {\n          param_user_id: string\n        }\n        Returns: undefined\n      }\n      admin_get_latest_subscription_by_org_id: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          id: string\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n          last_payment_id: string\n          org_id: string\n          trial_end: string\n          cancel_at_period_end: boolean\n          canceled_at: string\n          plan_id: string\n        }[]\n      }\n      admin_get_marketplace_agents: {\n        Args: {\n          page?: number\n          row_count?: number\n          sort_by?: string\n        }\n        Returns:\n          Database['public']['CompositeTypes']['marketplace_agents_result']\n      }\n      admin_get_organization_data: {\n        Args: {\n          user_email: string\n          orgid: string\n        }\n        Returns: {\n          organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n        }[]\n      }\n      admin_get_organization_owner_data: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: {\n          user_id: string\n          email: string\n        }[]\n      }\n      admin_get_recent_user_ip: {\n        Args: {\n          user_id: string\n        }\n        Returns: string\n      }\n      admin_search_users_by_email_or_userid: {\n        Args: {\n          search?: string\n          userid?: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      admin_search_users_by_email_or_userid_test: {\n        Args: {\n          search?: string\n          userid?: string\n          page?: number\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n          total_records: number\n          total_pages: number\n        }[]\n      }\n      admin_search_users_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          user_data: Json\n          agreement: Json\n          profiling: Json\n          organization_list: Json[]\n          selected_organization: Json\n          agent_count: number\n          document_count: number\n          plan: Json[]\n          features: Json\n        }[]\n      }\n      append_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_tier_subscription: {\n        Args: {\n          param_customer_id?: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_free_trial: {\n        Args: {\n          param_customer_id: string\n          param_org_id?: string\n        }\n        Returns: undefined\n      }\n      cancel_non_stripe_subscription:\n        | {\n          Args: {\n            param_customer_id: string\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n        | {\n          Args: {\n            param_org_id?: string\n          }\n          Returns: undefined\n        }\n      change_organization_image: {\n        Args: {\n          orgid: string\n          image_url: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_agent_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_and_unfreeze_document_by_orgid_userid_or_apikey: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: undefined\n      }\n      check_email_registered: {\n        Args: {\n          email: string\n        }\n        Returns: boolean\n      }\n      create_agent: {\n        Args: {\n          template_id?: string\n          custom_name?: string\n          custom_prompt?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }\n      }\n      create_apikey: {\n        Args: {\n          apikey_name: string\n        }\n        Returns: {\n          created_at: string | null\n          id: string\n          key: string\n          last_used_at: string | null\n          name: string | null\n          user_id: string\n        }\n      }\n      create_documents_folder: {\n        Args: {\n          name: string\n          parent_folder_id?: string\n        }\n        Returns: undefined\n      }\n      delete_agent_by_agent_id_and_org_id_and_user_id: {\n        Args: {\n          agentid: string\n          orgid: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n        }[]\n      }\n      delete_marked_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_marketplace_agent: {\n        Args: {\n          agentid: string\n        }\n        Returns: undefined\n      }\n      delete_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      delete_user_from_org: {\n        Args: {\n          ou_id_to_delete: string\n        }\n        Returns: boolean\n      }\n      deselect_organization_for_frozen_members: {\n        Args: {\n          org_id_param: string\n        }\n        Returns: undefined\n      }\n      generate_agent_slug: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_active_organization_subscription: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_organization_subscription_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          plan_id: string\n          plan: string\n          daily_completion_count: number\n          files: number\n          max_agents: number\n          text_storage: number\n          status: Database['public']['Enums']['subscription_status']\n          created_at: string\n          begin_date: string\n          finish_date: string\n        }[]\n      }\n      get_active_plans_with_pricing: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_active_plans_with_pricing_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          description: string\n          status: boolean\n          trial_days: number\n          limits: Json\n          features: Json\n          pricing: Json\n        }[]\n      }\n      get_agent_and_selected_documents:\n        | {\n          Args: {\n            agentid: string\n            orgid: string\n            apikey?: string\n            userid?: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n        | {\n          Args: {\n            apikey: string\n            orgid: string\n            agentid: string\n          }\n          Returns: {\n            topk: number\n            model: string\n            temperature: number\n            name: string\n            prompt: string\n            documents_ids: string[]\n          }[]\n        }\n      get_agent_by_id_chat: {\n        Args: {\n          agentid: string\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          model: string\n          name: string\n          temperature: number\n          prompt: string\n          plan_name: string\n          daily_completion_count: number\n          user_id: string\n          user_email: string\n        }[]\n      }\n      get_agent_with_documents: {\n        Args: {\n          agentid: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          share_agent_type_id: number\n          selecteddocuments: Json\n          is_marketplace: boolean\n          tagline: string\n          description: string\n          tags: string[]\n        }[]\n      }\n      get_agent_with_documents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n          agent_documents: Json\n        }[]\n      }\n      get_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          slug: string\n          is_frozen: boolean\n          memory: number\n          is_marketplace: boolean\n        }[]\n      }\n      get_agents_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n          agentid?: string\n        }\n        Returns: {\n          agent_type: Database['public']['Enums']['agent_type'] | null\n          created_at: string\n          description: string | null\n          font: string | null\n          id: string\n          image: string | null\n          is_frozen: boolean\n          is_public: boolean\n          memory: number\n          model: string\n          name: string\n          org_id: string\n          palette: string | null\n          pincode: string | null\n          prompt: string | null\n          prompt_library: Json | null\n          share_agent_type_id: number | null\n          slug: string\n          status: Database['public']['Enums']['status']\n          temperature: number\n          topk: number\n          welcome: string | null\n        }[]\n      }\n      get_agents_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n          agentid?: string\n        }\n        Returns: {\n          id: string\n          org_id: string\n          created_at: string\n          pincode: string\n          is_public: boolean\n          welcome: string\n          image: string\n          agent_type: Database['public']['Enums']['agent_type']\n          name: string\n          prompt: string\n          model: string\n          description: string\n          temperature: number\n          topk: number\n          is_frozen: boolean\n        }[]\n      }\n      get_auth_credentials: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          inputuserid?: string\n        }\n        Returns: {\n          org_id: string\n          user_id: string\n        }[]\n      }\n      get_chunks: {\n        Args: {\n          org_id_in: string\n          api_key_in: string\n          user_id_in: string\n          searchquery: string\n          agentid: string\n        }\n        Returns: Json\n      }\n      get_colleagues: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_colleagues_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          profile_id: string\n          username: string\n          fullname: string\n          email: string\n          organization_id: string\n          organization_name: string\n          organization_image: string\n          daily_interactions: number\n          role: string\n          ou_id: string\n          is_frozen: boolean\n          status: Database['public']['Enums']['org_member_status']\n        }[]\n      }\n      get_crew_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          name: string\n          slug: string\n          image: string\n          description: string\n          tagline: string\n          tags: string[]\n        }[]\n      }\n      get_current_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          sel_org_id: string\n          daily_interactions: number\n          plan: Json\n        }[]\n      }\n      get_documents_from_api: {\n        Args: {\n          apikey?: string\n          userid?: string\n          orgid?: string\n          documentid?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n          is_frozen: boolean\n        }[]\n      }\n      get_email_by_user_id: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          email: string\n        }[]\n      }\n      get_last_user_session_ip: {\n        Args: {\n          userid: string\n        }\n        Returns: {\n          ip: string\n        }[]\n      }\n      get_latest_plan_by_customer_id: {\n        Args: {\n          customer_id_param: string\n        }\n        Returns: {\n          org_id: string\n          id: string\n          name: string\n          status: Database['public']['Enums']['subscription_status']\n          description: string\n          files: number\n          max_agents: number\n          max_marketplace_agents: number\n          organization_member_limit: number\n        }[]\n      }\n      get_limits_by_api_key_and_org_id: {\n        Args: {\n          apikey: string\n          orgid: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n        }[]\n      }\n      get_marketplace_agent_as_anonymous: {\n        Args: {\n          agentid: string\n          secret_key?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          is_frozen: boolean\n          prompt: string\n          org_id: string\n          memory: number\n        }[]\n      }\n      get_marketplace_agent_by_slug: {\n        Args: {\n          agent_slug: string\n        }\n        Returns: {\n          id: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          organization_image: string\n          organization_name: string\n          total_favorite_users: number\n          tags: string[]\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          user_rating: number\n        }[]\n      }\n      get_marketplace_agents: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_by_org_id: {\n        Args: {\n          orgid: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_agents_testo: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organization_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          featured: boolean\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorite_agent_by_id: {\n        Args: {\n          agentid: string\n          userid?: string\n        }\n        Returns: {\n          id: string\n          created_at: string\n          name: string\n          welcome: string\n          image: string\n          palette: string\n          font: string\n          prompt_library: Json\n          model: string\n          agent_type: Database['public']['Enums']['agent_type']\n          temperature: number\n          topk: number\n          is_public: boolean\n          pincode: string\n          status: Database['public']['Enums']['status']\n          description: string\n          slug: string\n          memory: number\n          is_frozen: boolean\n          prompt: string\n          original_org_id: string\n          org_id: string\n          is_installed: boolean\n        }[]\n      }\n      get_marketplace_favorites_agents: {\n        Args: {\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_marketplace_favorites_agents_by_org_id_and_api_key_or_user_: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          created_at: string\n          name: string\n          model: string\n          temperature: number\n          prompt: string\n          topk: number\n          welcome: string\n          status: Database['public']['Enums']['status']\n          id: string\n          image: string\n          org_id: string\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt_library: Json\n          palette: string\n          font: string\n          slug: string\n          is_frozen: boolean\n          product_detail_id: number\n          tagline: string\n          description: string\n          rating: number\n          total_rating_users: number\n          total_favorite_users: number\n          is_installed: boolean\n          user_rating: number\n          organization_name: string\n          organizations_image: string\n          organization_verified: boolean\n          marketplace_agent_org_id: string\n          tags: string[]\n        }[]\n      }\n      get_organization_owner_email: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          email: string\n        }[]\n      }\n      get_owned_organization_plan: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          owned_org_id: string\n          daily_interactions: number\n          email: string\n          plan: Json\n        }[]\n      }\n      get_personal_organization: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          user_id: string\n          id: string\n          customer_id: string\n          name: string\n          created_at: string\n          image: string\n          daily_interactions: number\n          status: Database['public']['Enums']['entity_status']\n        }[]\n      }\n      get_plan_limits: {\n        Args: {\n          orgid: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          max_agents: number\n          files: number\n          text_storage: number\n          daily_completion_count: number\n          plan_name: string\n          id: string\n          daily_max_tokens: number\n          daily_tokens: number\n          daily_max_usage: number\n          daily_usage: number\n          vision: boolean\n          user_org_id: string\n          plan_user_id: string\n          daily_interactions: number\n          user_email: string\n          distinct_id: string\n        }[]\n      }\n      get_plan_name_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: string\n      }\n      get_plan_trial_days_by_price_id: {\n        Args: {\n          price_id_param: string\n        }\n        Returns: number\n      }\n      get_refresh_tokens: {\n        Args: Record<PropertyKey, never>\n        Returns: unknown[]\n      }\n      get_usage_before_current_date: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          agent_id: string | null\n          channel: string\n          completion_token: number\n          embeddings_tokens: number\n          id: string\n          model: string\n          org_id: string | null\n          plan_name: string\n          prompt_token: number\n          session_id: string | null\n          source: string\n          start_date: string\n          type: Database['public']['Enums']['usage_type']\n          user_id: string | null\n        }[]\n      }\n      get_user_data_by_api_key_or_user_id: {\n        Args: {\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n          organizations: Json\n        }[]\n      }\n      get_user_profile: {\n        Args: {\n          user_id_param?: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_by_email: {\n        Args: {\n          user_email: string\n        }\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      get_user_profile_test: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          id: string\n          avatar_url: string\n          full_name: string\n          username: string\n          org_sel_id: string\n          organization_user: Json\n          features: Json\n          plan: Json\n        }[]\n      }\n      has_had_free_trial: {\n        Args: {\n          user_id_param?: string\n          org_id_param?: string\n        }\n        Returns: boolean\n      }\n      insert_tags_and_associate_with_agent: {\n        Args: {\n          tag_names: string[]\n          agentid: string\n        }\n        Returns: undefined\n      }\n      is_owner_or_admin: {\n        Args: {\n          orgid: string\n        }\n        Returns: boolean\n      }\n      mark_for_deletion: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      match_agent_chunks: {\n        Args: {\n          embedding_input: string\n          match_threshold: number\n          match_count: number\n          min_content_length: number\n          agent_id_input: string\n        }\n        Returns: {\n          id: string\n          document_name: string\n          content: string\n          similarity: number\n        }[]\n      }\n      match_agent_semantic_routes: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          semantic_routes_id: string\n          response: string\n          name: string\n          similarity: number\n        }[]\n      }\n      match_documents: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          content: string\n          metadata: Json\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_cohere: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n        }\n        Returns: {\n          id: number\n          metadata: Json\n          content: string\n          embedding: Json\n          similarity: number\n        }[]\n      }\n      match_documents_llama: {\n        Args: {\n          query_embedding: string\n          match_count?: number\n          filter?: Json\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          similarity: number\n        }[]\n      }\n      match_documents_llama_v2: {\n        Args: {\n          query_embedding: string\n          agentid: string\n          match_count?: number\n          similarity_threshold?: number\n        }\n        Returns: {\n          id: string\n          metadata: Json\n          document_id: string\n          document_metadata: Json\n          document_tokens: number\n          similarity: number\n        }[]\n      }\n      rename_organization: {\n        Args: {\n          new_name: string\n        }\n        Returns: boolean\n      }\n      reset_daily_interactions: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      set_agent_documents: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n        }\n        Returns: undefined\n      }\n      set_agent_documents_from_api: {\n        Args: {\n          agent_documents_list: string[]\n          documents_agent_id: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: undefined\n      }\n      update_agent_by_org_id_and_api_key_or_user_id: {\n        Args: {\n          orgid: string\n          apikey: string\n          userid: string\n          agentid: string\n          agent: Json\n        }\n        Returns: {\n          id: string\n          name: string\n          model: string\n          temperature: number\n          agent_type: Database['public']['Enums']['agent_type']\n          prompt: string\n          topk: number\n          welcome: string\n          is_public: boolean\n          pincode: string\n          image: string\n        }[]\n      }\n      update_daily_usage: {\n        Args: {\n          orgid: string\n          inputtokens: number\n          outputtokens: number\n          model: Database['public']['Enums']['models']\n        }\n        Returns: undefined\n      }\n      update_document_metada_from_api: {\n        Args: {\n          documentid: string\n          metadata_param: Json\n          apikey?: string\n          userid?: string\n          orgid?: string\n        }\n        Returns: undefined\n      }\n      update_subscriptions_status: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      update_user_data_by_api_key_or_user_id: {\n        Args: {\n          user_data: Json\n          apikey?: string\n          userid?: string\n        }\n        Returns: {\n          username: string\n          full_name: string\n          avatar_url: string\n        }[]\n      }\n      update_user_role: {\n        Args: {\n          ou_id: string\n          new_role: string\n        }\n        Returns: boolean\n      }\n      upsert_product_details: {\n        Args: {\n          v_agent_id: string\n          v_tagline: string\n          v_description: string\n        }\n        Returns: undefined\n      }\n      validate_document_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          created_at: string\n          file_id: string\n          user_id: string\n          name: string\n          id: string\n          org_id: string\n          file_type: Database['public']['Enums']['file_type']\n          metadata: Json\n          tokens: number\n          chunk_count: number\n          documents_folders_id: string\n        }[]\n      }\n      validate_document_ownership_from_api: {\n        Args: {\n          documentid: string\n          orgid?: string\n          userid?: string\n          apikey?: string\n        }\n        Returns: {\n          file_id: string\n        }[]\n      }\n      validate_max_agents: {\n        Args: {\n          orgid?: string\n          apikey?: string\n          userid?: string\n        }\n        Returns: Json\n      }\n    }\n    Enums: {\n      agent_type: 'qa' | 'other' | 'repository'\n      billing_interval: 'day' | 'week' | 'month' | 'year'\n      entity_status: 'active' | 'deleted'\n      file_type: 'text' | 'table' | 'repository'\n      git_provider: 'github' | 'gitlab' | 'bitbucket'\n      locale: 'es' | 'en'\n      models:\n        | 'gpt-4-turbo'\n        | 'gpt-4'\n        | 'gpt-4-vision'\n        | 'gpt-3.5-turbo-16k'\n        | 'gpt-3.5-turbo'\n        | 'claude-2.1'\n        | 'claude-instant-1.2'\n        | 'gemini-1.0-pro'\n        | 'text-embedding-ada-002'\n        | 'claude-3-sonnet'\n        | 'claude-3-haiku'\n        | 'command-r-plus'\n        | 'llama3-70b-8192'\n        | 'gemini-1.5-pro-latest'\n        | 'llama3-70b'\n        | 'gemini-1.5-flash'\n        | 'gpt-4o'\n        | 'codestral'\n        | 'claude-3.5-sonnet'\n      org_member_status: 'active' | 'pending' | 'invited' | 'frozen'\n      org_role: 'owner' | 'admin' | 'moderator' | 'member'\n      plan_data_source: 'stripe' | 'manual'\n      price_type: 'recurring' | 'one_time'\n      question_type: 'score' | 'comment' | 'like'\n      role: 'function' | 'system' | 'user' | 'assistant'\n      status: 'published' | 'draft'\n      subscription_status:\n        | 'active'\n        | 'past_due'\n        | 'unpaid'\n        | 'canceled'\n        | 'incomplete'\n        | 'incomplete_expired'\n        | 'trialing'\n        | 'paused'\n        | 'free_trial'\n      usage_type: 'TRAINING' | 'SEMANTIC_SEARCH' | 'CHAT' | 'FUNCTION'\n    }\n    CompositeTypes: {\n      agent_data: {\n        agent: unknown\n        agent_selected_documents:\n          | Database['public']['Tables']['agents_documents']['Row'][]\n          | null\n        documents: Database['public']['Tables']['documents']['Row'][] | null\n        messages: Database['public']['Tables']['messages']['Row'][] | null\n      }\n      get_chunks_result: {\n        constant_data: Json | null\n        matching_documents: Json[] | null\n      }\n      marketplace_agent_data: {\n        id: string | null\n        name: string | null\n        image: string | null\n        slug: string | null\n        welcome: string | null\n        description: string | null\n        agent_install_count: number | null\n        agent_message_count: number | null\n      }\n      marketplace_agents_result: {\n        total: number | null\n        total_installations: number | null\n        total_messages: number | null\n        agents_data:\n          | Database['public']['CompositeTypes']['marketplace_agent_data'][]\n          | null\n      }\n    }\n  }\n}\n\ntype PublicSchema = Database[Extract<keyof Database, 'public'>]\n\nexport type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (\n      & Database[PublicTableNameOrOptions['schema']]['Tables']\n      & Database[PublicTableNameOrOptions['schema']]['Views']\n    )\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database } ? (\n    & Database[PublicTableNameOrOptions['schema']]['Tables']\n    & Database[PublicTableNameOrOptions['schema']]['Views']\n  )[TableName] extends {\n    Row: infer R\n  } ? R\n  : never\n  : PublicTableNameOrOptions extends\n    keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    ? (PublicSchema['Tables'] & PublicSchema['Views'])[\n      PublicTableNameOrOptions\n    ] extends {\n      Row: infer R\n    } ? R\n    : never\n  : never\n\nexport type TablesInsert<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Insert: infer I\n  } ? I\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    } ? I\n    : never\n  : never\n\nexport type TablesUpdate<\n  PublicTableNameOrOptions extends keyof PublicSchema['Tables'] | {\n    schema: keyof Database\n  },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never,\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n    Update: infer U\n  } ? U\n  : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n    ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    } ? U\n    : never\n  : never\n\nexport type Enums<\n  PublicEnumNameOrOptions extends keyof PublicSchema['Enums'] | {\n    schema: keyof Database\n  },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never,\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n    ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never",
    "originFile": "\\types\\supabase.ts"
  },
  {
    "id": "\\types\\user::User",
    "language": "typescript",
    "label": "User",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user",
    "totalTokens": 143,
    "inDegree": 3,
    "outDegree": 5,
    "code": "interface User {\n  id: string\n  app_metadata: UserAppMetadata\n  user_metadata: UserMetadata\n  aud: string\n  confirmation_sent_at?: string\n  recovery_sent_at?: string\n  email_change_sent_at?: string\n  new_email?: string\n  new_phone?: string\n  invited_at?: string\n  action_link?: string\n  email?: string\n  phone?: string\n  created_at: string\n  confirmed_at?: string\n  email_confirmed_at?: string\n  phone_confirmed_at?: string\n  last_sign_in_at?: string\n  role?: string\n  updated_at?: string\n  identities?: UserIdentity[]\n  factors?: Factor[]\n}",
    "importStatements": [],
    "codeNoBody": "interface User {\n       //...\n       }",
    "originFile": "\\types\\user.ts"
  },
  {
    "id": "\\types\\user::Factor",
    "language": "typescript",
    "label": "Factor",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user",
    "totalTokens": 112,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface Factor {\n  /** ID of the factor. */\n  id: string\n\n  /** Friendly name of the factor, useful to disambiguate between multiple factors. */\n  friendly_name?: string\n\n  /**\n   * Type of factor. Only `totp` supported with this version but may change in\n   * future versions.\n   */\n  factor_type: 'totp' | string\n\n  /** Factor's status. */\n  status: 'verified' | 'unverified'\n\n  created_at: string\n  updated_at: string\n}",
    "importStatements": [],
    "codeNoBody": "interface Factor {\n//...\n}",
    "originFile": "\\types\\user.ts"
  },
  {
    "id": "\\types\\user::UserIdentity",
    "language": "typescript",
    "label": "UserIdentity",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user",
    "totalTokens": 56,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserIdentity {\n  id: string\n  user_id: string\n  identity_data?: {\n    [key: string]: any\n  }\n  provider: string\n  created_at?: string\n  last_sign_in_at?: string\n  updated_at?: string\n}",
    "importStatements": [],
    "codeNoBody": "interface UserIdentity {\n//...\n}",
    "originFile": "\\types\\user.ts"
  },
  {
    "id": "\\types\\user::UserMetadata",
    "language": "typescript",
    "label": "UserMetadata",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user",
    "totalTokens": 13,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserMetadata {\n  [key: string]: any\n}",
    "importStatements": [],
    "codeNoBody": "interface UserMetadata {\n//...\n}",
    "originFile": "\\types\\user.ts"
  },
  {
    "id": "\\types\\user::UserAppMetadata",
    "language": "typescript",
    "label": "UserAppMetadata",
    "type": "interface",
    "parent": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user",
    "totalTokens": 19,
    "inDegree": 4,
    "outDegree": 1,
    "code": "interface UserAppMetadata {\n  provider?: string\n  [key: string]: any\n}",
    "importStatements": [],
    "codeNoBody": "interface UserAppMetadata {\n//...\n}",
    "originFile": "\\types\\user.ts"
  },
  {
    "id": "\\types\\user",
    "language": "typescript",
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\api-vicuna-deno-main\\types\\user.ts",
    "type": "file",
    "totalTokens": 356,
    "inDegree": 0,
    "outDegree": 10,
    "code": "// deno-lint-ignore-file no-explicit-any\ninterface UserAppMetadata {\n  provider?: string\n  [key: string]: any\n}\n\ninterface UserMetadata {\n  [key: string]: any\n}\n\ninterface UserIdentity {\n  id: string\n  user_id: string\n  identity_data?: {\n    [key: string]: any\n  }\n  provider: string\n  created_at?: string\n  last_sign_in_at?: string\n  updated_at?: string\n}\n\ninterface Factor {\n  /** ID of the factor. */\n  id: string\n\n  /** Friendly name of the factor, useful to disambiguate between multiple factors. */\n  friendly_name?: string\n\n  /**\n   * Type of factor. Only `totp` supported with this version but may change in\n   * future versions.\n   */\n  factor_type: 'totp' | string\n\n  /** Factor's status. */\n  status: 'verified' | 'unverified'\n\n  created_at: string\n  updated_at: string\n}\n\nexport interface User {\n  id: string\n  app_metadata: UserAppMetadata\n  user_metadata: UserMetadata\n  aud: string\n  confirmation_sent_at?: string\n  recovery_sent_at?: string\n  email_change_sent_at?: string\n  new_email?: string\n  new_phone?: string\n  invited_at?: string\n  action_link?: string\n  email?: string\n  phone?: string\n  created_at: string\n  confirmed_at?: string\n  email_confirmed_at?: string\n  phone_confirmed_at?: string\n  last_sign_in_at?: string\n  role?: string\n  updated_at?: string\n  identities?: UserIdentity[]\n  factors?: Factor[]\n}\n",
    "importStatements": [],
    "codeNoBody": "// deno-lint-ignore-file no-explicit-any\ninterface UserAppMetadata {\n//...\n}\ninterface UserMetadata {\n//...\n}\n\ninterface UserIdentity {\n//...\n}\n\ninterface Factor {\n//...\n}\n\nexport interface User {\n       //...\n       }",
    "originFile": "\\types\\user.ts"
  }
]