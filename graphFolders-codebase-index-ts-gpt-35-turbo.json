{
  "\\src\\utils\\bitbucket": "# Bitbucket Utilities\n\n## Introduction\n\nThe `bitbucket` folder within the `src/utils` directory is designed to handle various utility functions related to Bitbucket's API. Its primary purpose is to facilitate the interaction with Bitbucket's OAuth2 authentication system, specifically focusing on refreshing access tokens. This ensures that authenticated sessions with Bitbucket remain active by automatically refreshing access tokens when they expire.\n\n## Directory Structure\n\n### File: `refresh-token.ts`\n\n#### Purpose:\nThe `refresh-token.ts` file is dedicated to managing the process of refreshing Bitbucket OAuth2 access tokens.\n\n#### Main Features:\n- **Function `refreshAccessToken`**:\n  - **Parameters**: Accepts a `refreshToken` string as input.\n  - **Functionality**: \n    - Sends a POST request to Bitbucket's OAuth2 access token endpoint.\n    - Utilizes the provided refresh token, client ID, and client secret (retrieved from environment variables) to request a new access token.\n  - **Output**: \n    - On success, it returns a new access token and refresh token.\n    - On failure, it logs an error message and returns `null`.\n\nThis utility is crucial for maintaining continuous authenticated sessions with Bitbucket by ensuring that access tokens are refreshed automatically when they expire.\n\n## Code Examples\n\n### Example: Refreshing an Access Token\n\nBelow is an example of how to use the `refreshAccessToken` function to refresh a Bitbucket OAuth2 access token.\n\n```typescript\nimport { refreshAccessToken } from './refresh-token';\n\n// Example usage of the refreshAccessToken function\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    \n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh tokens');\n        }\n    } catch (error) {\n        console.error('Error refreshing tokens:', error);\n    }\n}\n\nexampleUsage();\n```\n\nIn this example, the `refreshAccessToken` function is called with a refresh token. If the token refresh is successful, the new access and refresh tokens are logged to the console. If the refresh fails, an error message is logged.\n\nThis demonstrates how the `refreshAccessToken` function can be integrated into an application to manage Bitbucket OAuth2 tokens effectively.",
  "\\src\\utils\\gitlab": "# GitLab Utilities\n\n## Introduction\nThe `\\src\\utils\\gitlab` folder contains utility functions designed to interact with GitLab's API. These utilities are essential for tasks such as refreshing access tokens, which are crucial for maintaining authenticated sessions with GitLab. The primary functionality provided in this folder is encapsulated in the `refresh-token.ts` file.\n\n## Directory Structure\n```\n\\src\\utils\\gitlab\n    ├── refresh-token.ts\n```\n\n### Explanation of Important Files\n\n#### File: `refresh-token.ts`\n- **Purpose**: \n  - This file provides a utility function to refresh GitLab access tokens.\n- **Main Features**:\n  - **Function `refreshAccessToken`**: \n    - **Parameters**: \n      - `refreshToken` (string): The refresh token used to obtain a new access token.\n    - **Functionality**: \n      - Sends a POST request to the GitLab API to obtain a new access token using the provided refresh token.\n      - Utilizes client ID and client secret from environment variables for authentication.\n      - Returns a new access token and refresh token upon a successful request.\n      - Logs an error message and returns `null` if the request fails.\n\n## Code Examples\n\n### Refreshing GitLab Access Token\n\nThe following example demonstrates how to use the `refreshAccessToken` function to refresh a GitLab access token.\n\n```typescript\nimport { refreshAccessToken } from './refresh-token';\n\n// Example usage of refreshAccessToken function\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh access token.');\n        }\n    } catch (error) {\n        console.error('Error refreshing access token:', error);\n    }\n}\n\nexampleUsage();\n```\n\nIn this example, the `refreshAccessToken` function is called with a refresh token. If successful, it logs the new access and refresh tokens. If the request fails, it logs an error message.\n\nThis utility is essential for maintaining authenticated sessions with the GitLab API by refreshing tokens as needed.",
  "\\src\\communities": "# Documentation: `src/communities`\n\n## 1. Introduction\n\nThe `src/communities` folder is dedicated to constructing and analyzing graph data using community detection algorithms. Specifically, it leverages the Louvain algorithm to identify communities within a graph. The folder's primary functionality revolves around reading graph data from JSON files, processing this data to detect communities, and serving the results via an Express web server.\n\n## 2. Directory Structure\n\n### File: `communities.ts`\n\n#### Purpose:\nThe `communities.ts` file is the core script within the `src/communities` folder. It handles the entire workflow of graph construction, community detection, and data serving.\n\n#### Main Features:\n1. **Graph Construction**:\n   - Reads node and link data from JSON files specified by `nodesFilePath` and `linksFilePath`.\n   - Constructs a graph using the `Graphology` library, adding nodes and edges with their respective attributes.\n\n2. **Community Detection**:\n   - Utilizes the Louvain algorithm from the `graphology-communities-louvain` package to detect communities within the graph.\n   - Assigns detected community labels to the nodes.\n\n3. **Data Serving**:\n   - Sets up an Express server to serve the graph data in JSON format.\n   - Serves static HTML content to visualize the graph.\n\n4. **File Operations**:\n   - Saves the constructed graph and detected communities to JSON files (`myGraph.json` and `communities.json`).\n\n#### Key Functions:\n- `readJson(filePath: string)`: Reads and parses JSON data from a specified file path.\n- `constructGraphFromJson(nodesFilePath: string, linksFilePath: string)`: Constructs and returns a graph from the provided nodes and links JSON files.\n\n#### Execution:\nThe script is executed with Node.js, and it performs the following steps:\n1. Constructs the graph from JSON files.\n2. Detects communities within the graph.\n3. Saves the graph and community data to JSON files.\n4. Sets up an Express server to serve the graph data and static content.\n\n## 3. Code Examples\n\n### Example: Constructing and Serving a Graph with Community Detection\n\n```typescript\nconst fs = require(\"fs\").promises;\nimport { AllowedTypes } from \"../model/consts\";\nconst { Graph } = require(\"graphology\");\nconst louvain = require(\"graphology-communities-louvain\");\nimport ForceSupervisor from \"graphology-layout-force/worker\";\nconst sigma = require(\"sigma\");\nimport { v4 as uuid } from \"uuid\";\nconst express = require(\"express\");\nconst path = require(\"path\");\n\nconst projectId = \"judini-python-main\";\nconst folder_path = `../../test_files/`;\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\n\n// Function to read JSON files\nasync function readJson(filePath: string) {\n  // Implementation here...\n}\n\n// Function to construct graph from nodes and links\nasync function constructGraphFromJson(\n  nodesFilePath: string,\n  linksFilePath: string\n) {\n  // Implementation here...\n}\n\n(async () => {\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\n\n  // Detect communities using Louvain algorithm\n  const communities = louvain(graph);\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\n\n  // Assign community colors\n  graph.forEachNode((node: wikiNode, attr: string) => {\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\n  });\n\n  // Create Express app\n  const app = express();\n  const port = 8002;\n\n  // Serve the graph data\n  app.get(\"/\", (req: any, res: any) => {\n    res.json(graph.export());\n  });\n\n  // Serve the HTML file\n  app.use(express.static(path.join(__dirname, \"public\")));\n\n  app.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}`);\n  });\n})();\n```\n\n### Explanation:\n1. **Graph Construction**:\n   - The `constructGraphFromJson` function reads node and link data from JSON files and constructs a graph using the `Graphology` library.\n   \n2. **Community Detection**:\n   - The Louvain algorithm is applied to detect communities within the graph, and the results are saved to a JSON file.\n\n3. **Data Serving**:\n   - An Express server is set up to serve the graph data and static HTML content for visualization.\n\nThis example demonstrates how to read graph data, process it to detect communities, and serve the results using a web server, encapsulating the core functionalities of the `src/communities` folder.",
  "\\src\\queries": "# Documentation for `src/queries` Folder\n\n## Introduction\nThe `src/queries` folder is a crucial part of the `codebase-index-ts` repository, containing a collection of language-specific query definitions used for parsing and analyzing code structures. These queries leverage the Tree-sitter parsing library to extract and manipulate abstract syntax trees (ASTs) for various programming languages. This enables detailed code analysis, indexing, refactoring, and static analysis across different languages.\n\n## Directory Structure\nThe `src/queries` folder includes the following key files, each dedicated to a specific programming language:\n\n1. **`c.ts`**: Defines queries for analyzing C code.\n2. **`index.ts`**: Centralizes and exports all language-specific query objects.\n3. **`java.ts`**: Contains queries for parsing Java code.\n4. **`javascript.ts`**: Provides queries for analyzing JavaScript code.\n5. **`php.ts`**: Defines queries for extracting elements from PHP code.\n6. **`python.ts`**: Contains queries for parsing Python code.\n7. **`typescript.ts`**: Extends JavaScript queries to handle TypeScript-specific constructs.\n\n### Detailed File Descriptions\n\n#### 1. `c.ts`\n- **Purpose**: Defines a set of queries and templates for parsing and analyzing C code structures.\n- **Main Features**:\n  - **Import Statements**: Captures C preprocessor include statements.\n  - **Assignments**: Matches assignment statements within C code.\n  - **Definition Template**: Captures function and global assignment declarations.\n  - **Constructor Definitions**: Identifies constructor methods and other function definitions.\n  - **Function Calls**: Matches call expressions, capturing function names and arguments.\n  - **Any Assignments**: Matches general assignment statements.\n\n#### 2. `index.ts`\n- **Purpose**: Serves as a central hub for organizing and exporting language-specific query objects.\n- **Main Features**:\n  - **Language Queries Aggregation**: Imports and aggregates query objects for various languages.\n  - **Interface Definition**: Defines the `treeSitterQueries` interface to standardize queries across languages.\n\n#### 3. `java.ts`\n- **Purpose**: Defines queries for extracting elements from Java source code.\n- **Main Features**:\n  - **Import Statements**: Captures Java import declarations.\n  - **Constructor and Method Definitions**: Captures constructor and method declarations.\n  - **Package Declarations**: Extracts package declarations.\n  - **Variable Assignments**: Targets variable declarations and assignments.\n  - **Method Calls**: Extracts method invocations.\n  - **Extra Assignment Code**: Generates additional assignment code.\n\n#### 4. `javascript.ts`\n- **Purpose**: Defines queries for parsing and analyzing JavaScript code.\n- **Main Features**:\n  - **Import Statements**: Captures various forms of import statements.\n  - **Assignments**: Identifies variable assignments.\n  - **Definitions**: Captures function and arrow function definitions.\n  - **Constructor Definitions**: Detects constructor definitions.\n  - **Export Clauses**: Parses export statements.\n  - **Call Expressions**: Identifies different types of call expressions.\n  - **Any Assignments**: Captures assignment expressions and variable declarations.\n  - **Extra Assignment Code**: Generates additional JavaScript code for specific assignment patterns.\n\n#### 5. `php.ts`\n- **Purpose**: Defines queries for analyzing PHP code.\n- **Main Features**:\n  - **Import Statements**: Captures different types of import statements.\n  - **Assignments**: Identifies global assignments.\n  - **Constructor Definitions**: Captures class, method, function, and interface declarations.\n  - **Namespace Definitions**: Captures namespace definitions.\n  - **Function and Method Calls**: Extracts identifiers from function calls and member accesses.\n  - **Extra Assignment Code**: Generates additional assignment code.\n\n#### 6. `python.ts`\n- **Purpose**: Defines queries for analyzing Python code.\n- **Main Features**:\n  - **Import Statements**: Extracts various types of import statements.\n  - **Assignments**: Captures global assignment expressions.\n  - **Definitions**: Extracts function and class definitions.\n  - **Constructor Definitions**: Identifies function and class definitions.\n  - **Calls**: Identifies various types of calls.\n  - **Any Assignments**: Captures assignments and function definitions with typed parameters.\n  - **Extra Assignment Code**: Generates code snippets for specific assignment cases.\n\n#### 7. `typescript.ts`\n- **Purpose**: Extends JavaScript queries to handle TypeScript-specific constructs.\n- **Main Features**:\n  - **Import Statements**: Reuses JavaScript import statement queries.\n  - **Constructor Definitions**: Includes TypeScript interfaces, enums, and type alias declarations.\n  - **Definition Template**: Extracts method signatures and arrow functions.\n  - **Export Clauses**: Reuses JavaScript export clause queries.\n  - **Extra Assignment Code**: Reuses JavaScript additional assignment code.\n  - **Calls**: Includes type identifiers for method calls and type annotations.\n  - **Assignments**: Enhances JavaScript assignment queries to include function declarations with parameters and type annotations.\n\n## Code Examples\n\n### Example: Extracting Function Definitions in JavaScript\n```typescript\nconst definitionTemplate = `\n( _\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    [body: (_)\n    ; for types\n    value: (_)] @body\n)?\n; arrow function\n(variable_declarator\n    name: (_) @name\n    value: (arrow_function\n        parameters: (formal_parameters (_) @param)?\n        body: (_)? @body\n            )\n)?\n`;\n```\n\n### Example: Capturing Import Statements in Python\n```typescript\nconst importStatements = `\n(import_statement\n    name: [\n      (dotted_name) @module\n      (aliased_import name: _ @module alias: _ @alias)\n    ] ) @import_statement\n\n(import_from_statement\n    module_name: _ @module\n    name: [\n      (dotted_name) @name\n      (aliased_import name: _ @name alias: _ @alias)\n    ]?\n    (wildcard_import _ @wildcard)?\n    ) @import_statement\n`;\n```\n\n### Example: Identifying Method Calls in Java\n```typescript\nconst calls = `\n(method_invocation) @identifier.name\n(type_identifier) @parameter_type\n( _ object: _ @identifier.name)\n`;\n```\n\nBy consolidating and standardizing these queries, the `src/queries` folder provides a robust framework for analyzing and processing code across multiple programming languages, facilitating tasks such as code indexing, refactoring, and static analysis.",
  "\\src\\routes": "# \\src\\routes\n\n## Introduction\nThe `\\src\\routes` folder contains the API endpoint definitions for the codebase-index-ts repository. These endpoints handle various operations related to creating and updating graph representations of code repositories. The primary functionalities include request validation, authentication, repository handling, graph creation, and updating. The endpoints are designed to facilitate better code analysis and documentation by generating and managing graph data representing the code elements and their relationships.\n\n## Directory Structure\nThe `\\src\\routes` folder includes the following key files:\n\n1. **create_graph-test.ts**:\n   - Defines a POST endpoint for creating a graph representation of a codebase from a specified repository.\n   - Validates incoming JSON requests using `zod` and `zValidator`.\n   - Retrieves the commit hash of the specified branch, downloads, and extracts the repository.\n   - Initializes a `Codebase` object, parses the folder structure, and generates a simplified representation of the codebase.\n   - Creates a graph with nodes and links representing the code elements and their relationships.\n   - Returns the generated graph as a JSON response with error handling for failed repository downloads.\n\n2. **create_graph.ts**:\n   - Defines an API endpoint for creating graphs based on code repositories.\n   - Validates incoming JSON requests using `repoRequestValidator`.\n   - Extracts and verifies JWT from request headers for user authorization.\n   - Retrieves access tokens for the specified git provider.\n   - Fetches the latest commit hash for the specified repository and branch.\n   - Checks if the repository with the given commit hash already exists in the database and inserts a new record if not.\n   - Initiates the graph creation process by downloading and extracting the repository.\n   - Calls `processGraphCreation` to handle detailed graph creation tasks, including optional documentation generation.\n   - Returns appropriate JSON responses based on the success or failure of each step in the process.\n\n3. **graphs.ts**:\n   - Defines an endpoint for updating graph data associated with a specific Git repository.\n   - Defines a PATCH endpoint at `/:id` to update a specific graph.\n   - Validates the JWT token from the request header to authenticate the user.\n   - Fetches graph and repository details from the database based on the authenticated user and graph ID.\n   - Retrieves access tokens for the specified Git provider.\n   - Fetches the latest commit hash from the repository to determine if an update is needed.\n   - Updates the graph status in the database to 'updating' or 'completed' based on the commit hash comparison.\n   - Supports optional documentation generation for the graph nodes and links.\n   - Invokes the `updateGraph` function to update the graph using the provided repository details and marks the update as completed or failed.\n\n## Code Examples\n\n### create_graph-test.ts\n```typescript\nimport { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\n\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    user: z.string(),\n    repo: z.string(),\n    branch: z.string(),\n    token: z.string()\n  })\n)\n\nconst createGraphTest = new Hono()\n\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const { user: repoOrg, repo: repoName, branch, token: gitAccessToken } = request\n  console.time(repoName)\n  const gitProvider = 'github'\n  console.log({ gitProvider, repoOrg, repoName, branch })\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\n    if (!codebasePath) {\n      console.log('Failed to download repo')\n      return c.json({ message: 'Failed to download repo' }, 500)\n    }\n\n    const codebase = new Codebase(codebasePath)\n    const fileNodesMap = await codebase.parseFolder()\n    codebase.getCalls(fileNodesMap, false)\n    const nodes = codebase.simplify()\n    const links = codebase.getLinks()\n  \n    console.timeEnd(repoName)\n    return c.json({ graph: { nodes, links } })\n  } catch (error: any) {\n    console.log(error)\n    return c.json({ message: error.message }, 500)\n  }\n})\n\nexport { createGraphTest }\n```\n\n### create_graph.ts\n```typescript\nimport { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '../utils/utils'\nimport { GitServiceType } from '../utils/git'\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\n\nconst secret = getEnv('SUPABASE_JWT')\nconst repoRequestValidator = zValidator(\n  'json',\n  z.object({\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\n    repo_org: z.string(),\n    repo_name: z.string(),\n    branch: z.string(),\n    connection_id: z.string(),\n    gitlab_repo_id: z.number().optional(),\n    generate_documentation: z.boolean().optional()\n  })\n)\n\nconst createGraph = new Hono()\n\ncreateGraph.post('/', repoRequestValidator, async (c) => {\n  const request = c.req.valid('json')\n  const { git_provider: gitProvider, repo_org: repoOrg, repo_name: repoName, branch, connection_id: connectionId, gitlab_repo_id: gitlabRepoId, generate_documentation: generateDocBool } = request\n\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n  if (!jwt) {\n    return c.json({ message: 'Unauthorized' }, 401)\n  }\n\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\n  const userId = payload.sub\n\n  if (!userId) {\n    return c.json({ message: 'Unauthorized' }, 401)\n  }\n\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\n  const userOrgId = resOrg[0].org_sel_id\n\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n  if (!tokens) {\n    console.log('Failed to get access token')\n    return c.json({ message: 'Failed to get access token' }, 500)\n  }\n\n  const { accessToken, refreshToken } = tokens\n\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n  if (!commitHash) {\n    console.log('Failed to get commit')\n    return c.json({ message: 'Failed to get commit' }, 500)\n  }\n\n  // check if repo exists\n  const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE \n        git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n  let repoId = crypto.randomUUID()\n\n  if (rows.length == 0) {\n    const respository: Record<string, string | number> = {\n      id: repoId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      branch: branch,\n      commit_hash: commitHash\n    }\n\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\n\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\n\n    if (!res) {\n      console.log('Failed to create repository')\n      return c.json({ message: 'Failed to create repository' }, 500)\n    }\n  } else {\n    repoId = rows[0].id\n  }\n\n  const graphUsersData = await sql`\n    SELECT g.org_id, g.user_id\n    FROM nodes n -- must have at least one node\n    LEFT JOIN repositories r \n      ON n.repo_id = r.id\n    LEFT JOIN graphs g\n      ON g.repo_id = n.repo_id\n    WHERE\n      n.repo_id = ${repoId}\n      AND r.git_provider = ${gitProvider}\n      AND r.commit_hash = ${commitHash}`\n\n  let graphExists = false\n\n  // graph already exists with that commit\n  if (graphUsersData.length > 0) {\n    const orgIds = graphUsersData.map((row) => row.org_id)\n    const userIds = graphUsersData.map((row) => row.user_id)\n    // the user and org already have this graph\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\n      console.log('Graph already exists')\n      return c.json({ message: 'Graph already exists' }, 500)\n    }\n    graphExists = true\n  }\n\n  try {\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, accessToken, commitHash, gitlabRepoId)\n    // Perform background task\n    processGraphCreation({\n      gitProvider,\n      repoId,\n      userOrgId,\n      userId,\n      graphExists,\n      connectionId,\n      codebasePath,\n      repoName,\n      generateDocBool\n    })\n\n    return c.json({ message: 'Graph creation started' })\n  } catch (error: any) {\n    return c.json({ message: error.message }, 500)\n  }\n})\n\nasync function processGraphCreation({\n  gitProvider,\n  repoId,\n  userOrgId,\n  userId,\n  graphExists,\n  connectionId,\n  codebasePath,\n  repoName,\n  generateDocBool\n}: {\n  gitProvider: GitServiceType\n  repoId: string\n  userOrgId: string\n  userId: string\n  graphExists: boolean\n  connectionId: string\n  codebasePath: string\n  repoName: string\n  generateDocBool?: boolean\n}) {\n  //...\n}\n\nexport { createGraph }\n```\n\n### graphs.ts\n```typescript\nimport { Hono } from 'hono'\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\nimport { getEnv } from '../utils/utils'\nimport { jwtVerify } from 'jose'\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\n\nconst graphs = new Hono()\n\ngraphs.patch('/:id', async (c) => {\n  try {\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\n\n    if (!jwt) {\n      return c.json({ error: 'Unauthorized' }, 401)\n    }\n\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\n\n    const userId = payload.sub\n\n    if (!userId) {\n      return c.json({ error: 'Unauthorized' }, 401)\n    }\n\n    const graphId = c.req.param('id')\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\n\n    const graph = await sql`\n      SELECT\n        r.git_provider,\n        r.repo_org,\n        r.repo_name,\n        r.branch,\n        r.commit_hash,\n        r.gitlab_repo_id,\n        g.github_connection_id,\n        g.gitlab_connection_id,\n        g.bitbucket_connection_id,\n        p.org_sel_id\n      FROM profiles p\n      JOIN graphs g ON g.org_id = p.org_sel_id\n      JOIN repositories r ON g.repo_id = r.id\n      WHERE p.id = ${userId}\n        AND g.id = ${graphId}\n    `\n\n    if (graph.length === 0) {\n      return c.json({ error: 'Graph not found' }, 404)\n    }\n\n    const {\n      org_sel_id: userOrgId,\n      git_provider: gitProvider,\n      repo_org: repoOrg,\n      repo_name: repoName,\n      commit_hash: repoCommitHash,\n      branch,\n      gitlab_repo_id: gitlabRepoId,\n      github_connection_id,\n      gitlab_connection_id,\n      bitbucket_connection_id\n    } = graph[0]\n\n    const connections: Record<string, string | number> = {\n      github: github_connection_id,\n      gitlab: gitlab_connection_id,\n      bitbucket: bitbucket_connection_id\n    }\n\n    const connectionId = String(connections[gitProvider])\n\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\n\n    if (!tokens) {\n      console.log('Failed to get access token')\n      return c.json({ message: 'Failed to get access token' }, 500)\n    }\n\n    const { accessToken, refreshToken } = tokens\n\n    const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, accessToken, refreshToken, connectionId, gitlabRepoId)\n\n    if (!commitHash) {\n      console.log('Failed to get commit')\n      return c.json({ error: 'Failed to get commit' }, 400)\n    }\n\n    if (commitHash === repoCommitHash) {\n      if (generateDocBool) {\n        const rows = await sql`\n        SELECT \n          id\n        FROM repositories\n        WHERE git_provider = ${gitProvider}\n          AND repo_org = ${repoOrg}\n          AND repo_name = ${repoName}\n          AND branch = ${branch}\n          AND commit_hash = ${commitHash}\n        `\n  \n        if (rows.length > 0) {\n            const repoId = rows[0].id\n            const res = await Promise.all([\n              getGraphNodesById({userOrgId, graphId}),\n              getGraphLinksById({userOrgId, graphId}),\n              getGraphFolderById({userOrgId, graphId})])\n\n            const graphNodes = res[0]\n            const graphLinks = res[1]\n            const graphFolders = res[2]\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\n            }\n        }\n      }\n      return c.json({ message: 'Graph already up to date' }, 200)\n    }\n\n    await sql`\n      UPDATE graphs \n      SET \n        status = 'updating'\n      WHERE id = ${graphId}\n    `\n\n    const rows = await sql`\n      SELECT \n        id\n      FROM repositories\n      WHERE git_provider = ${gitProvider}\n        AND repo_org = ${repoOrg}\n        AND repo_name = ${repoName}\n        AND branch = ${branch}\n        AND commit_hash = ${commitHash}\n    `\n\n    if (rows.length > 0) {\n      await sql`\n        UPDATE graphs \n        SET \n          status = 'completed',\n          repo_id = ${rows[0].id}\n        WHERE id = ${graphId}\n      `\n\n      return c.json({ message: 'Graph updated' }, 200)\n    }\n\n    updateGraph({\n      gitProvider,\n      repoOrg,\n      repoName,\n      branch,\n      accessToken,\n      commitHash,\n      gitlabRepoId,\n      graphId,\n      generateDocBool\n    })\n\n    return c.json({ message: 'Graph updating' }, 200)\n  } catch (error) {\n    console.log('Error updating graph', error)\n    return c.json({ error: 'Error updating graph' }, 500)\n  }\n})\n\ninterface UpdateGraph {\n  //...\n}\n\nasync function updateGraph({\n  gitProvider,\n  repoOrg,\n  repoName,\n  branch,\n  accessToken,\n  commitHash,\n  gitlabRepoId,\n  graphId,\n  generateDocBool\n}: UpdateGraph) {\n  //...\n}\n\nexport { graphs }\n```",
  "\\src\\model": "# Folder: `\\src\\model`\n\n## Introduction\nThe `\\src\\model` folder is a crucial part of the `codebase-index-ts` repository, designed to model and manage various aspects of a codebase. It provides classes and utility functions to handle nodes, import statements, calls, assignments, and other elements within a codebase. This folder facilitates operations such as parsing files and folders, resolving imports, capturing calls and assignments, and managing code relationships.\n\n## Directory Structure\nThe `\\src\\model` folder contains the following important files:\n\n1. **calls.ts**\n2. **codebase.ts**\n3. **consts.ts**\n4. **utils.ts**\n\n### File: `calls.ts`\n#### Purpose\nThe `calls.ts` file captures and analyzes various elements such as calls, assignments, and nodes within a given file node. This is essential for understanding the structure and behavior of the codebase.\n\n#### Main Features\n- **Classes**\n  - **VariableAssignment**: Represents and handles variable assignments within the code.\n  - **CallIdentifier**: Stores information about a node's identifier and line number.\n  - **CallsCapturer**: Captures and stores calls, assignments, and nodes from a given file node.\n    - **Constructor**: Initializes the `fileNode` and populates `nodesMap` with aliases and corresponding nodes.\n    - **Methods**:\n      - `captureAssignments`: Captures instances of `VariableAssignment`.\n      - `captureCalls`: Captures instances of `CallIdentifier`.\n      - `getCallsFromNode`: Returns a mapping of node aliases to their corresponding numbers for further analysis.\n\n#### Code Examples\n```typescript\n// Example of capturing calls from a code string\nconst callsCapturer = new CallsCapturer(fileNode, true);\nconst calls = callsCapturer.captureCalls(codeString, nodeRef);\nconsole.log(calls);\n```\n\n### File: `codebase.ts`\n#### Purpose\nThe `codebase.ts` file models and manages a codebase by representing its structure and relationships through nodes. It provides classes and methods to handle import statements, nodes, and the entire codebase, facilitating operations such as adding, retrieving, and organizing nodes, parsing files and folders, resolving imports, and managing code relationships.\n\n#### Main Features\n- **ImportName Class**: Represents an import name with properties `name` and `alias`.\n- **ImportStatement Class**: Encapsulates details of an import statement.\n- **Node Class**: Represents a node in the codebase graph.\n- **Codebase Class**: Manages the entire codebase by organizing nodes and resolving spaces.\n- **NodeCallTuple Type**: Defines a tuple type for associating a node with its corresponding lines of code.\n- **Constants and Utilities**: Utilizes various constants and utility functions to support the operations of the classes.\n\n#### Code Examples\n```typescript\n// Example of parsing a folder and generating nodes\nconst codebase = new Codebase('/path/to/root/folder');\nconst nodes = await codebase.parseFolder();\nconsole.log(nodes);\n```\n\n### File: `consts.ts`\n#### Purpose\nThe `consts.ts` file defines various constants and type definitions used throughout the codebase to manage and process different programming languages and their specific characteristics.\n\n#### Main Features\n- **Language Definitions**: Defines a set of supported programming languages using `tree-sitter` parsers.\n- **Allowed Types**: Defines a union type `AllowedTypes` and an array `AllowedTypesArray`.\n- **Exclusion Lists**: Defines arrays for excluded folders and file extensions.\n- **Language Mappings**: Maps file extensions to programming languages, class constructor method names, keywords for referring to the current instance within classes, and index suffixes.\n- **Comment Types**: Lists different types of comments recognized by `tree-sitter`.\n\n### File: `utils.ts`\n#### Purpose\nThe `utils.ts` file provides a set of utility functions to facilitate file handling, parsing, and code analysis within a codebase. These utilities are essential for tasks such as retrieving files, calculating their sizes, parsing code using Tree-Sitter, and managing code dependencies.\n\n#### Main Features\n- **File Retrieval and Size Calculation**\n  - `getAllFiles`: Recursively retrieves all files in a given folder.\n  - `getTotalSize`: Calculates the total size in bytes of all files retrieved by `getAllFiles`.\n- **Tree-Sitter Integration**\n  - `getRequiredDefinitions`: Returns the Tree-Sitter parser and queries for a specified programming language.\n  - `captureQuery`: Uses Tree-Sitter to capture specific elements from code.\n- **Code Analysis and Manipulation**\n  - `cleanDefCaptures`: Cleans and filters captured elements from Tree-Sitter queries.\n  - `renameSource`: Modifies source names based on language-specific rules.\n  - `getCalledNode`: Retrieves a specific node from imported file nodes.\n- **Content Processing**\n  - `cleanAndSplitContent`: Cleans and splits a string content into an array of strings.\n- **Utility Functions**\n  - `firstConsecutiveDots`: Finds the length of the first consecutive dots at the beginning of a string.\n\n#### Code Examples\n```typescript\n// Example of retrieving all files in a folder\nconst files = await getAllFiles('/path/to/folder');\nconsole.log(files);\n```\n\n## Summary\nThe `\\src\\model` folder is essential for representing and managing the structure and relationships within a codebase. It provides comprehensive classes and utility functions for handling nodes, import statements, calls, assignments, and other elements, facilitating efficient code analysis and management.",
  "\\src\\tools": "# Documentation for `\\src\\tools` Folder\n\n## Introduction\nThe `\\src\\tools` folder is a crucial part of the codebase-index-ts repository, providing essential utilities and functions for managing and analyzing graph structures. These tools are designed to handle nodes and links within a graph, enabling functionalities such as data retrieval, similarity calculations, code extraction, and prompt generation. This folder is particularly important for tools that interact with graph-based representations of code repositories.\n\n## Directory Structure\nThe `\\src\\tools` folder mainly contains the `function_tools.ts` file, which houses the core functionalities required for graph management and analysis.\n\n### File: `function_tools.ts`\n#### Purpose\nThe `function_tools.ts` file offers a comprehensive set of utilities for managing and analyzing graph structures. It focuses on nodes and links within a graph, providing functionalities for retrieving graph data, calculating similarities, and generating descriptive prompts for user tools.\n\n#### Main Features\n1. **Graph Data Retrieval:**\n   - **`getGraphNodesById`**: Fetches graph nodes from a database based on `userOrgId` and `graphId`.\n   - **`getGraphLinksById`**: Retrieves graph links from a database using `userOrgId` and `graphId`.\n\n2. **Code Retrieval:**\n   - **`getCode`**: Recursively retrieves code snippets and related documentation from a graph structure based on node information (name or ID).\n\n3. **Similarity Calculation:**\n   - **`similarTo`**: Finds and returns the most similar node names to a given name based on Levenshtein distance, categorized by node type.\n   - **`topNSimilar`**: Helper function to calculate and return the top `n` similar nodes to a given name.\n\n4. **Language Analysis:**\n   - **`calculateLanguagePercentages`**: Calculates the percentage distribution of programming languages within the nodes.\n\n5. **Function Definitions for External Use:**\n   - **`getCodeDescription`**: Defines a function to retrieve code by node name.\n   - **`getCodebyNodeIdDescription`**: Defines a function to retrieve code by node ID.\n   - **`similarToDescription`**: Defines a function to find similar nodes by name.\n\n6. **User Tools and Prompt Generation:**\n   - **`getUserToolsAndPrompt`**: Retrieves nodes and links, categorizes them, calculates language percentages, and generates a prompt displaying the most common node IDs per type.\n\n#### Interfaces\n- **`Similarity`**: Defines the structure for similarity comparison with properties `id` and `score`.\n- **`nodeSeen`**: Defines a structure to track the visibility status of nodes within a graph.\n\n## Code Examples\nHere are some use cases demonstrating the core functionalities provided by the `function_tools.ts` file:\n\n### Example 1: Retrieving Graph Nodes and Links\n```typescript\nconst userOrgId = 'exampleOrgId';\nconst graphId = 'exampleGraphId';\n\nconst nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId });\nconst links: GraphLink[] = await getGraphLinksById({ userOrgId, graphId });\n\nconsole.log(nodes);\nconsole.log(links);\n```\n\n### Example 2: Finding Similar Nodes\n```typescript\nconst nodeName = 'exampleNodeName';\nconst similarNodes = similarTo(nodeName, nodes, 'all', 10);\n\nconsole.log(similarNodes);\n```\n\n### Example 3: Generating User Tools and Prompt\n```typescript\nconst userOrgId = 'exampleOrgId';\nconst graphId = 'exampleGraphId';\n\nconst { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt } = await getUserToolsAndPrompt(userOrgId, graphId);\n\nconsole.log(prompt);\n```\n\n### Example 4: Calculating Language Percentages\n```typescript\nconst languages = nodes.map(node => node.language);\nconst languagePercentages = calculateLanguagePercentages(languages);\n\nconsole.log(languagePercentages);\n```\n\n### Example 5: Retrieving Code by Node Name\n```typescript\nconst nodeName = 'exampleNodeName';\nconst code = await getCode(nodes, links, nodeName);\n\nconsole.log(code);\n```\n\n### Example 6: Retrieving Code by Node ID\n```typescript\nconst nodeId = 'example/path/file::exampleNodeName';\nconst code = await getCode(nodes, links, undefined, nodeId);\n\nconsole.log(code);\n```\n\nThis documentation provides an overview of the `\\src\\tools` folder and its functionalities, highlighting the importance of `function_tools.ts` in managing and analyzing graph structures within the codebase.",
  "\\src\\utils": "# Utils Folder Documentation\n\n## Introduction\n\nThe `utils` folder within the `src` directory is a collection of utility modules designed to support various functionalities across the application. These utilities include managing environment variables, interacting with Git service providers, handling database connections, and facilitating communication with external APIs like OpenAI, Bitbucket, and GitLab. The primary purpose of this folder is to provide reusable and centralized functions that can be leveraged throughout the codebase to maintain clean and efficient code.\n\n## Directory Structure\n\n```\n\\src\\utils\n    ├── ai.ts\n    ├── bitbucket\n    │   └── refresh-token.ts\n    ├── db.ts\n    ├── git.ts\n    ├── gitlab\n    │   └── refresh-token.ts\n    └── utils.ts\n```\n\n### Explanation of Important Files and Subfolders\n\n#### 1. **File: `ai.ts`**\n\n- **Purpose**: Facilitates interactions with the OpenAI API for generating chat completions.\n- **Main Features**:\n  - **Types**:\n    - `chatCompletionMessages`: An array of chat messages structured as per `OpenAI.Chat.Completions.ChatCompletionMessageParam`.\n  - **Interfaces**:\n    - `chatResponse`: Defines the structure of the response from the OpenAI API, including the AI's response and optionally the total tokens used.\n  - **Functions**:\n    - `getOpenAIChatCompletion`: Sends chat messages to the OpenAI API and returns a generated response.\n\n#### 2. **Subfolder: `bitbucket`**\n\n- **Purpose**: Contains utilities for interacting with Bitbucket's API, specifically for OAuth2 token management.\n- **Main Features**:\n  - **File: `refresh-token.ts`**:\n    - **Function `refreshAccessToken`**: Refreshes Bitbucket OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n#### 3. **File: `db.ts`**\n\n- **Purpose**: Manages database interactions, particularly with a PostgreSQL database.\n- **Main Features**:\n  - **Database Connection**: Establishes a connection to a PostgreSQL database using environment variables.\n  - **Interfaces**:\n    - `GraphNode`, `GraphLink`, `GraphFolder`: Define the structure for graph-related data.\n  - **Functions**:\n    - `getGraphNodesById`, `getGraphLinksById`, `getGraphFolderById`: Retrieve graph nodes, links, and folders from the database based on specific identifiers.\n\n#### 4. **File: `git.ts`**\n\n- **Purpose**: Provides utilities for interacting with Git service providers (GitHub, GitLab, Bitbucket).\n- **Main Features**:\n  - **Types**:\n    - `GitServiceType`: Specifies supported Git service providers.\n  - **Constants**:\n    - `MAXSIZE`: Defines the maximum allowed size for extracted repositories.\n  - **Functions**:\n    - `downloadAndExtractRepo`, `getCommitRepo`, `getCommitHash`, `getAccessToken`: Manage repository data, retrieve commit hashes, and handle access tokens.\n\n#### 5. **Subfolder: `gitlab`**\n\n- **Purpose**: Contains utilities for interacting with GitLab's API, specifically for OAuth2 token management.\n- **Main Features**:\n  - **File: `refresh-token.ts`**:\n    - **Function `refreshAccessToken`**: Refreshes GitLab OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n#### 6. **File: `utils.ts`**\n\n- **Purpose**: Manages and accesses environment variables required for the application's configuration.\n- **Main Features**:\n  - **Environment Variables Storage (`ENV_VARS`)**: Holds essential configuration details such as database credentials and authentication data.\n  - **Environment Variable Retrieval (`getEnv`)**: Retrieves environment variable values and ensures all necessary variables are present.\n\n## Code Examples\n\n### Example: Refreshing a Bitbucket Access Token\n\n```typescript\nimport { refreshAccessToken } from './bitbucket/refresh-token';\n\n// Example usage of the refreshAccessToken function\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    \n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh tokens');\n        }\n    } catch (error) {\n        console.error('Error refreshing tokens:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Refreshing a GitLab Access Token\n\n```typescript\nimport { refreshAccessToken } from './gitlab/refresh-token';\n\n// Example usage of refreshAccessToken function\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh access token.');\n        }\n    } catch (error) {\n        console.error('Error refreshing access token:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Using OpenAI Chat Completion\n\n```typescript\nimport { getOpenAIChatCompletion } from './ai';\n\n// Example usage of getOpenAIChatCompletion function\nasync function exampleUsage() {\n    const messages = [\n        { role: 'system', content: 'You are a helpful assistant.' },\n        { role: 'user', content: 'Tell me a joke.' }\n    ];\n    \n    try {\n        const response = await getOpenAIChatCompletion(messages);\n        console.log('AI Response:', response.response);\n    } catch (error) {\n        console.error('Error getting chat completion:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Retrieving Graph Nodes from Database\n\n```typescript\nimport { getGraphNodesById } from './db';\n\n// Example usage of getGraphNodesById function\nasync function exampleUsage() {\n    const userOrgId = 'user-org-id';\n    const graphId = 'graph-id';\n    \n    try {\n        const nodes = await getGraphNodesById({ userOrgId, graphId });\n        console.log('Graph Nodes:', nodes);\n    } catch (error) {\n        console.error('Error retrieving graph nodes:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Retrieving Environment Variables\n\n```typescript\nimport { getEnv } from './utils';\n\n// Example usage of getEnv function\nconst databaseHost = getEnv('DATABASE_HOST');\nconsole.log('Database Host:', databaseHost);\n```\n\nThis documentation provides an overview of the `utils` folder, detailing its purpose, structure, and key functionalities. The provided code examples demonstrate how to utilize the various utilities within this folder effectively.",
  "\\src\\wiki": "# Wiki Documentation for `\\src\\wiki` Folder\n\n## Introduction\n\nThe `\\src\\wiki` folder is a crucial component of the `codebase-index-ts` repository, designed to automate the process of generating comprehensive documentation for a codebase. This folder contains scripts that analyze the structure and relationships within the codebase, generate graph representations, and produce detailed documentation using AI models. The main functionalities include parsing the codebase, constructing graphs, and generating documentation for nodes, files, and folders.\n\n## Directory Structure\n\nThe `\\src\\wiki` folder contains the following key files:\n\n1. **`test-wiki.ts`**:\n    - **Purpose**: Parses the codebase, generates a graph representation, and creates documentation using an AI model.\n    - **Main Features**:\n        - Initializes a `Codebase` object.\n        - Parses and simplifies the codebase.\n        - Generates nodes and links with unique UUIDs.\n        - Utilizes `generateDocumentation` to produce documentation.\n        - Outputs the generated data to JSON files.\n\n2. **`utils.ts`**:\n    - **Purpose**: Provides utility functions to analyze and document nodes and links within a graph structure.\n    - **Main Features**:\n        - Calculates language usage percentages.\n        - Categorizes nodes by type.\n        - Identifies frequently used nodes.\n        - Determines parent file nodes.\n        - Constructs graph objects.\n        - Performs breadth-first search to determine node levels.\n        - Generates prompts and documentation for nodes.\n        - Documents nodes by levels and folders.\n\n3. **`wiki.ts`**:\n    - **Purpose**: Handles the generation and updating of documentation for a repository.\n    - **Main Features**:\n        - `generateDocumentation`: Creates documentation for a repository by constructing a graph and organizing nodes by levels and folders.\n        - `generateAndUpdateDocumentation`: Extends `generateDocumentation` by updating or inserting the documentation into a database.\n\n4. **`wikiGuille.ts`**:\n    - **Purpose**: Generates comprehensive documentation for a codebase by analyzing its structure and relationships.\n    - **Main Features**:\n        - Processes nodes and links from JSON files.\n        - Constructs graphs representing calls and definitions.\n        - Generates documentation for nodes, files, and folders using the OpenAI API.\n        - Performs BFS to traverse the graph.\n        - Creates a markdown wiki page with the aggregated documentation.\n        - Includes utility functions for reading JSON files, calculating elapsed time, and tokenizing content.\n        - Outputs the generated documentation to JSON files and a final markdown file.\n\n## Code Examples\n\n### Example 1: Parsing and Documenting a Codebase (`test-wiki.ts`)\n\n```typescript\nimport { fstat } from \"fs\";\nimport { Codebase } from \"../model/codebase\";\nimport { GraphLink, GraphNode } from \"../utils/db\";\nimport { generateDocumentation } from \"./wiki\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport fs from \"fs/promises\";\n\n(async () => {\n  const repoName = \"codebase-index-ts\";\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\n  const codebase = new Codebase(codebasePath);\n  console.log(\"Parsing folders ..\");\n  const fileNodesMap = await codebase.parseFolder();\n  console.log(\"Getting calls ..\");\n  codebase.getCalls(fileNodesMap, false);\n  const nodes = codebase.simplify();\n\n  const nodeDBIds: { [key: string]: string } = {};\n  for (const node of nodes) {\n    nodeDBIds[node.id] = uuidv4();\n  }\n\n  const grapNodes: GraphNode[] = nodes.map((n) => {\n    return {\n      id: nodeDBIds[n.id],\n      fullName: n.id.replace(codebasePath, \"\"),\n      type: n.type,\n      language: n.language,\n      documentation: n.documentation,\n      code: n.code,\n      codeNoBody: n.codeNoBody,\n      totalTokens: 0,\n      inDegree: 0,\n      outDegree: 0,\n      label: n.label,\n      originFile: n.originFile,\n      generatedDocumentation: \"\",\n      importStatements: n.importStatements.join(\"\\n\"),\n    };\n  });\n\n  const links = codebase.getLinks();\n\n  const graphLinks: GraphLink[] = links.map((l) => {\n    return {\n      id: uuidv4(),\n      source: nodeDBIds[l.source],\n      target: nodeDBIds[l.target],\n      label: l.label,\n      line: l.line,\n    };\n  });\n\n  const model = \"gpt-3.5-turbo\";\n\n  const documentedFolders = await generateDocumentation(\n    grapNodes,\n    graphLinks,\n    repoName,\n    model\n  );\n\n  const modelNoDots = model.replaceAll(\".\", \"\");\n\n  fs.writeFile(\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(grapNodes, null, 2)\n  );\n  fs.writeFile(\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(documentedFolders, null, 2)\n  );\n})();\n```\n\n### Example 2: Utility Function for Calculating Language Percentages (`utils.ts`)\n\n```typescript\nfunction calculateLanguagePercentages(\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\n) {\n  const languageCounts: { [language: string]: number } = {};\n  let totalNodes = 0;\n\n  for (const type in nodesPerType) {\n    for (const node of nodesPerType[type]) {\n      if (node.language) {\n        languageCounts[node.language] = (languageCounts[node.language] || 0) + 1;\n        totalNodes++;\n      }\n    }\n  }\n\n  const languagePercentages: { [language: string]: number } = {};\n  for (const language in languageCounts) {\n    languagePercentages[language] = (languageCounts[language] / totalNodes) * 100;\n  }\n\n  return languagePercentages;\n}\n```\n\n### Example 3: Generating Documentation for a Repository (`wiki.ts`)\n\n```typescript\nimport { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\n\nexport async function generateDocumentation(\n  nodes: GraphNode[],\n  links: GraphLink[],\n  repoName: string,\n  model: string = 'gpt-4o-mini'\n) {\n  const graph = buildGraphs(nodes, links);\n  const nodeIdsByLevels = bfsLevels(nodes, graph);\n\n  await documentNodesByLevels(nodeIdsByLevels, nodes, graph, repoName, model);\n  const documentedFolders = await documentFolders(nodes, links, repoName, model);\n\n  return documentedFolders;\n}\n```\n\n### Example 4: Creating a Wiki Page (`wikiGuille.ts`)\n\n```typescript\n(async () => {\n  const startTime = new Date();\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath);\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\");\n\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\n  const links: wikiLink[] = await readJson(linksPath);\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links);\n\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\n  const startNodes = findStartNodes(callGraph);\n\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes);\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\n\n  const fileToNodes = nodesWithFiles\n    .filter((item: wikiNode) => item.type === \"file\")\n    .reduce((acc: any, item: any) => {\n      acc[item.label] = [];\n      return acc;\n    }, {});\n  console.log(fileToNodes);\n  const filesDocumentation = await classifyAndDocumentFiles(\n    fileToNodes,\n    nodesWithFiles,\n    usedNodes\n  );\n  await fs2.writeFile(\n    \"filesDocumentation.json\",\n    JSON.stringify(filesDocumentation, null, 2)\n  );\n  const folderDocumentation = await documentFolders(filesDocumentation);\n  await fs2.writeFile(\n    \"folderDocumentation.json\",\n    JSON.stringify(folderDocumentation, null, 2)\n  );\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\n  console.log(\"Total tokens used: \", totalTokensUsed);\n  const endTime = new Date();\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\n})();\n```\n\n## Conclusion\n\nThe `\\src\\wiki` folder is a powerful tool for automating the documentation process of a codebase. By leveraging AI models and various utility functions, it simplifies the task of understanding and documenting complex code structures. This folder is essential for developers looking to maintain comprehensive and up-to-date documentation for their projects.",
  "\\tests": "# Tests Folder Documentation\n\n## Introduction\nThe `tests` folder contains a comprehensive suite of unit tests designed to validate the functionality of the `Node` and `Codebase` classes, as well as various utility functions within the `codebase-index-ts` project. These tests cover multiple programming languages, including C, Java, JavaScript, PHP, Python, and TypeScript, ensuring that the codebase indexing and analysis functionalities are robust and accurate across different code structures and relationships.\n\n## Directory Structure\nThe `tests` folder includes the following test files, each focusing on a specific programming language or utility function:\n\n1. **c.test.ts**: Tests for C language code structures.\n2. **java.test.ts**: Tests for Java code parsing and analysis.\n3. **javascript.test.ts**: Tests for JavaScript and TypeScript code handling.\n4. **php.test.ts**: Tests for PHP code parsing and indexing.\n5. **python.test.ts**: Tests for Python code structures and relationships.\n6. **utils.test.ts**: Tests for utility functions and graph-related operations.\n\n### Important Files and Their Roles\n\n#### c.test.ts\n- **Purpose**: Validates the functionality of the `Node` and `Codebase` classes in handling C language code structures.\n- **Main Features**:\n  - Import Statements Test\n  - Assignments Test\n  - Function Definition Test\n  - Struct Definition Test\n  - Union Definition Test\n  - Header File Test\n  - Function Calls Test\n\n#### java.test.ts\n- **Purpose**: Ensures correct parsing and analysis of Java code within the codebase.\n- **Main Features**:\n  - Import Statements Test\n  - Class Definition Test\n  - Code without Body Test\n  - Calls Test\n\n#### javascript.test.ts\n- **Purpose**: Validates the parsing and analysis of JavaScript and TypeScript code.\n- **Main Features**:\n  - Import Statements Parsing\n  - Assignments Parsing\n  - Function Definitions\n  - Class Definitions\n  - Code Without Body Extraction\n  - Function and Method Calls\n\n#### php.test.ts\n- **Purpose**: Ensures the robustness of PHP code parsing and indexing functionalities.\n- **Main Features**:\n  - Testing Import Statements\n  - Global Variable Assignments\n  - Function Definitions\n  - Class Definitions\n  - Namespace Handling\n  - Function and Method Calls\n\n#### python.test.ts\n- **Purpose**: Validates the functionality of parsing and analyzing Python code.\n- **Main Features**:\n  - Import Statements Test\n  - Assignments Test\n  - Function Definition Test\n  - Class Definition Test\n  - Code Without Body Test\n  - Calls Test\n\n#### utils.test.ts\n- **Purpose**: Tests utility functions and graph-related operations within the codebase.\n- **Main Features**:\n  - Testing Utility Functions (e.g., `cleanAndSplitContent`, `renameSource`)\n  - Graph and Wiki Utilities (e.g., BFS Levels, Graph Building)\n  - Capture Queries (e.g., Import Statements, Constructor Definitions)\n\n## Code Examples\n\n### Example from `c.test.ts`\n```typescript\ntest('Import Statements', () => {\n    const fileContent = `\n    #include <stdio.h>\n    #include \"myHeader.h\"\n    #include \"../otherFolder/otherHeader.h\"\n    `;\n\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\n    fileNode.generateImports();\n\n    const expectedImports = [\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined, `#include <stdio.h>`),\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined, `#include \"myHeader.h\"`),\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined, `#include \"../otherFolder/otherHeader.h\"`),\n    ];\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\n});\n```\n\n### Example from `java.test.ts`\n```typescript\ntest('Class definition', () => {\n    const fileContent = `\npackage file;\n\n/**\n * The FooClass documentation\n */\npublic class FooClass {\n    private int foo = 1;\n\n    public FooClass() {\n        this.foo = 1;\n    }\n\n    public int bar() {\n        return 1;\n    }\n}\n`;\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\n    fileNode.getChildrenDefinitions();\n    const packageChildren = Object.values(fileNode.children)[0];\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children']);\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\n\n    const expectedFileChildren = [\n        {\n            id: `${fileNode.id}::file`,\n            type: 'package',\n            name: 'file',\n            label: 'file',\n            language: 'java',\n            exportable: true,\n            documentation: \"\",\n            code: `package file;\n\n/**\n * The FooClass documentation\n */\npublic class FooClass {\n    private int foo = 1;\n\n    public FooClass() {\n        this.foo = 1;\n    }\n\n    public int bar() {\n        return 1;\n    }\n}`,\n            parent: fileNode.id,\n            inDegree: 1,\n            outDegree: 1,\n            children: [`${fileNode.id}::FooClass`],\n        },\n    ];\n\n    const expectedClass = {\n        id: `${fileNode.id}::FooClass`,\n        type: 'class',\n        name: 'FooClass',\n        label: 'FooClass',\n        language: 'java',\n        exportable: true,\n        documentation: \"/**\\n * The FooClass documentation\\n */\",\n        code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\n        parent: `${fileNode.id}::file`,\n        inDegree: 2,\n        outDegree: 1,\n        children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\n    };\n\n    const expectedMethods = [\n        {\n            id: `${fileNode.id}::FooClass.bar`,\n            type: 'method',\n            name: 'FooClass.bar',\n            label: 'FooClass.bar',\n            language: 'java',\n            exportable: true,\n            documentation: '',\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\n            parent: `${fileNode.id}::FooClass`,\n            inDegree: 0,\n            outDegree: 1\n        },\n        {\n            id: `${fileNode.id}::FooClass.FooClass`,\n            type: 'method',\n            name: 'FooClass.FooClass',\n            label: 'FooClass.FooClass',\n            language: 'java',\n            exportable: true,\n            documentation: '',\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\n            parent: `${fileNode.id}::FooClass`,\n            inDegree: 0,\n            outDegree: 1\n        },\n    ];\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\n    expect(fileNode.inDegree).toBe(1);\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\n});\n```\n\n### Example from `utils.test.ts`\n```typescript\ndescribe('Common', () => {\n    test('cleanAndSplitContent: Get each element', () => {\n        const content = '[first, [second: third], (fourth)]';\n        const result = utils.cleanAndSplitContent(content);\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth']);\n    });\n});\n```\n\n## Conclusion\nThe `tests` folder plays a crucial role in ensuring the reliability and accuracy of the `codebase-index-ts` project. By covering a wide range of programming languages and utility functions, these tests provide comprehensive validation of the codebase's indexing and analysis capabilities, ensuring robust performance across different code structures and relationships.",
  "\\src": "# Documentation for `src` Folder\n\n## Introduction\n\nThe `src` folder is the core of the `codebase-index-ts` repository, containing various subfolders and files that manage different aspects of the application. This folder includes utilities for interacting with external APIs, handling graph data, managing codebase models, and generating documentation. The primary purpose of the `src` folder is to provide a structured and organized codebase that facilitates code analysis, graph generation, and documentation.\n\n## Directory Structure\n\nThe `src` folder includes the following key subfolders and files:\n\n1. **`utils`**: Contains utility functions and modules for interacting with external APIs, managing environment variables, and handling database connections.\n2. **`communities`**: Focuses on constructing and analyzing graph data using community detection algorithms.\n3. **`queries`**: Contains language-specific query definitions for parsing and analyzing code structures.\n4. **`routes`**: Defines API endpoints for creating and updating graph representations of code repositories.\n5. **`model`**: Provides classes and utility functions to model and manage various aspects of a codebase.\n6. **`tools`**: Offers utilities for managing and analyzing graph structures.\n7. **`wiki`**: Automates the process of generating comprehensive documentation for a codebase.\n8. **`index.ts`**: The main entry point for the Node.js server application.\n\n### Detailed Subfolder and File Descriptions\n\n### 1. `utils`\n\nThe `utils` folder contains various utility modules designed to support different functionalities across the application.\n\n#### Subfolder: `bitbucket`\n\n- **Purpose**: Contains utilities for interacting with Bitbucket's API, specifically for OAuth2 token management.\n- **File: `refresh-token.ts`**:\n  - **Function `refreshAccessToken`**: Refreshes Bitbucket OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n#### Subfolder: `gitlab`\n\n- **Purpose**: Contains utilities for interacting with GitLab's API, specifically for OAuth2 token management.\n- **File: `refresh-token.ts`**:\n  - **Function `refreshAccessToken`**: Refreshes GitLab OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n#### File: `ai.ts`\n\n- **Purpose**: Facilitates interactions with the OpenAI API for generating chat completions.\n- **Function `getOpenAIChatCompletion`**: Sends chat messages to the OpenAI API and returns a generated response.\n\n#### File: `db.ts`\n\n- **Purpose**: Manages database interactions, particularly with a PostgreSQL database.\n- **Functions**: `getGraphNodesById`, `getGraphLinksById`, `getGraphFolderById`.\n\n#### File: `git.ts`\n\n- **Purpose**: Provides utilities for interacting with Git service providers (GitHub, GitLab, Bitbucket).\n- **Functions**: `downloadAndExtractRepo`, `getCommitRepo`, `getCommitHash`, `getAccessToken`.\n\n#### File: `utils.ts`\n\n- **Purpose**: Manages and accesses environment variables required for the application's configuration.\n- **Function `getEnv`**: Retrieves environment variable values and ensures all necessary variables are present.\n\n### 2. `communities`\n\nThe `communities` folder is dedicated to constructing and analyzing graph data using community detection algorithms.\n\n#### File: `communities.ts`\n\n- **Purpose**: Handles the entire workflow of graph construction, community detection, and data serving.\n- **Main Features**:\n  - Graph Construction\n  - Community Detection\n  - Data Serving\n  - File Operations\n\n### 3. `queries`\n\nThe `queries` folder contains language-specific query definitions used for parsing and analyzing code structures.\n\n#### Files:\n- **`c.ts`**: Defines queries for analyzing C code.\n- **`index.ts`**: Centralizes and exports all language-specific query objects.\n- **`java.ts`**: Contains queries for parsing Java code.\n- **`javascript.ts`**: Provides queries for analyzing JavaScript code.\n- **`php.ts`**: Defines queries for extracting elements from PHP code.\n- **`python.ts`**: Contains queries for parsing Python code.\n- **`typescript.ts`**: Extends JavaScript queries to handle TypeScript-specific constructs.\n\n### 4. `routes`\n\nThe `routes` folder contains the API endpoint definitions for the codebase-index-ts repository.\n\n#### Files:\n- **`create_graph-test.ts`**: Defines a POST endpoint for creating a graph representation of a codebase from a specified repository.\n- **`create_graph.ts`**: Defines an API endpoint for creating graphs based on code repositories.\n- **`graphs.ts`**: Defines an endpoint for updating graph data associated with a specific Git repository.\n\n### 5. `model`\n\nThe `model` folder is designed to model and manage various aspects of a codebase.\n\n#### Files:\n- **`calls.ts`**: Captures and analyzes various elements such as calls, assignments, and nodes within a given file node.\n- **`codebase.ts`**: Models and manages a codebase by representing its structure and relationships through nodes.\n- **`consts.ts`**: Defines various constants and type definitions used throughout the codebase.\n- **`utils.ts`**: Provides a set of utility functions to facilitate file handling, parsing, and code analysis within a codebase.\n\n### 6. `tools`\n\nThe `tools` folder provides essential utilities and functions for managing and analyzing graph structures.\n\n#### File: `function_tools.ts`\n\n- **Purpose**: Offers a comprehensive set of utilities for managing and analyzing graph structures.\n- **Main Features**:\n  - Graph Data Retrieval\n  - Code Retrieval\n  - Similarity Calculation\n  - Language Analysis\n  - Function Definitions for External Use\n  - User Tools and Prompt Generation\n\n### 7. `wiki`\n\nThe `wiki` folder automates the process of generating comprehensive documentation for a codebase.\n\n#### Files:\n- **`test-wiki.ts`**: Parses the codebase, generates a graph representation, and creates documentation using an AI model.\n- **`utils.ts`**: Provides utility functions to analyze and document nodes and links within a graph structure.\n- **`wiki.ts`**: Handles the generation and updating of documentation for a repository.\n- **`wikiGuille.ts`**: Generates comprehensive documentation for a codebase by analyzing its structure and relationships.\n\n### 8. `index.ts`\n\nThe `index.ts` file serves as the main entry point for a Node.js server application built with the Hono framework.\n\n- **Purpose**: Sets up the server, defines routes, and handles the processing of codebase data to generate graph representations.\n- **Main Features**:\n  - Server Initialization\n  - Root Route (\"/\")\n  - API Routes\n  - Server Execution\n\n## Code Examples\n\n### Example: Refreshing a Bitbucket Access Token\n\n```typescript\nimport { refreshAccessToken } from './bitbucket/refresh-token';\n\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    \n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh tokens');\n        }\n    } catch (error) {\n        console.error('Error refreshing tokens:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Constructing and Serving a Graph with Community Detection\n\n```typescript\nconst fs = require(\"fs\").promises;\nimport { AllowedTypes } from \"../model/consts\";\nconst { Graph } = require(\"graphology\");\nconst louvain = require(\"graphology-communities-louvain\");\nimport ForceSupervisor from \"graphology-layout-force/worker\";\nconst sigma = require(\"sigma\");\nimport { v4 as uuid } from \"uuid\";\nconst express = require(\"express\");\nconst path = require(\"path\");\n\nconst projectId = \"judini-python-main\";\nconst folder_path = `../../test_files/`;\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\n\nasync function readJson(filePath: string) {\n  // Implementation here...\n}\n\nasync function constructGraphFromJson(\n  nodesFilePath: string,\n  linksFilePath: string\n) {\n  // Implementation here...\n}\n\n(async () => {\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\n\n  const communities = louvain(graph);\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\n\n  graph.forEachNode((node: wikiNode, attr: string) => {\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\n  });\n\n  const app = express();\n  const port = 8002;\n\n  app.get(\"/\", (req: any, res: any) => {\n    res.json(graph.export());\n  });\n\n  app.use(express.static(path.join(__dirname, \"public\")));\n\n  app.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}`);\n  });\n})();\n```\n\n### Example: Using OpenAI Chat Completion\n\n```typescript\nimport { getOpenAIChatCompletion } from './ai';\n\nasync function exampleUsage() {\n    const messages = [\n        { role: 'system', content: 'You are a helpful assistant.' },\n        { role: 'user', content: 'Tell me a joke.' }\n    ];\n    \n    try {\n        const response = await getOpenAIChatCompletion(messages);\n        console.log('AI Response:', response.response);\n    } catch (error) {\n        console.error('Error getting chat completion:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Parsing and Documenting a Codebase\n\n```typescript\nimport { fstat } from \"fs\";\nimport { Codebase } from \"../model/codebase\";\nimport { GraphLink, GraphNode } from \"../utils/db\";\nimport { generateDocumentation } from \"./wiki\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport fs from \"fs/promises\";\n\n(async () => {\n  const repoName = \"codebase-index-ts\";\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\n  const codebase = new Codebase(codebasePath);\n  console.log(\"Parsing folders ..\");\n  const fileNodesMap = await codebase.parseFolder();\n  console.log(\"Getting calls ..\");\n  codebase.getCalls(fileNodesMap, false);\n  const nodes = codebase.simplify();\n\n  const nodeDBIds: { [key: string]: string } = {};\n  for (const node of nodes) {\n    nodeDBIds[node.id] = uuidv4();\n  }\n\n  const grapNodes: GraphNode[] = nodes.map((n) => {\n    return {\n      id: nodeDBIds[n.id],\n      fullName: n.id.replace(codebasePath, \"\"),\n      type: n.type,\n      language: n.language,\n      documentation: n.documentation,\n      code: n.code,\n      codeNoBody: n.codeNoBody,\n      totalTokens: 0,\n      inDegree: 0,\n      outDegree: 0,\n      label: n.label,\n      originFile: n.originFile,\n      generatedDocumentation: \"\",\n      importStatements: n.importStatements.join(\"\\n\"),\n    };\n  });\n\n  const links = codebase.getLinks();\n\n  const graphLinks: GraphLink[] = links.map((l) => {\n    return {\n      id: uuidv4(),\n      source: nodeDBIds[l.source],\n      target: nodeDBIds[l.target],\n      label: l.label,\n      line: l.line,\n    };\n  });\n\n  const model = \"gpt-3.5-turbo\";\n\n  const documentedFolders = await generateDocumentation(\n    grapNodes,\n    graphLinks,\n    repoName,\n    model\n  );\n\n  const modelNoDots = model.replaceAll(\".\", \"\");\n\n  fs.writeFile(\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(grapNodes, null, 2)\n  );\n  fs.writeFile(\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(documentedFolders, null, 2)\n  );\n})();\n```\n\nThis documentation provides an overview of the `src` folder, detailing its purpose, structure, and key functionalities. The provided code examples demonstrate how to utilize the various utilities and modules within this folder effectively.",
  "": "# Repository Documentation: `codebase-index-ts`\n\n## 1. Introduction\n\nThe `codebase-index-ts` repository is designed to facilitate the analysis, indexing, and documentation of codebases. It provides tools and utilities to parse code structures, generate graph representations, and create comprehensive documentation using AI models. The repository supports multiple programming languages, including TypeScript, JavaScript, Python, Java, PHP, and C.\n\n## 2. Getting Started\n\n### Prerequisites\n\nBefore you begin, ensure you have the following software installed:\n\n- Node.js (version 14 or higher)\n- npm (version 6 or higher)\n- PostgreSQL (for database interactions)\n- Git\n\n### Installation\n\n1. **Clone the Repository:**\n   ```bash\n   git clone https://github.com/your-username/codebase-index-ts.git\n   cd codebase-index-ts\n   ```\n\n2. **Install Dependencies:**\n   ```bash\n   npm install\n   ```\n\n3. **Set Up Environment Variables:**\n   Create a `.env` file in the root directory and add the necessary environment variables:\n   ```env\n   DATABASE_USERNAME=your_db_username\n   DATABASE_PASSWORD=your_db_password\n   DATABASE_HOST=your_db_host\n   DATABASE_PORT=your_db_port\n   DATABASE_NAME=your_db_name\n   SUPABASE_CA_CERTIFICATE=your_supabase_ca_certificate\n   SUPABASE_JWT=your_supabase_jwt\n   GITLAB_APP_ID=your_gitlab_app_id\n   GITLAB_SECRET_ID=your_gitlab_secret_id\n   BITBUCKET_KEY=your_bitbucket_key\n   BITBUCKET_SECRET=your_bitbucket_secret\n   ```\n\n4. **Run the Application:**\n   ```bash\n   npm start\n   ```\n\n## 3. Project Structure\n\n### Overview\n\nThe `src` folder is the core of the `codebase-index-ts` repository, containing various subfolders and files that manage different aspects of the application. This folder includes utilities for interacting with external APIs, handling graph data, managing codebase models, and generating documentation.\n\n### Directory Structure\n\n```\nsrc\n├── communities\n│   └── communities.ts\n├── model\n│   ├── calls.ts\n│   ├── codebase.ts\n│   ├── consts.ts\n│   └── utils.ts\n├── queries\n│   ├── c.ts\n│   ├── index.ts\n│   ├── java.ts\n│   ├── javascript.ts\n│   ├── php.ts\n│   ├── python.ts\n│   └── typescript.ts\n├── routes\n│   ├── create_graph-test.ts\n│   ├── create_graph.ts\n│   └── graphs.ts\n├── tools\n│   └── function_tools.ts\n├── utils\n│   ├── ai.ts\n│   ├── bitbucket\n│   │   └── refresh-token.ts\n│   ├── db.ts\n│   ├── git.ts\n│   ├── gitlab\n│   │   └── refresh-token.ts\n│   └── utils.ts\n├── wiki\n│   ├── test-wiki.ts\n│   ├── utils.ts\n│   ├── wiki.ts\n│   └── wikiGuille.ts\n└── index.ts\n```\n\n### Detailed Subfolder and File Descriptions\n\n#### 1. `communities`\n\nThe `communities` folder is dedicated to constructing and analyzing graph data using community detection algorithms.\n\n- **File: `communities.ts`**\n  - **Purpose**: Handles the entire workflow of graph construction, community detection, and data serving.\n  - **Main Features**:\n    - Graph Construction\n    - Community Detection\n    - Data Serving\n    - File Operations\n\n#### 2. `model`\n\nThe `model` folder is designed to model and manage various aspects of a codebase.\n\n- **Files:**\n  - **`calls.ts`**: Captures and analyzes various elements such as calls, assignments, and nodes within a given file node.\n  - **`codebase.ts`**: Models and manages a codebase by representing its structure and relationships through nodes.\n  - **`consts.ts`**: Defines various constants and type definitions used throughout the codebase.\n  - **`utils.ts`**: Provides a set of utility functions to facilitate file handling, parsing, and code analysis within a codebase.\n\n#### 3. `queries`\n\nThe `queries` folder contains language-specific query definitions used for parsing and analyzing code structures.\n\n- **Files:**\n  - **`c.ts`**: Defines queries for analyzing C code.\n  - **`index.ts`**: Centralizes and exports all language-specific query objects.\n  - **`java.ts`**: Contains queries for parsing Java code.\n  - **`javascript.ts`**: Provides queries for analyzing JavaScript code.\n  - **`php.ts`**: Defines queries for extracting elements from PHP code.\n  - **`python.ts`**: Contains queries for parsing Python code.\n  - **`typescript.ts`**: Extends JavaScript queries to handle TypeScript-specific constructs.\n\n#### 4. `routes`\n\nThe `routes` folder contains the API endpoint definitions for the codebase-index-ts repository.\n\n- **Files:**\n  - **`create_graph-test.ts`**: Defines a POST endpoint for creating a graph representation of a codebase from a specified repository.\n  - **`create_graph.ts`**: Defines an API endpoint for creating graphs based on code repositories.\n  - **`graphs.ts`**: Defines an endpoint for updating graph data associated with a specific Git repository.\n\n#### 5. `tools`\n\nThe `tools` folder provides essential utilities and functions for managing and analyzing graph structures.\n\n- **File: `function_tools.ts`**\n  - **Purpose**: Offers a comprehensive set of utilities for managing and analyzing graph structures.\n  - **Main Features**:\n    - Graph Data Retrieval\n    - Code Retrieval\n    - Similarity Calculation\n    - Language Analysis\n    - Function Definitions for External Use\n    - User Tools and Prompt Generation\n\n#### 6. `utils`\n\nThe `utils` folder contains various utility modules designed to support different functionalities across the application.\n\n- **Subfolder: `bitbucket`**\n  - **File: `refresh-token.ts`**\n    - **Function `refreshAccessToken`**: Refreshes Bitbucket OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n- **Subfolder: `gitlab`**\n  - **File: `refresh-token.ts`**\n    - **Function `refreshAccessToken`**: Refreshes GitLab OAuth2 access tokens using the provided refresh token, client ID, and client secret.\n\n- **Files:**\n  - **`ai.ts`**: Facilitates interactions with the OpenAI API for generating chat completions.\n  - **`db.ts`**: Manages database interactions, particularly with a PostgreSQL database.\n  - **`git.ts`**: Provides utilities for interacting with Git service providers (GitHub, GitLab, Bitbucket).\n  - **`utils.ts`**: Manages and accesses environment variables required for the application's configuration.\n\n#### 7. `wiki`\n\nThe `wiki` folder automates the process of generating comprehensive documentation for a codebase.\n\n- **Files:**\n  - **`test-wiki.ts`**: Parses the codebase, generates a graph representation, and creates documentation using an AI model.\n  - **`utils.ts`**: Provides utility functions to analyze and document nodes and links within a graph structure.\n  - **`wiki.ts`**: Handles the generation and updating of documentation for a repository.\n  - **`wikiGuille.ts`**: Generates comprehensive documentation for a codebase by analyzing its structure and relationships.\n\n#### 8. `index.ts`\n\nThe `index.ts` file serves as the main entry point for a Node.js server application built with the Hono framework.\n\n- **Purpose**: Sets up the server, defines routes, and handles the processing of codebase data to generate graph representations.\n- **Main Features**:\n  - Server Initialization\n  - Root Route (\"/\")\n  - API Routes\n  - Server Execution\n\n## 4. Code Examples\n\n### Example: Refreshing a Bitbucket Access Token\n\n```typescript\nimport { refreshAccessToken } from './bitbucket/refresh-token';\n\nasync function exampleUsage() {\n    const refreshToken = 'your-refresh-token-here';\n    \n    try {\n        const newTokens = await refreshAccessToken(refreshToken);\n        if (newTokens) {\n            console.log('New Access Token:', newTokens.access_token);\n            console.log('New Refresh Token:', newTokens.refresh_token);\n        } else {\n            console.log('Failed to refresh tokens');\n        }\n    } catch (error) {\n        console.error('Error refreshing tokens:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Constructing and Serving a Graph with Community Detection\n\n```typescript\nconst fs = require(\"fs\").promises;\nimport { AllowedTypes } from \"../model/consts\";\nconst { Graph } = require(\"graphology\");\nconst louvain = require(\"graphology-communities-louvain\");\nimport ForceSupervisor from \"graphology-layout-force/worker\";\nconst sigma = require(\"sigma\");\nimport { v4 as uuid } from \"uuid\";\nconst express = require(\"express\");\nconst path = require(\"path\");\n\nconst projectId = \"judini-python-main\";\nconst folder_path = `../../test_files/`;\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\n\nasync function readJson(filePath: string) {\n  // Implementation here...\n}\n\nasync function constructGraphFromJson(\n  nodesFilePath: string,\n  linksFilePath: string\n) {\n  // Implementation here...\n}\n\n(async () => {\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\n\n  const communities = louvain(graph);\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\n\n  graph.forEachNode((node: wikiNode, attr: string) => {\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\n  });\n\n  const app = express();\n  const port = 8002;\n\n  app.get(\"/\", (req: any, res: any) => {\n    res.json(graph.export());\n  });\n\n  app.use(express.static(path.join(__dirname, \"public\")));\n\n  app.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}`);\n  });\n})();\n```\n\n### Example: Using OpenAI Chat Completion\n\n```typescript\nimport { getOpenAIChatCompletion } from './ai';\n\nasync function exampleUsage() {\n    const messages = [\n        { role: 'system', content: 'You are a helpful assistant.' },\n        { role: 'user', content: 'Tell me a joke.' }\n    ];\n    \n    try {\n        const response = await getOpenAIChatCompletion(messages);\n        console.log('AI Response:', response.response);\n    } catch (error) {\n        console.error('Error getting chat completion:', error);\n    }\n}\n\nexampleUsage();\n```\n\n### Example: Parsing and Documenting a Codebase\n\n```typescript\nimport { fstat } from \"fs\";\nimport { Codebase } from \"../model/codebase\";\nimport { GraphLink, GraphNode } from \"../utils/db\";\nimport { generateDocumentation } from \"./wiki\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport fs from \"fs/promises\";\n\n(async () => {\n  const repoName = \"codebase-index-ts\";\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\n  const codebase = new Codebase(codebasePath);\n  console.log(\"Parsing folders ..\");\n  const fileNodesMap = await codebase.parseFolder();\n  console.log(\"Getting calls ..\");\n  codebase.getCalls(fileNodesMap, false);\n  const nodes = codebase.simplify();\n\n  const nodeDBIds: { [key: string]: string } = {};\n  for (const node of nodes) {\n    nodeDBIds[node.id] = uuidv4();\n  }\n\n  const grapNodes: GraphNode[] = nodes.map((n) => {\n    return {\n      id: nodeDBIds[n.id],\n      fullName: n.id.replace(codebasePath, \"\"),\n      type: n.type,\n      language: n.language,\n      documentation: n.documentation,\n      code: n.code,\n      codeNoBody: n.codeNoBody,\n      totalTokens: 0,\n      inDegree: 0,\n      outDegree: 0,\n      label: n.label,\n      originFile: n.originFile,\n      generatedDocumentation: \"\",\n      importStatements: n.importStatements.join(\"\\n\"),\n    };\n  });\n\n  const links = codebase.getLinks();\n\n  const graphLinks: GraphLink[] = links.map((l) => {\n    return {\n      id: uuidv4(),\n      source: nodeDBIds[l.source],\n      target: nodeDBIds[l.target],\n      label: l.label,\n      line: l.line,\n    };\n  });\n\n  const model = \"gpt-3.5-turbo\";\n\n  const documentedFolders = await generateDocumentation(\n    grapNodes,\n    graphLinks,\n    repoName,\n    model\n  );\n\n  const modelNoDots = model.replaceAll(\".\", \"\");\n\n  fs.writeFile(\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(grapNodes, null, 2)\n  );\n  fs.writeFile(\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\n    JSON.stringify(documentedFolders, null, 2)\n  );\n})();\n```\n\n## 5. Configuration\n\n### Default Configuration Settings\n\nThe repository uses environment variables to manage configuration settings. These variables are stored in a `.env` file in the root directory. Below are the default configuration settings:\n\n```env\nDATABASE_USERNAME=your_db_username\nDATABASE_PASSWORD=your_db_password\nDATABASE_HOST=your_db_host\nDATABASE_PORT=your_db_port\nDATABASE_NAME=your_db_name\nSUPABASE_CA_CERTIFICATE=your_supabase_ca_certificate\nSUPABASE_JWT=your_supabase_jwt\nGITLAB_APP_ID=your_gitlab_app_id\nGITLAB_SECRET_ID=your_gitlab_secret_id\nBITBUCKET_KEY=your_bitbucket_key\nBITBUCKET_SECRET=your_bitbucket_secret\n```\n\n## 6. Glossary\n\n- **Node**: A fundamental unit in the codebase graph representing a code element such as a function, class, or file.\n- **Graph**: A data structure consisting of nodes and edges representing relationships between code elements.\n- **AST (Abstract Syntax Tree)**: A tree representation of the abstract syntactic structure of source code.\n- **Tree-sitter**: A parser generator tool and an incremental parsing library used for generating syntax trees.\n- **Louvain Algorithm**: A community detection algorithm used to identify clusters or communities within a graph.\n- **OAuth2**: An authorization framework that enables applications to obtain limited access to user accounts on an HTTP service.\n\nThis documentation provides a comprehensive overview of the `codebase-index-ts` repository, detailing its structure, functionalities, and usage examples. By following the provided instructions and examples, users can effectively utilize the tools and utilities offered by this repository to analyze, index, and document their codebases."
}