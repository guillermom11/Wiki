[
  {
    "id": "0ada64ee-3b79-4f91-8e39-b992597d8ddd",
    "fullName": "\\jest.config",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };\r\n  ",
    "codeNoBody": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\jest.config.js",
    "originFile": "\\jest.config.js",
    "generatedDocumentation": "The `jest.config.js` file in the `codebase-index-ts` repository configures the Jest testing framework for a TypeScript project. Key features include:\n\n1. **Preset Configuration**: Uses `ts-jest` to handle TypeScript files.\n2. **Test Environment**: Specifies `node` as the environment for running tests.\n3. **Test Matching**: Defines patterns to locate test files, including those in `__tests__` directories and files with `.spec.ts` or `.test.ts` suffixes.\n4. **Setup Files**: Loads environment variables from a `.env` file using `dotenv/config` before running tests.\n\nThe purpose of this file is to ensure that Jest is properly set up to run and manage tests within a TypeScript project, providing a consistent testing environment.",
    "importStatements": ""
  },
  {
    "id": "43115e8d-af6f-42cc-98e8-569e091a7768",
    "fullName": "\\llamaindex::readJson",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "readJson",
    "originFile": "\\llamaindex.ts",
    "generatedDocumentation": "The \"readJson\" function takes a file path as a parameter, reads the JSON data from the specified file asynchronously using fs.readFile with \"utf8\" encoding, parses the data into an array, and returns it. If an error occurs during the reading or parsing process, it logs the error and exits the process with an error code of 1.",
    "importStatements": ""
  },
  {
    "id": "db447a5e-19d0-4fb1-b485-83287d735aea",
    "fullName": "\\llamaindex::main",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function main() {\r\n  // Load file\r\n  dotenv.config();\r\n  const path =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\grapNodes-codebase-index-ts-gpt-35-turbo.json\";\r\n  const data = await readJson(path);\r\n  //console.log(data);\r\n  const vectorStore = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n  });\r\n  //console.log(\"HEREEEEE\");\r\n  // Create Document object with file\r\n  const docs = [];\r\n  for (let i = 0; i < data.length; i++) {\r\n    docs.push(\r\n      new Document({ text: data[i].generatedDocumentation, id_: data[i].id })\r\n    );\r\n  }\r\n  //const document = new Document({ text: data, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments(docs, {\r\n    vectorStore,\r\n  });\r\n\r\n  // Query the index (own implementation for CODEGPT)\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  //\r\n  const response = await queryEngine.query({\r\n    query: \"What does the file db.ts do? Why is it important?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}",
    "codeNoBody": "async function main() {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "main",
    "originFile": "\\llamaindex.ts",
    "generatedDocumentation": "The \"\\llamaindex::main\" function in the file loads a JSON file from a specified path using the \"readJson\" function, creates Document objects from the data, generates embeddings for the text, and stores them in a VectorStoreIndex using a QdrantVectorStore. It then queries the index using a query engine and outputs the response to the console.",
    "importStatements": ""
  },
  {
    "id": "8e8a26d8-d7e8-401c-b58f-d0577b2fd640",
    "fullName": "\\llamaindex",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport dotenv from \"dotenv\";\r\nasync function main() {\r\n  // Load file\r\n  dotenv.config();\r\n  const path =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\\\\grapNodes-codebase-index-ts-gpt-35-turbo.json\";\r\n  const data = await readJson(path);\r\n  //console.log(data);\r\n  const vectorStore = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n  });\r\n  //console.log(\"HEREEEEE\");\r\n  // Create Document object with file\r\n  const docs = [];\r\n  for (let i = 0; i < data.length; i++) {\r\n    docs.push(\r\n      new Document({ text: data[i].generatedDocumentation, id_: data[i].id })\r\n    );\r\n  }\r\n  //const document = new Document({ text: data, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments(docs, {\r\n    vectorStore,\r\n  });\r\n\r\n  // Query the index (own implementation for CODEGPT)\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  //\r\n  const response = await queryEngine.query({\r\n    query: \"What does the file db.ts do? Why is it important?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}\r\n\r\nmain().catch(console.error);\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n",
    "codeNoBody": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport dotenv from \"dotenv\";\r\nasync function main() {\n//...\n}\r\nmain().catch(console.error);\r\n\r\nasync function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\llamaindex.ts",
    "originFile": "\\llamaindex.ts",
    "generatedDocumentation": "### llamaindex.ts\n\nThis file is designed to handle the process of reading JSON data, creating document embeddings, storing them in a vector store, and querying the stored data. The main features and purpose of the file are as follows:\n\n- **readJson Function**: Reads and parses JSON data from a specified file path asynchronously. It handles any errors that occur during the reading or parsing process by logging the error and exiting the process with an error code.\n\n- **main Function**: \n  - Loads JSON data using the `readJson` function.\n  - Creates `Document` objects from the loaded data.\n  - Generates embeddings for the text contained in these documents.\n  - Stores the generated embeddings in a `VectorStoreIndex` using a `QdrantVectorStore`.\n  - Queries the index using a query engine and outputs the response to the console.\n\nThe purpose of this file is to facilitate the creation and querying of a vector store index from JSON data, leveraging the capabilities of the `llamaindex` library and Qdrant vector store for efficient data retrieval and processing.",
    "importStatements": "import fs from \"node:fs/promises\";\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\nimport dotenv from \"dotenv\";"
  },
  {
    "id": "a475f31e-8f62-4b65-b800-4150bc4f6826",
    "fullName": "\\src\\communities\\communities::cmap",
    "type": "assignment",
    "language": "python",
    "documentation": "# Spring layout for better visualization\r",
    "code": "cmap = plt.get_cmap('viridis')",
    "codeNoBody": "cmap = plt.get_cmap('viridis')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cmap",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: cmap = plt.get_cmap('viridis')",
    "importStatements": ""
  },
  {
    "id": "e5d8ee2c-f8dc-453d-b086-dbafa4bf9194",
    "fullName": "\\src\\communities\\communities::pos",
    "type": "assignment",
    "language": "python",
    "documentation": "# Draw the graph\r",
    "code": "pos = nx.spring_layout(G)",
    "codeNoBody": "pos = nx.spring_layout(G)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "pos",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: pos = nx.spring_layout(G)",
    "importStatements": ""
  },
  {
    "id": "ef2a55f2-3d00-4ae2-85f6-0b42b7b90f86",
    "fullName": "\\src\\communities\\communities::partition",
    "type": "assignment",
    "language": "python",
    "documentation": "# Detect communities using Louvain algorithm\r",
    "code": "partition = community_louvain.best_partition(G)",
    "codeNoBody": "partition = community_louvain.best_partition(G)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "partition",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: partition = community_louvain.best_partition(G)",
    "importStatements": ""
  },
  {
    "id": "121c2112-c11b-4669-8536-185878b25468",
    "fullName": "\\src\\communities\\communities::G",
    "type": "assignment",
    "language": "python",
    "documentation": "# Construct the graph\r",
    "code": "G = construct_graph_from_json(nodes, links)",
    "codeNoBody": "G = construct_graph_from_json(nodes, links)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "G",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: G = construct_graph_from_json(nodes, links)",
    "importStatements": ""
  },
  {
    "id": "bed8c4dd-fa3a-4f26-9f1d-89abd9256bd2",
    "fullName": "\\src\\communities\\communities::links",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "links = read_json(links_path)",
    "codeNoBody": "links = read_json(links_path)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "links",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: links = read_json(links_path)",
    "importStatements": ""
  },
  {
    "id": "f66dabbb-7b8f-4688-bead-89451d2312b3",
    "fullName": "\\src\\communities\\communities::nodes",
    "type": "assignment",
    "language": "python",
    "documentation": "# Read nodes and links from JSON files\r",
    "code": "nodes = read_json(nodes_path)",
    "codeNoBody": "nodes = read_json(nodes_path)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodes",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: nodes = read_json(nodes_path)",
    "importStatements": ""
  },
  {
    "id": "f3960109-f41d-4d91-8712-3d982487a33c",
    "fullName": "\\src\\communities\\communities::construct_graph_from_json",
    "type": "function",
    "language": "python",
    "documentation": "# Function to construct graph from nodes and links\r",
    "code": "def construct_graph_from_json(nodes, links):\r\n    G = nx.Graph()\r\n    for node in nodes:\r\n        G.add_node(node['id'], **node)\r\n    for link in links:\r\n        G.add_edge(link['source'], link['target'], **link)\r\n    return G",
    "codeNoBody": "def construct_graph_from_json(nodes, links):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "construct_graph_from_json",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "This function constructs a graph using the provided nodes and links in JSON format, where the \"nodes\" parameter contains a list of dictionaries representing nodes with their attributes, and the \"links\" parameter contains a list of dictionaries representing links between nodes with their attributes. The function iterates over the nodes and links to add them to the graph as nodes and edges, respectively, including their respective attributes, and returns the resulting graph.",
    "importStatements": ""
  },
  {
    "id": "863c754a-b168-41e1-9bf5-b4566f8184cb",
    "fullName": "\\src\\communities\\communities::save_json",
    "type": "function",
    "language": "python",
    "documentation": "",
    "code": "def save_json(data, file_path):\r\n    with open(file_path, 'w') as file:\r\n        json.dump(data, file, indent=4)",
    "codeNoBody": "def save_json(data, file_path):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "save_json",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "This function \"save_json\" saves the provided data to a JSON file located at the specified file_path by opening the file in write mode and using the json.dump method to write the data with an indentation of 4 spaces. The \"data\" parameter represents the data to be saved, while the \"file_path\" parameter specifies the path of the JSON file where the data will be stored.",
    "importStatements": ""
  },
  {
    "id": "4cadaf4b-70ac-4993-9698-03c57fbe1cd6",
    "fullName": "\\src\\communities\\communities::read_json",
    "type": "function",
    "language": "python",
    "documentation": "# Function to read JSON files\r",
    "code": "def read_json(file_path):\r\n    with open(file_path, 'r') as file:\r\n        return json.load(file)",
    "codeNoBody": "def read_json(file_path):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "read_json",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "This function \"read_json\" takes a file_path parameter, opens the specified file in read mode, and loads its content as a JSON object using the json.load() method, then returns the JSON data.",
    "importStatements": ""
  },
  {
    "id": "6aee6ff0-0efc-4e1a-b052-ddd745cc4b3e",
    "fullName": "\\src\\communities\\communities::graph_to_csv",
    "type": "function",
    "language": "python",
    "documentation": "",
    "code": "def graph_to_csv(name='codebase'):\r\n\r\n    nodes = pd.read_json(\"nodesCommunities.json\")\r\n    nodes['full_name'] = nodes['id']\r\n    edges = pd.read_json(links_path)\r\n\r\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\r\n    edges.to_csv(f'edges_{name}.csv', index=False)",
    "codeNoBody": "def graph_to_csv(name='codebase'):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "graph_to_csv",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "The `graph_to_csv` function reads node data from a JSON file, assigns the 'full_name' column in the dataframe, reads edge data from a specified path, and then saves the node and edge dataframes to CSV files named 'nodes_codebase.csv' and 'edges_codebase.csv' respectively, with the option to specify a different name for the files.",
    "importStatements": ""
  },
  {
    "id": "27503c44-9788-484a-a55c-227989c01e30",
    "fullName": "\\src\\communities\\communities::links_path",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "links_path = f\"{folder_path}/{projectId}/links.json\"",
    "codeNoBody": "links_path = f\"{folder_path}/{projectId}/links.json\"",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "links_path",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: links_path = f\"{folder_path}/{projectId}/links.json\"",
    "importStatements": ""
  },
  {
    "id": "b66b34dc-837e-44e9-98be-45a82e27ced0",
    "fullName": "\\src\\communities\\communities::nodes_path",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "codeNoBody": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodes_path",
    "originFile": "\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "importStatements": ""
  },
  {
    "id": "98b899db-2112-44c6-8f8f-3e9d4b3ca91b",
    "fullName": "\\src\\communities\\communities::folder_path",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const folder_path = `../../test_files/`;",
    "codeNoBody": "const folder_path = `../../test_files/`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "folder_path",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const folder_path = `../../test_files/`;",
    "importStatements": ""
  },
  {
    "id": "7a364864-5fc1-48c4-ab45-8ca4204a8fc5",
    "fullName": "\\src\\communities\\communities::projectId",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const projectId = \"judini-python-main\";",
    "codeNoBody": "const projectId = \"judini-python-main\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "projectId",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const projectId = \"judini-python-main\";",
    "importStatements": ""
  },
  {
    "id": "24481756-73c9-48e3-81d9-fd70f2f06aea",
    "fullName": "\\src\\communities\\communities",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\n\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();\r\n",
    "codeNoBody": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "### File: `communities.ts`\n\n#### Purpose:\nThe `communities.ts` file is designed to construct a graph from JSON data, detect communities within the graph using the Louvain algorithm, and serve the graph data via an Express web server.\n\n#### Main Features:\n1. **Graph Construction**:\n   - Reads node and link data from JSON files specified by `nodesFilePath` and `linksFilePath`.\n   - Constructs a graph using the `Graphology` library, adding nodes and edges with their respective attributes.\n\n2. **Community Detection**:\n   - Utilizes the Louvain algorithm from the `graphology-communities-louvain` package to detect communities within the graph.\n   - Assigns detected community labels to the nodes.\n\n3. **Data Serving**:\n   - Sets up an Express server to serve the graph data in JSON format.\n   - Serves static HTML content to visualize the graph.\n\n4. **File Operations**:\n   - Saves the constructed graph and detected communities to JSON files (`myGraph.json` and `communities.json`).\n\n#### Key Functions:\n- `readJson(filePath: string)`: Reads and parses JSON data from a specified file path.\n- `constructGraphFromJson(nodesFilePath: string, linksFilePath: string)`: Constructs and returns a graph from the provided nodes and links JSON files.\n\n#### Execution:\nThe script is executed with Node.js, and it performs the following steps:\n1. Constructs the graph from JSON files.\n2. Detects communities within the graph.\n3. Saves the graph and community data to JSON files.\n4. Sets up an Express server to serve the graph data and static content.\n\nThis file is essential for analyzing and visualizing community structures within a graph based on node and link data, providing both backend processing and frontend serving capabilities.",
    "importStatements": "const fs = require(\"fs\").promises;\nimport { AllowedTypes } from \"../model/consts\";\nconst { Graph } = require(\"graphology\");\nconst louvain = require(\"graphology-communities-louvain\");\nimport ForceSupervisor from \"graphology-layout-force/worker\";\nconst sigma = require(\"sigma\");\nimport { v4 as uuid } from \"uuid\";\nconst express = require(\"express\");\nconst path = require(\"path\");"
  },
  {
    "id": "09ab1a9e-f8fa-4d37-bc88-de239e73efd5",
    "fullName": "\\src\\communities\\communities::constructGraphFromJson",
    "type": "function",
    "language": "typescript",
    "documentation": "// Function to construct graph from nodes and links\r",
    "code": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}",
    "codeNoBody": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "constructGraphFromJson",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `constructGraphFromJson` function in the `communities.ts` file reads JSON data from specified files asynchronously using `readJson`, creates a directed graph using the `Graphology` library, populates the graph with nodes and edges based on the provided `nodesFilePath` and `linksFilePath`, and returns the constructed graph. The `wikiNode` type represents nodes with various properties, and the `wikiLink` type defines connections between nodes in the graph.",
    "importStatements": ""
  },
  {
    "id": "6033be3b-136b-444c-bdb7-5a9f4fbab13b",
    "fullName": "\\src\\communities\\communities::readJson",
    "type": "function",
    "language": "typescript",
    "documentation": "// Function to read JSON files\r",
    "code": "async function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}",
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "readJson",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `readJson` function in the codebase reads a JSON file specified by the `filePath` parameter asynchronously using `fs.readFile` with encoding \"utf8\" and returns the parsed JSON data.",
    "importStatements": ""
  },
  {
    "id": "72ed7850-3338-4258-aab9-ffe65d80b34c",
    "fullName": "\\src\\communities\\communities::wikiLink",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiLink",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `wikiLink` type in the `communities.ts` file represents a structure with `source`, `target`, and `label` properties, defining a link between nodes in a graph, commonly used to represent connections between different entities in a network.",
    "importStatements": ""
  },
  {
    "id": "4afddfee-5098-42fe-9dd1-7bf95aba1465",
    "fullName": "\\src\\communities\\communities::wikiNode",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiNode",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `wikiNode` type in the codebase represents a node in a wiki, containing properties such as id, alias, language, label, type, parent (optional), totalTokens, inDegree, outDegree, code, summary (optional), importStatements, codeNoBody, and originFile.",
    "importStatements": ""
  },
  {
    "id": "55719d93-12f4-4c1c-a8a0-a6788c76e18d",
    "fullName": "\\src\\communities\\communities::linksFilePath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "codeNoBody": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "linksFilePath",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "importStatements": ""
  },
  {
    "id": "dcd08381-c845-47b3-9e95-c3a341be2e2a",
    "fullName": "\\src\\communities\\communities::nodesFilePath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "codeNoBody": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodesFilePath",
    "originFile": "\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "importStatements": ""
  },
  {
    "id": "11984d84-cdca-4f6e-9ff8-22905d3f8f8f",
    "fullName": "\\src\\index::const",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// const\r",
    "code": "const app = new Hono();",
    "codeNoBody": "const app = new Hono();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "const",
    "originFile": "\\src\\index.ts",
    "generatedDocumentation": "Code: const app = new Hono();",
    "importStatements": ""
  },
  {
    "id": "fe693d91-9d39-4dbf-bec5-97c6130ac78c",
    "fullName": "\\src\\index",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\n\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});\r\n",
    "codeNoBody": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index.ts",
    "originFile": "\\src\\index.ts",
    "generatedDocumentation": "### File: `src/index.ts`\n\n#### Purpose:\nThe `index.ts` file serves as the main entry point for a Node.js server application built with the Hono framework. It sets up the server, defines routes, and handles the processing of codebase data to generate graph representations.\n\n#### Main Features:\n1. **Server Initialization**:\n   - Initializes a Hono application instance (`const app = new Hono()`).\n   - Configures middleware for JSON formatting (`prettyJSON()`) and Cross-Origin Resource Sharing (CORS) (`cors()`).\n\n2. **Root Route (\"/\")**:\n   - Parses a specified codebase directory.\n   - Generates a simplified representation of the codebase nodes and their links.\n   - Writes the nodes and links data to JSON files (`nodes.json` and `links.json`).\n   - Returns the simplified codebase data as a JSON response.\n\n3. **API Routes**:\n   - `/v1/repo`: Handled by `createGraph` for creating graph data from a repository.\n   - `/v1/graphs`: Handled by `graphs` for retrieving graph data.\n   - `/v1/repo-test`: Handled by `createGraphTest` for testing graph creation from a repository.\n\n4. **Server Execution**:\n   - Starts the server on port 8001 and logs a message indicating the server is running.\n\nThis file is crucial for setting up the server, defining the API endpoints, and processing codebase data to create and serve graph representations.",
    "importStatements": "import { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { prettyJSON } from \"hono/pretty-json\";\nimport { createGraph } from \"./routes/create_graph\";\nimport { createGraphTest } from \"./routes/create_graph-test\";\nimport { graphs } from \"./routes/graphs\";\nimport { Codebase } from \"./model/codebase\";\nimport { writeFile } from \"node:fs/promises\";"
  },
  {
    "id": "45c9a78f-8250-48ce-9a29-f73f9e857856",
    "fullName": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.getCallsFromNode",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"getCallsFromNode\" method within the \"CallsCapturer\" class in the \"\\src\\model\\calls\" file replaces import names with aliases, captures assignments, and variable replacements, then captures calls from the provided node, returning a mapping of node aliases to their corresponding line numbers based on the given fileNode's language and content for further analysis.",
    "importStatements": ""
  },
  {
    "id": "38e3b58e-c1c3-402e-9510-0b43ad5eba43",
    "fullName": "\\src\\model\\calls::CallsCapturer.captureCalls",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.captureCalls",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer.captureCalls\" method in the \"\\src\\model\\calls\" file captures call identifiers from the provided code based on the language's query for calls, sorting them by position, and avoiding duplicates. It then processes the captured content, cleans and splits it, and maps the call names to corresponding nodes in the nodesMap. If a match is found, a new CallIdentifier object is created with the called node's id and starting line number, which is added to the results array. Additionally, it handles nested calls by splitting the call name and checking for matches at different levels in the nodesMap.",
    "importStatements": ""
  },
  {
    "id": "9bb94539-2902-4a5a-8931-4571a5cad8f0",
    "fullName": "\\src\\model\\calls::CallsCapturer.captureAssignments",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.captureAssignments",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The method \"captureAssignments\" in \"CallsCapturer\" class captures variable assignments from the provided \"code\" string based on the specified \"language\". It uses the \"captureQuery\" function to extract assignments, then processes and organizes the results into an array of \"VariableAssignment\" objects with properties like startLine, left, and right. The method handles different assignment scenarios, cleans up the content, and ensures proper assignment grouping before returning the sorted array of assignments.",
    "importStatements": ""
  },
  {
    "id": "a9308336-7747-4838-9740-9458a1399964",
    "fullName": "\\src\\model\\calls::CallsCapturer.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.constructor",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer\" class in the \"\\src\\model\\calls\" file captures calls, assignments, and nodes from a given fileNode, storing them in nodesMap for further analysis. The constructor initializes the fileNode and populates nodesMap with aliases and corresponding nodes, while the captureAssignments method captures VariableAssignments, captureCalls captures CallIdentifiers, and getCallsFromNode returns a mapping of node aliases to their corresponding numbers.",
    "importStatements": ""
  },
  {
    "id": "0e8a0fbc-3c9b-4212-a788-d771116e3a79",
    "fullName": "\\src\\model\\calls::CallsCapturer",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "codeNoBody": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n        //...\n    }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer\" class in the \"\\src\\model\\calls\" file captures calls, assignments, and nodes from a given fileNode, storing them in nodesMap for further analysis. The constructor initializes the fileNode and populates nodesMap with aliases and corresponding nodes, while the captureAssignments method captures VariableAssignments, captureCalls captures CallIdentifiers, and getCallsFromNode returns a mapping of node aliases to their corresponding numbers.",
    "importStatements": ""
  },
  {
    "id": "c9166f06-58cc-43ed-93e5-183f4e510773",
    "fullName": "\\src\\model\\calls::CallIdentifier.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }",
    "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallIdentifier.constructor",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallIdentifier\" class in the \"\\src\\model\\calls\" file defines a class with properties \"nodeId\" and \"line\" to store information about a node's identifier and line number. The constructor initializes these properties with the provided values for \"nodeId\" and \"line\".",
    "importStatements": ""
  },
  {
    "id": "04d58cfa-0859-4d3d-ba9a-65cb76e03d78",
    "fullName": "\\src\\model\\calls::CallIdentifier",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "codeNoBody": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallIdentifier",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallIdentifier\" class in the \"\\src\\model\\calls\" file defines a class with properties \"nodeId\" and \"line\" to store information about a node's identifier and line number. The constructor initializes these properties with the provided values for \"nodeId\" and \"line\".",
    "importStatements": ""
  },
  {
    "id": "9cec6a3b-5e1c-4ad3-bf98-d973fbcb8213",
    "fullName": "\\src\\model\\calls::VariableAssignment",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}",
    "codeNoBody": "class VariableAssignment {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "VariableAssignment",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "The class \"VariableAssignment\" in the calls.ts file defines a data structure for representing variable assignments in the codebase-index-ts repository. It includes parameters for the variable name, value, and type, allowing for the storage and retrieval of assignment information within the codebase.",
    "importStatements": ""
  },
  {
    "id": "035fd844-e0df-467e-9d18-712479d4d37a",
    "fullName": "\\src\\model\\calls",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\n\r\nclass VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}\r\n\r\nclass CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}\r\n\r\nexport class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "codeNoBody": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\nclass VariableAssignment {\n//...\n}\r\n\r\nclass CallIdentifier {\n//...\n}\r\n\r\nexport class CallsCapturer {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "originFile": "\\src\\model\\calls.ts",
    "generatedDocumentation": "# File: `calls.ts`\n\n## Purpose\nThe `calls.ts` file in the `\\src\\model` folder is designed to capture and analyze various elements such as calls, assignments, and nodes within a given file node. This is essential for understanding the structure and behavior of the codebase.\n\n## Main Features\n\n### Classes\n1. **VariableAssignment**\n   - This class is used to represent and handle variable assignments within the code.\n\n2. **CallIdentifier**\n   - This class stores information about a node's identifier and line number. It has properties `nodeId` and `line`, which are initialized via the constructor.\n\n3. **CallsCapturer**\n   - This is the primary class in the file, responsible for capturing and storing calls, assignments, and nodes from a given file node.\n   - **Constructor**: Initializes the `fileNode` and populates `nodesMap` with aliases and corresponding nodes.\n   - **Methods**:\n     - `captureAssignments`: Captures instances of `VariableAssignment`.\n     - `captureCalls`: Captures instances of `CallIdentifier`.\n     - `getCallsFromNode`: Returns a mapping of node aliases to their corresponding numbers for further analysis.\n\n## Summary\nThe `calls.ts` file is a crucial part of the codebase, providing the functionality to capture and analyze calls, assignments, and nodes within a file node. This helps in understanding the code structure and interactions, facilitating better code analysis and maintenance.",
    "importStatements": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\nimport { Node, ImportStatement} from \"./codebase\"\nimport { itselfClassMap } from \"./consts\""
  },
  {
    "id": "f0c8d6c5-58fc-47d3-a7f5-589dafb213ae",
    "fullName": "\\src\\model\\codebase::Codebase.resolveHeaderC",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveHeaderC",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.resolveHeaderC\" method in the codebase-index-ts repository, within the \"Codebase\" class, resolves header C files by checking if the provided \"headerNode\" is of type 'header' and language 'c' or 'cpp'. It then iterates through the child nodes of the header node, finds corresponding nodes in the file node, and reassigns them to the header node without changing the parent, updating the nodes map and outDegree accordingly.",
    "importStatements": ""
  },
  {
    "id": "85fade28-04a2-4e6a-b6ad-472f2ff1608f",
    "fullName": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveImportStatementsNodes",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.resolveImportStatementsNodes\" method in the codebase-index-ts repository iterates over nodes in the codebase, handles import statements by resolving paths and modules, creates new ImportName instances, resolves header C files, and handles cases like wildcard imports and define statements. The method interacts with the nodesMap property of the Codebase class to update import statements with corresponding nodes, ensuring proper organization and resolution of imports within the codebase.",
    "importStatements": ""
  },
  {
    "id": "bbc60d30-313e-442f-954f-383550ac96ce",
    "fullName": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolvePythonInitImportStatements",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements\" method in the codebase-index-ts repository's \"\\src\\model\\codebase\" class resolves Python import statements by iterating through nodes, filtering out import statements ending with '__init__', and merging them with import statements from corresponding '__init__.py' files to ensure proper import organization within the codebase. The method handles import statements within Python files to streamline the import structure for better code management and organization.",
    "importStatements": ""
  },
  {
    "id": "eece672c-0bc2-4092-8efc-95dd8104d490",
    "fullName": "\\src\\model\\codebase::Codebase.getLinks",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[] {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getLinks",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Codebase.getLinks\" method in the \"\\src\\model\\codebase::Codebase\" class retrieves links between nodes in the codebase by iterating through all nodes, identifying parent-child relationships, and capturing calls between nodes. For each node with a parent, a link is created with the source and target node IDs, a label indicating the relationship ('defines' or 'calls'), and the line number where the relationship occurs. If a node has associated calls, additional links are created for each call with the corresponding source, target, label, and line number.",
    "importStatements": ""
  },
  {
    "id": "df8d6ca0-85b9-42d4-957f-aaccc5bbfab3",
    "fullName": "\\src\\model\\codebase::Codebase.simplify",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.simplify",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.simplify\" method in the codebase-index-ts repository's \"\\src\\model\\codebase\" class simplifies nodes by returning an array of simplified nodes based on the provided attributes array and the root folder path. The method iterates over the nodes map, calling the \"simplify\" method on each node with the specified attributes and the root folder path to simplify the nodes accordingly.",
    "importStatements": ""
  },
  {
    "id": "edba0ac1-d0a0-4343-9e31-fc4cd7843031",
    "fullName": "\\src\\model\\codebase::Codebase.getCalls",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getCalls",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.getCalls\" method in the codebase-index-ts repository iterates over a map of file nodes, capturing calls from each node by creating a CallsCapturer instance, retrieving nodes and their children, and adding calls between nodes if certain conditions are met, handling verbose logging if specified. The method utilizes the NodesMap to track and add calls, considering the type of the called node, and handling cases where calls cannot be added due to missing information, providing feedback if verbose mode is enabled.",
    "importStatements": ""
  },
  {
    "id": "df3280a7-e339-4648-89a3-edeb4cd0f83c",
    "fullName": "\\src\\model\\codebase::Codebase.parseFolder",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.parseFolder",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.parseFolder\" method in the codebase-index-ts repository parses a folder to generate nodes representing files, resolving import statements, and handling Python special cases. It iterates through all files in the specified root folder, generates nodes from each file path, resolves import statements paths, and handles errors. After parsing all files, it resolves Python init import statements and spaces, then resolves import statements nodes before returning a map of file nodes indexed by ID.",
    "importStatements": ""
  },
  {
    "id": "68e2e435-d3bf-42a1-84e2-7d3acb8a4f7d",
    "fullName": "\\src\\model\\codebase::Codebase.resolveSpaces",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveSpaces() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveSpaces",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Codebase.resolveSpaces\" method in the \"\\src\\model\\codebase::Codebase\" class organizes nodes within a codebase by creating a global space map based on the existing space map. It iterates through each space, consolidates nodes into a global node per space, updates node IDs, manages parent-child relationships, and updates the space map accordingly. This method effectively resolves spaces within the codebase by merging related nodes and updating their relationships.",
    "importStatements": ""
  },
  {
    "id": "091249ea-d621-4c36-97de-074b662483de",
    "fullName": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.generateNodesFromFilePath",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Codebase.generateNodesFromFilePath\" method in the \"\\src\\model\\codebase::Codebase\" class reads a file from a given file path, creates a node representing the file or header, and generates a map of nodes with their attributes like id, type, and code. It distinguishes header files, calculates total tokens, adds nodes to space map based on type, and handles import statements and export clauses. The method returns the nodes map and a boolean indicating if the file is a header.",
    "importStatements": ""
  },
  {
    "id": "648f2122-4b5f-4ba4-9c2e-014ba7da98e2",
    "fullName": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNodeToSpaceMap",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.addNodeToSpaceMap\" method in the codebase-index-ts repository, within the \"Codebase\" class, adds a given \"Node\" to a space map by pushing it into an array under the node's name key. The \"Node\" class represents a node in the codebase graph with properties like id, type, name, language, and code, enabling operations to manage import statements, track calls, and relationships with other nodes effectively.",
    "importStatements": ""
  },
  {
    "id": "ca13f393-b799-49e7-9879-548ca9f4ab77",
    "fullName": "\\src\\model\\codebase::Codebase.addNodeMap",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNodeMap",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.addNodeMap\" method in the codebase-index-ts repository adds a map of nodes to the existing nodes map in the Codebase class, allowing for efficient organization and management of nodes within a codebase. The \"nodeMap\" parameter is an object containing node IDs as keys and Node instances as values. By merging the provided node map with the current nodes map using the spread operator, this method effectively incorporates new nodes into the codebase structure for further manipulation and analysis.",
    "importStatements": ""
  },
  {
    "id": "98faa4a6-f3e1-4f70-aa93-40f1ee416a5e",
    "fullName": "\\src\\model\\codebase::Codebase.getNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getNode",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.getNode\" method in the codebase-index-ts repository retrieves a node by its ID from the nodesMap property of the Codebase class, enabling access to properties like id, type, name, language, and code of the Node class representing a node in the codebase graph. This method allows for efficient retrieval and manipulation of nodes within the codebase, facilitating operations such as checking relationships, handling imports, and managing node attributes effectively.",
    "importStatements": ""
  },
  {
    "id": "c1dc18f3-64f9-4436-ac68-e923c381b80e",
    "fullName": "\\src\\model\\codebase::Codebase.addNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNode",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.addNode\" method in the codebase-index-ts repository adds a node to the codebase graph by assigning the node to the nodesMap using its id as the key. The \"Node\" class represents a node with properties like id, type, name, language, and code, enabling operations to manage children nodes, import statements, calls, and relationships with other nodes, and to parse export clauses, resolve import paths, and simplify attributes effectively.",
    "importStatements": ""
  },
  {
    "id": "8232d4f1-d13a-48ab-b672-5f8212fd8d3b",
    "fullName": "\\src\\model\\codebase::Codebase.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.constructor",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase.constructor\" method in the codebase-index-ts repository initializes the root folder path for the Codebase class, which provides functionality to add, retrieve, and organize nodes within a codebase, resolve spaces, parse folders to generate nodes, get calls, simplify attributes, get links, resolve Python import statements, and resolve header C files.",
    "importStatements": ""
  },
  {
    "id": "cd1ccdce-d15f-41f3-be33-20895933b26c",
    "fullName": "\\src\\model\\codebase::Codebase",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }\r\n}",
    "codeNoBody": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\n      //...\n  }\r\n  getNode(id: string): Node | undefined {\n      //...\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\n      //...\n  }\r\n  addNodeToSpaceMap(node: Node) {\n      //...\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n      //...\n  }\r\n\r\n  resolveSpaces() {\n      //...\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\n      //...\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n\r\n  getLinks(): Link[] {\n      //...\n  }\r\n\r\n  resolvePythonInitImportStatements() {\n      //...\n  }\r\n\r\n  resolveImportStatementsNodes() {\n      //...\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\n      //...\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Codebase\" class in the codebase-index-ts repository contains methods to add, retrieve, and organize nodes within a codebase, resolve spaces, parse folders to generate nodes, get calls, simplify attributes, get links, resolve Python import statements, and resolve header C files. The class constructor initializes the root folder path. The \"addNode\" method adds a node, \"getNode\" retrieves a node by ID, \"addNodeMap\" adds a map of nodes, and \"addNodeToSpaceMap\" adds a node to a space map. The \"generateNodesFromFilePath\" method generates nodes from a file path, and the \"resolveSpaces\" method resolves spaces. The class also includes methods to parse folders, get calls, simplify attributes, get links, resolve Python import statements, and resolve header C files.",
    "importStatements": ""
  },
  {
    "id": "5fa6eb7a-d509-415a-823f-94be37081a3f",
    "fullName": "\\src\\model\\codebase::Node.simplify",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }",
    "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = [], rootFolderPath?: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.simplify",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.simplify\" method in the \"Node\" class simplifies node attributes by returning a subset of attributes specified in the \"attributes\" parameter or all attributes if none are specified. It extracts essential information such as id, type, name, language, code, import statements, parent, children, calls, degrees, and origin file. If \"rootFolderPath\" is provided, it adjusts the paths accordingly. This method facilitates the extraction of specific node details for analysis or processing within the codebase graph.",
    "importStatements": ""
  },
  {
    "id": "7e3a09e8-02e9-4777-9041-b3e4fead7b67",
    "fullName": "\\src\\model\\codebase::Node.getChildrenDefinitions",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getChildrenDefinitions",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"getChildrenDefinitions\" method in the \"Node\" class filters and processes captured node definitions based on the node's type and language, generating a map of child nodes with attributes like name, alias, documentation, and body. It handles various language-specific cases, such as adjusting code for different languages, extracting modifiers, names, aliases, documentation, and bodies from the code, and identifying package or namespace declarations. Additionally, it establishes relationships between child nodes, filters unnecessary node types, and adds a space node if applicable, returning a map of processed child nodes.",
    "importStatements": ""
  },
  {
    "id": "50df6223-c44f-4656-8152-3613e26b9a52",
    "fullName": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.resolveImportStatementsPath",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"resolveImportStatementsPath\" method in the \"Node\" class of the codebase graph resolves import paths by iterating through import statements, constructing possible paths based on rootFolderPath, importStatement path, and suffixes, and updating the importStatement path if a matching file path is found in the provided allFiles array. Additionally, it handles special cases for index files and paths starting with \"@/\".",
    "importStatements": ""
  },
  {
    "id": "c4930c45-6c73-49f2-b025-cd3ad5e9207e",
    "fullName": "\\src\\model\\codebase::Node.parseExportClauses",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.parseExportClauses",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Node.parseExportClauses\" in the codebase handles the parsing of export clauses in JavaScript and TypeScript files, extracting information such as the exported code, module name, alias, and name. It iterates through the captured export clauses, updating node properties accordingly, resolving import statements, updating node IDs, and managing node exports within the same file or from external files. This method is part of the \"Node\" class, which manages nodes in the codebase graph, including adding, removing, and retrieving children nodes, handling import statements, tracking calls, and relationships, and simplifying node attributes.",
    "importStatements": ""
  },
  {
    "id": "7aeacfd3-96a6-4b14-a7ec-185acb8f9f3e",
    "fullName": "\\src\\model\\codebase::Node.generateImports",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }",
    "codeNoBody": "class Node\n    ...\n    generateImports() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.generateImports",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Node.generateImports()\" in the codebase graph's \"Node\" class parses import statements from the node's code if it represents a file, sorts them by position, and creates ImportStatement objects with module, names, moduleAlias, path, and code properties based on the captured import details, handling aliases and module paths effectively for codebase management.",
    "importStatements": ""
  },
  {
    "id": "a709b5a8-b9bf-4285-9fb7-9243932f738f",
    "fullName": "\\src\\model\\codebase::Node.getCodeWithoutBody",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getCodeWithoutBody",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Node.getCodeWithoutBody\" in the Node class retrieves the code of a node excluding its body content, considering options to preserve line breaks and exclude assignment files. It iterates over the node's children, removing their bodies while keeping class initialization methods intact, and handles file nodes differently by excluding assignment files if specified. The method also trims the resulting code and adjusts it based on the parent node's type, ultimately returning the modified code without the body content.",
    "importStatements": ""
  },
  {
    "id": "f7103852-8178-40fc-b56b-1b193adaceab",
    "fullName": "\\src\\model\\codebase::Node.addNodeRelationship",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addNodeRelationship",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"addNodeRelationship\" method in the \"Node\" class checks if a given node is within the current node and has no parent, then handles specific cases based on the types of nodes involved, such as setting exportable status, updating documentation, modifying node types and names, and adding the child node to the current node. This method effectively manages relationships between nodes in the codebase graph, ensuring proper node additions and attribute adjustments as needed.",
    "importStatements": ""
  },
  {
    "id": "6987ca36-bc48-4c02-a34c-ef3eac334543",
    "fullName": "\\src\\model\\codebase::Node.isWithin",
    "type": "method",
    "language": "typescript",
    "documentation": "// Checks if this node is within another node\r",
    "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }",
    "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.isWithin",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"isWithin\" method in the \"Node\" class checks if the current node is within another node by comparing their start and end positions in the codebase graph, returning a boolean value based on the comparison. This method is part of a comprehensive set of functionalities in the \"Node\" class that allows managing relationships between nodes, tracking calls, handling imports, and simplifying node attributes effectively within the codebase graph.",
    "importStatements": ""
  },
  {
    "id": "73077c9c-21b0-4b21-b36e-f690e3d8f6c4",
    "fullName": "\\src\\model\\codebase::Node.addImportStatement",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addImportStatement",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method Node.addImportStatement(importStatement: ImportStatement) adds the provided ImportStatement object to the importStatements array within a Node instance, allowing the management of import statements in the codebase graph. The ImportStatement class encapsulates details of an import statement, including module, names, moduleAlias, path, and an optional code, providing a structured representation for codebase organization and manipulation.",
    "importStatements": ""
  },
  {
    "id": "cb008fe3-1607-4bf1-8697-6f0d3575fcd7",
    "fullName": "\\src\\model\\codebase::Node.addCall",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addCall",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"addCall\" method in the \"Node\" class adds a call relationship between the current node and the specified node, updating the inDegree and outDegree properties accordingly. The method takes a \"node\" parameter representing the node being called and an optional \"lines\" parameter indicating the line numbers where the call occurs.",
    "importStatements": ""
  },
  {
    "id": "9ce2e308-7490-4249-8b05-77385ca97782",
    "fullName": "\\src\\model\\codebase::Node.removeChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }",
    "codeNoBody": "class Node\n    ...\n    removeChild(child: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.removeChild",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.removeChild\" method in the \"Node\" class removes a child node from the parent node by deleting the child node from the parent's children collection if the child node's id exists in the parent's children. Additionally, it updates the inDegree and outDegree properties of the parent and child nodes accordingly.",
    "importStatements": ""
  },
  {
    "id": "d1b688ee-a29d-411c-8275-5132ab213808",
    "fullName": "\\src\\model\\codebase::Node.addChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addChild(child: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addChild",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"addChild\" method in the \"Node\" class adds a child node to the current node, establishing a parent-child relationship between them by updating their respective degrees. This method is part of the functionality of the \"Node\" class, which manages nodes in the codebase graph, allowing the addition, removal, and retrieval of children nodes, and tracking relationships between nodes effectively.",
    "importStatements": ""
  },
  {
    "id": "729ad5da-a14a-45c3-a796-5f9b8fe0d40d",
    "fullName": "\\src\\model\\codebase::Node.getAllChildren",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getAllChildren",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Node.getAllChildren\" in the \"Node\" class retrieves all children nodes recursively, considering optional parent types to filter the result, and returns an array of Node instances. It iterates over the children of the current node, adding them to the result array and recursively calling \"getAllChildren\" on each child to include their descendants, providing a way to traverse the node's children tree structure effectively within the codebase graph.",
    "importStatements": ""
  },
  {
    "id": "3c3a6f64-d2cc-4366-9d1f-f41f580b8085",
    "fullName": "\\src\\model\\codebase::Node.getChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getChild",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.getChild\" method in the \"Node\" class recursively searches for a child node by the given childId within the children nodes of the current node, returning the node if found, or undefined otherwise. If the current node is a file node, it iterates over its children to find the child node. This method enables efficient navigation through the codebase graph by retrieving specific child nodes based on their IDs.",
    "importStatements": ""
  },
  {
    "id": "561a1629-28e8-41ae-970f-1448a4ce8538",
    "fullName": "\\src\\model\\codebase::Node.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }",
    "codeNoBody": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.constructor",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Node.constructor\" method in the \"Node\" class initializes a node in the codebase graph with an id, code, type, and language, defaulting to 'function' and 'js' if not provided, respectively. This constructor sets up the fundamental properties of a node, facilitating the creation and management of nodes within the codebase graph structure efficiently.",
    "importStatements": ""
  },
  {
    "id": "fa17e38d-9743-42ec-b58f-ad8122df5330",
    "fullName": "\\src\\model\\codebase::Node",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}",
    "codeNoBody": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\n      //...\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n      //...\n  }\r\n\r\n  addChild(child: Node) {\n      //...\n  }\r\n\r\n  removeChild(child: Node) {\n      //...\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\n      //...\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\n      //...\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\n      //...\n  }\r\n\r\n  addNodeRelationship(node: Node) {\n      //...\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n      //...\n  }\r\n\r\n  generateImports() {\n      //...\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n      //...\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n      //...\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\n      //...\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node\" class represents a node in the codebase graph with properties like id, type, name, language, and code, allowing to add, remove, and retrieve children nodes, manage import statements, track calls, and relationships with other nodes, and generate imports. It also provides methods to parse export clauses, resolve import statements path, simplify node attributes, and get children definitions, enabling operations like checking if a node is within another, getting code without body, and handling node relationships effectively.",
    "importStatements": ""
  },
  {
    "id": "9685bdd3-34d5-474d-947b-d3491d9db976",
    "fullName": "\\src\\model\\codebase::NodeCallTuple",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r",
    "codeNoBody": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "NodeCallTuple",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "Code: type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r",
    "importStatements": ""
  },
  {
    "id": "2f8d6749-5219-40d5-ae7c-f7eac2be29c1",
    "fullName": "\\src\\model\\codebase::Link",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}",
    "codeNoBody": "interface Link {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Link",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Link\" interface defines properties for representing a connection between nodes in a graph, including the source and target nodes identified by strings, a label for the link, and a line number associated with the link.",
    "importStatements": ""
  },
  {
    "id": "8f2d10a7-b2ce-4cdc-bcee-f6debd114184",
    "fullName": "\\src\\model\\codebase::ImportStatement.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }",
    "codeNoBody": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportStatement.constructor",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `ImportStatement.constructor` method in the `ImportStatement` class initializes an instance with properties `module` (string), `names` (array of `ImportName` objects), `moduleAlias` (string, defaults to `module` if not provided), `path` (string), and an optional `code` (string). The constructor allows custom values for each parameter, setting default values if not provided, encapsulating import statement details for codebase management.",
    "importStatements": ""
  },
  {
    "id": "40f86697-c7f9-4718-8bbb-ce5140c0624d",
    "fullName": "\\src\\model\\codebase::ImportStatement",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
    "codeNoBody": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportStatement",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The class \"ImportStatement\" in the file \"codebase.ts\" defines a class that represents an import statement with properties such as \"module\" (string), \"names\" (array of ImportName objects), \"moduleAlias\" (string), \"path\" (string), and an optional \"code\" (string). The constructor initializes these properties with default values and allows setting custom values for each parameter, where \"moduleAlias\" defaults to \"module\" if not provided. The \"ImportStatement\" class encapsulates import statement details for codebase management.",
    "importStatements": ""
  },
  {
    "id": "8d0070d6-f7bb-4924-ade7-19d8f189261f",
    "fullName": "\\src\\model\\codebase::ImportName.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }",
    "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportName.constructor",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::ImportName.constructor\" method initializes an instance of the \"ImportName\" class with the provided \"name\" parameter (string) and an optional \"alias\" parameter (string), defaulting to the value of \"name\" if not provided. The class properties \"name\" and \"alias\" are set to the corresponding parameters passed to the constructor.",
    "importStatements": ""
  },
  {
    "id": "f352bd73-548e-4a1a-bafd-e28568b38fd6",
    "fullName": "\\src\\model\\codebase::ImportName",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
    "codeNoBody": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportName",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "The class \"\\src\\model\\codebase::ImportName\" in the file \"codebase.ts\" defines a class named \"ImportName\" with properties \"name\" and \"alias\" initialized to empty strings, and an optional property \"node\" of type Node. The class has a constructor that takes a \"name\" parameter (string) and an optional \"alias\" parameter (string), setting \"alias\" to \"name\" if not provided.",
    "importStatements": ""
  },
  {
    "id": "8ab3ef89-2454-4531-9c1c-6c2d53e7c038",
    "fullName": "\\src\\model\\codebase::const",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const enc = encoding_for_model('gpt-4-turbo')",
    "codeNoBody": "const enc = encoding_for_model('gpt-4-turbo')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "const",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "Code: const enc = encoding_for_model('gpt-4-turbo')",
    "importStatements": ""
  },
  {
    "id": "b955be51-c58b-4dbe-9fb9-f1c858650aef",
    "fullName": "\\src\\model\\codebase",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\n\r\nexport class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}\r\nexport class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}\r\n\r\ninterface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // this -> \"defines\" -> child\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.outDegree++\r\n    child.inDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> \"calls\" -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = [], rootFolderPath?: string) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: rootFolderPath ? this.id.replace(rootFolderPath, '') : this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: rootFolderPath ? this.originFile.replace(rootFolderPath, '') : this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}\r\n\r\nexport class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    fileNode.originFile = filePath\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].outDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes, this.rootFolderPath))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        links.push({ source: n.parent.id.replace(this.rootFolderPath, ''),\r\n                      target: n.id.replace(this.rootFolderPath, ''),\r\n                      label: 'defines',\r\n                      line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) => {\r\n          links.push({ source: n.id.replace(this.rootFolderPath, ''),\r\n                        target: c.node.id.replace(this.rootFolderPath, ''),\r\n                        label: 'calls',\r\n                        line: c.lines[0] + 1 })\r\n        })\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.outDegree++\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "codeNoBody": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\nexport class ImportName {\n       //...\n       }\r\nexport class ImportStatement {\n       //...\n       }\r\n\r\ninterface Link {\n//...\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\n       //...\n       }\r\n\r\nexport class Codebase {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "originFile": "\\src\\model\\codebase.ts",
    "generatedDocumentation": "### File: `codebase.ts`\n\n#### Purpose:\nThe `codebase.ts` file is designed to model and manage a codebase by representing its structure and relationships through nodes. It provides classes and methods to handle import statements, nodes, and the entire codebase, facilitating operations such as adding, retrieving, and organizing nodes, parsing files and folders, resolving imports, and managing code relationships.\n\n#### Main Features:\n\n1. **ImportName Class**:\n   - Represents an import name with properties `name` and `alias`.\n   - Optionally associates a node with the import name.\n\n2. **ImportStatement Class**:\n   - Encapsulates details of an import statement including `module`, `names` (array of `ImportName`), `moduleAlias`, `path`, and optional `code`.\n   - Provides a constructor to initialize these properties with default or custom values.\n\n3. **Node Class**:\n   - Represents a node in the codebase graph with properties like `id`, `type`, `name`, `language`, and `code`.\n   - Methods to add, remove, and retrieve children nodes, manage import statements, track calls, and handle relationships with other nodes.\n   - Additional functionalities include parsing export clauses, resolving import paths, simplifying attributes, and checking node containment.\n\n4. **Codebase Class**:\n   - Manages the entire codebase by organizing nodes and resolving spaces.\n   - Methods to add nodes (`addNode`, `addNodeMap`, `addNodeToSpaceMap`), retrieve nodes (`getNode`), and generate nodes from file paths (`generateNodesFromFilePath`).\n   - Additional functionalities include parsing folders, getting calls, simplifying attributes, getting links, and resolving Python import statements and C header files.\n\n5. **NodeCallTuple Type**:\n   - Defines a tuple type for associating a node with its corresponding lines of code.\n\n6. **Constants and Utilities**:\n   - Utilizes various constants and utility functions to support the operations of the classes, including language mappings, allowed types, and encoding for models.\n\n### Summary:\nThe `codebase.ts` file is a crucial part of the `codebase-index-ts` repository, providing a comprehensive model for representing and managing a codebase. It defines classes for import statements and nodes, along with a `Codebase` class that offers extensive methods to handle the organization and relationship of code elements within a project.",
    "importStatements": "import fs from 'node:fs/promises'\nimport { Point } from 'tree-sitter'\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\nimport { CallsCapturer } from './calls'\nimport path from 'path'\nimport { encoding_for_model } from 'tiktoken'"
  },
  {
    "id": "49c08810-ab15-460e-b963-e9d5acc3f5e9",
    "fullName": "\\src\\model\\consts::treeSitterCommentTypes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "codeNoBody": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "treeSitterCommentTypes",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "Code: export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": ""
  },
  {
    "id": "898da04a-2ab4-489c-ae67-229469a402a6",
    "fullName": "\\src\\model\\consts::indexSuffixesMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
    "codeNoBody": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "indexSuffixesMap",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `indexSuffixesMap` constant in the code assigns specific index suffixes to different programming languages, such as Python, JavaScript, TypeScript, TSX, Java, Rust, and PHP, with empty strings denoting languages without index suffixes.",
    "importStatements": ""
  },
  {
    "id": "0826e0a7-66cd-498c-83da-8136f4c67c1c",
    "fullName": "\\src\\model\\consts::itselfClassMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
    "codeNoBody": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "itselfClassMap",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The \"itselfClassMap\" constant in the codebase-index-ts repository's consts.ts file is a Record object mapping programming languages to their respective keywords for referring to the current instance within classes, such as 'this' in JavaScript and TypeScript, 'self' in Python and Rust, and '$this' in PHP.",
    "importStatements": ""
  },
  {
    "id": "04816dfb-23eb-4500-b45e-cb44ec5137c8",
    "fullName": "\\src\\model\\consts::newClassMethodsMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
    "codeNoBody": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "newClassMethodsMap",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `newClassMethodsMap` constant in the code defines a mapping of programming languages to their respective class constructor method names, including languages like Python, JavaScript, TypeScript, JSX, Java, Rust, and PHP, where Java constructors have the same name as the class, and Rust uses 'new' as the constructor method name.",
    "importStatements": ""
  },
  {
    "id": "2d50a440-2cf8-4ac4-803e-104afc706225",
    "fullName": "\\src\\model\\consts::languageExtensionMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
    "codeNoBody": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languageExtensionMap",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `languageExtensionMap` in the consts.ts file maps file extensions to their corresponding programming languages, including extensions for Python, C, TypeScript, Java, and PHP, facilitating language identification within the codebase.",
    "importStatements": ""
  },
  {
    "id": "639f0fa3-5c5b-41a1-a8de-69622c749bf3",
    "fullName": "\\src\\model\\consts::languages",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
    "codeNoBody": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languages",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `languages` constant in the file defines a collection of programming languages including JavaScript, Python, TypeScript, TSX, Java, C, and PHP.",
    "importStatements": ""
  },
  {
    "id": "16fbbe9a-b4c5-41da-8b1d-17113e4e33d1",
    "fullName": "\\src\\model\\consts::excludedExtensions",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
    "codeNoBody": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "excludedExtensions",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `excludedExtensions` constant in the codebase-index-ts repository's consts.ts file contains an array of file extensions commonly excluded from processing, including 'min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', and '.config.js'.",
    "importStatements": ""
  },
  {
    "id": "f400448c-f2f8-468e-b15c-54781e1d7497",
    "fullName": "\\src\\model\\consts::excludedFolders",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]",
    "codeNoBody": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "excludedFolders",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `excludedFolders` constant in the file defines an array of folder names that are excluded from certain operations within the codebase, including common folders like `.git`, `node_modules`, and `dist`, among others.",
    "importStatements": ""
  },
  {
    "id": "dab414d7-b065-4531-a8e8-03fac26a7f7d",
    "fullName": "\\src\\model\\consts::AllowedTypesArray",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
    "codeNoBody": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "AllowedTypesArray",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `AllowedTypesArray` in the consts file is an array of `AllowedTypes` that restricts the possible values to specific types like function, class, interface, method, enum, struct, export, type, assignment, file, union, namespace, mod, header, and package, as defined in the `AllowedTypes` type, ensuring that only these types are allowed within the codebase.",
    "importStatements": ""
  },
  {
    "id": "5537b5de-ee4d-4040-920d-d06a84497631",
    "fullName": "\\src\\model\\consts::AllowedTypes",
    "type": "type",
    "language": "typescript",
    "documentation": "// - a header is a file that contains a set of declarations\r",
    "code": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "codeNoBody": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "AllowedTypes",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `AllowedTypes` type in the consts file defines a union type that includes various allowed types such as function, class, interface, method, enum, struct, export, type, assignment, file, union, namespace, mod, header, and package, restricting the possible values to these specific types.",
    "importStatements": ""
  },
  {
    "id": "90cc8fa7-632a-4168-bae2-c60e537db835",
    "fullName": "\\src\\model\\consts",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']\r\n",
    "codeNoBody": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "originFile": "\\src\\model\\consts.ts",
    "generatedDocumentation": "The `consts.ts` file in the `\\src\\model` directory defines various constants and type definitions that are used throughout the codebase to manage and process different programming languages and their specific characteristics. \n\n### Main Features and Purpose:\n\n1. **Language Definitions**:\n   - The file imports and defines a set of supported programming languages using `tree-sitter` parsers for JavaScript, Python, TypeScript, TSX, Java, C, and PHP.\n\n2. **Allowed Types**:\n   - Defines a union type `AllowedTypes` and an array `AllowedTypesArray` which include specific types like `function`, `class`, `interface`, `method`, `enum`, `struct`, `export`, `type`, `assignment`, `file`, `union`, `namespace`, `mod`, `header`, and `package`. These types restrict and standardize the possible values used within the codebase.\n\n3. **Exclusion Lists**:\n   - `excludedFolders`: An array of folder names that should be excluded from certain operations, including `.git`, `node_modules`, `dist`, etc.\n   - `excludedExtensions`: An array of file extensions to be excluded from processing, such as `min.js`, `min.css`, `d.ts`, etc.\n\n4. **Language Mappings**:\n   - `languageExtensionMap`: Maps file extensions to their corresponding programming languages, aiding in language identification.\n   - `newClassMethodsMap`: Maps programming languages to their respective class constructor method names.\n   - `itselfClassMap`: Maps programming languages to their respective keywords for referring to the current instance within classes.\n   - `indexSuffixesMap`: Assigns specific index suffixes to different programming languages, indicating how index files are named.\n\n5. **Comment Types**:\n   - `treeSitterCommentTypes`: An array that lists different types of comments recognized by `tree-sitter`.\n\nThe purpose of this file is to centralize and standardize the definitions and mappings related to various programming languages, ensuring consistency and facilitating easier management and processing of code across different languages within the codebase.",
    "importStatements": "const JavaScript = require('tree-sitter-javascript')\nconst Python = require('tree-sitter-python')\nconst TypeScript = require('tree-sitter-typescript').typescript\nconst TSX = require('tree-sitter-typescript').tsx\nconst Java = require('tree-sitter-java')\nconst C = require('tree-sitter-c')\nconst PHP = require('tree-sitter-php').php"
  },
  {
    "id": "f6f7c13b-7858-470a-b464-03018330f9d6",
    "fullName": "\\src\\model\\utils::getCalledNode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
    "codeNoBody": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCalledNode",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "The `getCalledNode` function takes three parameters: `callName` (string), `importFrom` (string), and `importedFileNodes` (Record<string, { fileNode: Node; importStatement: ImportStatement }>). It retrieves the `fileNode` from the `importedFileNodes` based on the `importFrom` parameter, then attempts to find a child node with the name `${importedFile.id}::${callName}` within the retrieved `fileNode`. Finally, it returns the found `calledNode`.",
    "importStatements": ""
  },
  {
    "id": "ea71e1f9-710a-4bf4-a416-286f0dec1818",
    "fullName": "\\src\\model\\utils::cleanAndSplitContent",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
    "codeNoBody": "const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cleanAndSplitContent",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "This function \"cleanAndSplitContent\" takes a string \"content\" as a parameter, removes parentheses and their contents, newlines, and unwanted characters, replaces ':' and '|' with ',', trims the resulting string, splits it by commas, removes surrounding brackets/braces, and trims each part, returning an array of strings.",
    "importStatements": ""
  },
  {
    "id": "f62853c5-36fb-4501-9f90-ea32b13f4874",
    "fullName": "\\src\\model\\utils::firstConsecutiveDots",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
    "codeNoBody": "function firstConsecutiveDots(s: string): number {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "firstConsecutiveDots",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "The function \"firstConsecutiveDots\" in the utils.ts file takes a string parameter \"s\" and uses a regular expression to find the length of the first consecutive dots at the beginning of the string, returning the number of consecutive dots found or 0 if none are present.",
    "importStatements": ""
  },
  {
    "id": "161f8551-a734-4f2b-85b3-d90f7286caca",
    "fullName": "\\src\\model\\utils::renameSource",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */",
    "code": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}",
    "codeNoBody": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "renameSource",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "The function \"renameSource\" in utils.ts takes parameters filePath (string), sourceName (string), and language (string) to modify the sourceName based on the specified language rules, including handling file extensions, directory structure adjustments, and special cases for certain languages like C++, C#, and Python. It utilizes the firstConsecutiveDots function to transform sourceName for Python files with dot-separated module names, and it appends \"::header\" to the newSourceName for C/C++ header files.",
    "importStatements": ""
  },
  {
    "id": "ca3228db-c00f-475d-b8a1-480c5d238776",
    "fullName": "\\src\\model\\utils::cleanDefCaptures",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */",
    "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
    "codeNoBody": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cleanDefCaptures",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "This function `cleanDefCaptures` takes an array of `captures` and an optional `keyword` parameter, defaulting to \"name\". It sorts the captures based on their node positions, then filters out duplicates of the capture with the specified `keyword`, keeping only the first occurrence. The function returns the updated array of captures.",
    "importStatements": ""
  },
  {
    "id": "47ebf2df-b4f2-4233-afba-0d97595785eb",
    "fullName": "\\src\\model\\utils::captureQuery",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */",
    "code": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}",
    "codeNoBody": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "captureQuery",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "The `captureQuery` function in the file \"utils.ts\" takes in parameters `language`, `queryName`, `code`, and an optional `queryArg`. It utilizes the `getRequiredDefinitions` function to obtain the necessary parser and queries based on the provided `language`. The function then constructs a query using the `treeSitterQueries` based on the `queryName` and processes the `code` to capture specific elements. It ensures uniqueness among the captured elements and returns an array of `Parser.QueryCapture` objects. If any errors occur during the process, it throws an error message indicating the issue.",
    "importStatements": ""
  },
  {
    "id": "0b9e9704-729c-41cb-8aac-1296119c1e9a",
    "fullName": "\\src\\model\\utils::getRequiredDefinitions",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */",
    "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
    "codeNoBody": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getRequiredDefinitions",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "This function `getRequiredDefinitions` takes a `language` parameter and returns an object with `parser` and `queries`. Depending on the `language` value provided, it initializes a new `Parser` object, sets the language of the parser accordingly, and assigns the corresponding language queries to the `queries` variable. If the `language` is not supported, it throws an error.",
    "importStatements": ""
  },
  {
    "id": "b7dd0763-8d62-41e0-9274-7d8c5418e479",
    "fullName": "\\src\\model\\utils::getTotalSize",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */",
    "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}",
    "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getTotalSize",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "The function \"getTotalSize\" in \"\\src\\model\\utils\" calculates the total size in bytes of all files within a specified root folder path by utilizing the async function \"getAllFiles\" to retrieve valid file paths meeting predefined extension, exclusion patterns, and folders criteria, then fetching the size of each file using fs.stat, summing up the sizes, and returning the total size as a Promise<number>.",
    "importStatements": ""
  },
  {
    "id": "0f88b4be-c64c-42cd-8ab0-c63c2a28a3c8",
    "fullName": "\\src\\model\\utils::getAllFiles",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */",
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}",
    "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getAllFiles",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "This async function \"getAllFiles\" takes a rootFolderPath string parameter, retrieves all files recursively in the specified folder, filters them based on predefined extension, exclusion patterns, and folders, then returns a sorted array of valid file paths meeting the criteria.",
    "importStatements": ""
  },
  {
    "id": "5bafeb10-d7e5-4a4c-be77-14199d05ef10",
    "fullName": "\\src\\model\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}\r\n\r\nfunction firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}\r\n",
    "codeNoBody": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }\r\n\r\nfunction firstConsecutiveDots(s: string): number {\n//...\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "originFile": "\\src\\model\\utils.ts",
    "generatedDocumentation": "# utils.ts\n\n## Purpose\nThe `utils.ts` file provides a set of utility functions to facilitate file handling, parsing, and code analysis within a codebase. These utilities are essential for tasks such as retrieving files, calculating their sizes, parsing code using Tree-Sitter, and managing code dependencies.\n\n## Main Features\n\n1. **File Retrieval and Size Calculation**\n   - `getAllFiles`: Recursively retrieves all files in a given folder, filtering by specified extensions and excluding certain folders and extensions.\n   - `getTotalSize`: Calculates the total size in bytes of all files retrieved by `getAllFiles`.\n\n2. **Tree-Sitter Integration**\n   - `getRequiredDefinitions`: Returns the Tree-Sitter parser and queries for a specified programming language.\n   - `captureQuery`: Uses Tree-Sitter to capture specific elements from code based on predefined queries for a given language.\n\n3. **Code Analysis and Manipulation**\n   - `cleanDefCaptures`: Cleans and filters captured elements from Tree-Sitter queries, ensuring uniqueness and relevance.\n   - `renameSource`: Modifies source names based on language-specific rules, handling file extensions and directory structures.\n   - `getCalledNode`: Retrieves a specific node from imported file nodes based on a call name and import source.\n\n4. **Content Processing**\n   - `cleanAndSplitContent`: Cleans and splits a string content into an array of strings, removing unwanted characters and formatting.\n\n5. **Utility Functions**\n   - `firstConsecutiveDots`: Finds the length of the first consecutive dots at the beginning of a string.\n\nThese utilities collectively support the analysis and manipulation of codebases, enabling efficient file handling, code parsing, and dependency management.",
    "importStatements": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\nimport { treeSitterQueries, languageQueries } from \"../queries\";\nimport { glob } from \"glob\";\nimport fs from \"node:fs/promises\";\nimport path from \"path\";\nimport Parser from \"tree-sitter\";\nimport { Node, ImportStatement } from \"./codebase\";"
  },
  {
    "id": "5315b959-fa2d-41ed-a279-241ed3fa9791",
    "fullName": "\\src\\queries\\c::cQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cQueries",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The `cQueries` object in the \"c.ts\" file contains various properties such as `importStatements`, `constructorDefinitions`, `definitionTemplate`, `exportClauses`, `extraAssignmentCode`, `calls`, `assignments`, and `spaceDeclaration`, which define templates and patterns for handling import statements, constructor definitions, function and global assignment declarations, export clauses, extra assignment code generation, function calls, any assignments, and space declarations in the TypeScript codebase, aiding in querying and analyzing code structures effectively.",
    "importStatements": ""
  },
  {
    "id": "610c02dc-610d-4792-a9cf-cd11a7d37a9a",
    "fullName": "\\src\\queries\\c::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// > my_class.my_method()\r",
    "code": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The `anyAssignments` assignment in the file defines a pattern for matching a declaration with an identifier and a pointer declarator, capturing the identifier as `left` and the pointer declarator as `right`.",
    "importStatements": ""
  },
  {
    "id": "2d8471f5-bb35-47b3-b5c9-beedfaef2db9",
    "fullName": "\\src\\queries\\c::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "codeNoBody": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The \"calls\" assignment in the file defines a template for matching call expressions in the codebase, capturing the function name and its arguments using AST patterns for identifiers, aiding in querying and analyzing function calls within the TypeScript codebase.",
    "importStatements": ""
  },
  {
    "id": "a9407a08-e17b-46a2-acc0-7c1059e00fa7",
    "fullName": "\\src\\queries\\c::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// ASSIGNMENT SPECIAL CASE\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The function `extraAssignmentCode` takes a `name` parameter as a string and generates a specific AST (Abstract Syntax Tree) structure for an assignment code snippet with the provided name. The function constructs an expression statement with a call expression that checks for equality between the identifier name and the input `name`, returning the generated AST code.",
    "importStatements": ""
  },
  {
    "id": "3ec0c6b8-b9bd-4ead-a938-605d5520a1b5",
    "fullName": "\\src\\queries\\c::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// modifier can be public, private or protected. By default is private\r",
    "code": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The `definitionTemplate` constant in the \"c.ts\" file defines a template for function and global assignment declarations in a specific syntax format, including optional return type, function name, parameters, and body for functions, as well as name and value for global assignments.",
    "importStatements": ""
  },
  {
    "id": "5e6600f2-f9fc-4be7-8bc6-d1b34302dc60",
    "fullName": "\\src\\queries\\c::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Java has no global assignments\r",
    "code": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "The \"assignments\" query in the file extracts declaration statements from a translation unit, specifically focusing on init_declarator instances, providing a structured representation of assignments within the codebase.",
    "importStatements": ""
  },
  {
    "id": "01ebcb25-1a2e-4fa3-8db6-eeaab17074d6",
    "fullName": "\\src\\queries\\c",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    ` \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => {\n//...\n} \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "originFile": "\\src\\queries\\c.ts",
    "generatedDocumentation": "### File: `c.ts`\n\n#### Purpose:\nThe `c.ts` file defines a set of queries and templates for parsing and analyzing C code structures using Tree-sitter. It focuses on identifying and extracting various code elements such as import statements, function and constructor definitions, assignments, and function calls. These queries help in understanding and manipulating the abstract syntax tree (AST) of C code.\n\n#### Main Features:\n1. **Import Statements**:\n   - Defines patterns to match C preprocessor include statements, capturing the module names.\n\n2. **Assignments**:\n   - Provides a template to match assignment statements within the C code, focusing on `init_declarator` instances.\n\n3. **Definition Template**:\n   - Specifies a template for function and global assignment declarations, including optional return types, function names, parameters, and bodies.\n\n4. **Constructor Definitions**:\n   - Identifies constructor methods and other function definitions, marking them appropriately in the AST.\n\n5. **Extra Assignment Code**:\n   - A function to generate specific AST structures for assignment code snippets with a given name.\n\n6. **Function Calls**:\n   - Defines patterns to match call expressions, capturing function names and their arguments.\n\n7. **Any Assignments**:\n   - Matches general assignment statements, capturing identifiers and their assigned values.\n\n#### Usage:\nThe `cQueries` object consolidates these patterns and templates, making them accessible for querying and analyzing C code structures effectively. This aids in tasks such as code indexing, refactoring, and static analysis.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "740464f7-6a24-465a-a9b1-a88f343b6fff",
    "fullName": "\\src\\queries\\index::treeSitterQueries",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "codeNoBody": "interface treeSitterQueries {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "treeSitterQueries",
    "originFile": "\\src\\queries\\index.ts",
    "generatedDocumentation": "The interface `treeSitterQueries` in the file provides properties to capture import statements, constructor definitions, definition templates, export clauses, assignments, extra assignment code for classes, calls, and space declarations for various programming languages, facilitating code analysis and indexing operations within the codebase.",
    "importStatements": ""
  },
  {
    "id": "a1f7f35b-6085-483a-a1d5-c1486f6bb13f",
    "fullName": "\\src\\queries\\index::languageQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "codeNoBody": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languageQueries",
    "originFile": "\\src\\queries\\index.ts",
    "generatedDocumentation": "The \"languageQueries\" object in this code snippet contains queries for various programming languages such as JavaScript, TypeScript, Python, Java, C, and PHP, each referencing specific query objects like \"jsQueries\" and \"tsQueries\" for their respective languages.",
    "importStatements": ""
  },
  {
    "id": "ef2a4969-602f-4ac6-b680-8f2678d4339c",
    "fullName": "\\src\\queries\\index",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\n\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "codeNoBody": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index.ts",
    "originFile": "\\src\\queries\\index.ts",
    "generatedDocumentation": "### File: `src/queries/index.ts`\n\n#### Purpose:\nThe file `index.ts` in the `src/queries` directory serves as a central hub for organizing and exporting language-specific query objects used for code analysis and indexing operations within the codebase.\n\n#### Main Features:\n1. **Language Queries Aggregation**:\n   - The file imports query objects for various programming languages including JavaScript, TypeScript, Python, Java, C, and PHP.\n   - These imported queries are then aggregated into a single `languageQueries` object, which maps each language to its respective query object.\n\n2. **Interface Definition**:\n   - The file defines an interface `treeSitterQueries` which outlines the structure for capturing various code elements such as import statements, constructor definitions, export clauses, assignments, and more. This interface is used to standardize the queries across different languages.\n\nBy centralizing the queries and providing a structured interface, this file facilitates efficient code analysis and indexing across multiple programming languages within the codebase.",
    "importStatements": "import { jsQueries } from \"./javascript\"\nimport { tsQueries } from \"./typescript\"\nimport { pyQueries } from \"./python\"\nimport { javaQueries } from \"./java\"\nimport { cQueries } from \"./c\"\nimport { phpQueries } from \"./php\""
  },
  {
    "id": "166dbc5d-1769-4c35-b902-ec507c8b35ab",
    "fullName": "\\src\\queries\\java::javaQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "javaQueries",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The `javaQueries` assignment in the Java queries file defines a set of queries for extracting information from Java source code in the codebase-index-ts repository. It includes capturing import statements, constructor definitions, method definitions, export clauses, extra assignment code generation, method calls, variable assignments, and package declarations, utilizing GraphQL syntax for querying and processing Java code elements efficiently.",
    "importStatements": ""
  },
  {
    "id": "fbb527a4-0fc7-4914-97c2-2fc3a30cd85f",
    "fullName": "\\src\\queries\\java::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// > my_class.my_method()\r",
    "code": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The `anyAssignments` query in the Java file targets variable declarations with identifiers on the left and various assignment patterns on the right, including identifiers and object creation expressions, capturing them as assignments.",
    "importStatements": ""
  },
  {
    "id": "17981cf0-2660-47a0-a7aa-22769f339cac",
    "fullName": "\\src\\queries\\java::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The \"calls\" assignment in the Java queries file extracts method invocations with their corresponding identifiers and parameter types, focusing on objects and their associated identifiers.",
    "importStatements": ""
  },
  {
    "id": "ebc91d9b-3dc3-449b-bc4d-877fff7c4bcd",
    "fullName": "\\src\\queries\\java::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// No assignments\r",
    "code": "const extraAssignmentCode = (name: string) => ``",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The function `extraAssignmentCode` takes a `name` parameter as a string and returns an empty template string. It is used to generate additional assignment code for Java queries in the codebase-index-ts repository.",
    "importStatements": ""
  },
  {
    "id": "682ae267-ccdb-41f9-8c08-744e5e335a62",
    "fullName": "\\src\\queries\\java::spaceDeclaration",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Space Declaration: package\r",
    "code": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "codeNoBody": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "spaceDeclaration",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The `spaceDeclaration` function in the Java queries file extracts the package declaration from the codebase, capturing the space name for further processing.",
    "importStatements": ""
  },
  {
    "id": "052f1411-31d4-4d06-8d2c-94f5c10e296a",
    "fullName": "\\src\\queries\\java::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// modifier can be public, private or protected. By default is private\r",
    "code": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "The `definitionTemplate` in the Java queries file defines a pattern for capturing method definitions in Java code, including modifiers, return type, method name, parameters, and method body, using GraphQL syntax for querying and extracting this information from Java source code.",
    "importStatements": ""
  },
  {
    "id": "b4d4bc98-4dcd-4bd3-b5d1-a72304376754",
    "fullName": "\\src\\queries\\java::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Java has no global assignments\r",
    "code": "const assignments = ``",
    "codeNoBody": "const assignments = ``",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "Code: const assignments = ``",
    "importStatements": ""
  },
  {
    "id": "26dea62a-a9ff-484c-be3b-b0df6e779491",
    "fullName": "\\src\\queries\\java",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = ``\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = {\n//...\n}\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "originFile": "\\src\\queries\\java.ts",
    "generatedDocumentation": "# Java Queries File Documentation\n\n## Purpose\nThe `java.ts` file in the `\\src\\queries` folder defines a set of queries for extracting various elements from Java source code. These queries are designed to be used with the Tree-sitter parsing library to analyze and process Java code efficiently within the codebase-index-ts repository.\n\n## Main Features\n\n### Import Statements\n- **Query:** `importStatements`\n- **Description:** Captures Java import declarations, including both scoped and unscoped identifiers.\n\n### Constructor and Method Definitions\n- **Query:** `constructorDefinitions`\n- **Description:** Captures constructor and method declarations within Java classes.\n- **Template:** `definitionTemplate`\n  - **Description:** Defines a pattern for capturing method details such as modifiers, return type, name, parameters, and body.\n\n### Package Declarations\n- **Query:** `spaceDeclaration`\n- **Description:** Extracts package declarations to capture the space name.\n\n### Variable Assignments\n- **Query:** `anyAssignments`\n- **Description:** Targets variable declarations and various assignment patterns, capturing them as assignments.\n\n### Method Calls\n- **Query:** `calls`\n- **Description:** Extracts method invocations, focusing on objects and their associated identifiers and parameter types.\n\n### Extra Assignment Code\n- **Function:** `extraAssignmentCode`\n- **Description:** Generates additional assignment code, though it currently returns an empty template string.\n\n### Export Clauses\n- **Query:** `exportClauses`\n- **Description:** Currently set to an empty string, indicating no specific export clauses are defined.\n\n## Exported Object\n- **Object:** `javaQueries`\n- **Description:** Consolidates all the defined queries into a single exportable object for use in processing Java code.\n\nThis file is essential for enabling the extraction and analysis of Java code elements, facilitating tasks such as code indexing, searching, and refactoring within the codebase-index-ts repository.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "47ce5d18-7327-4b11-a4ce-e7995bb2ecd3",
    "fullName": "\\src\\queries\\javascript::jsQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "codeNoBody": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "jsQueries",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `jsQueries` object in the JavaScript queries file captures import statements, constructor definitions, a definition template for function and arrow function definitions, export clauses, extra assignment code generation, call expressions, any assignments including object methods forEach, map, and reduce with arrow function parameters, and space declaration.",
    "importStatements": ""
  },
  {
    "id": "54c7ea57-afaf-4e83-bdf3-6e81c43f529f",
    "fullName": "\\src\\queries\\javascript::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
    "codeNoBody": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `anyAssignments` query in the JavaScript file identifies assignment expressions and variable declarations, capturing the left and right identifiers or member expressions. Additionally, it supports experimental cases like object methods forEach, map, and reduce with arrow function parameters, enabling the extraction of specific assignment patterns in the codebase.",
    "importStatements": ""
  },
  {
    "id": "c31c2e5b-dbe7-4fc5-b254-f42610d75766",
    "fullName": "\\src\\queries\\javascript::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;",
    "codeNoBody": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The \"calls\" assignment in the JavaScript queries file defines patterns for identifying various elements in JavaScript code, such as call expressions, member expressions, arguments, new expressions, keyword arguments, object properties, format strings, and shorthand identifiers, using AST patterns with identifiers.",
    "importStatements": ""
  },
  {
    "id": "be8f108c-a890-44f5-a43c-baa56ab2fe1c",
    "fullName": "\\src\\queries\\javascript::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// It will include the myEndpoint.get to the code of the assignment\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `extraAssignmentCode` function takes a `name` parameter and generates JavaScript code that represents an assignment statement using the provided `name`. The function constructs an AST (Abstract Syntax Tree) for an assignment statement with the specified `name` as the identifier.",
    "importStatements": ""
  },
  {
    "id": "1db652f5-59bd-4857-9b25-dc8f8803a76f",
    "fullName": "\\src\\queries\\javascript::exportClauses",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Export clauses can contain an alias\r",
    "code": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
    "codeNoBody": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "exportClauses",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `exportClauses` assignment defines a template for parsing export statements in JavaScript code, capturing the name and optional alias of export specifiers, as well as the module path if present, using the defined structure for export clauses.",
    "importStatements": ""
  },
  {
    "id": "9834699a-bb07-4593-a575-0549179e8c8b",
    "fullName": "\\src\\queries\\javascript::arrowFunctionConstructor",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
    "codeNoBody": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "arrowFunctionConstructor",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The \"arrowFunctionConstructor\" in the codebase-index-ts repository defines a string representation of an arrow function using a specific syntax pattern for a lexical declaration with a variable declarator and an arrow function value.",
    "importStatements": ""
  },
  {
    "id": "72d1c9d1-5db3-490b-b294-4c2957a40013",
    "fullName": "\\src\\queries\\javascript::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `definitionTemplate` constant in the JavaScript queries file defines a template for capturing function and arrow function definitions, including name, parameters, body, and value, with optional formal parameters and body for arrow functions.",
    "importStatements": ""
  },
  {
    "id": "08c4e803-df4a-4c8c-ad1f-303adf3108db",
    "fullName": "\\src\\queries\\javascript",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for JavaScript\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};\r\n",
    "codeNoBody": "// Tree-sitter definition + call queries for JavaScript\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n};\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifier.name\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "originFile": "\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `javascript.ts` file in the `\\src\\queries` folder defines a set of tree-sitter queries for parsing and analyzing JavaScript code. The primary purpose of this file is to facilitate the extraction and identification of various code patterns and constructs within JavaScript source files. \n\n### Main Features:\n1. **Import Statements**: Captures different forms of import statements, including namespace imports, named imports, and `require` calls.\n2. **Assignments**: Identifies variable assignments, excluding arrow functions and `require` imports, and includes global and exportable assignments.\n3. **Definitions**: Provides a template for capturing function and arrow function definitions, including their names, parameters, and bodies.\n4. **Constructor Definitions**: Detects various types of constructor definitions, including functions, arrow functions, and class methods.\n5. **Export Clauses**: Parses export statements, capturing names, aliases, and optional module paths.\n6. **Call Expressions**: Identifies different types of call expressions, member expressions, arguments, new expressions, and other related constructs.\n7. **Any Assignments**: Captures assignment expressions and variable declarations, including experimental support for methods like `forEach`, `map`, and `reduce` with arrow function parameters.\n8. **Extra Assignment Code**: Generates additional JavaScript code for specific assignment patterns using a provided name.\n\nThe file exports an object `jsQueries` that consolidates these queries, making them available for use in analyzing JavaScript codebases.",
    "importStatements": "import { treeSitterQueries } from \"./index\";"
  },
  {
    "id": "8c4c1918-4822-4ae0-a442-5ae3b0a5b1ad",
    "fullName": "\\src\\queries\\php::phpQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "phpQueries",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The `phpQueries` object in the PHP queries file defines various elements such as import statements, constructor definitions, a definition template for functions or methods, export clauses, extra assignment code generation based on a provided name, identifiers extracted from function calls, any assignment patterns, and a template string for namespace definitions.",
    "importStatements": ""
  },
  {
    "id": "0c2eb435-0063-4f2d-8ea0-057b41a8f908",
    "fullName": "\\src\\queries\\php::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The `anyAssignments` query in the `\\src\\queries\\php` file defines a pattern for matching assignment expressions in an abstract syntax tree, capturing the left and right sides of the assignment as well as any parameters involved.",
    "importStatements": ""
  },
  {
    "id": "bcb0d1bb-87f5-447a-a874-74940dc1bb5a",
    "fullName": "\\src\\queries\\php::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The \"calls\" assignment in the \"\\src\\queries\\php::calls\" file extracts identifiers from function calls, named types, member calls, member accesses, and object names in the provided TypeScript code snippet.",
    "importStatements": ""
  },
  {
    "id": "5fca579d-13ad-4934-8556-08982a201cb9",
    "fullName": "\\src\\queries\\php::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// It will include the myEndpoint.get to the code of the assignment\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The function `extraAssignmentCode` takes a `name` parameter and generates a program in a specific format with an expression statement containing a binary expression checking for equality between the provided `name` parameter and a variable name.",
    "importStatements": ""
  },
  {
    "id": "109eeb12-bcd6-442c-ba6f-761b8e354816",
    "fullName": "\\src\\queries\\php::spaceDeclaration",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Space Declaration: namespace\r",
    "code": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "codeNoBody": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "spaceDeclaration",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The `spaceDeclaration` assignment in the file defines a template string for a namespace definition in a query, specifying a placeholder for the namespace name and body, following a specific syntax pattern.",
    "importStatements": ""
  },
  {
    "id": "454b922a-60de-45fc-b218-9cb445d5a2bf",
    "fullName": "\\src\\queries\\php::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The `definitionTemplate` in the PHP queries file defines a template for a function or method, including elements like visibility modifier, name, parameters, return type, and body, with a note that interfaces do not have a body. Additionally, it includes a structure for global assignments with an assignment expression and variable name.",
    "importStatements": ""
  },
  {
    "id": "c2491ccf-f02c-4a33-b2cc-7e9bfdca2f73",
    "fullName": "\\src\\queries\\php::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Global only\r",
    "code": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The \"assignments\" query in the file retrieves program expressions with assignment statements, specifically targeting assignment expressions with a variable name on the left side and an underscore on the right side, capturing them as \"assignment\" nodes.",
    "importStatements": ""
  },
  {
    "id": "c6cce84b-3ac7-4342-8515-4665112e94ae",
    "fullName": "\\src\\queries\\php",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for PHP\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for PHP\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "originFile": "\\src\\queries\\php.ts",
    "generatedDocumentation": "The `php.ts` file in the `\\src\\queries` folder defines a set of tree-sitter queries tailored for analyzing PHP code. The main purpose of this file is to facilitate the extraction of specific code elements and structures from PHP source files. These queries help in identifying and capturing various components such as import statements, global assignments, function and class definitions, and function calls. Here are the key features:\n\n1. **Import Statements**: Captures different types of import statements including `include`, `require`, and namespace use declarations.\n2. **Assignments**: Identifies global assignments and distinguishes them from arrow functions by checking for the presence of a body.\n3. **Constructor Definitions**: Defines patterns to capture class declarations, method declarations, function definitions, and interface declarations.\n4. **Namespace Definitions**: Captures namespace definitions without their bodies.\n5. **Function and Method Calls**: Extracts identifiers from function calls, member calls, member accesses, and object names.\n6. **Extra Assignment Code**: Provides a function to generate additional assignment code based on a given name.\n7. **Any Assignments**: Defines patterns to capture assignment expressions, including complex cases involving member access and object creation.\n\nThe `phpQueries` object consolidates these queries, making it easier to analyze and process PHP code by providing a structured way to extract relevant code elements.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "c840596e-df7a-42e0-9d19-f0c5fa3cc31f",
    "fullName": "\\src\\queries\\python::pyQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "pyQueries",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The `pyQueries` object in the Python queries file contains structured patterns for extracting import statements, constructor definitions, function definitions, extra assignment code, export clauses, function calls, any assignments, and space declarations from Python code, enabling detailed code analysis by matching patterns for global assignments, class and function calls, method calls, self.parameter calls, class extensions, typed parameters, return types, and more.",
    "importStatements": ""
  },
  {
    "id": "a6d2443b-bb59-4249-bc83-f999f39fdd39",
    "fullName": "\\src\\queries\\python::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The `anyAssignments` query in the Python file identifies assignments by capturing the left side as an identifier and the right side as any value, as well as function definitions with typed parameters, extracting the parameter names and types.",
    "importStatements": ""
  },
  {
    "id": "4277ed0d-91be-4950-9fc1-caca289f8e09",
    "fullName": "\\src\\queries\\python::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The `calls` assignment in the Python queries file defines patterns for identifying class and function calls, method calls, self.parameter calls, class extensions, pydantic-like parameters, typed parameters and return types, assignments with identifiers, keyword arguments, attributes, arguments, object names, and format strings within the codebase, providing a structured approach to extract relevant information during code analysis.",
    "importStatements": ""
  },
  {
    "id": "2361698e-ecb9-43a2-8b11-a116e85a93e3",
    "fullName": "\\src\\queries\\python::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// We need to know the assignment name\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The function `extraAssignmentCode` takes a `name` parameter and generates a code snippet in the form of a module with an expression statement that checks for equality between the provided `name` parameter and the identifier name in the code. The function returns the generated code snippet as a string. The commented-out section shows an alternative code snippet that is not used in the current implementation.",
    "importStatements": ""
  },
  {
    "id": "27699389-085c-4633-b0b2-b3657cc5fedf",
    "fullName": "\\src\\queries\\python::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The `definitionTemplate` in the Python queries file defines a template for extracting function definitions, including the function name, parameters, return type, body, and documentation, as well as global assignments using a structured pattern matching approach.",
    "importStatements": ""
  },
  {
    "id": "121430bb-7275-4546-bbb8-7a8adb62dd67",
    "fullName": "\\src\\queries\\python::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Globals only\r",
    "code": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "The \"assignments\" query in the Python file of the codebase-index-ts repository targets and captures assignment expressions within a module, specifically focusing on the assignment of values to identifiers.",
    "importStatements": ""
  },
  {
    "id": "55c3adde-3f8a-4d7b-85ea-00d63c63b49a",
    "fullName": "\\src\\queries\\python",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition queries for Python\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}\r\n",
    "codeNoBody": "// Tree-sitter definition queries for Python\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "originFile": "\\src\\queries\\python.ts",
    "generatedDocumentation": "### File: `python.ts`\n\n#### Purpose:\nThe `python.ts` file defines a set of Tree-sitter queries specifically for analyzing Python code. These queries are used to extract various code elements and structures, enabling detailed code analysis and understanding of Python codebases.\n\n#### Main Features:\n- **Import Statements**: Extracts different types of import statements, including standard imports, wildcard imports, and future imports.\n- **Assignments**: Captures global assignment expressions within a module.\n- **Definitions**: Provides a template for extracting function and class definitions, including names, parameters, return types, bodies, and documentation.\n- **Constructor Definitions**: Identifies function and class definitions, including async functions and constructors.\n- **Calls**: Defines patterns for identifying various types of calls, such as class and function calls, method calls, self.parameter calls, class extensions, and more.\n- **Any Assignments**: Identifies assignments by capturing both the left (identifier) and right (value) sides, as well as function definitions with typed parameters.\n- **Extra Assignment Code**: Generates code snippets to handle specific assignment cases.\n\n#### Usage:\nThe `pyQueries` object consolidates all these query patterns, making it easier to perform comprehensive code analysis on Python codebases by matching and extracting relevant code elements and structures. This facilitates tasks such as code indexing, refactoring, and understanding dependencies within the code.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "599bddc5-9426-4229-a041-d226f2c8301c",
    "fullName": "\\src\\queries\\typescript::tsQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "tsQueries",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `tsQueries` assignment in the TypeScript queries file includes features such as `importStatements`, `constructorDefinitions`, `definitionTemplate`, `exportClauses`, `extraAssignmentCode`, `calls`, `assignments`, and `spaceDeclaration`, providing structured queries for extracting information related to import statements, constructor definitions, method signatures, export clauses, additional assignment code, function calls, and function declarations with type annotations, serving as a comprehensive tool for analyzing and processing TypeScript code snippets efficiently.",
    "importStatements": ""
  },
  {
    "id": "9e0b737c-bdb7-4b0d-b03c-fa349a217eff",
    "fullName": "\\src\\queries\\typescript::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "codeNoBody": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `anyAssignments` query in the TypeScript file retrieves function declarations with their parameters and type annotations from JavaScript code using jsQueries, appending the specified structure to the existing assignments query.",
    "importStatements": ""
  },
  {
    "id": "b93c8b96-bd57-4dc8-8224-129c93dae925",
    "fullName": "\\src\\queries\\typescript::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "codeNoBody": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The \"calls\" function in the TypeScript queries file concatenates the existing jsQueries.calls with additional type identifiers, specifically targeting parameter types and emphasizing the importance of handling calls to itself in classes to be removed.",
    "importStatements": ""
  },
  {
    "id": "5d19b613-eeec-49d8-98e2-d42615e42fac",
    "fullName": "\\src\\queries\\typescript::extraAssignmentCode",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// We need to know the assignment name\r",
    "code": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "codeNoBody": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "Code: const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "importStatements": ""
  },
  {
    "id": "47a3701d-62b8-4517-b523-0b318f128390",
    "fullName": "\\src\\queries\\typescript::exportClauses",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//The same as for JavaScript\r",
    "code": "const exportClauses = jsQueries.exportClauses",
    "codeNoBody": "const exportClauses = jsQueries.exportClauses",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "exportClauses",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "Code: const exportClauses = jsQueries.exportClauses",
    "importStatements": ""
  },
  {
    "id": "7d33690f-ed6b-43f9-8b22-f29642ef7e2c",
    "fullName": "\\src\\queries\\typescript::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//////////////////////////\r",
    "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `definitionTemplate` in the TypeScript queries file defines a template for method signatures and arrow functions, specifying elements like name, parameters, return type, and body, with optional formal parameters and type annotations, serving as a structured guide for parsing and extracting relevant information from code snippets.",
    "importStatements": ""
  },
  {
    "id": "415c4f8d-af6d-43e3-90f2-fbd48dd80cbf",
    "fullName": "\\src\\queries\\typescript",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition queries for Typescript\r\n\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "// Tree-sitter definition queries for Typescript\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "originFile": "\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `typescript.ts` file in the `\\src\\queries` folder defines Tree-sitter queries specifically tailored for analyzing and processing TypeScript code. It extends the JavaScript queries (`jsQueries`) to accommodate TypeScript-specific constructs. The main features of this file include:\n\n1. **Import Statements**: Reuses JavaScript import statement queries to identify and extract import statements in TypeScript.\n2. **Constructor Definitions**: Extends JavaScript constructor definitions to include TypeScript interfaces, enums, and type alias declarations.\n3. **Definition Template**: Provides a template for extracting method signatures and arrow functions, capturing elements like name, parameters, return type, and body.\n4. **Export Clauses**: Reuses JavaScript export clause queries to identify and extract export statements in TypeScript.\n5. **Extra Assignment Code**: Reuses additional assignment code from JavaScript to handle specific assignment cases.\n6. **Calls**: Extends JavaScript call queries to include type identifiers, ensuring accurate handling of method calls and type annotations.\n7. **Assignments**: Enhances JavaScript assignment queries to include function declarations with parameters and type annotations, ensuring correct identification of assignments.\n\nThe file serves as a comprehensive tool for extracting and analyzing various elements of TypeScript code, facilitating efficient code processing and analysis.",
    "importStatements": "import { jsQueries } from './javascript';\nimport { treeSitterQueries } from './index';"
  },
  {
    "id": "cb2cf895-1c47-4814-bb7a-561a0a8abbaf",
    "fullName": "\\src\\routes\\create_graph-test::repoRequestValidator",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
    "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "repoRequestValidator",
    "originFile": "\\src\\routes\\create_graph-test.ts",
    "generatedDocumentation": "The \"repoRequestValidator\" function in the codebase validates a JSON object containing user, repo, branch, and token properties using the zod library for type validation.",
    "importStatements": ""
  },
  {
    "id": "3b23c17b-61da-4dae-85d7-8aab8ec1e37e",
    "fullName": "\\src\\routes\\create_graph-test::createGraphTest",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
    "codeNoBody": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "createGraphTest",
    "originFile": "\\src\\routes\\create_graph-test.ts",
    "generatedDocumentation": "The \"createGraphTest\" function in the codebase is a POST endpoint that handles requests to create a graph representation of a codebase stored in a specified repository. It utilizes functions to download and extract the repository, retrieve the commit hash, parse the codebase, simplify the codebase structure, and generate links between code elements. The function also includes error handling to manage failed repository downloads and returns the generated graph as a JSON response. The \"repoRequestValidator\" function is used to validate the incoming JSON request object properties.",
    "importStatements": ""
  },
  {
    "id": "f9a6d4c0-df76-4b33-8534-9ea092bea1a1",
    "fullName": "\\src\\routes\\create_graph-test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test.ts",
    "originFile": "\\src\\routes\\create_graph-test.ts",
    "generatedDocumentation": "The `create_graph-test.ts` file defines a POST endpoint for creating a graph representation of a codebase from a specified repository. The main features and purpose of the file are:\n\n1. **Validation**: It uses `zod` and `zValidator` to validate incoming JSON requests, ensuring they contain the required properties: `user`, `repo`, `branch`, and `token`.\n\n2. **Repository Handling**: Upon receiving a valid request, the endpoint retrieves the commit hash of the specified branch and downloads and extracts the repository.\n\n3. **Codebase Parsing**: It initializes a `Codebase` object with the downloaded repository path, parses the folder structure, and generates a simplified representation of the codebase.\n\n4. **Graph Generation**: The endpoint creates a graph with nodes and links representing the code elements and their relationships.\n\n5. **Response**: The generated graph is returned as a JSON response. The endpoint includes error handling to manage issues such as failed repository downloads.\n\nOverall, the file's purpose is to provide an API endpoint that processes repository information to generate and return a graph representation of the codebase.",
    "importStatements": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'"
  },
  {
    "id": "e8990f41-45a7-4749-8f8c-48ee810ede9b",
    "fullName": "\\src\\routes\\create_graph::processGraphCreation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label,\r\n            origin_file,\r\n            import_statements\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label},\r\n            ${node.originFile},\r\n            ${node.importStatements.join('\\n')}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    \r\n    if (generateDocBool) {\r\n\r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n \r\n\r\n\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "codeNoBody": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "processGraphCreation",
    "originFile": "\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "The \"processGraphCreation\" function takes in parameters such as gitProvider, repoId, userOrgId, userId, graphExists, connectionId, codebasePath, repoName, and generateDocBool to handle the creation of a graph. It generates a unique graphId, determines the status of the graph creation, inserts graph data into the database, processes codebase files to extract nodes and links, inserts nodes and links into the database, and updates the graph status accordingly. Additionally, if generateDocBool is true, it generates and updates documentation for the graph using the provided data.",
    "importStatements": ""
  },
  {
    "id": "6dc653e6-986e-41d0-b063-2129aacfcdd3",
    "fullName": "\\src\\routes\\create_graph::repoRequestValidator",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)",
    "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "repoRequestValidator",
    "originFile": "\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "The \"repoRequestValidator\" function in the create_graph.ts file validates JSON data for creating a graph, checking for properties like git provider, repository organization, name, branch, connection ID, optional GitLab repository ID, and optional documentation generation flag.",
    "importStatements": ""
  },
  {
    "id": "d208669f-d8fb-4ab8-8528-d19530dfd62b",
    "fullName": "\\src\\routes\\create_graph::secret",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const secret = getEnv('SUPABASE_JWT')",
    "codeNoBody": "const secret = getEnv('SUPABASE_JWT')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "secret",
    "originFile": "\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "Code: const secret = getEnv('SUPABASE_JWT')",
    "importStatements": ""
  },
  {
    "id": "e09cc8b0-6c36-4660-9289-41691758a847",
    "fullName": "\\src\\routes\\create_graph::createGraph",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
    "codeNoBody": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "createGraph",
    "originFile": "\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "The \"createGraph\" function in create_graph.ts validates JSON data for creating a graph, including properties like git provider, repository organization, name, branch, connection ID, optional GitLab repository ID, and documentation generation flag, then handles the graph creation process by checking authorization, retrieving access tokens, getting commit information, verifying repository existence, and initiating background tasks for graph creation and documentation generation if specified.",
    "importStatements": ""
  },
  {
    "id": "49710af6-1250-4b09-a2b9-e9f0553deeb1",
    "fullName": "\\src\\routes\\create_graph",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label,\r\n            origin_file,\r\n            import_statements\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label},\r\n            ${node.originFile},\r\n            ${node.importStatements.join('\\n')}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    \r\n    if (generateDocBool) {\r\n\r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n \r\n\r\n\r\n\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { createGraph }\r\n",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst secret = getEnv('SUPABASE_JWT')\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional(),\r\n    generate_documentation: z.boolean().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId,\r\n    generate_documentation: generateDocBool\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath,\r\n      repoName,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath,\r\n  repoName,\r\n  generateDocBool\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n  repoName: string\r\n  generateDocBool?: boolean\r\n}) {\n//...\n}\r\n\r\nexport { createGraph }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "originFile": "\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "### File: `create_graph.ts`\n\n#### Purpose:\nThe `create_graph.ts` file defines an API endpoint for creating graphs based on code repositories. It handles the validation of incoming requests, authorization, and the initiation of the graph creation process, including optional documentation generation.\n\n#### Main Features:\n1. **Request Validation**:\n   - Uses `repoRequestValidator` to validate incoming JSON requests. The request must include properties like `git_provider`, `repo_org`, `repo_name`, `branch`, `connection_id`, and optional `gitlab_repo_id` and `generate_documentation` flag.\n\n2. **Authorization**:\n   - Extracts and verifies JWT from the request headers to ensure the user is authorized to perform the action.\n\n3. **Access Token Retrieval**:\n   - Retrieves access tokens for the specified git provider using the provided connection ID and user organization ID.\n\n4. **Commit Information**:\n   - Fetches the latest commit hash for the specified repository and branch.\n\n5. **Repository Existence Check**:\n   - Checks if the repository with the given commit hash already exists in the database. If not, it inserts a new repository record.\n\n6. **Graph Creation**:\n   - Initiates the graph creation process by downloading and extracting the repository, then calls `processGraphCreation` to handle the detailed graph creation tasks.\n\n7. **Background Task Handling**:\n   - The `processGraphCreation` function processes the codebase files to extract nodes and links, inserts them into the database, and updates the graph status. If `generateDocBool` is true, it also generates and updates the documentation for the graph.\n\n8. **Response Handling**:\n   - Returns appropriate JSON responses based on the success or failure of each step in the process.\n\nThis file is crucial for enabling users to create and manage graphs representing their code repositories, facilitating better code analysis and documentation.",
    "importStatements": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { GraphLink, GraphNode, sql } from '../utils/db'\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '../utils/utils'\nimport { GitServiceType } from '../utils/git'\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'"
  },
  {
    "id": "40fffc44-edb3-405d-a4de-19b2a749d835",
    "fullName": "\\src\\routes\\graphs::updateGraph",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label,\r\n          origin_file,\r\n          import_statements\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName},\r\n          ${node.label},\r\n          ${node.originFile},\r\n          ${node.importStatements.join('\\n')}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    if(generateDocBool) {\r\n      \r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "codeNoBody": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "updateGraph",
    "originFile": "\\src\\routes\\graphs.ts",
    "generatedDocumentation": "The \"updateGraph\" function takes an object with properties defined by the \"UpdateGraph\" interface to update a graph based on the provided Git repository information, including the Git provider type, repository details, branch, access token, commit hash, optional GitLab repository ID, graph ID, and a boolean flag to generate documentation. It downloads and extracts the repository, parses the codebase, simplifies the nodes, inserts nodes and links into the database, and updates the graph status accordingly. If specified, it also generates documentation for the graph nodes and links before marking the graph update as completed or failed.",
    "importStatements": ""
  },
  {
    "id": "c43d7272-940c-4e96-9a40-41529813db16",
    "fullName": "\\src\\routes\\graphs::UpdateGraph",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n  generateDocBool: boolean\r\n}",
    "codeNoBody": "interface UpdateGraph {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "UpdateGraph",
    "originFile": "\\src\\routes\\graphs.ts",
    "generatedDocumentation": "The \"UpdateGraph\" interface defines properties for updating a graph, including the Git provider type, repository organization and name, branch, access token, commit hash, optional GitLab repository ID, graph ID, and a boolean flag to generate documentation.",
    "importStatements": ""
  },
  {
    "id": "0767966f-c2a3-4a8f-8526-2329622bb3d4",
    "fullName": "\\src\\routes\\graphs::graphs",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
    "codeNoBody": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "graphs",
    "originFile": "\\src\\routes\\graphs.ts",
    "generatedDocumentation": "The \"graphs\" endpoint handles PATCH requests to update a specific graph based on user authentication, retrieves graph and repository information, verifies access tokens, fetches the latest commit hash, and updates the graph status accordingly. If the commit hash matches the repository's current one, it checks if documentation generation is requested, retrieves graph nodes, links, and folders from the database, and updates the documentation. If the commit hash differs, it triggers the \"updateGraph\" function to update the graph using the provided repository details and marks the update as completed or failed, also supporting documentation generation if specified.",
    "importStatements": ""
  },
  {
    "id": "58973bc1-e8c9-4516-a88e-52b43a01c5d3",
    "fullName": "\\src\\routes\\graphs",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\n\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n  generateDocBool: boolean\r\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label,\r\n          origin_file,\r\n          import_statements\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName},\r\n          ${node.label},\r\n          ${node.originFile},\r\n          ${node.importStatements.join('\\n')}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    if(generateDocBool) {\r\n      \r\n      const graphNodes: GraphNode[] = nodes.map(n => {\r\n        return {\r\n          id: nodeDBIds[n.id],\r\n          fullName: n.id,\r\n          type: n.type,\r\n          language: n.language,\r\n          documentation: n.documentation,\r\n          code: n.code,\r\n          codeNoBody: n.codeNoBody,\r\n          totalTokens: 0,\r\n          inDegree: 0,\r\n          outDegree: 0,\r\n          label: n.label,\r\n          originFile: n.originFile,\r\n          generatedDocumentation: '',\r\n          importStatements: n.importStatements.join('\\n')\r\n          }\r\n      })\r\n\r\n      const graphLinks: GraphLink[] = links.map(l => {\r\n          return {\r\n              id: '0',\r\n              source: nodeDBIds[l.source],\r\n              target: nodeDBIds[l.target],\r\n              label: l.label,\r\n              line: l.line\r\n          }\r\n      } )\r\n      await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { graphs }\r\n",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n    const generateDocBool = Boolean(c.req.query('generate_documentation')) || false\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      if (generateDocBool) {\r\n        const rows = await sql`\r\n        SELECT \r\n          id\r\n        FROM repositories\r\n        WHERE git_provider = ${gitProvider}\r\n          AND repo_org = ${repoOrg}\r\n          AND repo_name = ${repoName}\r\n          AND branch = ${branch}\r\n          AND commit_hash = ${commitHash}\r\n        `\r\n  \r\n        if (rows.length > 0) {\r\n            const repoId = rows[0].id\r\n            const res = await Promise.all([\r\n              getGraphNodesById({userOrgId, graphId}),\r\n              getGraphLinksById({userOrgId, graphId}),\r\n              getGraphFolderById({userOrgId, graphId})])\r\n\r\n            const graphNodes = res[0]\r\n            const graphLinks = res[1]\r\n            const graphFolders = res[2]\r\n            if (graphNodes.length > 0 && graphLinks.length > 0 ) {\r\n              await generateAndUpdateDocumentation(repoName, repoId, graphNodes, graphLinks, graphFolders)\r\n            }\r\n        }\r\n      }\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId,\r\n      generateDocBool\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\n//...\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId,\r\n  generateDocBool\r\n}: UpdateGraph) {\n//...\n}\r\n\r\nexport { graphs }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
    "originFile": "\\src\\routes\\graphs.ts",
    "generatedDocumentation": "### File: `graphs.ts`\n\n#### Purpose:\nThe `graphs.ts` file defines an endpoint for updating graph data associated with a specific Git repository. It handles user authentication, retrieves repository and graph information, verifies access tokens, fetches the latest commit hash, and updates the graph status accordingly. It also supports optional documentation generation for the graph nodes and links.\n\n#### Main Features:\n1. **Endpoint Definition**:\n   - Defines a PATCH endpoint at `/:id` to update a specific graph.\n   \n2. **User Authentication**:\n   - Validates the JWT token from the request header to authenticate the user.\n   \n3. **Graph and Repository Information Retrieval**:\n   - Fetches graph and repository details from the database based on the authenticated user and graph ID.\n   \n4. **Access Token Verification**:\n   - Retrieves access tokens for the specified Git provider to interact with the repository.\n   \n5. **Commit Hash Verification**:\n   - Fetches the latest commit hash from the repository to determine if an update is needed.\n   \n6. **Graph Status Update**:\n   - Updates the graph status in the database to 'updating' or 'completed' based on the commit hash comparison.\n   \n7. **Documentation Generation**:\n   - If requested, retrieves graph nodes, links, and folders from the database and generates documentation.\n   \n8. **Graph Update Handling**:\n   - Invokes the `updateGraph` function to update the graph using the provided repository details and marks the update as completed or failed.\n\nThis file is crucial for maintaining up-to-date graph data and documentation based on the latest repository changes, ensuring that users have access to the most current information.",
    "importStatements": "import { Hono } from 'hono'\nimport { getGraphFolderById, getGraphLinksById, getGraphNodesById, GraphLink, GraphNode, sql } from '../utils/db'\nimport { getEnv } from '../utils/utils'\nimport { jwtVerify } from 'jose'\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'\nimport { generateAndUpdateDocumentation } from '../wiki/wiki'"
  },
  {
    "id": "a87127ee-fd17-4ff7-aa05-83843c2d00e6",
    "fullName": "\\src\\tools\\function_tools::similarToDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
    "codeNoBody": "export const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarToDescription",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The `similarToDescription` function in the `function_tools.ts` file defines a FunctionDefinition object named 'similar_to' that describes a function to find similar node names based on a provided node name, returning a list of node Ids. The function takes an object parameter with a required property 'node_name' of type string representing the name to search for similar nodes.",
    "importStatements": ""
  },
  {
    "id": "973316fd-f8e6-4247-a8c5-286121660d9c",
    "fullName": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}",
    "codeNoBody": "export const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodebyNodeIdDescription",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This code defines a constant \"getCodebyNodeIdDescription\" representing a function to retrieve the code of a node based on its id, requiring the node_id parameter in the format \"my/path/file::node_name\" and providing a description for the function and its parameters.",
    "importStatements": ""
  },
  {
    "id": "7441e70e-5040-452b-9dec-74f3d3906479",
    "fullName": "\\src\\tools\\function_tools::getCodeDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
    "codeNoBody": "export const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodeDescription",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The `getCodeDescription` function defines a `FunctionDefinition` object with the name \"get_code\" and a description to retrieve the code of a node based on its name, specifying the required parameter \"node_name\" as a string within an object structure.",
    "importStatements": ""
  },
  {
    "id": "45d633e5-af35-48c2-bb1e-2f09f58425f4",
    "fullName": "\\src\\tools\\function_tools::similarToTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }",
    "codeNoBody": "function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarToTool",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"similarToTool\" function in the file \"function_tools.ts\" takes a nodeName and an optional type parameter, defaulting to 'undefined'. It internally calls the \"similarTo\" function with the provided parameters, which calculates the similarity between the nodeName and graph nodes of the specified type using Levenshtein distance, returning a list of similar node IDs categorized by type such as files, classes, functions, methods, interfaces, and assignments, or a message if no matches are found.",
    "importStatements": ""
  },
  {
    "id": "5b96da01-412d-49bf-b9c1-813aae6cb6af",
    "fullName": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }",
    "codeNoBody": "function getCodenbyNodeIdTool(nodeId: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodenbyNodeIdTool",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCodenbyNodeIdTool\" function in the function_tools module retrieves code snippets and related documentation from a graph structure based on the provided node ID. It internally calls the \"getCode\" function, which recursively explores connected nodes to a specified depth level, preventing revisiting nodes to avoid infinite loops. If the node is not found, it suggests similar nodes using Levenshtein distance. The function returns the retrieved code snippets, matched node name, and categorized top nodes by type for further analysis.",
    "importStatements": ""
  },
  {
    "id": "66159a7e-758f-4abb-9937-f6847dd64c8d",
    "fullName": "\\src\\tools\\function_tools::getCodeTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }",
    "codeNoBody": "function getCodeTool(nodeName: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodeTool",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCodeTool\" function in the function_tools module calls the \"getCode\" function to retrieve code snippets and related documentation from a graph structure based on the provided node name. It utilizes nodes and links data to find the relevant information. The \"getCode\" function recursively explores connected nodes, prevents revisiting nodes to avoid infinite loops, tracks visited nodes using the \"nodeSeen\" interface, and suggests similar nodes using the \"similarTo\" function based on Levenshtein distance if a node is not found. The output includes retrieved code snippets, matched node name, and categorized top nodes by type for further analysis.",
    "importStatements": ""
  },
  {
    "id": "262cf907-b4c4-4dfc-a52c-09222c5f6d28",
    "fullName": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}",
    "codeNoBody": "async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getUserToolsAndPrompt",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getUserToolsAndPrompt\" function retrieves graph nodes and links based on the provided \"userOrgId\" and \"graphId\" parameters, categorizes nodes by type, calculates language percentages, and generates a prompt displaying the most common node IDs per type. It also includes functions to get code snippets and related documentation by node name or ID, and to find similar nodes based on Levenshtein distance. The \"similarToTool\" function calculates node similarity, \"getCodenbyNodeIdTool\" retrieves code by node ID, and \"getCodeTool\" retrieves code by node name, all utilizing the \"similarTo\" function.",
    "importStatements": ""
  },
  {
    "id": "2d0c88d6-aa1d-4151-8935-ec18e7d072df",
    "fullName": "\\src\\tools\\function_tools::getCode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\r\n  if (!nodesSeen) {\r\n    nodesSeen = {}\r\n  }\r\n\r\n  let node: GraphNode | undefined\r\n  if (nodeId) {\r\n    node = nodes.find((node) => node.id === nodeId)\r\n    if (node) {\r\n      nodeName = node.label\r\n    }\r\n  } else if (nodeName) {\r\n    node = nodes.find((node) => node.label === nodeName) ||\r\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\r\n  }\r\n\r\n  let toReturn = ''\r\n  if (maxTokens < 0) {\r\n    return toReturn\r\n  }\r\n\r\n  if (Object.keys(nodesSeen).length > 0) {\r\n    toReturn += '\\n\\n-------\\n\\n'\r\n  }\r\n\r\n  if (node) {\r\n    nodesSeen[node.id] = true\r\n    const language = node.language\r\n    toReturn += `From ${node.full_name}:\\n`\r\n    if (node.documentation) {\r\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\r\n    }\r\n    if (node.total_tokens > maxTokens || node.type === 'file') {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\r\n    } else {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\r\n    }\r\n\r\n    if (maxDeepLevel > 0) {\r\n      maxDeepLevel -= 1\r\n      const calls = links.filter((link) =>\r\n        link.node_source_id === node!.id && link.label === 'calls'\r\n      )\r\n      for (const call of calls) {\r\n        if (nodesSeen[call.node_target_id]) {\r\n          continue\r\n        }\r\n        nodesSeen[call.node_target_id] = true\r\n        const callNode = await getCode(\r\n          nodes,\r\n          links,\r\n          undefined,\r\n          call.node_target_id,\r\n          maxTokens - node.total_tokens,\r\n          nodesSeen,\r\n          maxDeepLevel,\r\n        )\r\n        toReturn += callNode\r\n      }\r\n    }\r\n  } else {\r\n    toReturn = `There is no node named ${nodeName}.\\n`\r\n    if (nodeName) {\r\n      const res = similarTo(nodeName, nodes)\r\n      return {\r\n        ...res,\r\n        content: toReturn + res.content,\r\n        targetNodes: [],\r\n        sourceNodes: [],\r\n      }\r\n    }\r\n  }\r\n\r\n  let targetNodes: GraphNode[] = []\r\n  let sourceNodes: GraphNode[] = []\r\n\r\n  if (node) {\r\n    const targetLinks = links.filter((link) => {\r\n      return link.node_source_id === node.id\r\n    }) ?? []\r\n\r\n    const sourceLinks = links.filter((link) => {\r\n      return link.node_target_id === node.id\r\n    }) ?? []\r\n\r\n    sourceNodes = nodes.filter((node) => {\r\n      return sourceLinks.some((link) => link.node_source_id === node.id)\r\n    }) ?? []\r\n\r\n    targetNodes = nodes.filter((node) => {\r\n      return targetLinks.some((link) => link.node_target_id === node.id)\r\n    }) ?? []\r\n  }\r\n\r\n  return {\r\n    content: toReturn,\r\n    match: nodeName,\r\n    topFiles: [],\r\n    topClasses: [],\r\n    topFunctions: [],\r\n    topMethods: [],\r\n    topInterfaces: [],\r\n    topAssignments: [],\r\n    targetNodes,\r\n    sourceNodes,\r\n  }\r\n}",
    "codeNoBody": "async function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCode",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCode\" function in the function_tools module retrieves code snippets and related documentation from a graph structure based on provided node information, such as nodes, links, node name, and node ID. It recursively explores connected nodes up to a specified depth level, avoiding revisiting nodes to prevent infinite loops. The function utilizes the \"nodeSeen\" interface to track visited nodes, and if a node is not found, it uses the \"similarTo\" function to suggest similar nodes based on Levenshtein distance. The output includes the retrieved code snippets, matched node name, and categorized top nodes by type for further analysis.",
    "importStatements": ""
  },
  {
    "id": "40383a41-4c51-4501-8093-79219ca8ee7b",
    "fullName": "\\src\\tools\\function_tools::nodeSeen",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface nodeSeen {\r\n  [key: string]: boolean\r\n}",
    "codeNoBody": "interface nodeSeen {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeSeen",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"nodeSeen\" interface defines an object type where keys are strings and values are booleans, serving as a data structure to track the visibility status of nodes within a graph or data structure.",
    "importStatements": ""
  },
  {
    "id": "ef3255fc-2acb-4335-964b-6344817d21f2",
    "fullName": "\\src\\tools\\function_tools::similarTo",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Finds the most similar nodes to the given name based on their type.\r\n *\r\n * @param {string} name - The name to compare against.\r\n * @param {GraphNode[]} nodes - The array of nodes to search.\r\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\r\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\r\n */",
    "code": "function similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\r\n  const similarNodes = []\r\n  let topFiles: string[] = []\r\n  let topClasses: string[] = []\r\n  let topFunctions: string[] = []\r\n  let topMethods: string[] = []\r\n  let topInterfaces: string[] = []\r\n  let topAssignments: string[] = []\r\n  let similars: string[] = []\r\n\r\n  if (type === 'all') {\r\n    topFiles = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'file'),\r\n      n,\r\n    )\r\n\r\n    topClasses = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'class'),\r\n      n,\r\n    )\r\n    topFunctions = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'function'),\r\n      n,\r\n    )\r\n    topMethods = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'method'),\r\n      n,\r\n    )\r\n    topInterfaces = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'interface'),\r\n      n,\r\n    )\r\n    topAssignments = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'assignment'),\r\n      n,\r\n    )\r\n\r\n    if (topFiles.length > 0) {\r\n      similarNodes.push(` - Files: ${topFiles}`)\r\n    }\r\n    if (topClasses.length > 0) {\r\n      similarNodes.push(` - Classes: ${topClasses}`)\r\n    }\r\n    if (topFunctions.length > 0) {\r\n      similarNodes.push(` - Functions: ${topFunctions}`)\r\n    }\r\n    if (topMethods.length > 0) {\r\n      similarNodes.push(` - Methods: ${topMethods}`)\r\n    }\r\n    if (topInterfaces.length > 0) {\r\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\r\n    }\r\n    if (topAssignments.length > 0) {\r\n      similarNodes.push(` - Assignments: ${topAssignments}`)\r\n    }\r\n  } else {\r\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\r\n    if (similars.length > 0) {\r\n      similarNodes.push(\r\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\r\n      )\r\n    }\r\n  }\r\n\r\n  if (similarNodes.length === 0) {\r\n    return {\r\n      content: `No similar node IDs found for ${name}.`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  } else {\r\n    return {\r\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  }\r\n}",
    "codeNoBody": "function similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarTo",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"similarTo\" function takes a name, an array of graph nodes, a node type (defaulting to 'all'), and an optional number \"n\" as parameters. It calculates the similarity between the provided name and nodes of the specified type using the \"topNSimilar\" function based on Levenshtein distance, returning a list of similar node IDs. The function categorizes and aggregates the similar nodes by type, providing the top matches for files, classes, functions, methods, interfaces, and assignments. If no matches are found, it returns a message indicating the absence of similar node IDs.",
    "importStatements": ""
  },
  {
    "id": "bbef67c0-19a7-47f7-ae6e-0c47035a5fb2",
    "fullName": "\\src\\tools\\function_tools::topNSimilar",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\r\n  const similarities: Similarity[] = nodes.map((n) => ({\r\n    id: n.full_name,\r\n    score: distance(targetName, n.label),\r\n  }))\r\n\r\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\r\n\r\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\r\n    .map((item) => item.id)\r\n}",
    "codeNoBody": "function topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "topNSimilar",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The function \"topNSimilar\" takes a target name, an array of graph nodes, and an optional number \"n\" as parameters, where \"n\" defaults to 10. It calculates the similarity scores between the target name and each node label using the Levenshtein distance algorithm, then returns an array of up to \"n\" node IDs that have similarity scores below a predefined threshold defined in CONFIGURATION.DISTANCE_THRESHOLD.",
    "importStatements": ""
  },
  {
    "id": "6a44b05f-b021-4872-9c3f-ff6e683f8c2a",
    "fullName": "\\src\\tools\\function_tools::getGraphLinksById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id,\r\n        l.node_target_id,\r\n        l.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphLinksById",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This async function \"getGraphLinksById\" retrieves graph links based on the provided \"userOrgId\" and \"graphId\" parameters by querying the database for specific link details such as id, source node id, target node id, and label. It returns a Promise that resolves to an array of GraphLink objects. If an error occurs during the database query, it logs the error and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "e96604c6-6416-4f4f-a1cc-b4ac9daefb1f",
    "fullName": "\\src\\tools\\function_tools::getGraphNodesById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name,\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body,\r\n        n.total_tokens,\r\n        n.in_degree,\r\n        n.out_degree,\r\n        n.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphNodesById",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This async function \"getGraphNodesById\" retrieves graph nodes based on the provided \"userOrgId\" and \"graphId\" parameters by querying the database for nodes' information such as id, full name, type, language, documentation, code, and more. It uses SQL queries to join tables and filter results by the organization ID, graph ID, and completion status. In case of an error, it logs the issue and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "4023540e-7e4b-4250-9bc2-fa7727f4da8d",
    "fullName": "\\src\\tools\\function_tools::Similarity",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface Similarity {\r\n  id: string\r\n  score: number\r\n}",
    "codeNoBody": "interface Similarity {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Similarity",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The interface \"Similarity\" defines a structure with two properties: \"id\" of type string and \"score\" of type number, representing an object that holds an identifier and a numerical value for similarity comparison purposes.",
    "importStatements": ""
  },
  {
    "id": "5cb93420-43c6-448b-ba58-5ee30c6b4889",
    "fullName": "\\src\\tools\\function_tools::calculateLanguagePercentages",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function calculateLanguagePercentages(languages: string[]) {\r\n  const total = languages.length\r\n  const counts: Record<string, number> = {}\r\n\r\n  languages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1\r\n  })\r\n\r\n  const percentages: Record<string, string> = {}\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\r\n    parseFloat(b[1]) - parseFloat(a[1])\r\n  )\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\r\n\r\n  return sortedPercentages\r\n}",
    "codeNoBody": "function calculateLanguagePercentages(languages: string[]) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calculateLanguagePercentages",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The function \"calculateLanguagePercentages\" takes an array of strings representing programming languages as a parameter, calculates the percentage of each language occurrence in the array, and returns an object with each language as a key and its corresponding percentage as a value, sorted in descending order of percentage.",
    "importStatements": ""
  },
  {
    "id": "e53e8ccb-b902-4fba-831b-0b95295130d4",
    "fullName": "\\src\\tools\\function_tools",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\r\nimport { sql } from '@/lib/db/index.ts'\r\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\r\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\r\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\r\n\r\nfunction calculateLanguagePercentages(languages: string[]) {\r\n  const total = languages.length\r\n  const counts: Record<string, number> = {}\r\n\r\n  languages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1\r\n  })\r\n\r\n  const percentages: Record<string, string> = {}\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\r\n    parseFloat(b[1]) - parseFloat(a[1])\r\n  )\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\r\n\r\n  return sortedPercentages\r\n}\r\n\r\ninterface Similarity {\r\n  id: string\r\n  score: number\r\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name,\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body,\r\n        n.total_tokens,\r\n        n.in_degree,\r\n        n.out_degree,\r\n        n.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id,\r\n        l.node_target_id,\r\n        l.label\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nfunction topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\r\n  const similarities: Similarity[] = nodes.map((n) => ({\r\n    id: n.full_name,\r\n    score: distance(targetName, n.label),\r\n  }))\r\n\r\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\r\n\r\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\r\n    .map((item) => item.id)\r\n}\r\n\r\n/**\r\n * Finds the most similar nodes to the given name based on their type.\r\n *\r\n * @param {string} name - The name to compare against.\r\n * @param {GraphNode[]} nodes - The array of nodes to search.\r\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\r\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\r\n */\r\nfunction similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\r\n  const similarNodes = []\r\n  let topFiles: string[] = []\r\n  let topClasses: string[] = []\r\n  let topFunctions: string[] = []\r\n  let topMethods: string[] = []\r\n  let topInterfaces: string[] = []\r\n  let topAssignments: string[] = []\r\n  let similars: string[] = []\r\n\r\n  if (type === 'all') {\r\n    topFiles = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'file'),\r\n      n,\r\n    )\r\n\r\n    topClasses = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'class'),\r\n      n,\r\n    )\r\n    topFunctions = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'function'),\r\n      n,\r\n    )\r\n    topMethods = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'method'),\r\n      n,\r\n    )\r\n    topInterfaces = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'interface'),\r\n      n,\r\n    )\r\n    topAssignments = topNSimilar(\r\n      name,\r\n      nodes.filter((n) => n.type === 'assignment'),\r\n      n,\r\n    )\r\n\r\n    if (topFiles.length > 0) {\r\n      similarNodes.push(` - Files: ${topFiles}`)\r\n    }\r\n    if (topClasses.length > 0) {\r\n      similarNodes.push(` - Classes: ${topClasses}`)\r\n    }\r\n    if (topFunctions.length > 0) {\r\n      similarNodes.push(` - Functions: ${topFunctions}`)\r\n    }\r\n    if (topMethods.length > 0) {\r\n      similarNodes.push(` - Methods: ${topMethods}`)\r\n    }\r\n    if (topInterfaces.length > 0) {\r\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\r\n    }\r\n    if (topAssignments.length > 0) {\r\n      similarNodes.push(` - Assignments: ${topAssignments}`)\r\n    }\r\n  } else {\r\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\r\n    if (similars.length > 0) {\r\n      similarNodes.push(\r\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\r\n      )\r\n    }\r\n  }\r\n\r\n  if (similarNodes.length === 0) {\r\n    return {\r\n      content: `No similar node IDs found for ${name}.`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  } else {\r\n    return {\r\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\r\n      match: '',\r\n      similars: similarNodes.slice(0, 1),\r\n      topFiles: topFiles.slice(0, 1),\r\n      topClasses: topClasses.slice(0, 1),\r\n      topFunctions: topFunctions.slice(0, 1),\r\n      topMethods: topMethods.slice(0, 1),\r\n      topInterfaces: topInterfaces.slice(0, 1),\r\n      topAssignments: topAssignments.slice(0, 1),\r\n    }\r\n  }\r\n}\r\n\r\ninterface nodeSeen {\r\n  [key: string]: boolean\r\n}\r\n\r\nasync function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\r\n  if (!nodesSeen) {\r\n    nodesSeen = {}\r\n  }\r\n\r\n  let node: GraphNode | undefined\r\n  if (nodeId) {\r\n    node = nodes.find((node) => node.id === nodeId)\r\n    if (node) {\r\n      nodeName = node.label\r\n    }\r\n  } else if (nodeName) {\r\n    node = nodes.find((node) => node.label === nodeName) ||\r\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\r\n  }\r\n\r\n  let toReturn = ''\r\n  if (maxTokens < 0) {\r\n    return toReturn\r\n  }\r\n\r\n  if (Object.keys(nodesSeen).length > 0) {\r\n    toReturn += '\\n\\n-------\\n\\n'\r\n  }\r\n\r\n  if (node) {\r\n    nodesSeen[node.id] = true\r\n    const language = node.language\r\n    toReturn += `From ${node.full_name}:\\n`\r\n    if (node.documentation) {\r\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\r\n    }\r\n    if (node.total_tokens > maxTokens || node.type === 'file') {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\r\n    } else {\r\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\r\n    }\r\n\r\n    if (maxDeepLevel > 0) {\r\n      maxDeepLevel -= 1\r\n      const calls = links.filter((link) =>\r\n        link.node_source_id === node!.id && link.label === 'calls'\r\n      )\r\n      for (const call of calls) {\r\n        if (nodesSeen[call.node_target_id]) {\r\n          continue\r\n        }\r\n        nodesSeen[call.node_target_id] = true\r\n        const callNode = await getCode(\r\n          nodes,\r\n          links,\r\n          undefined,\r\n          call.node_target_id,\r\n          maxTokens - node.total_tokens,\r\n          nodesSeen,\r\n          maxDeepLevel,\r\n        )\r\n        toReturn += callNode\r\n      }\r\n    }\r\n  } else {\r\n    toReturn = `There is no node named ${nodeName}.\\n`\r\n    if (nodeName) {\r\n      const res = similarTo(nodeName, nodes)\r\n      return {\r\n        ...res,\r\n        content: toReturn + res.content,\r\n        targetNodes: [],\r\n        sourceNodes: [],\r\n      }\r\n    }\r\n  }\r\n\r\n  let targetNodes: GraphNode[] = []\r\n  let sourceNodes: GraphNode[] = []\r\n\r\n  if (node) {\r\n    const targetLinks = links.filter((link) => {\r\n      return link.node_source_id === node.id\r\n    }) ?? []\r\n\r\n    const sourceLinks = links.filter((link) => {\r\n      return link.node_target_id === node.id\r\n    }) ?? []\r\n\r\n    sourceNodes = nodes.filter((node) => {\r\n      return sourceLinks.some((link) => link.node_source_id === node.id)\r\n    }) ?? []\r\n\r\n    targetNodes = nodes.filter((node) => {\r\n      return targetLinks.some((link) => link.node_target_id === node.id)\r\n    }) ?? []\r\n  }\r\n\r\n  return {\r\n    content: toReturn,\r\n    match: nodeName,\r\n    topFiles: [],\r\n    topClasses: [],\r\n    topFunctions: [],\r\n    topMethods: [],\r\n    topInterfaces: [],\r\n    topAssignments: [],\r\n    targetNodes,\r\n    sourceNodes,\r\n  }\r\n}\r\n\r\nexport async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\r\n  const [nodes, links] = await Promise.all([\r\n    getGraphNodesById({ userOrgId, graphId }),\r\n    getGraphLinksById({ userOrgId, graphId }),\r\n  ])\r\n\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = []\r\n    }\r\n    acc[node.type].push(node)\r\n    return acc\r\n  }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\r\n    ).slice(0, 5).map((n) => n.full_name)\r\n    return acc\r\n  }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n  const allLanguages = calculateLanguagePercentages(\r\n    nodesPerType['file'].map((n) => n.language),\r\n  )\r\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\r\n    `${name}: ${pct}`\r\n  ).join(', ')\r\n\r\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\r\n      mostUsedNodesPerType[type as NodeType]\r\n    }`\r\n  }).join('\\n')\r\n\r\n  prompt = `Languages: ${allLanguagesString}\r\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n  These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n  function getCodeTool(nodeName: string) {\r\n    return getCode(nodes, links, nodeName)\r\n  }\r\n\r\n  function getCodenbyNodeIdTool(nodeId: string) {\r\n    return getCode(nodes, links, undefined, nodeId)\r\n  }\r\n\r\n  function similarToTool(\r\n    nodeName: string,\r\n    type: NodeType | undefined = undefined,\r\n  ) {\r\n    return similarTo(nodeName, nodes, type)\r\n  }\r\n\r\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\r\n}\r\n\r\nexport const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}\r\n\r\nexport const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\r\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\r\n\r\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\r\n// const links = await getGraphLinksById({ userOrgId, graphId })\r\n\r\n// console.log(await getCode(nodes, links, 'langchain_utils'))\r\n\r\n// // console.log(similarTo('Props', nodes, 'all'))\r\n// const nodesPerType = nodes.reduce((acc, node) => {\r\n//   if (!acc[node.type]) {\r\n//     acc[node.type] = []\r\n//   }\r\n//   acc[node.type].push(node)\r\n//   return acc\r\n// }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\r\n\r\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\r\n// console.log(allLanguagesString)\r\n\r\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\r\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\r\n//     ).slice(0, 5).map((n) => n.full_name)\r\n//   return acc\r\n// }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\r\n// }).join('\\n')\r\n\r\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n// These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n// console.log(prompt)\r\n",
    "codeNoBody": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\r\nimport { sql } from '@/lib/db/index.ts'\r\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\r\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\r\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\r\nfunction calculateLanguagePercentages(languages: string[]) {\n//...\n}\r\n\r\ninterface Similarity {\n//...\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }\r\n\r\nfunction topNSimilar(\r\n  targetName: string,\r\n  nodes: GraphNode[],\r\n  n: number = 10,\r\n): string[] {\n//...\n}\r\n\r\n/**\r\n * Finds the most similar nodes to the given name based on their type.\r\n *\r\n * @param {string} name - The name to compare against.\r\n * @param {GraphNode[]} nodes - The array of nodes to search.\r\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\r\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\r\n */\r\nfunction similarTo(\r\n  name: string,\r\n  nodes: GraphNode[],\r\n  type: NodeType | 'all' = 'all',\r\n  n = 10,\r\n) {\n//...\n}\r\n\r\ninterface nodeSeen {\n//...\n}\r\n\r\nasync function getCode(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  nodeName?: string,\r\n  nodeId?: string,\r\n  maxTokens = 4096,\r\n  nodesSeen: nodeSeen = {},\r\n  maxDeepLevel = 2,\r\n  // deno-lint-ignore no-explicit-any\r\n): Promise<any> {\n//...\n}\r\n\r\nexport async function getUserToolsAndPrompt(\r\n  userOrgId: string,\r\n  graphId: string,\r\n) {\n       //...\n       }\r\n\r\nexport const getCodeDescription: FunctionDefinition = {\r\n  name: 'get_code',\r\n  description: 'Get the code of a node by its name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The name of the node to get the code of',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\r\n  name: 'get_code_by_node_id',\r\n  description:\r\n    'Get the code of a node by its id in the form my/path/file::node_name',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_id: {\r\n        type: 'string',\r\n        description:\r\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\r\n      },\r\n    },\r\n    required: ['node_id'],\r\n  },\r\n}\r\n\r\nexport const similarToDescription: FunctionDefinition = {\r\n  name: 'similar_to',\r\n  description:\r\n    'Find similar node names by a name. It returns a list of node Ids.',\r\n  parameters: {\r\n    type: 'object',\r\n    properties: {\r\n      node_name: {\r\n        type: 'string',\r\n        description: 'The node name to search for similar nodes',\r\n      },\r\n    },\r\n    required: ['node_name'],\r\n  },\r\n}\r\n\r\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\r\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\r\n\r\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\r\n// const links = await getGraphLinksById({ userOrgId, graphId })\r\n\r\n// console.log(await getCode(nodes, links, 'langchain_utils'))\r\n\r\n// // console.log(similarTo('Props', nodes, 'all'))\r\n// const nodesPerType = nodes.reduce((acc, node) => {\r\n//   if (!acc[node.type]) {\r\n//     acc[node.type] = []\r\n//   }\r\n//   acc[node.type].push(node)\r\n//   return acc\r\n// }, {} as Record<NodeType, GraphNode[]>)\r\n\r\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\r\n\r\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\r\n// console.log(allLanguagesString)\r\n\r\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\r\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\r\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\r\n//     ).slice(0, 5).map((n) => n.full_name)\r\n//   return acc\r\n// }, {} as Record<NodeType, (string | number)[]>)\r\n\r\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\r\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\r\n// }).join('\\n')\r\n\r\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\r\n// These are the most common nodes Ids from the repository:\\n${prompt}`\r\n\r\n// console.log(prompt)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "originFile": "\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "### File: `function_tools.ts`\n\n#### Purpose:\nThe `function_tools.ts` file provides a set of utility functions and definitions for managing and analyzing graph structures, specifically focusing on nodes and links within a graph. It includes functionalities for retrieving graph data, calculating similarities, and generating descriptive prompts for user tools.\n\n#### Main Features:\n\n1. **Graph Data Retrieval:**\n   - `getGraphNodesById`: Fetches graph nodes from a database based on `userOrgId` and `graphId`.\n   - `getGraphLinksById`: Retrieves graph links from a database using `userOrgId` and `graphId`.\n\n2. **Code Retrieval:**\n   - `getCode`: Recursively retrieves code snippets and related documentation from a graph structure based on node information (name or ID).\n\n3. **Similarity Calculation:**\n   - `similarTo`: Finds and returns the most similar node names to a given name based on Levenshtein distance, categorized by node type.\n   - `topNSimilar`: Helper function to calculate and return the top `n` similar nodes to a given name.\n\n4. **Language Analysis:**\n   - `calculateLanguagePercentages`: Calculates the percentage distribution of programming languages within the nodes.\n\n5. **Function Definitions for External Use:**\n   - `getCodeDescription`: Defines a function to retrieve code by node name.\n   - `getCodebyNodeIdDescription`: Defines a function to retrieve code by node ID.\n   - `similarToDescription`: Defines a function to find similar nodes by name.\n\n6. **User Tools and Prompt Generation:**\n   - `getUserToolsAndPrompt`: Retrieves nodes and links, categorizes them, calculates language percentages, and generates a prompt displaying the most common node IDs per type.\n\n#### Interfaces:\n- `Similarity`: Defines the structure for similarity comparison with properties `id` and `score`.\n- `nodeSeen`: Defines a structure to track the visibility status of nodes within a graph.\n\nThis file is essential for managing graph data, performing similarity analysis, and generating descriptive prompts, which are crucial for tools that interact with graph-based representations of code repositories.",
    "importStatements": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'"
  },
  {
    "id": "05718771-e94f-4f21-896a-5233d03b694c",
    "fullName": "\\src\\utils\\ai::getOpenAIChatCompletion",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
    "codeNoBody": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getOpenAIChatCompletion",
    "originFile": "\\src\\utils\\ai.ts",
    "generatedDocumentation": "This async function \"getOpenAIChatCompletion\" in the AI utility module takes in an array of chat messages \"messages\" and an optional model string \"model\" (defaulting to 'gpt-4o-mini'), then uses the OpenAI API to generate a chat completion based on the provided messages with a temperature of 0.3. It returns an object with the AI's response in the \"response\" property and the total tokens used in the response generation in the optional \"tokens\" property, following the structure defined in the \"chatResponse\" interface.",
    "importStatements": ""
  },
  {
    "id": "ea95f86d-fc45-46b7-9357-30a07465de6d",
    "fullName": "\\src\\utils\\ai::chatResponse",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}",
    "codeNoBody": "interface chatResponse {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "chatResponse",
    "originFile": "\\src\\utils\\ai.ts",
    "generatedDocumentation": "The \"chatResponse\" interface in the AI utility module defines an object with a \"response\" property of type string, representing the AI's generated response, and an optional \"tokens\" property of type number indicating the number of tokens used in the response generation process.",
    "importStatements": ""
  },
  {
    "id": "fb5fa2fd-5459-407d-baa5-2818e40daa84",
    "fullName": "\\src\\utils\\ai::chatCompletionMessages",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "codeNoBody": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "chatCompletionMessages",
    "originFile": "\\src\\utils\\ai.ts",
    "generatedDocumentation": "Code: type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "importStatements": ""
  },
  {
    "id": "97c66e0f-1bfd-419b-8f34-a7257f957568",
    "fullName": "\\src\\utils\\ai",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import OpenAI from 'openai';\r\n\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
    "codeNoBody": "import OpenAI from 'openai';\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\n//...\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-4o-mini') : Promise<chatResponse> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
    "originFile": "\\src\\utils\\ai.ts",
    "generatedDocumentation": "# ai.ts\n\n## Purpose\nThe `ai.ts` file in the `utils` directory is designed to facilitate interactions with the OpenAI API, specifically for generating chat completions. It provides a utility function to send a series of chat messages to the OpenAI API and receive a generated response.\n\n## Main Features\n\n### Types\n- **chatCompletionMessages**: This type represents an array of chat messages that follow the structure defined by `OpenAI.Chat.Completions.ChatCompletionMessageParam`.\n\n### Interfaces\n- **chatResponse**: This interface defines the structure of the response object returned by the `getOpenAIChatCompletion` function. It includes:\n  - `response`: A string representing the AI's generated response.\n  - `tokens` (optional): A number indicating the total tokens used in generating the response.\n\n### Functions\n- **getOpenAIChatCompletion**: \n  - **Parameters**:\n    - `messages`: An array of chat messages of type `chatCompletionMessages`.\n    - `model` (optional): A string specifying the model to use, defaulting to 'gpt-4o-mini'.\n  - **Returns**: A promise that resolves to a `chatResponse` object.\n  - **Description**: This async function sends the provided chat messages to the OpenAI API using the specified model (or the default model if none is specified). It sets a temperature of 0.3 for the response generation. The function returns an object containing the AI's response and optionally the total number of tokens used.",
    "importStatements": "import OpenAI from 'openai';"
  },
  {
    "id": "4c7a97f4-28fd-4701-b629-be3f6d4a31c0",
    "fullName": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "refreshAccessToken",
    "originFile": "\\src\\utils\\bitbucket\\refresh-token.ts",
    "generatedDocumentation": "The function \"refreshAccessToken\" takes a refresh token as a parameter and sends a POST request to Bitbucket's OAuth2 access token endpoint to refresh the access token. It uses the provided refresh token along with the client ID and client secret from environment variables to authenticate the request. If successful, it returns a new access token and refresh token; otherwise, it logs an error message and returns null.",
    "importStatements": ""
  },
  {
    "id": "e6ce2271-14b0-4c00-b9b5-c889be3d6143",
    "fullName": "\\src\\utils\\bitbucket\\refresh-token",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts",
    "originFile": "\\src\\utils\\bitbucket\\refresh-token.ts",
    "generatedDocumentation": "### File: `refresh-token.ts`\n\n#### Purpose:\nThe purpose of this file is to handle the process of refreshing Bitbucket OAuth2 access tokens.\n\n#### Main Features:\n- **Function `refreshAccessToken`**: \n  - **Parameters**: Takes a `refreshToken` string as input.\n  - **Functionality**: Sends a POST request to Bitbucket's OAuth2 access token endpoint using the provided refresh token, client ID, and client secret (retrieved from environment variables).\n  - **Output**: If the request is successful, it returns a new access token and refresh token. In case of failure, it logs an error message and returns `null`.\n\nThis utility is essential for maintaining authenticated sessions with Bitbucket by ensuring that access tokens are refreshed automatically when they expire.",
    "importStatements": "import { getEnv } from \"../utils\""
  },
  {
    "id": "f0bc9a24-ad7d-42c8-a57c-9ffe94b3ec21",
    "fullName": "\\src\\utils\\db::getGraphFolderById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\r\n  try {\r\n    const rows = await sql<GraphFolder[]>`\r\n      SELECT\r\n        f.id,\r\n        f.name,\r\n        f.wiki\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN graph_folders f\r\n        ON f.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph folder by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphFolderById",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The `getGraphFolderById` function retrieves a list of graph folders by their unique identifiers, filtering by the user organization ID and the graph ID. It queries the database to fetch the folder's ID, name, and associated wiki URL from the \"graph_folders\" table, considering the completed status of the graph and the matching organization ID. In case of an error during the database operation, it logs the error and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "06b39596-b91d-4cca-82f5-5beecdec3f41",
    "fullName": "\\src\\utils\\db::getGraphLinksById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphLinksById",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The function \"getGraphLinksById\" retrieves graph links based on the provided user organization ID and graph ID, querying the database to fetch link data such as the link identifier, connected nodes' source and target, label, and an optional line property from the \"links\" table, filtering by the specified graph ID, user organization ID, and completed status. If successful, it returns an array of GraphLink objects; otherwise, it logs an error and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "8d9dd388-1375-45eb-9053-4d6c32dec093",
    "fullName": "\\src\\utils\\db::getGraphNodesById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS \"fullName\",\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS \"codeNoBody\",\r\n        n.total_tokens AS \"totalTokens\",\r\n        n.in_degree AS \"inDegree\",\r\n        n.out_degree AS \"outDegree\",\r\n        n.label,\r\n        n.origin_file AS \"originFile\",\r\n        n.generated_documentation AS \"generatedDocumentation\",\r\n        n.import_statements AS \"importStatements\"\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphNodesById",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The function \"getGraphNodesById\" retrieves graph nodes by their identifiers from a PostgreSQL database based on the provided user organization ID and graph ID. It executes a SQL query to select various properties of the nodes, such as their ID, full name, type, language, documentation, code snippets, token count, in and out degrees, label, origin file, generated documentation, and import statements, from the \"graphs,\" \"repositories,\" and \"nodes\" tables. If successful, it returns an array of graph nodes; otherwise, it logs an error and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "2f7f6aed-fb9f-448c-8ffe-ceae98d1a0fc",
    "fullName": "\\src\\utils\\db::GraphFolder",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface GraphFolder {\r\n  id: string\r\n  name: string\r\n  wiki: string\r\n}",
    "codeNoBody": "interface GraphFolder {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GraphFolder",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The \"GraphFolder\" interface defines a structure with three properties: \"id\" representing a string identifier, \"name\" for the folder name, and \"wiki\" for the associated wiki page URL.",
    "importStatements": ""
  },
  {
    "id": "95f84fe2-5013-4274-935b-0a859bf787a9",
    "fullName": "\\src\\utils\\db::GraphLink",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}",
    "codeNoBody": "interface GraphLink {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GraphLink",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The \"GraphLink\" interface defines the structure for representing links in a graph, including properties such as \"id\" for the link identifier, \"source\" and \"target\" for the connected nodes, \"label\" for the link label, and an optional \"line\" property for additional information.",
    "importStatements": ""
  },
  {
    "id": "654c9ff7-ed97-403b-8994-53779ed59209",
    "fullName": "\\src\\utils\\db::GraphNode",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}",
    "codeNoBody": "interface GraphNode {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GraphNode",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The \"GraphNode\" interface defines properties for representing a node in a graph, including an identifier, full name, type, language, optional documentation, code snippets, token count, in and out degrees, label, origin file, generated documentation, and import statements.",
    "importStatements": ""
  },
  {
    "id": "0c9a8ec4-4717-47f3-8c0f-cc37c0de6384",
    "fullName": "\\src\\utils\\db::sql",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "codeNoBody": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "sql",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "The `sql` function in the `db.ts` file establishes a connection to a PostgreSQL database using the provided environment variables for the host, database name, port, username, password, and SSL certificate. It includes settings for connection and idle timeouts, as well as SSL configuration for secure communication.",
    "importStatements": ""
  },
  {
    "id": "434d4dd3-d865-46e3-8581-afec0acfe4f1",
    "fullName": "\\src\\utils\\db",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\n\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}\r\n\r\nexport interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}\r\n\r\nexport interface GraphFolder {\r\n  id: string\r\n  name: string\r\n  wiki: string\r\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS \"fullName\",\r\n        n.type,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS \"codeNoBody\",\r\n        n.total_tokens AS \"totalTokens\",\r\n        n.in_degree AS \"inDegree\",\r\n        n.out_degree AS \"outDegree\",\r\n        n.label,\r\n        n.origin_file AS \"originFile\",\r\n        n.generated_documentation AS \"generatedDocumentation\",\r\n        n.import_statements AS \"importStatements\"\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\r\n  try {\r\n    const rows = await sql<GraphFolder[]>`\r\n      SELECT\r\n        f.id,\r\n        f.name,\r\n        f.wiki\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN graph_folders f\r\n        ON f.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph folder by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\n       //...\n       }\r\n\r\nexport interface GraphLink {\n       //...\n       }\r\n\r\nexport interface GraphFolder {\n       //...\n       }\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }\r\n\r\nexport async function getGraphFolderById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphFolder[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "originFile": "\\src\\utils\\db.ts",
    "generatedDocumentation": "### File: `db.ts`\n\n#### Purpose:\nThe `db.ts` file is responsible for managing database interactions within the application. It establishes a connection to a PostgreSQL database and provides functions to retrieve graph-related data, such as nodes, links, and folders, based on specific identifiers.\n\n#### Main Features:\n\n1. **Database Connection:**\n   - The `sql` function sets up a connection to a PostgreSQL database using environment variables for configuration. It includes settings for connection timeouts and SSL for secure communication.\n\n2. **GraphNode Interface:**\n   - Defines the structure for graph nodes, including properties like ID, full name, type, language, documentation, code snippets, token count, degrees, label, origin file, generated documentation, and import statements.\n\n3. **GraphLink Interface:**\n   - Defines the structure for graph links, including properties such as ID, source and target nodes, label, and an optional line property.\n\n4. **GraphFolder Interface:**\n   - Defines the structure for graph folders, including properties like ID, name, and associated wiki URL.\n\n5. **getGraphNodesById Function:**\n   - Retrieves graph nodes based on user organization ID and graph ID. It queries the database to fetch various properties of the nodes and returns an array of `GraphNode` objects.\n\n6. **getGraphLinksById Function:**\n   - Retrieves graph links based on user organization ID and graph ID. It queries the database to fetch link data and returns an array of `GraphLink` objects.\n\n7. **getGraphFolderById Function:**\n   - Retrieves graph folders based on user organization ID and graph ID. It queries the database to fetch folder details and returns an array of `GraphFolder` objects.\n\nThese functions handle database queries and ensure that the application can efficiently retrieve and utilize graph-related data.",
    "importStatements": "import { AllowedTypes } from '../model/consts'\nimport { getEnv } from './utils'\nimport postgres from 'postgres'"
  },
  {
    "id": "5be39943-924a-44a6-b148-28853bd98a20",
    "fullName": "\\src\\utils\\git::getAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getAccessToken",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "The function \"getAccessToken\" in the file retrieves the access token and refresh token for a given Git service provider, specified by the \"gitProvider\" parameter which can be 'github', 'gitlab', or 'bitbucket', based on the connection ID and user organization ID provided. If the connection ID is '-1', it returns a default access token. Otherwise, it queries the database to fetch the access token and refresh token associated with the provided connection ID and user organization ID, returning them if found or null if not found or an error occurs.",
    "importStatements": ""
  },
  {
    "id": "a29b7b41-1659-42e6-8d1b-5cabf42214e6",
    "fullName": "\\src\\utils\\git::getCommitHash",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
    "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCommitHash",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "The function \"getCommitHash\" takes two parameters: \"provider\" specifying the source control platform (github, gitlab, or bitbucket) and \"data\" containing the commit information. It returns the commit hash based on the provider: for github, it returns the \"sha\" property of the first element in the data array; for gitlab, it returns the \"id\" property of the first element; and for bitbucket, it returns the \"hash\" property of the first element in the \"values\" array within the data object. If the provider is not recognized, it returns an empty string.",
    "importStatements": ""
  },
  {
    "id": "1a29cf8a-2e60-4d8a-8da4-1124cb2f01ca",
    "fullName": "\\src\\utils\\git::getCommitRepo",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "codeNoBody": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCommitRepo",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "The function \"getCommitRepo\" retrieves the latest commit hash from a specified repository on a given Git service (GitHub, GitLab, or Bitbucket) by making API requests with the provided access tokens and connection information. It takes parameters such as the Git service type, repository organization, repository name, branch name, access token, refresh token, connection ID, and optionally GitLab repository ID. It handles token refreshes, updates connection information, and utilizes the \"getCommitHash\" function to extract and return the commit hash based on the Git service type from the fetched commit data.",
    "importStatements": ""
  },
  {
    "id": "e631e3bd-faf0-4ffa-af9a-3112c6fbde61",
    "fullName": "\\src\\utils\\git::downloadAndExtractRepo",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "codeNoBody": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "downloadAndExtractRepo",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "The function \"downloadAndExtractRepo\" downloads and extracts a repository from either GitHub, GitLab, or Bitbucket based on the provided Git service type, repository organization, name, branch, access token, commit SHA, and optionally GitLab repository ID. It handles different API endpoints for each service, saves the repository as a zip file, extracts it to a temporary folder, calculates its size, and ensures it does not exceed the maximum size of 2 MB (MAXSIZE constant). If the size exceeds the limit, it deletes the extracted repository and throws an error. The function returns the path to the extracted repository.",
    "importStatements": ""
  },
  {
    "id": "b8eeeb13-5668-4642-a641-e4821f0c1b1f",
    "fullName": "\\src\\utils\\git::MAXSIZE",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const MAXSIZE = 2 // MB\r",
    "codeNoBody": "const MAXSIZE = 2 // MB",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "MAXSIZE",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "Code: const MAXSIZE = 2 // MB\r",
    "importStatements": ""
  },
  {
    "id": "79f0df5e-314e-4353-948c-418e0695b091",
    "fullName": "\\src\\utils\\git::GitServiceType",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "codeNoBody": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GitServiceType",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "Code: type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "importStatements": ""
  },
  {
    "id": "e9fc8cd1-8013-444f-9095-1e0477ed33a4",
    "fullName": "\\src\\utils\\git",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\n\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}\r\n",
    "codeNoBody": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "originFile": "\\src\\utils\\git.ts",
    "generatedDocumentation": "### File: `src/utils/git.ts`\n\n#### Purpose:\nThe `git.ts` file provides utility functions for interacting with various Git service providers (GitHub, GitLab, and Bitbucket). It includes functionalities for downloading and extracting repositories, retrieving commit hashes, and managing access tokens.\n\n#### Main Features:\n\n1. **GitServiceType**:\n   - A type definition that specifies the supported Git service providers: `'github'`, `'gitlab'`, and `'bitbucket'`.\n\n2. **MAXSIZE**:\n   - A constant that defines the maximum allowed size for extracted repositories, set to 2 MB.\n\n3. **downloadAndExtractRepo**:\n   - Downloads and extracts a repository from GitHub, GitLab, or Bitbucket.\n   - Parameters include details such as Git service type, repository organization, name, branch, access token, commit SHA, and optionally GitLab repository ID.\n   - Ensures the extracted repository size does not exceed the defined maximum size (2 MB).\n\n4. **getCommitRepo**:\n   - Retrieves the latest commit hash from a specified repository on a given Git service.\n   - Handles API requests, token refreshes, and updates connection information.\n   - Utilizes the `getCommitHash` function to extract and return the commit hash.\n\n5. **getCommitHash**:\n   - Extracts and returns the commit hash from the commit data based on the Git service provider.\n   - Supports GitHub, GitLab, and Bitbucket.\n\n6. **getAccessToken**:\n   - Retrieves the access token and refresh token for a specified Git service provider.\n   - Queries the database to fetch tokens based on the connection ID and user organization ID.\n   - Returns the tokens if found, or null if not found or an error occurs.\n\nThis file is essential for managing interactions with Git repositories, ensuring secure access through tokens, and handling repository data efficiently.",
    "importStatements": "import axios from 'axios'\nimport fs from 'node:fs/promises'\nimport AdmZip from 'adm-zip'\nimport path from 'node:path'\nimport { sql } from './db'\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\nimport { getTotalSize } from '../model/utils'"
  },
  {
    "id": "8d0a1fa7-dc0d-4582-b825-a57d0db4eeee",
    "fullName": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "refreshAccessToken",
    "originFile": "\\src\\utils\\gitlab\\refresh-token.ts",
    "generatedDocumentation": "The function \"refreshAccessToken\" takes a \"refreshToken\" string as a parameter, sends a POST request to the GitLab API to refresh the access token using the provided refresh token, client ID, and client secret from environment variables, and returns a new access token and refresh token if the request is successful; otherwise, it logs an error message and returns null.",
    "importStatements": ""
  },
  {
    "id": "06d9b471-18c6-4300-b0cb-41ffc04cffbf",
    "fullName": "\\src\\utils\\gitlab\\refresh-token",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts",
    "originFile": "\\src\\utils\\gitlab\\refresh-token.ts",
    "generatedDocumentation": "### File: `refresh-token.ts`\n\n#### Purpose:\nThe purpose of this file is to provide a utility function for refreshing GitLab access tokens.\n\n#### Main Features:\n- **Function `refreshAccessToken`**: \n  - **Parameters**: Takes a `refreshToken` string as input.\n  - **Functionality**: \n    - Sends a POST request to the GitLab API to obtain a new access token using the provided refresh token.\n    - Utilizes client ID and client secret from environment variables for authentication.\n    - Returns a new access token and refresh token upon a successful request.\n    - Logs an error message and returns `null` if the request fails.\n\nThis utility is essential for maintaining authenticated sessions with the GitLab API by refreshing tokens as needed.",
    "importStatements": "import { getEnv } from \"../utils\""
  },
  {
    "id": "ee271eab-e81f-45d8-abf6-5ec12481b229",
    "fullName": "\\src\\utils\\utils::getEnv",
    "type": "function",
    "language": "typescript",
    "documentation": "//\r",
    "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getEnv",
    "originFile": "\\src\\utils\\utils.ts",
    "generatedDocumentation": "The `getEnv` function in the code retrieves a specific environment variable value based on the provided `envKey`, which is a key of the `ENV_VARS` object containing essential configuration details like database credentials, Supabase settings, and authentication data for GitLab and Bitbucket. If the requested `envKey` is not found in `ENV_VARS`, an error is thrown indicating the missing environment variable.",
    "importStatements": ""
  },
  {
    "id": "250b4e14-d34d-40fd-99ab-a53085d35d02",
    "fullName": "\\src\\utils\\utils::ENV_VARS",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ENV_VARS",
    "originFile": "\\src\\utils\\utils.ts",
    "generatedDocumentation": "The `ENV_VARS` object in the code defines various environment variables related to database credentials, Supabase configuration, GitLab and Bitbucket authentication details, storing them for easy access throughout the application by assigning their corresponding values from the `process.env` object.",
    "importStatements": ""
  },
  {
    "id": "471b676a-d564-4367-9287-6c3dd5cf0620",
    "fullName": "\\src\\utils\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils.ts",
    "originFile": "\\src\\utils\\utils.ts",
    "generatedDocumentation": "### File: `src/utils/utils.ts`\n\n#### Purpose:\nThe `utils.ts` file serves as a utility module for managing and accessing environment variables required for the application's configuration. It centralizes the retrieval of these variables, ensuring they are easily accessible and consistently handled throughout the codebase.\n\n#### Main Features:\n1. **Environment Variables Storage (`ENV_VARS`)**:\n   - Defines an object `ENV_VARS` that holds essential configuration details such as database credentials, Supabase settings, and authentication data for GitLab and Bitbucket.\n   - Values are assigned from the `process.env` object, which contains the environment variables set in the system or environment.\n\n2. **Environment Variable Retrieval (`getEnv`)**:\n   - Provides a function `getEnv` that takes a key (`envKey`) from the `ENV_VARS` object and returns the corresponding environment variable value.\n   - Throws an error if the requested `envKey` is not found in `ENV_VARS`, ensuring that all necessary environment variables are present and accounted for.\n\nThis file is crucial for maintaining a clean and organized approach to handling environment variables, which are vital for the application's configuration and security.",
    "importStatements": ""
  },
  {
    "id": "9dfd3276-71ff-47e2-9fc3-c1ccbf3f3d6e",
    "fullName": "\\src\\wiki\\test-wiki",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();\r\n",
    "codeNoBody": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\test-wiki.ts",
    "originFile": "\\src\\wiki\\test-wiki.ts",
    "generatedDocumentation": "### File: `test-wiki.ts`\n\n#### Purpose:\nThe `test-wiki.ts` file is designed to parse a codebase, generate a graph representation of the code structure, and create documentation using an AI model. It performs these tasks by leveraging various utilities and models defined within the project.\n\n#### Main Features:\n1. **Codebase Initialization**:\n   - Initializes a `Codebase` object with the path to the codebase directory.\n\n2. **Parsing and Simplifying Codebase**:\n   - Parses the folders within the codebase to create a map of file nodes.\n   - Extracts call relationships between different parts of the codebase.\n   - Simplifies the parsed data into a more manageable format.\n\n3. **Node and Link Generation**:\n   - Generates unique UUIDs for each node in the graph.\n   - Creates `GraphNode` objects containing detailed information about each node, such as its type, language, documentation, and code.\n   - Extracts and maps links (relationships) between nodes into `GraphLink` objects.\n\n4. **Documentation Generation**:\n   - Utilizes the `generateDocumentation` function to produce documentation for the nodes and links using an AI model (e.g., GPT-3.5-turbo).\n\n5. **Output**:\n   - Writes the generated graph nodes and documented folders to JSON files for further use or analysis.\n\nThis script automates the process of analyzing a codebase, visualizing its structure, and generating comprehensive documentation, making it a valuable tool for developers looking to understand and document large codebases.",
    "importStatements": "import { fstat } from \"fs\";\nimport { Codebase } from \"../model/codebase\";\nimport { GraphLink, GraphNode } from \"../utils/db\";\nimport { generateDocumentation } from \"./wiki\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport fs from \"fs/promises\";"
  },
  {
    "id": "a92a939d-b49f-40ec-a4f2-72ed98e094ee",
    "fullName": "\\src\\wiki\\utils::documentFolders",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const nodesPerType = getNodesPerType(nodes);\r\n  const allLanguages = calculateLanguagePercentages(nodesPerType);\r\n  const allLanguagesString = Object.entries(allLanguages)\r\n    .map(([name, pct]) => `${name} (${pct})`)\r\n    .join(\", \");\r\n\r\n  console.log(\"Generating documentation for each folder ..\");\r\n  const fileNodes = nodes.filter((n) => n.type === \"file\");\r\n  const folderNames = fileNodes.map((n) =>\r\n    n.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\")\r\n  );\r\n  const uniqueFolderNames = [...new Set(folderNames)];\r\n\r\n  // sort by level (number of '/')\r\n  uniqueFolderNames.sort(\r\n    (a, b) => b.split(\"\\\\\").length - a.split(\"\\\\\").length || b.length - a.length\r\n  );\r\n  const documentedFolders: { [key: string]: string } = {};\r\n  uniqueFolderNames.forEach(\r\n    (foldername) => (documentedFolders[foldername] = \"\")\r\n  );\r\n  //console.log(\"Documented Folders:\", documentedFolders);\r\n  for (const folderName of uniqueFolderNames) {\r\n    const filteredNodes =\r\n      folderName.length > 0\r\n        ? nodes.filter((n) => n.originFile?.startsWith(folderName))\r\n        : nodes;\r\n    //console.log(\"Folder:\", folderName);\r\n    //console.log(\"Nodes:\", filteredNodes);\r\n    const codeNoBodyFolder = filteredNodes.map((n) => n.codeNoBody).join(\"\\n\");\r\n    const fileNodesPerType = getNodesPerType(filteredNodes);\r\n    const mostUsedNodesPerType = getMostUsedNodesPerType(fileNodesPerType);\r\n    const mostUsedNodesPerTypeString = Object.keys(mostUsedNodesPerType)\r\n      .map((type) => {\r\n        return mostUsedNodesPerType[type as AllowedTypes].join(\"\\n\\n\");\r\n      })\r\n      .join(\"\\n\");\r\n    let systemPrompt = `You are a helpful code expert and wikipedia editor who is writing a publication for repository ${repoName}, which uses the following languages: ${allLanguagesString}.`;\r\n    systemPrompt += `\\nThese are the most common elements from the repository:\\n${mostUsedNodesPerTypeString}\\n\\n`;\r\n    systemPrompt += `The user will pass you information about files and subfolders of the repo, and you have to generate a final wiki.`;\r\n\r\n    if (folderName.length === 0) {\r\n      systemPrompt += ` The wiki must describe the main features of the repo and its final purpose, i.e.:\\n\r\n        1. **Introduction**: Brief description of the project, its purpose, and main functionalities.\r\n        2. **Getting Started**: List of software, libraries, and tools needed. Step-by-step instructions on how to install and set up the project.\r\n        3. **Project Structure**: Description of the main directories and their purposes. Explanation of important files and their roles.\r\n        4. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\`\r\n        5. (optional) **Configuration** : Explanation of default configuration settings.\r\n        6. (optional) **Glossary**:  Definitions of key terms and concepts used in the project.`;\r\n    } else {\r\n      systemPrompt += ` The wiki must describe the main features of the folder and its final purpose, i.e.:\\n\r\n            1. **Introduction**: Brief description of the folder, its purpose, and main functionalities.\r\n            2. **Directory structure**:  Explanation of important files/directories and their roles.\r\n            3. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\``;\r\n    }\r\n\r\n    const fileNodesInFolder = fileNodes.filter(\r\n      (n) =>\r\n        n.fullName.startsWith(folderName) &&\r\n        n.fullName.split(\"\\\\\").length ==\r\n          (folderName ? folderName.split(\"\\\\\").length + 1 : 1)\r\n    );\r\n    const subfoldersDocumentations = Object.fromEntries(\r\n      Object.entries(documentedFolders).filter(([key]) => {\r\n        return key.startsWith(folderName) && key != folderName; // && key.split('/').length == folderName.split('/').length + 1 && key != folderName\r\n      })\r\n    );\r\n\r\n    const folderContext =\r\n      folderName.length > 0\r\n        ? `folder \"${folderName}\"`\r\n        : `repository ${repoName}`;\r\n    let userPrompt = `Generate a publication for the ${folderContext}. The following information corresponds to the documentation of the subfolders of the folder we want to document. Use them to generate a better response. Here they are:\\n\\n`;\r\n\r\n    for (const [subfolder, subfolderDoc] of Object.entries(\r\n      subfoldersDocumentations\r\n    )) {\r\n      if (subfolderDoc) {\r\n        userPrompt += `Subfolder ${subfolder} information:\\n${subfolderDoc}`;\r\n        userPrompt += `\\n------------------------------------------------\\n\\n`;\r\n      }\r\n    }\r\n\r\n    for (const fileNode of fileNodesInFolder) {\r\n      userPrompt += `Documentation for file ${fileNode.label}:\\n${\r\n        fileNode.generatedDocumentation ?? \"\"\r\n      }\\n`;\r\n      // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n      // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n\r\n      // if (callLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Uses:\\n`\r\n      //     callLinks.forEach(l => {\r\n      //         const calledNode = nodes.find(n => n.id === l.target)\r\n      //         if (calledNode) {\r\n      //             userPrompt += `   - ${calledNode.type} ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // }\r\n\r\n      // if (defineLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n      //     defineLinks.forEach(l => {\r\n      //         const definedNode = nodes.find(n => n.id === l.target)\r\n      //         if (definedNode) {\r\n      //             userPrompt += `   - ${definedNode.type} ${definedNode.label}${\": \" + definedNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n      // }\r\n    }\r\n\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (folderName.length === 0) {\r\n      console.log(systemPrompt);\r\n      console.log(userPrompt);\r\n    }\r\n\r\n    const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n    totalTokens += tokens ?? 0;\r\n    documentedFolders[folderName] = response;\r\n  }\r\n\r\n  console.log(`${repoName} - Total tokens used:`, totalTokens);\r\n  return documentedFolders;\r\n}",
    "codeNoBody": "async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentFolders",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `documentFolders` takes in arrays of `nodes` and `links`, along with `repoName` and `model` strings. It utilizes helper functions like `getNodesPerType`, `calculateLanguagePercentages`, and `getMostUsedNodesPerType` to categorize nodes by type, calculate language percentages, and determine the most used nodes per type, respectively. It generates a documentation for each folder in the repository based on the nodes' information, including code examples, project structure, and language usage. The function interacts with OpenAI to generate responses for system and user prompts, providing detailed information about the repository or specific folders. The final output includes a mapping of folder names to their respective documentation.",
    "importStatements": ""
  },
  {
    "id": "5d7157ce-9593-44f7-a822-67f53d42590e",
    "fullName": "\\src\\wiki\\utils::documentNodesByLevels",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  console.log(\"Generating documentation for each node ..\");\r\n  const levels = Object.keys(nodeIdsByLevels);\r\n  levels.sort((a, b) => parseInt(b) - parseInt(a));\r\n\r\n  for (const l of levels) {\r\n    const level = parseInt(l); // Convert the key back to a number if needed\r\n    const nodeIds = nodeIdsByLevels[level];\r\n    const promises = nodeIds.map((nodeId) => {\r\n      const node = nodes.find((n) => n.id === nodeId);\r\n      if (node && node.generatedDocumentation?.length === 0) {\r\n        return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n      }\r\n    });\r\n    await Promise.all(promises);\r\n  }\r\n  console.log(`${repoName} - Used tokens for node documentation:`, totalTokens);\r\n}",
    "codeNoBody": "async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentNodesByLevels",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `documentNodesByLevels` in `\\src\\wiki\\utils` generates documentation for nodes grouped by levels in a graph, iterating through each level, retrieving the corresponding nodes, and calling `generateNodeDocumentation` to create documentation for nodes lacking documentation. The function utilizes the `generateNodeDocumentation` function, interacting with the OpenAI chat completion API to generate tailored documentation based on prompts, adjusting the model according to the node type. The total number of tokens used for documentation is logged to the console.",
    "importStatements": ""
  },
  {
    "id": "8507f02c-86b3-40fc-aae3-76a4a6bf7c2a",
    "fullName": "\\src\\wiki\\utils::generateNodeDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const { systemPrompt, userPrompt } = generateNodePrompts(\r\n    node,\r\n    nodes,\r\n    graph,\r\n    repoName\r\n  );\r\n\r\n  try {\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (\r\n      [\"class\", \"function\", \"method\"].includes(node.type) ||\r\n      node.code.split(\"\\n\").length >= 2\r\n    ) {\r\n      const { response, tokens } = await getOpenAIChatCompletion(\r\n        messages,\r\n        node.type === \"file\" ? \"gpt-4o\" : model\r\n      );\r\n      totalTokens += tokens ?? 0;\r\n      node.generatedDocumentation = response;\r\n    } else {\r\n      node.generatedDocumentation = `Code: ${node.code}`;\r\n    }\r\n    // console.log(`#### ${node.label} ####`)\r\n    // console.log({ systemPrompt, userPrompt } )\r\n    // console.log({ response, tokens })\r\n  } catch (error: any) {\r\n    console.error(\r\n      `Error generating documentation for ${node.label}: ${error.message}`\r\n    );\r\n  }\r\n}",
    "codeNoBody": "async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodeDocumentation",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `generateNodeDocumentation` in `\\src\\wiki\\utils` generates documentation for a given `node` in a graph, utilizing the `generateNodePrompts` function to create system and user prompts tailored to the `node` type, assisting in code documentation creation. It interacts with the OpenAI chat completion API to generate documentation text based on the prompts, adjusting the model used depending on the `node` type. If the `node` is a file or has multiple lines of code, it uses a specific model for completion; otherwise, it includes the code itself in the documentation. Any errors during the process are logged to the console.",
    "importStatements": ""
  },
  {
    "id": "d261d060-e2f8-4ef6-8f96-df45cceba003",
    "fullName": "\\src\\wiki\\utils::generateNodePrompts",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\r\n  const originFileNode = findFileParentNode(nodes, node);\r\n\r\n  let systemPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code and being concise but precise and accurate.`;\r\n  } else {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write summaries for files from the repository ${repoName}. The user will pass you a reduced version of the file content and you must explain the main features and purpose of the file. Be concise but accurate and precise.`;\r\n  }\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does or accomplishes.`;\r\n  }\r\n\r\n  if (node.type !== \"file\")\r\n    systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  const parentFileString = originFileNode\r\n    ? `from file \"${originFileNode.label}\" `\r\n    : \"\";\r\n\r\n  let userPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mentioning the principal features of the code:`;\r\n  } else {\r\n    const folder = node.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\");\r\n    userPrompt = `Write a brief documentation for the file \"${node.label}\" from folder \"${folder}\", explaining the main features and purpose of the file:`;\r\n  }\r\n\r\n  const code = [\r\n    \"method\",\r\n    \"function\",\r\n    \"interface\",\r\n    \"assignment\",\r\n    \"type\",\r\n    \"enum\",\r\n    \"struct\",\r\n    \"union\",\r\n  ].includes(node.type)\r\n    ? node.code\r\n    : node.codeNoBody;\r\n\r\n  if (\r\n    originFileNode &&\r\n    graph[node.id].length > 0 &&\r\n    originFileNode.importStatements\r\n  ) {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n    systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`;\r\n  } else {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n  }\r\n\r\n  const linkedNodes = graph[node.id].map((linkedNodeId) =>\r\n    nodes.find((node) => node.id === linkedNodeId)\r\n  );\r\n\r\n  if (\r\n    graph[node.id].length > 0 &&\r\n    linkedNodes.some((n) => n?.generatedDocumentation)\r\n  ) {\r\n    userPrompt += `Use the following information to generate a better description of what ${node.label} does:`;\r\n    systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`;\r\n\r\n    graph[node.id].forEach((linkedNodeId) => {\r\n      const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n      if (linkedNode && linkedNode.generatedDocumentation) {\r\n        userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n      }\r\n    });\r\n  }\r\n\r\n  userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`;\r\n  if (node.type === \"file\") {\r\n    userPrompt += \" Remember also to explain the purpose of the file.\";\r\n  }\r\n  return { systemPrompt, userPrompt };\r\n}",
    "codeNoBody": "function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodePrompts",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `generateNodePrompts` takes in a `node` of type `GraphNode`, an array of `nodes`, a `graph` object, and a `repoName` string. It generates system and user prompts based on the type of `node`, providing guidance for writing code documentation. The system prompt instructs a code assistant on summarizing code features concisely, while the user prompt guides the user in writing a brief description of the code element. It handles different node types like functions, classes, and methods, adjusting the prompts accordingly. Additionally, it utilizes the `findFileParentNode` function to determine the parent node of the given `node` within the graph.",
    "importStatements": ""
  },
  {
    "id": "38f917f7-e87b-44d4-a728-92e2593112f0",
    "fullName": "\\src\\wiki\\utils::bfsLevels",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\r\n  const results: { [key: number]: string[] } = {};\r\n  const levels: { [key: string]: number } = {};\r\n  const inDegree: { [key: string]: number } = {};\r\n\r\n  // Initialize in-degree for each node\r\n  for (const node of nodes) {\r\n    inDegree[node.id] = 0;\r\n  }\r\n\r\n  // Calculate in-degree for each node\r\n  for (const [source, targets] of Object.entries(graph)) {\r\n    for (const target of targets) {\r\n      inDegree[target] = (inDegree[target] || 0) + 1;\r\n    }\r\n  }\r\n\r\n  // Find start nodes (nodes with in-degree 0)\r\n  const queue = nodes\r\n    .filter((node) => inDegree[node.id] === 0)\r\n    .map((node) => node.id);\r\n\r\n  // Perform topological sort and assign levels\r\n  let currentLevel = 0;\r\n  while (queue.length > 0) {\r\n    const levelSize = queue.length;\r\n    for (let i = 0; i < levelSize; i++) {\r\n      const nodeId = queue.shift()!;\r\n      levels[nodeId] = currentLevel;\r\n\r\n      if (!results[currentLevel]) {\r\n        results[currentLevel] = [];\r\n      }\r\n\r\n      results[currentLevel].push(nodeId);\r\n\r\n      for (const neighbor of graph[nodeId] || []) {\r\n        inDegree[neighbor]--;\r\n        if (inDegree[neighbor] === 0) {\r\n          queue.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    currentLevel++;\r\n  }\r\n\r\n  // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n  for (const node of nodes) {\r\n    if (levels[node.id] === undefined) {\r\n      const dependencyLevels = (graph[node.id] || [])\r\n        .map((dep) => levels[dep] || 0)\r\n        .filter((level) => level !== undefined);\r\n      const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n      levels[node.id] = maxDependencyLevel + 1;\r\n\r\n      if (!results[levels[node.id]]) {\r\n        results[levels[node.id]] = [];\r\n      }\r\n      results[levels[node.id]].push(node.id);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}",
    "codeNoBody": "function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "bfsLevels",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function \"bfsLevels\" takes an array of GraphNodes and a Graph object as parameters, where Graph is defined as { [key: string]: string[] }. It performs a breadth-first search algorithm to determine the levels of each node in the graph based on their dependencies, returning an object where each key represents a level and the value is an array of node IDs at that level. The function handles cycles by assigning nodes to the highest level of their dependencies.",
    "importStatements": ""
  },
  {
    "id": "ed97404c-e1f2-4783-94bf-ea53a69509e9",
    "fullName": "\\src\\wiki\\utils::buildGraphs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n  //all nodes appear on links?\r\n  const graph: Graph = {};\r\n  nodes.forEach((node) => {\r\n    graph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (link.source === link.target) continue;\r\n\r\n    // each link save the id node\r\n    const sourceNode = nodes.find((node) => node.id === link.source);\r\n    const targetNode = nodes.find((node) => node.id === link.target);\r\n    // only save the links between nodes and not files\r\n    if (sourceNode && targetNode) {\r\n      graph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { graph };\r\n}",
    "codeNoBody": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildGraphs",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function \"buildGraphs\" takes in arrays of GraphNodes and GraphLinks, constructs a graph object where each node ID maps to an array of connected node IDs, ensuring that links between nodes (not files) are saved, and returns the constructed graph object. The graph object is defined as type Graph = { [key: string]: string[] };",
    "importStatements": ""
  },
  {
    "id": "1e297587-8a8c-4b9c-8e6e-e7f869a07059",
    "fullName": "\\src\\wiki\\utils::findFileParentNode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n  let parentName = \"\";\r\n  if (node.originFile) {\r\n    parentName = node.originFile?.split(\".\").slice(0, -1).join(\".\");\r\n  } else {\r\n    parentName = node.fullName.includes(\"::\")\r\n      ? node.fullName.split(\"::\")[0]\r\n      : \"\";\r\n  }\r\n  const parent = nodes.find((node) => node.fullName === parentName);\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent && parent.type !== \"file\") {\r\n    return findFileParentNode(nodes, parent);\r\n  }\r\n}",
    "codeNoBody": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findFileParentNode",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `findFileParentNode` takes in an array of `GraphNode` objects and a specific `node`, then it determines the parent node of the given `node` based on its `originFile` or `fullName`. If the parent node is a file type, it is returned; otherwise, the function recursively calls itself with the parent node until a file type parent is found and returned.",
    "importStatements": ""
  },
  {
    "id": "59e60651-7b46-4fdd-ad4f-3701a030bab5",
    "fullName": "\\src\\wiki\\utils::getMostUsedNodesPerType",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    if (discardMethods && type === \"method\") {\r\n      return acc;\r\n    }\r\n\r\n    if (\r\n      ![\"file\", \"namespace\", \"package\", \"mod\", \"assignment\", \"header\"].includes(\r\n        type\r\n      )\r\n    )\r\n      acc[type as AllowedTypes] = nodesPerType[type as AllowedTypes]\r\n        .filter((n) => n.outDegree > 0)\r\n        .sort((a, b) => b.outDegree + b.inDegree - (a.outDegree + a.inDegree))\r\n        .slice(0, 5)\r\n        .map(\r\n          (n) =>\r\n            `### From ${n.originFile}:\\n\\`\\`\\`${n.language}\\n${n.codeNoBody}\\n\\`\\`\\``\r\n        );\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, (string | number)[]>);\r\n\r\n  return mostUsedNodesPerType;\r\n}",
    "codeNoBody": "function getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getMostUsedNodesPerType",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "This function `getMostUsedNodesPerType` takes in an object `nodesPerType` containing arrays of `GraphNode` objects categorized by type and an optional boolean `discardMethods`. It filters and sorts the nodes based on their in_degree + out_degree, excluding methods if specified, and returns an object with the top 5 nodes per type formatted as markdown code blocks showing origin file, language, and code snippet.",
    "importStatements": ""
  },
  {
    "id": "c2ae1de2-97b0-4d46-9744-e84c5ceacc09",
    "fullName": "\\src\\wiki\\utils::getNodesPerType",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getNodesPerType(nodes: GraphNode[]) {\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = [];\r\n    }\r\n    acc[node.type].push(node);\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, GraphNode[]>);\r\n\r\n  return nodesPerType;\r\n}",
    "codeNoBody": "function getNodesPerType(nodes: GraphNode[]) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getNodesPerType",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function \"getNodesPerType\" takes an array of GraphNode objects as a parameter and returns an object where each key represents a unique node type and the corresponding value is an array of nodes of that type. It accomplishes this by iterating over the input nodes array, grouping nodes by their type, and returning the resulting object with nodes categorized per type.",
    "importStatements": ""
  },
  {
    "id": "b6789627-f3d5-4a64-a5d0-4726e57735bd",
    "fullName": "\\src\\wiki\\utils::calculateLanguagePercentages",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\r\n  const allLanguages = nodesPerType[\"file\"].map((n) => n.language);\r\n  const total = allLanguages.length;\r\n  const counts: Record<string, number> = {};\r\n\r\n  allLanguages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1;\r\n  });\r\n\r\n  const percentages: Record<string, string> = {};\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = ((count / total) * 100).toFixed(2) + \"%\";\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort(\r\n    (a, b) => parseFloat(b[1]) - parseFloat(a[1])\r\n  );\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray);\r\n  return sortedPercentages;\r\n}",
    "codeNoBody": "function calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calculateLanguagePercentages",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "This function `calculateLanguagePercentages` takes an object `nodesPerType` containing an array of `GraphNode` objects per allowed type, extracts the languages from the `file` type nodes, calculates the percentage of each language occurrence, sorts them in descending order, and returns an object with languages as keys and their respective percentages as values.",
    "importStatements": ""
  },
  {
    "id": "934c723f-83c3-4002-b62a-9632f880c4b8",
    "fullName": "\\src\\wiki\\utils::Graph",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type Graph = { [key: string]: string[] };",
    "codeNoBody": "type Graph = { [key: string]: string[] };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Graph",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "Code: type Graph = { [key: string]: string[] };",
    "importStatements": ""
  },
  {
    "id": "5146b041-d669-46a8-b1e7-21194e2452ef",
    "fullName": "\\src\\wiki\\utils::totalTokens",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "let totalTokens = 0;",
    "codeNoBody": "let totalTokens = 0;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "totalTokens",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "Code: let totalTokens = 0;",
    "importStatements": ""
  },
  {
    "id": "89324405-e8c1-4ee3-8513-aa85065a70e6",
    "fullName": "\\src\\wiki\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\nimport { AllowedTypes } from \"../model/consts\";\r\n\r\nlet totalTokens = 0;\r\n\r\ntype Graph = { [key: string]: string[] };\r\n\r\nfunction calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\r\n  const allLanguages = nodesPerType[\"file\"].map((n) => n.language);\r\n  const total = allLanguages.length;\r\n  const counts: Record<string, number> = {};\r\n\r\n  allLanguages.forEach((language) => {\r\n    counts[language] = (counts[language] || 0) + 1;\r\n  });\r\n\r\n  const percentages: Record<string, string> = {};\r\n  for (const [language, count] of Object.entries(counts)) {\r\n    percentages[language] = ((count / total) * 100).toFixed(2) + \"%\";\r\n  }\r\n\r\n  const sortedPercentagesArray = Object.entries(percentages).sort(\r\n    (a, b) => parseFloat(b[1]) - parseFloat(a[1])\r\n  );\r\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray);\r\n  return sortedPercentages;\r\n}\r\n\r\nfunction getNodesPerType(nodes: GraphNode[]) {\r\n  const nodesPerType = nodes.reduce((acc, node) => {\r\n    if (!acc[node.type]) {\r\n      acc[node.type] = [];\r\n    }\r\n    acc[node.type].push(node);\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, GraphNode[]>);\r\n\r\n  return nodesPerType;\r\n}\r\n\r\nfunction getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\r\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\r\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\r\n    if (discardMethods && type === \"method\") {\r\n      return acc;\r\n    }\r\n\r\n    if (\r\n      ![\"file\", \"namespace\", \"package\", \"mod\", \"assignment\", \"header\"].includes(\r\n        type\r\n      )\r\n    )\r\n      acc[type as AllowedTypes] = nodesPerType[type as AllowedTypes]\r\n        .filter((n) => n.outDegree > 0)\r\n        .sort((a, b) => b.outDegree + b.inDegree - (a.outDegree + a.inDegree))\r\n        .slice(0, 5)\r\n        .map(\r\n          (n) =>\r\n            `### From ${n.originFile}:\\n\\`\\`\\`${n.language}\\n${n.codeNoBody}\\n\\`\\`\\``\r\n        );\r\n    return acc;\r\n  }, {} as Record<AllowedTypes, (string | number)[]>);\r\n\r\n  return mostUsedNodesPerType;\r\n}\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n  let parentName = \"\";\r\n  if (node.originFile) {\r\n    parentName = node.originFile?.split(\".\").slice(0, -1).join(\".\");\r\n  } else {\r\n    parentName = node.fullName.includes(\"::\")\r\n      ? node.fullName.split(\"::\")[0]\r\n      : \"\";\r\n  }\r\n  const parent = nodes.find((node) => node.fullName === parentName);\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent && parent.type !== \"file\") {\r\n    return findFileParentNode(nodes, parent);\r\n  }\r\n}\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n  //all nodes appear on links?\r\n  const graph: Graph = {};\r\n  nodes.forEach((node) => {\r\n    graph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (link.source === link.target) continue;\r\n\r\n    // each link save the id node\r\n    const sourceNode = nodes.find((node) => node.id === link.source);\r\n    const targetNode = nodes.find((node) => node.id === link.target);\r\n    // only save the links between nodes and not files\r\n    if (sourceNode && targetNode) {\r\n      graph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { graph };\r\n}\r\n\r\nexport function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\r\n  const results: { [key: number]: string[] } = {};\r\n  const levels: { [key: string]: number } = {};\r\n  const inDegree: { [key: string]: number } = {};\r\n\r\n  // Initialize in-degree for each node\r\n  for (const node of nodes) {\r\n    inDegree[node.id] = 0;\r\n  }\r\n\r\n  // Calculate in-degree for each node\r\n  for (const [source, targets] of Object.entries(graph)) {\r\n    for (const target of targets) {\r\n      inDegree[target] = (inDegree[target] || 0) + 1;\r\n    }\r\n  }\r\n\r\n  // Find start nodes (nodes with in-degree 0)\r\n  const queue = nodes\r\n    .filter((node) => inDegree[node.id] === 0)\r\n    .map((node) => node.id);\r\n\r\n  // Perform topological sort and assign levels\r\n  let currentLevel = 0;\r\n  while (queue.length > 0) {\r\n    const levelSize = queue.length;\r\n    for (let i = 0; i < levelSize; i++) {\r\n      const nodeId = queue.shift()!;\r\n      levels[nodeId] = currentLevel;\r\n\r\n      if (!results[currentLevel]) {\r\n        results[currentLevel] = [];\r\n      }\r\n\r\n      results[currentLevel].push(nodeId);\r\n\r\n      for (const neighbor of graph[nodeId] || []) {\r\n        inDegree[neighbor]--;\r\n        if (inDegree[neighbor] === 0) {\r\n          queue.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    currentLevel++;\r\n  }\r\n\r\n  // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n  for (const node of nodes) {\r\n    if (levels[node.id] === undefined) {\r\n      const dependencyLevels = (graph[node.id] || [])\r\n        .map((dep) => levels[dep] || 0)\r\n        .filter((level) => level !== undefined);\r\n      const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n      levels[node.id] = maxDependencyLevel + 1;\r\n\r\n      if (!results[levels[node.id]]) {\r\n        results[levels[node.id]] = [];\r\n      }\r\n      results[levels[node.id]].push(node.id);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\r\n  const originFileNode = findFileParentNode(nodes, node);\r\n\r\n  let systemPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code and being concise but precise and accurate.`;\r\n  } else {\r\n    systemPrompt = `You are a helpful ${node.language} code assistant that helps to write summaries for files from the repository ${repoName}. The user will pass you a reduced version of the file content and you must explain the main features and purpose of the file. Be concise but accurate and precise.`;\r\n  }\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does or accomplishes.`;\r\n  }\r\n\r\n  if (node.type !== \"file\")\r\n    systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  const parentFileString = originFileNode\r\n    ? `from file \"${originFileNode.label}\" `\r\n    : \"\";\r\n\r\n  let userPrompt = \"\";\r\n  if (node.type !== \"file\") {\r\n    userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mentioning the principal features of the code:`;\r\n  } else {\r\n    const folder = node.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\");\r\n    userPrompt = `Write a brief documentation for the file \"${node.label}\" from folder \"${folder}\", explaining the main features and purpose of the file:`;\r\n  }\r\n\r\n  const code = [\r\n    \"method\",\r\n    \"function\",\r\n    \"interface\",\r\n    \"assignment\",\r\n    \"type\",\r\n    \"enum\",\r\n    \"struct\",\r\n    \"union\",\r\n  ].includes(node.type)\r\n    ? node.code\r\n    : node.codeNoBody;\r\n\r\n  if (\r\n    originFileNode &&\r\n    graph[node.id].length > 0 &&\r\n    originFileNode.importStatements\r\n  ) {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n    systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`;\r\n  } else {\r\n    userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`;\r\n  }\r\n\r\n  const linkedNodes = graph[node.id].map((linkedNodeId) =>\r\n    nodes.find((node) => node.id === linkedNodeId)\r\n  );\r\n\r\n  if (\r\n    graph[node.id].length > 0 &&\r\n    linkedNodes.some((n) => n?.generatedDocumentation)\r\n  ) {\r\n    userPrompt += `Use the following information to generate a better description of what ${node.label} does:`;\r\n    systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`;\r\n\r\n    graph[node.id].forEach((linkedNodeId) => {\r\n      const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n      if (linkedNode && linkedNode.generatedDocumentation) {\r\n        userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n      }\r\n    });\r\n  }\r\n\r\n  userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`;\r\n  if (node.type === \"file\") {\r\n    userPrompt += \" Remember also to explain the purpose of the file.\";\r\n  }\r\n  return { systemPrompt, userPrompt };\r\n}\r\n\r\nexport async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const { systemPrompt, userPrompt } = generateNodePrompts(\r\n    node,\r\n    nodes,\r\n    graph,\r\n    repoName\r\n  );\r\n\r\n  try {\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (\r\n      [\"class\", \"function\", \"method\"].includes(node.type) ||\r\n      node.code.split(\"\\n\").length >= 2\r\n    ) {\r\n      const { response, tokens } = await getOpenAIChatCompletion(\r\n        messages,\r\n        node.type === \"file\" ? \"gpt-4o\" : model\r\n      );\r\n      totalTokens += tokens ?? 0;\r\n      node.generatedDocumentation = response;\r\n    } else {\r\n      node.generatedDocumentation = `Code: ${node.code}`;\r\n    }\r\n    // console.log(`#### ${node.label} ####`)\r\n    // console.log({ systemPrompt, userPrompt } )\r\n    // console.log({ response, tokens })\r\n  } catch (error: any) {\r\n    console.error(\r\n      `Error generating documentation for ${node.label}: ${error.message}`\r\n    );\r\n  }\r\n}\r\n\r\nexport async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  console.log(\"Generating documentation for each node ..\");\r\n  const levels = Object.keys(nodeIdsByLevels);\r\n  levels.sort((a, b) => parseInt(b) - parseInt(a));\r\n\r\n  for (const l of levels) {\r\n    const level = parseInt(l); // Convert the key back to a number if needed\r\n    const nodeIds = nodeIdsByLevels[level];\r\n    const promises = nodeIds.map((nodeId) => {\r\n      const node = nodes.find((n) => n.id === nodeId);\r\n      if (node && node.generatedDocumentation?.length === 0) {\r\n        return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n      }\r\n    });\r\n    await Promise.all(promises);\r\n  }\r\n  console.log(`${repoName} - Used tokens for node documentation:`, totalTokens);\r\n}\r\n\r\nexport async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\r\n  const nodesPerType = getNodesPerType(nodes);\r\n  const allLanguages = calculateLanguagePercentages(nodesPerType);\r\n  const allLanguagesString = Object.entries(allLanguages)\r\n    .map(([name, pct]) => `${name} (${pct})`)\r\n    .join(\", \");\r\n\r\n  console.log(\"Generating documentation for each folder ..\");\r\n  const fileNodes = nodes.filter((n) => n.type === \"file\");\r\n  const folderNames = fileNodes.map((n) =>\r\n    n.fullName.split(\"\\\\\").slice(0, -1).join(\"\\\\\")\r\n  );\r\n  const uniqueFolderNames = [...new Set(folderNames)];\r\n\r\n  // sort by level (number of '/')\r\n  uniqueFolderNames.sort(\r\n    (a, b) => b.split(\"\\\\\").length - a.split(\"\\\\\").length || b.length - a.length\r\n  );\r\n  const documentedFolders: { [key: string]: string } = {};\r\n  uniqueFolderNames.forEach(\r\n    (foldername) => (documentedFolders[foldername] = \"\")\r\n  );\r\n  //console.log(\"Documented Folders:\", documentedFolders);\r\n  for (const folderName of uniqueFolderNames) {\r\n    const filteredNodes =\r\n      folderName.length > 0\r\n        ? nodes.filter((n) => n.originFile?.startsWith(folderName))\r\n        : nodes;\r\n    //console.log(\"Folder:\", folderName);\r\n    //console.log(\"Nodes:\", filteredNodes);\r\n    const codeNoBodyFolder = filteredNodes.map((n) => n.codeNoBody).join(\"\\n\");\r\n    const fileNodesPerType = getNodesPerType(filteredNodes);\r\n    const mostUsedNodesPerType = getMostUsedNodesPerType(fileNodesPerType);\r\n    const mostUsedNodesPerTypeString = Object.keys(mostUsedNodesPerType)\r\n      .map((type) => {\r\n        return mostUsedNodesPerType[type as AllowedTypes].join(\"\\n\\n\");\r\n      })\r\n      .join(\"\\n\");\r\n    let systemPrompt = `You are a helpful code expert and wikipedia editor who is writing a publication for repository ${repoName}, which uses the following languages: ${allLanguagesString}.`;\r\n    systemPrompt += `\\nThese are the most common elements from the repository:\\n${mostUsedNodesPerTypeString}\\n\\n`;\r\n    systemPrompt += `The user will pass you information about files and subfolders of the repo, and you have to generate a final wiki.`;\r\n\r\n    if (folderName.length === 0) {\r\n      systemPrompt += ` The wiki must describe the main features of the repo and its final purpose, i.e.:\\n\r\n        1. **Introduction**: Brief description of the project, its purpose, and main functionalities.\r\n        2. **Getting Started**: List of software, libraries, and tools needed. Step-by-step instructions on how to install and set up the project.\r\n        3. **Project Structure**: Description of the main directories and their purposes. Explanation of important files and their roles.\r\n        4. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\`\r\n        5. (optional) **Configuration** : Explanation of default configuration settings.\r\n        6. (optional) **Glossary**:  Definitions of key terms and concepts used in the project.`;\r\n    } else {\r\n      systemPrompt += ` The wiki must describe the main features of the folder and its final purpose, i.e.:\\n\r\n            1. **Introduction**: Brief description of the folder, its purpose, and main functionalities.\r\n            2. **Directory structure**:  Explanation of important files/directories and their roles.\r\n            3. **Code Examples**: Use cases demonstrating the core functionalities. Be precise and accurate, don't invent things. For this, use the code of the whole folder which is the following: \\n\\`\\`\\`${codeNoBodyFolder}\\n\\`\\`\\``;\r\n    }\r\n\r\n    const fileNodesInFolder = fileNodes.filter(\r\n      (n) =>\r\n        n.fullName.startsWith(folderName) &&\r\n        n.fullName.split(\"\\\\\").length ==\r\n          (folderName ? folderName.split(\"\\\\\").length + 1 : 1)\r\n    );\r\n    const subfoldersDocumentations = Object.fromEntries(\r\n      Object.entries(documentedFolders).filter(([key]) => {\r\n        return key.startsWith(folderName) && key != folderName; // && key.split('/').length == folderName.split('/').length + 1 && key != folderName\r\n      })\r\n    );\r\n\r\n    const folderContext =\r\n      folderName.length > 0\r\n        ? `folder \"${folderName}\"`\r\n        : `repository ${repoName}`;\r\n    let userPrompt = `Generate a publication for the ${folderContext}. The following information corresponds to the documentation of the subfolders of the folder we want to document. Use them to generate a better response. Here they are:\\n\\n`;\r\n\r\n    for (const [subfolder, subfolderDoc] of Object.entries(\r\n      subfoldersDocumentations\r\n    )) {\r\n      if (subfolderDoc) {\r\n        userPrompt += `Subfolder ${subfolder} information:\\n${subfolderDoc}`;\r\n        userPrompt += `\\n------------------------------------------------\\n\\n`;\r\n      }\r\n    }\r\n\r\n    for (const fileNode of fileNodesInFolder) {\r\n      userPrompt += `Documentation for file ${fileNode.label}:\\n${\r\n        fileNode.generatedDocumentation ?? \"\"\r\n      }\\n`;\r\n      // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n      // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n\r\n      // if (callLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Uses:\\n`\r\n      //     callLinks.forEach(l => {\r\n      //         const calledNode = nodes.find(n => n.id === l.target)\r\n      //         if (calledNode) {\r\n      //             userPrompt += `   - ${calledNode.type} ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // }\r\n\r\n      // if (defineLinks.length) {\r\n      //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n      //     defineLinks.forEach(l => {\r\n      //         const definedNode = nodes.find(n => n.id === l.target)\r\n      //         if (definedNode) {\r\n      //             userPrompt += `   - ${definedNode.type} ${definedNode.label}${\": \" + definedNode.generatedDocumentation ?? ''}\\n`\r\n      //         }\r\n      //     })\r\n      // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n      // }\r\n    }\r\n\r\n    const messages: chatCompletionMessages = [\r\n      { role: \"system\", content: systemPrompt },\r\n      { role: \"user\", content: userPrompt },\r\n    ];\r\n\r\n    if (folderName.length === 0) {\r\n      console.log(systemPrompt);\r\n      console.log(userPrompt);\r\n    }\r\n\r\n    const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n    totalTokens += tokens ?? 0;\r\n    documentedFolders[folderName] = response;\r\n  }\r\n\r\n  console.log(`${repoName} - Total tokens used:`, totalTokens);\r\n  return documentedFolders;\r\n}\r\n",
    "codeNoBody": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\nimport { AllowedTypes } from \"../model/consts\";\r\nlet totalTokens = 0;\r\n\r\ntype Graph = { [key: string]: string[] };\r\n\r\nfunction calculateLanguagePercentages(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>\r\n) {\n//...\n}\r\n\r\nfunction getNodesPerType(nodes: GraphNode[]) {\n//...\n}\r\n\r\nfunction getMostUsedNodesPerType(\r\n  nodesPerType: Record<AllowedTypes, GraphNode[]>,\r\n  discardMethods: boolean = false\r\n) {\n//...\n}\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }\r\n\r\nexport function bfsLevels(\r\n  nodes: GraphNode[],\r\n  graph: Graph\r\n): { [key: number]: string[] } {\n       //...\n       }\r\n\r\nexport function generateNodePrompts(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string\r\n): { systemPrompt: string; userPrompt: string } {\n       //...\n       }\r\n\r\nexport async function generateNodeDocumentation(\r\n  node: GraphNode,\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }\r\n\r\nexport async function documentNodesByLevels(\r\n  nodeIdsByLevels: { [key: number]: string[] },\r\n  nodes: GraphNode[],\r\n  graph: Graph,\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }\r\n\r\nexport async function documentFolders(\r\n  nodes: GraphNode[],\r\n  links: GraphLink[],\r\n  repoName: string,\r\n  model: string\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "originFile": "\\src\\wiki\\utils.ts",
    "generatedDocumentation": "### File: `\\src\\wiki\\utils.ts`\n\n#### Purpose:\nThe `utils.ts` file in the `wiki` directory provides utility functions to analyze and document nodes and links within a graph structure representing a codebase. It leverages OpenAI's API to generate detailed documentation for various code elements, enhancing the understanding and navigation of the codebase.\n\n#### Main Features:\n\n1. **calculateLanguagePercentages**:\n   - Calculates the percentage of each programming language used in the codebase based on file type nodes.\n\n2. **getNodesPerType**:\n   - Categorizes nodes by their type, returning an object with node types as keys and arrays of corresponding nodes as values.\n\n3. **getMostUsedNodesPerType**:\n   - Identifies and returns the most frequently used nodes per type, optionally excluding methods, formatted as markdown code blocks.\n\n4. **findFileParentNode**:\n   - Determines and returns the parent file node of a given node, recursively if necessary.\n\n5. **buildGraphs**:\n   - Constructs a graph object from arrays of nodes and links, mapping each node ID to its connected node IDs.\n\n6. **bfsLevels**:\n   - Performs a breadth-first search to determine the levels of nodes in the graph based on dependencies, returning an object with levels as keys and arrays of node IDs as values.\n\n7. **generateNodePrompts**:\n   - Creates system and user prompts for a given node to guide the generation of its documentation, tailored to the node type.\n\n8. **generateNodeDocumentation**:\n   - Generates documentation for a specific node using prompts and OpenAI's API, adjusting the model based on the node type.\n\n9. **documentNodesByLevels**:\n   - Generates documentation for nodes grouped by levels, iterating through each level and documenting nodes that lack documentation.\n\n10. **documentFolders**:\n    - Generates comprehensive documentation for each folder in the repository, including code examples, project structure, and language usage. It leverages various helper functions and interacts with OpenAI's API to produce detailed folder documentation.\n\n#### Additional Elements:\n- **Graph Type**:\n  - Defined as `{ [key: string]: string[] }`, representing the structure of the graph.\n  \n- **totalTokens**:\n  - A variable to keep track of the total number of tokens used during the documentation generation process.\n\nThis file is essential for automating the documentation process of a codebase, making it easier to understand and navigate through the use of AI-generated content.",
    "importStatements": "import { GraphLink, GraphNode } from \"../utils/db\";\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\nimport { AllowedTypes } from \"../model/consts\";"
  },
  {
    "id": "f3b274e5-f8f3-4d61-8bee-116e0cb995b7",
    "fullName": "\\src\\wiki\\wiki::generateAndUpdateDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\r\n\r\n  const documentedFolders = await generateDocumentation(graphNodes, graphLinks, repoName, model)\r\n\r\n  const insertFolderPromises = Object.entries(documentedFolders).map(([name, wiki]) => {\r\n\r\n    if (graphFolders?.find(folder => folder.name === name)) {\r\n      // update\r\n      return sql`\r\n        UPDATE graph_folders\r\n        SET wiki = ${wiki}\r\n        WHERE name = ${name}\r\n      `\r\n    } else {\r\n      return sql`\r\n        INSERT INTO graph_folders (\r\n          repo_id,\r\n          name,\r\n          wiki\r\n        ) VALUES (\r\n          ${repoId},\r\n          ${name},\r\n          ${wiki}\r\n        )\r\n      `\r\n    }\r\n  })\r\n\r\n  const updateNodeDocsPromises = graphNodes.map(node => {\r\n    if (node.generatedDocumentation) {\r\n      return sql`\r\n        UPDATE nodes\r\n        SET generated_documentation = ${node.generatedDocumentation}\r\n        WHERE id = ${node.id}\r\n      `\r\n    }\r\n  })\r\n\r\n  await Promise.all([...insertFolderPromises, ...updateNodeDocsPromises])\r\n}",
    "codeNoBody": "async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateAndUpdateDocumentation",
    "originFile": "\\src\\wiki\\wiki.ts",
    "generatedDocumentation": "The `generateAndUpdateDocumentation` function in the \"\\src\\wiki\\wiki.ts\" file asynchronously generates and updates documentation for a repository by utilizing the `generateDocumentation` function to create documentation for a graph constructed from provided nodes and links. It then handles updating or inserting folders in the database based on the generated documentation and updates node documentation if available. The function takes parameters `repoName` for the repository name, `repoId` for the repository ID, `graphNodes` for graph nodes, `graphLinks` for graph links, `graphFolders` for graph folders (optional), and `model` for the specified model (defaulting to 'gpt-4o-mini').",
    "importStatements": ""
  },
  {
    "id": "24326b14-ce67-4cde-8ccf-0cf7061e9ef4",
    "fullName": "\\src\\wiki\\wiki::generateDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}",
    "codeNoBody": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateDocumentation",
    "originFile": "\\src\\wiki\\wiki.ts",
    "generatedDocumentation": "The `generateDocumentation` function in the \"\\src\\wiki\\wiki.ts\" file asynchronously generates documentation for a given repository by building a graph from provided nodes and links, organizing nodes by levels using breadth-first search, and then documenting the nodes by levels and folders using a specified model. The function returns the documented folders after completion. The `nodes` parameter represents the graph nodes, `links` are the connections between nodes, `repoName` is the name of the repository, and `model` is an optional parameter specifying the model to use, defaulting to 'gpt-4o-mini'.",
    "importStatements": ""
  },
  {
    "id": "39c1ee87-1762-4243-914e-bdfa36474c37",
    "fullName": "\\src\\wiki\\wiki",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\nimport { sql } from \"../utils/db\";\r\n\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}\r\n\r\nexport async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\r\n\r\n  const documentedFolders = await generateDocumentation(graphNodes, graphLinks, repoName, model)\r\n\r\n  const insertFolderPromises = Object.entries(documentedFolders).map(([name, wiki]) => {\r\n\r\n    if (graphFolders?.find(folder => folder.name === name)) {\r\n      // update\r\n      return sql`\r\n        UPDATE graph_folders\r\n        SET wiki = ${wiki}\r\n        WHERE name = ${name}\r\n      `\r\n    } else {\r\n      return sql`\r\n        INSERT INTO graph_folders (\r\n          repo_id,\r\n          name,\r\n          wiki\r\n        ) VALUES (\r\n          ${repoId},\r\n          ${name},\r\n          ${wiki}\r\n        )\r\n      `\r\n    }\r\n  })\r\n\r\n  const updateNodeDocsPromises = graphNodes.map(node => {\r\n    if (node.generatedDocumentation) {\r\n      return sql`\r\n        UPDATE nodes\r\n        SET generated_documentation = ${node.generatedDocumentation}\r\n        WHERE id = ${node.id}\r\n      `\r\n    }\r\n  })\r\n\r\n  await Promise.all([...insertFolderPromises, ...updateNodeDocsPromises])\r\n}",
    "codeNoBody": "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\nimport { sql } from \"../utils/db\";\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-4o-mini') {\n       //...\n       }\r\n\r\nexport async function generateAndUpdateDocumentation(\r\n  repoName: string,\r\n  repoId: string,\r\n  graphNodes: GraphNode[],\r\n  graphLinks: GraphLink[],\r\n  graphFolders?: GraphFolder[],\r\n  model: string = 'gpt-4o-mini') {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki.ts",
    "originFile": "\\src\\wiki\\wiki.ts",
    "generatedDocumentation": "The `wiki.ts` file in the `\\src\\wiki` directory is designed to handle the generation and updating of documentation for a repository. It provides two main asynchronous functions:\n\n1. **generateDocumentation**: This function creates documentation for a given repository by constructing a graph from provided nodes and links. It organizes the nodes using a breadth-first search approach and documents them by levels and folders using a specified model (defaulting to 'gpt-4o-mini'). The function returns the documented folders upon completion.\n\n2. **generateAndUpdateDocumentation**: This function builds upon `generateDocumentation` by not only generating the documentation but also updating or inserting the resulting documentation into a database. It manages the documentation of nodes and folders, ensuring the repository's documentation is up-to-date. It takes parameters such as repository name, repository ID, graph nodes, graph links, optional graph folders, and an optional model.\n\nOverall, the `wiki.ts` file automates the process of documenting a repository's structure and content, making it easier to maintain and understand.",
    "importStatements": "import { GraphFolder, GraphLink, GraphNode } from \"../utils/db\";\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\nimport { sql } from \"../utils/db\";"
  },
  {
    "id": "966f7abb-99f5-45bb-a6fa-74fa46c3b5e7",
    "fullName": "\\src\\wiki\\wikiGuille::buildWiki",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}",
    "codeNoBody": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildWiki",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The \"buildWiki\" function takes in two dictionaries representing folder and file documentation, then generates a markdown wiki page for a repository by utilizing the OpenAI2 client to create a Wikipedia-style content. The function constructs a structured overview of the repository's documentation, incorporating the provided folder and file documentation into the wiki page. The completion from the OpenAI model \"gpt-3.5-turbo\" is used to enhance the generated wiki content, ensuring accuracy and organization in the documentation process.",
    "importStatements": ""
  },
  {
    "id": "b4f67c52-d41a-4978-b6fe-e08cf1761ef8",
    "fullName": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r",
    "code": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "codeNoBody": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateFolderDocumentation",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The function `generateFolderDocumentation` takes in a `folderPath` and `folderContent` as parameters, then utilizes the OpenAI2 client to interact with the OpenAI API, generating documentation based on the content of the files within the specified folder. It initializes the OpenAI2 client with a specific API key, sets the model to \"gpt-3.5-turbo\", temperature to 0, and max_tokens to 1024. The function also calculates the total tokens used in the process and logs the elapsed time in seconds using the `timeElapsedInSecconds` function.",
    "importStatements": ""
  },
  {
    "id": "8f333ece-47cb-4466-a192-5c76b4c38ab4",
    "fullName": "\\src\\wiki\\wikiGuille::documentFolders",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}",
    "codeNoBody": "async function documentFolders(filesDocumentation: any) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentFolders",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The function `documentFolders` takes in an object `filesDocumentation` containing file paths and their respective documentation, then organizes the documentation into folders based on the file paths. It iterates through the file paths, identifies the parent folders, and groups the documentation accordingly. It then generates documentation for each folder by concatenating the file documentation within the folder and utilizing the `generateFolderDocumentation` function to interact with the OpenAI API, producing documentation based on the folder content. The function returns an object mapping folder paths to their generated documentation.",
    "importStatements": ""
  },
  {
    "id": "9877c91b-286a-4b0b-8f24-1381e749779b",
    "fullName": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r",
    "code": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "codeNoBody": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateFileDocumentation",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `generateFileDocumentation` function takes in a `fileNode` representing a node in a wiki, `filePath`, and `fileContent`, then generates documentation based on the sub-components of a file. It constructs prompts for a code assistant using the `fileNode` properties, interacts with the OpenAI API through `client2` to generate responses, calculates token usage, and logs the elapsed time using `timeElapsedInSecconds`. The function returns the generated documentation as a string.",
    "importStatements": ""
  },
  {
    "id": "0fe98236-8b59-41ab-966b-86e55fdca206",
    "fullName": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}",
    "codeNoBody": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "classifyAndDocumentFiles",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The function `classifyAndDocumentFiles` takes in three parameters: `fileToNodes` mapping file paths to wikiNodes, `nodesWithFiles` containing wikiNodes associated with files, and `usedNodes` representing wikiNodes used for classification. It populates `fileToNodes` with nodes from `usedNodes`, writes the updated mapping to a JSON file, generates documentation for each file based on its wikiNodes' summaries, and returns a mapping of file paths to their corresponding documentation strings.",
    "importStatements": ""
  },
  {
    "id": "99387a86-e0a2-4331-b219-c4c2ac95999d",
    "fullName": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r",
    "code": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}",
    "codeNoBody": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodeDocumentation",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The function `generateNodeDocumentation` in the file `wikiGuille.ts` takes in an array of `wikiNode` objects `nodesWithFiles`, a specific `wikiNode` object `node`, and a string `calledNodesSummary`, then generates a code documentation prompt based on the node's properties and context. It constructs a system prompt and a user prompt, including import statements if available, and interacts with the OpenAI API to generate a response. The function utilizes the `findFileParent` function to locate the parent node of type \"file\" for context retrieval and logs the elapsed time for execution.",
    "importStatements": ""
  },
  {
    "id": "d00cf9dd-9254-4bd0-8e87-df7e52008c17",
    "fullName": "\\src\\wiki\\wikiGuille::bfs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}",
    "codeNoBody": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "bfs",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `bfs` function in the `wikiGuille.ts` file performs a breadth-first search traversal on a graph represented by `nodes` and `wholeGraph`, starting from the specified `startNodes`. It iterates through the nodes, generates documentation for non-file nodes using the `generateNodeDocumentation` function, and populates the `usedNodes` array with the processed nodes. The function ensures that nodes are visited only once, handles nodes that call other nodes, and returns an array of `wikiNode` objects with updated summaries after the traversal.",
    "importStatements": ""
  },
  {
    "id": "eca662af-feb1-4764-aae9-9185a5efec8b",
    "fullName": "\\src\\wiki\\wikiGuille::findStartNodes",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}",
    "codeNoBody": "function findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findStartNodes",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `findStartNodes` function takes a `callGraph` object as a parameter, where each key represents a node and its value is an array of nodes it calls. It filters and returns the keys of nodes in the `callGraph` object that do not call any other nodes, i.e., nodes with an empty array of calls.",
    "importStatements": ""
  },
  {
    "id": "b6bdcacd-7d77-4c21-ab97-827e1104a0be",
    "fullName": "\\src\\wiki\\wikiGuille::buildGraphs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}",
    "codeNoBody": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildGraphs",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `buildGraphs` function in the `\\src\\wiki\\wikiGuille` file takes in arrays of `wikiNode` and `wikiLink` objects, where `wikiNode` represents nodes in a wiki with various properties, and `wikiLink` represents links between nodes with label information. The function constructs three types of graphs (`callGraph`, `defineGraph`, and `wholeGraph`) based on the relationships between nodes in the input links array, categorizing them by whether they are called or defined by other nodes. The function filters out links that include files and returns the three constructed graphs as objects.",
    "importStatements": ""
  },
  {
    "id": "358b8fcd-a6a4-494d-af47-7341ea51d93f",
    "fullName": "\\src\\wiki\\wikiGuille::readJson",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "readJson",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The \"readJson\" function in the \"\\src\\wiki\\wikiGuille.ts\" file reads a JSON file specified by the \"filePath\" parameter asynchronously using fs2.readFile, parses the data into an array \"nodeInfo,\" and returns it. If an error occurs during reading or parsing, the function logs the error and exits the process with code 1.",
    "importStatements": ""
  },
  {
    "id": "ac677b0b-7603-444c-b196-846a77415ce2",
    "fullName": "\\src\\wiki\\wikiGuille::findFileParent",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}",
    "codeNoBody": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findFileParent",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The function `findFileParent` takes in an array of `wikiNode` objects `nodesWithFiles` and a specific `wikiNode` object `node`, and recursively searches for the parent node that is of type \"file\". If the parent node is found, it is returned; otherwise, the function continues to search for the parent node until a file type parent is found. If no file type parent is found, it logs a message indicating that the parent was not found.",
    "importStatements": ""
  },
  {
    "id": "0be7aab4-d670-45af-a38d-6898f9052324",
    "fullName": "\\src\\wiki\\wikiGuille::tokenizer",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};",
    "codeNoBody": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "tokenizer",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The \"tokenizer\" function takes two parameters: \"fnName\" as a string representing the function name and \"content\" as a string containing the text to tokenize. It initializes an encoding object using predefined parameters, encodes the content into tokens, logs the function name and the number of tokens, and then frees the encoding resources.",
    "importStatements": ""
  },
  {
    "id": "fe2f07ea-47be-45c4-84dd-4c0de0a00193",
    "fullName": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
    "type": "function",
    "language": "typescript",
    "documentation": "// Utils\r",
    "code": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};",
    "codeNoBody": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "timeElapsedInSecconds",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `timeElapsedInSecconds` function calculates the elapsed time in seconds between a start time and an end time provided as parameters, then logs the function name and the calculated time elapsed in seconds, returning the time elapsed as a string with two decimal places.",
    "importStatements": ""
  },
  {
    "id": "539e07da-73e6-43e1-b94b-e36532773a3f",
    "fullName": "\\src\\wiki\\wikiGuille::totalTokensUsed",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "let totalTokensUsed = 0;",
    "codeNoBody": "let totalTokensUsed = 0;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "totalTokensUsed",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: let totalTokensUsed = 0;",
    "importStatements": ""
  },
  {
    "id": "c1acc6a9-6126-4ff8-b9c1-c12f0a9ae06e",
    "fullName": "\\src\\wiki\\wikiGuille::linksPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "codeNoBody": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "linksPath",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "importStatements": ""
  },
  {
    "id": "1ab03e61-5b59-49fc-bd7d-69baec589307",
    "fullName": "\\src\\wiki\\wikiGuille::nodesPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "codeNoBody": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodesPath",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "importStatements": ""
  },
  {
    "id": "3c99def9-cf1b-4007-94aa-c2fd56c01507",
    "fullName": "\\src\\wiki\\wikiGuille::folder_path",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const folder_path = `../../test_files/`;",
    "codeNoBody": "const folder_path = `../../test_files/`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "folder_path",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const folder_path = `../../test_files/`;",
    "importStatements": ""
  },
  {
    "id": "754a4b06-f145-4922-b26a-a1616fd8a74d",
    "fullName": "\\src\\wiki\\wikiGuille::projectId",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//const projectId = \"codebase-index-ts\";\r",
    "code": "const projectId = \"judini-python-main\";",
    "codeNoBody": "const projectId = \"judini-python-main\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "projectId",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const projectId = \"judini-python-main\";",
    "importStatements": ""
  },
  {
    "id": "27446b2d-95c6-4340-8e61-8d272cf94f73",
    "fullName": "\\src\\wiki\\wikiGuille::onlyLogs",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const onlyLogs = false;",
    "codeNoBody": "const onlyLogs = false;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "onlyLogs",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const onlyLogs = false;",
    "importStatements": ""
  },
  {
    "id": "26d46611-264f-404d-a1d7-856d5d11dc20",
    "fullName": "\\src\\wiki\\wikiGuille::response_format",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const response_format = { type: \"json_object\" };",
    "codeNoBody": "const response_format = { type: \"json_object\" };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "response_format",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const response_format = { type: \"json_object\" };",
    "importStatements": ""
  },
  {
    "id": "cb58192a-2497-4fb0-b475-987a8c1b4cff",
    "fullName": "\\src\\wiki\\wikiGuille::max_tokens",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const max_tokens = 1024;",
    "codeNoBody": "const max_tokens = 1024;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "max_tokens",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const max_tokens = 1024;",
    "importStatements": ""
  },
  {
    "id": "18feaa0a-07f2-458f-8e8c-1fd58bac1111",
    "fullName": "\\src\\wiki\\wikiGuille::temperature",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const temperature = 0;",
    "codeNoBody": "const temperature = 0;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "temperature",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const temperature = 0;",
    "importStatements": ""
  },
  {
    "id": "f259f0de-37c0-46ef-8484-d98af6769941",
    "fullName": "\\src\\wiki\\wikiGuille::model",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// LLM settings\r",
    "code": "const model = \"gpt-3.5-turbo\";",
    "codeNoBody": "const model = \"gpt-3.5-turbo\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "model",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const model = \"gpt-3.5-turbo\";",
    "importStatements": ""
  },
  {
    "id": "e9602828-357b-4871-a4e8-d36ca41f98e4",
    "fullName": "\\src\\wiki\\wikiGuille::client2",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
    "codeNoBody": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "client2",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The code initializes a new instance of the OpenAI2 client with a specific API key for authentication, enabling interactions with the OpenAI API within the codebase.",
    "importStatements": ""
  },
  {
    "id": "247802c9-db87-41a6-a34f-b076c0ff8600",
    "fullName": "\\src\\wiki\\wikiGuille::wikiLink",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiLink",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `wikiLink` type in the `\\src\\wiki\\wikiGuille` file defines an object with `source`, `target`, and `label` properties, representing a link between two nodes in a wiki graph with associated label information.",
    "importStatements": ""
  },
  {
    "id": "a7b0c4c7-70b5-4967-a8fd-dfa5dcdd16ba",
    "fullName": "\\src\\wiki\\wikiGuille::wikiNode",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiNode",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `wikiNode` type in the file represents a node in a wiki with properties such as id, alias, language, label, type, parent (optional), totalTokens, inDegree, outDegree, code, summary (optional), importStatements, codeNoBody, and originFile.",
    "importStatements": ""
  },
  {
    "id": "7de2a7ea-c38f-4bf8-a07f-eec076e9004e",
    "fullName": "\\src\\wiki\\wikiGuille",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { AllowedTypes } from \"../model/consts\";\r\n\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}\r\n",
    "codeNoBody": "import { AllowedTypes } from \"../model/consts\";\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}\r\n\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\n//...\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "originFile": "\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "### File: `wikiGuille.ts`\n\n#### Purpose:\nThe `wikiGuille.ts` file is designed to generate comprehensive documentation for a codebase by analyzing its structure and relationships between various components. It utilizes the OpenAI API to create detailed summaries and documentation for files, folders, and nodes within the codebase, ultimately producing a structured wiki page in markdown format.\n\n#### Main Features:\n1. **Node and Link Processing**:\n   - Reads and processes nodes and links from JSON files (`nodes.json` and `links.json`).\n   - Filters nodes to exclude file types and constructs graphs (`callGraph`, `defineGraph`, and `wholeGraph`) based on relationships between nodes.\n\n2. **Graph Construction**:\n   - Builds different types of graphs to represent calls and definitions among nodes, excluding file nodes.\n\n3. **Documentation Generation**:\n   - Generates documentation for individual nodes, files, and folders using the OpenAI API.\n   - Classifies nodes and files, then documents them based on their relationships and content.\n\n4. **Breadth-First Search (BFS)**:\n   - Performs BFS to traverse the graph, generating documentation for nodes and ensuring all relevant nodes are processed.\n\n5. **Wiki Page Creation**:\n   - Aggregates the generated documentation for files and folders.\n   - Constructs a markdown wiki page that provides a structured overview of the codebase documentation.\n\n6. **Utility Functions**:\n   - Includes utility functions for reading JSON files, calculating elapsed time, and tokenizing content.\n\n7. **OpenAI Integration**:\n   - Utilizes the OpenAI API to enhance the documentation process, ensuring detailed and accurate content generation.\n\n8. **Output**:\n   - Writes the generated documentation and graphs to various JSON files.\n   - Produces a final markdown file (`wikiPage.md`) that serves as the comprehensive documentation for the codebase.\n\nOverall, `wikiGuille.ts` automates the process of documenting a codebase by leveraging AI to create detailed and organized documentation, making it easier to understand and navigate the codebase.",
    "importStatements": "import { AllowedTypes } from \"../model/consts\";\nconst fs2 = require(\"fs\").promises;\nconst path2 = require(\"path\");\nconst OpenAI2 = require(\"openai\");\nconst { Tiktoken } = require(\"tiktoken/lite\");\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");"
  },
  {
    "id": "28f2a23d-e592-425e-98e5-773551d8e2c2",
    "fullName": "\\tests\\c.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "\\tests\\c.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "2228630d-7b15-4c60-aaca-1c9a67211839",
    "fullName": "\\tests\\c.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "\\tests\\c.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "0627bf1a-1613-4856-ad5f-384cd3e895aa",
    "fullName": "\\tests\\c.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test.ts",
    "originFile": "\\tests\\c.test.ts",
    "generatedDocumentation": "The file `c.test.ts` in the `tests` folder contains a suite of unit tests for validating the functionality of the `Node` and `Codebase` classes in handling C language code structures. The main features and purposes of the file are:\n\n1. **Import Statements Test**: Validates the parsing and generation of import statements from C files, ensuring correct identification and path resolution of included headers.\n\n2. **Assignments Test**: Checks the detection and representation of variable assignments within a C file, ensuring that the nodes for assignments are correctly created and simplified.\n\n3. **Function Definition Test**: Ensures that function definitions in C files are correctly parsed, documented, and represented as nodes with appropriate attributes.\n\n4. **Struct Definition Test**: Verifies the correct parsing and node creation for struct definitions, including documentation and code representation.\n\n5. **Union Definition Test**: Tests the handling of union definitions, ensuring they are correctly parsed and represented as nodes.\n\n6. **Header File Test**: Validates the parsing of C header files, ensuring that typedefs for structs, unions, and function declarations are correctly identified and represented.\n\n7. **Function Calls Test**: Ensures that function calls within C files are correctly identified, with proper resolution of called functions and variables, and verifies the inter-file call relationships.\n\nThese tests collectively ensure the robustness of the codebase's ability to parse, represent, and analyze C language code structures accurately.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "5057ca38-884a-4f48-8745-8fab30c050fe",
    "fullName": "\\tests\\java.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "\\tests\\java.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "a05a5bff-89e2-4cc2-be95-13ddfc98d49a",
    "fullName": "\\tests\\java.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "\\tests\\java.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "d373120e-92a3-444e-9e0f-c0a69aa8e2fd",
    "fullName": "\\tests\\java.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estáticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estáticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test.ts",
    "originFile": "\\tests\\java.test.ts",
    "generatedDocumentation": "The file `java.test.ts` in the `tests` folder is designed to test the functionality of parsing and analyzing Java code within a codebase. It includes several test cases that validate different aspects of Java code handling:\n\n1. **Import Statements**: This test verifies the correct parsing and resolution of import statements in a Java file. It checks if the import statements are correctly identified and their paths resolved.\n\n2. **Class Definition**: This test ensures that Java class definitions, including their methods and attributes, are correctly parsed and represented in the node structure. It also verifies the extraction of class documentation.\n\n3. **Code without Body**: This test checks the ability to retrieve the code structure of a class and its methods without their bodies, ensuring that the structure is maintained while omitting the method implementations.\n\n4. **Calls**: This test validates the detection and resolution of method calls within and across Java files. It ensures that method invocations are correctly identified and linked to their definitions.\n\nOverall, the purpose of this file is to ensure that the codebase indexing and analysis functionalities work correctly for Java code, covering import resolution, class and method parsing, and call graph generation.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
  },
  {
    "id": "19168758-ff56-483d-85a2-2f75dfac7e32",
    "fullName": "\\tests\\javascript.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "\\tests\\javascript.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "54e0cffc-8602-47fb-8053-8d63d45e3c31",
    "fullName": "\\tests\\javascript.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "\\tests\\javascript.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "c159e9ac-38af-42d7-a0f4-5d74b63cd123",
    "fullName": "\\tests\\javascript.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test.ts",
    "originFile": "\\tests\\javascript.test.ts",
    "generatedDocumentation": "The `javascript.test.ts` file in the `\\tests` folder contains a suite of tests designed to validate the functionality of the `Node` and `Codebase` classes from the `codebase-index-ts` project. These tests focus on parsing and analyzing JavaScript and TypeScript code to ensure accurate representation and manipulation of code structures. The main features and purposes of the file are:\n\n1. **Import Statements Parsing**:\n   - Tests the ability to parse various import statements in JavaScript files.\n   - Validates the correct generation and resolution of import paths and names.\n\n2. **Assignments Parsing**:\n   - Tests the detection and parsing of variable assignments and export clauses.\n   - Ensures that assignments are correctly identified and their properties are accurately captured.\n\n3. **Function Definitions**:\n   - Tests the parsing of function definitions, including nested functions and their documentation.\n   - Validates the correct identification of function properties and their hierarchical relationships.\n\n4. **Class Definitions**:\n   - Tests the parsing of class definitions, including methods and constructors.\n   - Ensures that class properties, methods, and export aliases are correctly identified and represented.\n\n5. **Code Without Body Extraction**:\n   - Tests the ability to extract code structures without their bodies for classes and methods.\n   - Ensures that the code representation is accurate even when bodies are omitted.\n\n6. **Function and Method Calls**:\n   - Tests the detection and resolution of function and method calls across different files.\n   - Validates the correct mapping of calls to their respective definitions within the codebase.\n\nOverall, the file ensures the robustness and accuracy of the codebase indexing and analysis functionalities provided by the `Node` and `Codebase` classes, particularly in handling JavaScript and TypeScript code.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "10163bed-af70-4260-8187-eb44029b11f0",
    "fullName": "\\tests\\php.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "\\tests\\php.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "0a8af0c4-024b-4858-a296-2c693297a2ca",
    "fullName": "\\tests\\php.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "\\tests\\php.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "d3abcf56-4000-460c-b4a7-f42ff12e41d7",
    "fullName": "\\tests\\php.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test.ts",
    "originFile": "\\tests\\php.test.ts",
    "generatedDocumentation": "The `php.test.ts` file in the `\\tests` folder contains a series of unit tests for validating the functionality of the `Node` class and related operations within a PHP codebase. The main features and purposes of the file are:\n\n1. **Testing Import Statements**: Verifies that PHP import statements (`include`, `require`, `use`) are correctly parsed and resolved to their respective file paths.\n\n2. **Global Variable Assignments**: Ensures that global variable assignments within a PHP file are correctly identified and their attributes (like `id`, `type`, `name`, etc.) are accurately captured.\n\n3. **Function Definitions**: Checks that function definitions, along with their documentation and code, are correctly parsed and stored as child nodes of the file node.\n\n4. **Class Definitions**: Validates that class definitions, including their methods and properties, are correctly parsed and structured in the node tree.\n\n5. **Namespace Handling**: Tests the parsing and structuring of namespaces in PHP files, ensuring that classes within namespaces are correctly identified and their relationships are maintained.\n\n6. **Function and Method Calls**: Ensures that function and method calls are correctly identified and linked to their definitions, supporting the resolution of call graphs within the codebase.\n\nOverall, the file aims to ensure the robustness and accuracy of the PHP code parsing and indexing functionalities provided by the `Node` class and related components in the codebase.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "2c89c8ab-0dff-4050-9ef4-77eda80dcff2",
    "fullName": "\\tests\\python.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "\\tests\\python.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "f67f8784-3658-412d-9499-d87ab3d8c663",
    "fullName": "\\tests\\python.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "\\tests\\python.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "d4ff66ac-eb4f-4610-b032-a6d0c755fd6d",
    "fullName": "\\tests\\python.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test.ts",
    "originFile": "\\tests\\python.test.ts",
    "generatedDocumentation": "The `python.test.ts` file in the `\\tests` folder contains a series of unit tests designed to validate the functionality of the `Node` and `Codebase` classes from the codebase model. These tests focus on parsing and analyzing Python code to ensure that the system correctly identifies and processes various code structures and relationships. The main features and purposes of the file are:\n\n1. **Import Statements Test**: Verifies that the system can correctly parse and resolve import statements in Python files, including relative imports and aliasing.\n\n2. **Assignments Test**: Ensures that the system can detect and document variable assignments within a Python file, capturing attributes such as documentation, code, and relationships.\n\n3. **Function Definition Test**: Checks the system's ability to identify and document function definitions, including nested functions and decorators, capturing their code, documentation, and relationships.\n\n4. **Class Definition Test**: Validates the system's capability to parse and document class definitions, including methods and attributes, capturing their hierarchical structure and relationships.\n\n5. **Code Without Body Test**: Tests the functionality to retrieve code definitions without their bodies, useful for summarizing class and method structures.\n\n6. **Calls Test**: Ensures that the system can correctly identify and document function and method calls across different files, capturing the relationships between callers and callees.\n\nOverall, the file aims to ensure the robustness and accuracy of the codebase model's ability to parse, document, and analyze Python code, focusing on imports, assignments, functions, classes, and call relationships.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
  },
  {
    "id": "da277019-c44e-42ca-8514-e127ba733ed9",
    "fullName": "\\tests\\utils.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    // test('generateNodePrompts', async () => {\r\n    //     const links: GraphLink[] = [\r\n    //         { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n    //         { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n    //         { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n    //         { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n    //         { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n    //         { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n    //         { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n    //     ];\r\n    //     const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n    //     const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n    //     // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n    //     // console.log(systemPrompt)\r\n    //     // console.log(userPrompt)\r\n    //     // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n    //     await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n    //     wikiutils.documentFolders(nodes, links, repoName)\r\n    //     // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    // }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })\r\n",
    "codeNoBody": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    // test('generateNodePrompts', async () => {\r\n    //     const links: GraphLink[] = [\r\n    //         { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n    //         { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n    //         { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n    //         { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n    //         { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n    //         { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n    //         { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n    //     ];\r\n    //     const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n    //     const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n    //     // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n    //     // console.log(systemPrompt)\r\n    //     // console.log(userPrompt)\r\n    //     // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n    //     await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n    //     wikiutils.documentFolders(nodes, links, repoName)\r\n    //     // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    // }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\utils.test.ts",
    "originFile": "\\tests\\utils.test.ts",
    "generatedDocumentation": "The file `utils.test.ts` in the `\\tests` folder is designed to test utility functions from the `utils` module and related functionalities within the codebase. The main features and purposes of the file are:\n\n1. **Testing Utility Functions**:\n   - **cleanAndSplitContent**: Verifies that the function correctly processes and splits content strings into individual elements.\n   - **renameSource**: Ensures that the function accurately renames module paths for both TypeScript/JavaScript and Python files, considering different directory structures.\n\n2. **Graph and Wiki Utilities**:\n   - **Graph Node and Link Definitions**: Sets up mock data for graph nodes and links to simulate a codebase structure.\n   - **BFS (Breadth-First Search) Levels**: Tests the BFS implementation to ensure it correctly computes levels of nodes in a graph for various scenarios, including simple, all-to-one, circular, and self-referential graphs.\n   - **Graph Building**: Utilizes `wikiutils.buildGraphs` to construct graphs from nodes and links, validating the BFS levels output.\n\n3. **Capture Queries**:\n   - **Import Statements**: Tests the `captureQuery` function to ensure it correctly captures import statements in both JavaScript/TypeScript and Python code.\n   - **Constructor Definitions**: Although partially implemented, it aims to test the capture of constructor definitions in classes.\n\nOverall, the file ensures the reliability and correctness of utility functions and graph-related operations within the codebase, providing comprehensive test coverage for critical functionalities.",
    "importStatements": "import * as utils from '../src/model/utils'\nimport { GraphLink, GraphNode } from '../src/utils/db'\nimport * as wikiutils from '../src/wiki/utils'"
  }
]