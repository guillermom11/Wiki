[
  {
    "id": "7bf3de02-2407-4e2b-b140-1478a1844567",
    "fullName": "\\graph_to_csv::graph_to_csv",
    "type": "function",
    "language": "python",
    "documentation": "",
    "code": "def graph_to_csv(name='codebase'):\r\n\r\n    nodes = pd.read_json('nodes.json')\r\n    nodes['full_name'] = nodes['id']\r\n    edges = pd.read_json('edges.json')\r\n\r\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\r\n    edges.to_csv(f'edges_{name}.csv', index=False)",
    "codeNoBody": "def graph_to_csv(name='codebase'):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "graph_to_csv",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\graph_to_csv.py",
    "generatedDocumentation": "The function `graph_to_csv` reads node and edge data from JSON files, assigns the 'full_name' column in the nodes dataframe, and then saves the nodes and edges dataframes to CSV files with the specified name (default is 'codebase'). The parameter 'name' is used to customize the output CSV file names.",
    "importStatements": ""
  },
  {
    "id": "aa2ae06d-f72b-4d38-b525-f831484f6dd8",
    "fullName": "\\graph_to_csv",
    "type": "file",
    "language": "python",
    "documentation": "",
    "code": "import sys\r\nimport pandas as pd\r\n\r\ndef graph_to_csv(name='codebase'):\r\n\r\n    nodes = pd.read_json('nodes.json')\r\n    nodes['full_name'] = nodes['id']\r\n    edges = pd.read_json('edges.json')\r\n\r\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\r\n    edges.to_csv(f'edges_{name}.csv', index=False)\r\n\r\nif __name__ == '__main__':\r\n    if len(sys.argv) > 1:\r\n        name = sys.argv[1]\r\n\r\n    graph_to_csv(name)",
    "codeNoBody": "import sys\r\nimport pandas as pd\r\ndef graph_to_csv(name='codebase'):\r\n\r\n    ...\r\n\r\nif __name__ == '__main__':\r\n    if len(sys.argv) > 1:\r\n        name = sys.argv[1]\r\n\r\n    graph_to_csv(name)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\graph_to_csv.py",
    "originFile": "",
    "generatedDocumentation": "## Wiki for `graph_to_csv.py`\n\n### Overview\nThe `graph_to_csv.py` script is designed to convert graph data, specifically nodes and edges, from JSON format to CSV format. This conversion facilitates easier manipulation and analysis of graph data using standard data processing tools.\n\n### Main Features\n- **Function `graph_to_csv(name='codebase')`**:\n  - **Purpose**: This function reads node and edge data from JSON files, processes the data by assigning the 'full_name' column in the nodes dataframe, and saves the processed data into CSV files.\n  - **Parameters**: \n    - `name` (default is 'codebase'): This parameter allows customization of the output CSV file names.\n  - **Process**:\n    1. **Read Data**: It reads node and edge data from JSON files.\n    2. **Process Data**: It assigns the 'full_name' column in the nodes dataframe.\n    3. **Save Data**: It saves the nodes and edges dataframes to CSV files with the specified name.\n\n- **Command Line Interface**:\n  - The script can be executed from the command line, allowing the user to specify the name for the output CSV files.\n  - **Usage**: \n    - If a name is provided as a command-line argument, it will be used as the base name for the output CSV files.\n    - If no name is provided, the default name 'codebase' will be used.\n\n### Important Definitions\n- **Nodes Dataframe**: A structured representation of the nodes in the graph, including attributes such as 'full_name'.\n- **Edges Dataframe**: A structured representation of the edges in the graph, detailing the connections between nodes.\n\n### Purpose\nThe primary purpose of the `graph_to_csv.py` script is to facilitate the conversion of graph data from JSON format to CSV format, making it more accessible for data analysis and processing using common tools like spreadsheets and data analysis libraries.\n\nBy providing a simple command-line interface, the script allows users to easily customize the output file names, enhancing flexibility and usability.",
    "importStatements": "import sys\nimport pandas as pd"
  },
  {
    "id": "84eac015-816a-48ea-b84f-82478b04bf88",
    "fullName": "\\jest.config",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };\r\n  ",
    "codeNoBody": "module.exports = {\r\n    preset: 'ts-jest',\r\n    testEnvironment: 'node',\r\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\r\n    setupFiles: ['dotenv/config']\r\n  };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\jest.config.js",
    "originFile": "",
    "generatedDocumentation": "## jest.config.js\n\n### Overview\nThe `jest.config.js` file is a configuration file for Jest, a popular testing framework for JavaScript and TypeScript applications. This file is located in the root directory of the `codebase-index-ts` project and is used to define how Jest should behave when running tests.\n\n### Purpose\nThe primary purpose of the `jest.config.js` file is to set up the testing environment and specify the configuration options for running tests in the project. It ensures that tests are executed correctly and consistently across different environments.\n\n### Main Features\n1. **Preset Configuration**:\n    ```typescript\n    preset: 'ts-jest',\n    ```\n    - This line specifies that the project uses `ts-jest` as a preset. `ts-jest` is a Jest transformer that allows Jest to understand TypeScript code. It compiles TypeScript files to JavaScript before running the tests.\n\n2. **Test Environment**:\n    ```typescript\n    testEnvironment: 'node',\n    ```\n    - This setting defines the environment in which the tests will run. By setting it to `'node'`, Jest will use a Node.js environment for testing, which is suitable for server-side applications.\n\n3. **Test Match Patterns**:\n    ```typescript\n    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n    ```\n    - This array specifies the patterns Jest uses to detect test files. \n        - `**/__tests__/**/*.ts`: Matches any `.ts` files inside a `__tests__` directory at any level.\n        - `**/?(*.)+(spec|test).ts`: Matches any `.ts` files that end with `.spec.ts` or `.test.ts`, allowing for flexible naming conventions for test files.\n\n4. **Setup Files**:\n    ```typescript\n    setupFiles: ['dotenv/config']\n    ```\n    - This line indicates that Jest should load the `dotenv/config` module before running the tests. This is useful for loading environment variables from a `.env` file, which can be necessary for configuring the test environment.\n\n### Important Definitions\n- **`preset`**: Specifies a set of pre-configured settings for Jest. In this case, `ts-jest` is used to handle TypeScript files.\n- **`testEnvironment`**: Defines the environment in which tests are executed. Setting it to `'node'` configures Jest to use a Node.js environment.\n- **`testMatch`**: An array of glob patterns that Jest uses to find test files.\n- **`setupFiles`**: An array of modules that Jest should load before running the tests, useful for setting up the testing environment.\n\n### Conclusion\nThe `jest.config.js` file is crucial for setting up and customizing the testing environment for the `codebase-index-ts` project. By configuring Jest with `ts-jest`, specifying the test environment, defining test file patterns, and loading necessary setup files, it ensures that tests are run efficiently and correctly.",
    "importStatements": ""
  },
  {
    "id": "b9aaeb77-bad6-4c8c-94c8-7539452ddf7e",
    "fullName": "\\src\\communities\\communities::cmap",
    "type": "assignment",
    "language": "python",
    "documentation": "# Spring layout for better visualization\r",
    "code": "cmap = plt.get_cmap('viridis')",
    "codeNoBody": "cmap = plt.get_cmap('viridis')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cmap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: cmap = plt.get_cmap('viridis')",
    "importStatements": ""
  },
  {
    "id": "3d4494a8-f19c-4e0d-8740-6b6f8d9c454d",
    "fullName": "\\src\\communities\\communities::pos",
    "type": "assignment",
    "language": "python",
    "documentation": "# Draw the graph\r",
    "code": "pos = nx.spring_layout(G)",
    "codeNoBody": "pos = nx.spring_layout(G)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "pos",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: pos = nx.spring_layout(G)",
    "importStatements": ""
  },
  {
    "id": "8cf99677-f499-4735-a105-c274d242e4da",
    "fullName": "\\src\\communities\\communities::partition",
    "type": "assignment",
    "language": "python",
    "documentation": "# Detect communities using Louvain algorithm\r",
    "code": "partition = community_louvain.best_partition(G)",
    "codeNoBody": "partition = community_louvain.best_partition(G)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "partition",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: partition = community_louvain.best_partition(G)",
    "importStatements": ""
  },
  {
    "id": "c784104b-b743-44a6-b313-d5f90f2467bd",
    "fullName": "\\src\\communities\\communities::G",
    "type": "assignment",
    "language": "python",
    "documentation": "# Construct the graph\r",
    "code": "G = construct_graph_from_json(nodes, links)",
    "codeNoBody": "G = construct_graph_from_json(nodes, links)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "G",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: G = construct_graph_from_json(nodes, links)",
    "importStatements": ""
  },
  {
    "id": "a7125dda-c02a-4645-8fb0-60121d99a3c3",
    "fullName": "\\src\\communities\\communities::links",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "links = read_json(links_path)",
    "codeNoBody": "links = read_json(links_path)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "links",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: links = read_json(links_path)",
    "importStatements": ""
  },
  {
    "id": "a3ec16fd-b20b-455b-ac0d-72f490ffc5d0",
    "fullName": "\\src\\communities\\communities::nodes",
    "type": "assignment",
    "language": "python",
    "documentation": "# Read nodes and links from JSON files\r",
    "code": "nodes = read_json(nodes_path)",
    "codeNoBody": "nodes = read_json(nodes_path)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: nodes = read_json(nodes_path)",
    "importStatements": ""
  },
  {
    "id": "42467ebb-cb41-4432-be2d-ee09a18de794",
    "fullName": "\\src\\communities\\communities::construct_graph_from_json",
    "type": "function",
    "language": "python",
    "documentation": "# Function to construct graph from nodes and links\r",
    "code": "def construct_graph_from_json(nodes, links):\r\n    G = nx.Graph()\r\n    for node in nodes:\r\n        G.add_node(node['id'], **node)\r\n    for link in links:\r\n        G.add_edge(link['source'], link['target'], **link)\r\n    return G",
    "codeNoBody": "def construct_graph_from_json(nodes, links):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "construct_graph_from_json",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "This function constructs a graph using the NetworkX library from a list of nodes and links provided as parameters. It iterates over the nodes to add them as nodes in the graph with their corresponding attributes and then iterates over the links to add them as edges between the source and target nodes with their respective attributes. The function returns the constructed graph.",
    "importStatements": ""
  },
  {
    "id": "4eabfc43-10e9-4f27-b089-52fa6f9b081e",
    "fullName": "\\src\\communities\\communities::save_json",
    "type": "function",
    "language": "python",
    "documentation": "",
    "code": "def save_json(data, file_path):\r\n    with open(file_path, 'w') as file:\r\n        json.dump(data, file, indent=4)",
    "codeNoBody": "def save_json(data, file_path):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "save_json",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "This function saves the provided data into a JSON file specified by the file_path parameter. It uses the json module to dump the data with an indentation of 4 spaces into the file.",
    "importStatements": ""
  },
  {
    "id": "000d62ee-aa33-4a03-890b-dac0a365f8b7",
    "fullName": "\\src\\communities\\communities::read_json",
    "type": "function",
    "language": "python",
    "documentation": "# Function to read JSON files\r",
    "code": "def read_json(file_path):\r\n    with open(file_path, 'r') as file:\r\n        return json.load(file)",
    "codeNoBody": "def read_json(file_path):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "read_json",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "This function reads a JSON file specified by the `file_path` parameter and returns the contents of the file as a Python dictionary using the `json.load()` method.",
    "importStatements": ""
  },
  {
    "id": "e0ae4bf8-1ca5-47cd-9d78-3d5cad09771f",
    "fullName": "\\src\\communities\\communities::graph_to_csv",
    "type": "function",
    "language": "python",
    "documentation": "",
    "code": "def graph_to_csv(name='codebase'):\r\n\r\n    nodes = pd.read_json(\"nodesCommunities.json\")\r\n    nodes['full_name'] = nodes['id']\r\n    edges = pd.read_json(links_path)\r\n\r\n    nodes.to_csv(f'nodes_{name}.csv', index=False)\r\n    edges.to_csv(f'edges_{name}.csv', index=False)",
    "codeNoBody": "def graph_to_csv(name='codebase'):\r\n    ...",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "graph_to_csv",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "This function \"graph_to_csv\" reads nodes from a JSON file, assigns the 'full_name' column to the 'id' column, reads edges from a specified path, and then saves the nodes and edges data into CSV files with names based on the provided 'name' parameter.",
    "importStatements": ""
  },
  {
    "id": "5ffde936-5c37-4fca-9f53-f82eaa9116ff",
    "fullName": "\\src\\communities\\communities::links_path",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "links_path = f\"{folder_path}/{projectId}/links.json\"",
    "codeNoBody": "links_path = f\"{folder_path}/{projectId}/links.json\"",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "links_path",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: links_path = f\"{folder_path}/{projectId}/links.json\"",
    "importStatements": ""
  },
  {
    "id": "787c8de2-07a0-4de0-849b-ad255950bd4c",
    "fullName": "\\src\\communities\\communities::nodes_path",
    "type": "assignment",
    "language": "python",
    "documentation": "",
    "code": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "codeNoBody": "nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodes_path",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.py",
    "generatedDocumentation": "Code: nodes_path = f\"{folder_path}/{projectId}/nodes.json\"",
    "importStatements": ""
  },
  {
    "id": "f3242290-2786-4dc5-90e5-2d9b934b53e9",
    "fullName": "\\src\\communities\\communities::folder_path",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const folder_path = `../../test_files/`;",
    "codeNoBody": "const folder_path = `../../test_files/`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "folder_path",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const folder_path = `../../test_files/`;",
    "importStatements": ""
  },
  {
    "id": "cdce5b40-f11e-44c0-a70d-012cbab060bd",
    "fullName": "\\src\\communities\\communities::projectId",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const projectId = \"judini-python-main\";",
    "codeNoBody": "const projectId = \"judini-python-main\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "projectId",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const projectId = \"judini-python-main\";",
    "importStatements": ""
  },
  {
    "id": "42b1f868-9bcd-4844-83a0-f5b942321fe9",
    "fullName": "\\src\\communities\\communities",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\n\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();\r\n",
    "codeNoBody": "const fs = require(\"fs\").promises;\r\nimport { AllowedTypes } from \"../model/consts\";\r\nconst { Graph } = require(\"graphology\");\r\nconst louvain = require(\"graphology-communities-louvain\");\r\nimport ForceSupervisor from \"graphology-layout-force/worker\";\r\nconst sigma = require(\"sigma\");\r\nimport { v4 as uuid } from \"uuid\";\r\nconst express = require(\"express\");\r\nconst path = require(\"path\");\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\nconst nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksFilePath: string = `${folder_path}/${projectId}/links.json`;\r\n//run this file with: node --import=tsx communities.ts\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n// Function to read JSON files\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\n// Function to construct graph from nodes and links\r\nasync function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}\r\n\r\n(async () => {\r\n  const graph = await constructGraphFromJson(nodesFilePath, linksFilePath);\r\n  //console.log(graph);\r\n  await fs.writeFile(\"myGraph.json\", JSON.stringify(graph, null, 2));\r\n\r\n  // Detect communities using Louvain algorithm\r\n  const communities = louvain(graph);\r\n  //console.log(\"Communities: \", communities);\r\n  await fs.writeFile(\"communities.json\", JSON.stringify(communities, null, 2));\r\n\r\n  // Assign community colors\r\n  graph.forEachNode((node: wikiNode, attr: string) => {\r\n    graph.setNodeAttribute(node, \"community\", communities[node.id]);\r\n  });\r\n\r\n  // Create Express app\r\n  const app = express();\r\n  const port = 8002;\r\n\r\n  // Serve the graph data\r\n  app.get(\"/\", (req: any, res: any) => {\r\n    res.json(graph.export());\r\n  });\r\n\r\n  // Serve the HTML file\r\n  app.use(express.static(path.join(__dirname, \"public\")));\r\n\r\n  app.listen(port, () => {\r\n    console.log(`Server running at http://localhost:${port}`);\r\n  });\r\n})();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "originFile": "",
    "generatedDocumentation": "# Wiki for `communities.ts`\n\n## Overview\nThe `communities.ts` file is part of the `codebase-index-ts` project, located in the `src/communities` directory. This file is designed to read node and link data from JSON files, construct a graph using this data, detect communities within the graph using the Louvain algorithm, and serve the graph data via an Express server.\n\n## Main Features\n### Import Statements\n- **File System (fs)**: Used for reading and writing files asynchronously.\n- **Graphology**: A JavaScript library for graph data structures.\n- **Graphology-Communities-Louvain**: A module for detecting communities in graphs using the Louvain algorithm.\n- **Graphology-Layout-Force**: Used for force-directed graph layouts.\n- **Sigma**: A library for graph visualization.\n- **UUID**: Generates unique identifiers.\n- **Express**: A web framework for Node.js.\n- **Path**: Utilities for working with file and directory paths.\n\n### Constants\n- **projectId**: Specifies the project identifier.\n- **folder_path**: Path to the directory containing the test files.\n- **nodesFilePath**: Path to the JSON file containing node data.\n- **linksFilePath**: Path to the JSON file containing link data.\n\n### Type Definitions\n- **wikiNode**: Defines the structure of a node in the graph, including properties like `id`, `alias`, `language`, `label`, `type`, `parent`, `totalTokens`, `inDegree`, `outDegree`, `code`, `summary`, `importStatements`, `codeNoBody`, and `originFile`.\n- **wikiLink**: Defines the structure of a link in the graph, including `source`, `target`, and `label`.\n\n### Functions\n- **readJson**: Asynchronously reads a JSON file and returns its contents as a JavaScript object.\n- **constructGraphFromJson**: Reads node and link data from JSON files, constructs a graph using the Graphology library, and returns the constructed graph.\n\n### Main Execution Block\n- **Graph Construction**: Uses `constructGraphFromJson` to create a graph from the specified node and link JSON files.\n- **Community Detection**: Applies the Louvain algorithm to detect communities within the graph and writes the community data to a JSON file.\n- **Assign Community Colors**: Iterates over the nodes in the graph and assigns a community attribute to each node.\n- **Express Server**: Sets up an Express server to serve the graph data and a static HTML file for visualization.\n\n## Purpose\nThe primary purpose of the `communities.ts` file is to:\n1. Read node and link data from JSON files.\n2. Construct a graph using the Graphology library.\n3. Detect communities within the graph using the Louvain algorithm.\n4. Serve the graph data via an Express server for visualization and further analysis.\n\nThis file is essential for analyzing the structure of a graph, detecting communities, and providing a web interface for visualizing the graph data.",
    "importStatements": "const fs = require(\"fs\").promises;\nimport { AllowedTypes } from \"../model/consts\";\nconst { Graph } = require(\"graphology\");\nconst louvain = require(\"graphology-communities-louvain\");\nimport ForceSupervisor from \"graphology-layout-force/worker\";\nconst sigma = require(\"sigma\");\nimport { v4 as uuid } from \"uuid\";\nconst express = require(\"express\");\nconst path = require(\"path\");"
  },
  {
    "id": "bbb88f32-6694-4ac7-ac97-d2c4ad19ed76",
    "fullName": "\\src\\communities\\communities::constructGraphFromJson",
    "type": "function",
    "language": "typescript",
    "documentation": "// Function to construct graph from nodes and links\r",
    "code": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\r\n  const nodes: wikiNode[] = await readJson(nodesFilePath);\r\n  const links: wikiLink[] = await readJson(linksFilePath);\r\n\r\n  const graph = new Graph({\r\n    multi: true,\r\n    allowSelfLoops: false,\r\n    type: \"directed\",\r\n  });\r\n\r\n  nodes.forEach((node) => {\r\n    graph.addNode(node.id, node);\r\n  });\r\n\r\n  links.forEach((link) => {\r\n    graph.addEdge(link.source, link.target, link);\r\n  });\r\n\r\n  return graph;\r\n}",
    "codeNoBody": "async function constructGraphFromJson(\r\n  nodesFilePath: string,\r\n  linksFilePath: string\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "constructGraphFromJson",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `constructGraphFromJson` function asynchronously reads JSON files specified by `nodesFilePath` and `linksFilePath`, then constructs a graph using the data. It creates a graph with multiple edges, disallows self-loops, and is directed. It iterates over the nodes, adding them to the graph, and then iterates over the links, adding edges between the source and target nodes. The function returns the constructed graph with nodes and edges based on the provided JSON data.",
    "importStatements": ""
  },
  {
    "id": "001081f0-d340-4e37-bfb0-687b799c8eb0",
    "fullName": "\\src\\communities\\communities::readJson",
    "type": "function",
    "language": "typescript",
    "documentation": "// Function to read JSON files\r",
    "code": "async function readJson(filePath: string) {\r\n  const data = await fs.readFile(filePath, \"utf8\");\r\n  return JSON.parse(data);\r\n}",
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "readJson",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "The `readJson` function asynchronously reads a JSON file specified by the `filePath` parameter using `fs.readFile` with \"utf8\" encoding, then parses the data into a JavaScript object using `JSON.parse`, and finally returns the parsed JSON object.",
    "importStatements": ""
  },
  {
    "id": "be8da6ea-c5df-478e-859f-35e1890b4d48",
    "fullName": "\\src\\communities\\communities::wikiLink",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiLink",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "The type \"wikiLink\" defines an object with three properties: \"source\" of type string, \"target\" of type string, and \"label\" of type string, representing a link between a source and a target with a specified label.",
    "importStatements": ""
  },
  {
    "id": "2ae70d20-c967-4635-bf92-71362ada8744",
    "fullName": "\\src\\communities\\communities::wikiNode",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "The \"wikiNode\" type represents a node in a wiki system with properties such as id, alias, language, label, type, parent (optional), totalTokens, inDegree, outDegree, code, summary (optional), importStatements, codeNoBody, and originFile.",
    "importStatements": ""
  },
  {
    "id": "bb083014-8f50-4a29-b14d-1702531585cb",
    "fullName": "\\src\\communities\\communities::linksFilePath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "codeNoBody": "const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "linksFilePath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const linksFilePath: string = `${folder_path}/${projectId}/links.json`;",
    "importStatements": ""
  },
  {
    "id": "da3b0f04-deb6-47d6-a44f-9e6480efc225",
    "fullName": "\\src\\communities\\communities::nodesFilePath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "codeNoBody": "const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodesFilePath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\communities\\communities.ts",
    "generatedDocumentation": "Code: const nodesFilePath: string = `${folder_path}/${projectId}/nodes.json`;",
    "importStatements": ""
  },
  {
    "id": "96a68494-54e4-455d-9a5c-425b758c5907",
    "fullName": "\\src\\index::const",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// const\r",
    "code": "const app = new Hono();",
    "codeNoBody": "const app = new Hono();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "const",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index.ts",
    "generatedDocumentation": "Code: const app = new Hono();",
    "importStatements": ""
  },
  {
    "id": "3811f681-ba56-4df9-8abc-fa152f033237",
    "fullName": "\\src\\index",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\n\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});\r\n",
    "codeNoBody": "import { serve } from \"@hono/node-server\";\r\nimport { Hono } from \"hono\";\r\nimport { cors } from \"hono/cors\";\r\nimport { prettyJSON } from \"hono/pretty-json\";\r\nimport { createGraph } from \"./routes/create_graph\";\r\nimport { createGraphTest } from \"./routes/create_graph-test\";\r\nimport { graphs } from \"./routes/graphs\";\r\nimport { Codebase } from \"./model/codebase\";\r\nimport { writeFile } from \"node:fs/promises\";\r\n// const\r\nconst app = new Hono();\r\nvar fs = require(\"fs\");\r\napp.use(\"*\", prettyJSON());\r\napp.use(\"/v1/*\", cors());\r\napp.get(\"/\", async (c) => {\r\n  console.time(\"codebase\");\r\n  // const codebasePath = path.join(__dirname, '../../../codebase-index')\r\n  const codebasePath =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\codebase-index-ts\";\r\n  const codebasePath2 =\r\n    \"C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\judini-python-main\\\\judini-python-main\";\r\n  const codebase = new Codebase(codebasePath); //\r\n  console.log(`Parsing ${codebasePath}`);\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(`Found ${Object.keys(codebase.nodesMap).length} nodes`);\r\n  console.log(\"Getting Calls\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  console.timeEnd(\"codebase\");\r\n  const codebaseSimplified = codebase.simplify([\r\n    \"id\",\r\n    \"language\",\r\n    \"label\",\r\n    \"type\",\r\n    \"parent\",\r\n    \"totalTokens\",\r\n    \"inDegree\",\r\n    \"outDegree\",\r\n    \"code\",\r\n    \"parent\",\r\n    \"importStatements\",\r\n    \"codeNoBody\",\r\n    \"originFile\",\r\n  ]); //.filter(c => !['file'].includes(c.type))\r\n  const links = codebase.getLinks();\r\n\r\n  // console.log(codebaseSimplified)\r\n  await Promise.all([\r\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\r\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\r\n  ]);\r\n  return c.text(JSON.stringify(codebaseSimplified, null, 2));\r\n\r\n  // return c.text(JSON.stringify(codebase.getLinks(), null, 2))\r\n});\r\n\r\napp.route(\"/v1/repo\", createGraph);\r\napp.route(\"/v1/graphs\", graphs);\r\napp.route(\"v1/repo-test\", createGraphTest);\r\n\r\nconst port = 8001;\r\nconsole.log(`Server is running on port ${port}`);\r\n\r\nserve({\r\n  fetch: app.fetch,\r\n  port,\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\index.ts",
    "originFile": "",
    "generatedDocumentation": "# Overview of `src/index.ts`\n\nThe `src/index.ts` file serves as the main entry point for a Node.js server application built using the Hono framework. This server is designed to parse and analyze codebases, generate graph representations of the code structure, and provide endpoints for interacting with these graphs.\n\n## Main Features and Purpose\n\n### Server Initialization\n- **Hono Framework**: The server is created using the Hono framework, which is a lightweight web framework for building HTTP servers.\n  ```typescript\n  const app = new Hono();\n  ```\n\n### Middleware\n- **prettyJSON**: Formats JSON responses to be more readable.\n  ```typescript\n  app.use(\"*\", prettyJSON());\n  ```\n- **CORS**: Enables Cross-Origin Resource Sharing for routes prefixed with `/v1/`.\n  ```typescript\n  app.use(\"/v1/*\", cors());\n  ```\n\n### Routes\n- **Root Route (`/`)**: \n  - Parses a specified codebase directory.\n  - Generates a simplified representation of the codebase.\n  - Writes the nodes and links of the graph to JSON files (`nodes.json` and `links.json`).\n  - Returns the simplified codebase as a JSON response.\n  ```typescript\n  app.get(\"/\", async (c) => {\n    // Code for parsing codebase and generating JSON files\n    return c.text(JSON.stringify(codebaseSimplified, null, 2));\n  });\n  ```\n\n- **Graph-Related Routes**:\n  - `/v1/repo`: Handled by the `createGraph` module.\n  - `/v1/graphs`: Handled by the `graphs` module.\n  - `/v1/repo-test`: Handled by the `createGraphTest` module.\n  ```typescript\n  app.route(\"/v1/repo\", createGraph);\n  app.route(\"/v1/graphs\", graphs);\n  app.route(\"v1/repo-test\", createGraphTest);\n  ```\n\n### Codebase Parsing and Graph Generation\n- **Codebase Class**: Utilizes the `Codebase` class to parse the directory and generate nodes and links representing the code structure.\n  ```typescript\n  const codebase = new Codebase(codebasePath);\n  const fileNodesMap = await codebase.parseFolder();\n  codebase.getCalls(fileNodesMap, false);\n  const codebaseSimplified = codebase.simplify([...]);\n  const links = codebase.getLinks();\n  ```\n\n### File Operations\n- **Node.js File System**: Uses Node.js `fs/promises` to write the generated graph data to JSON files.\n  ```typescript\n  await Promise.all([\n    writeFile(\"nodes.json\", JSON.stringify(codebaseSimplified, null, 2)),\n    writeFile(\"links.json\", JSON.stringify(links, null, 2)),\n  ]);\n  ```\n\n### Server Execution\n- **Port Configuration**: The server listens on port `8001`.\n  ```typescript\n  const port = 8001;\n  console.log(`Server is running on port ${port}`);\n  serve({\n    fetch: app.fetch,\n    port,\n  });\n  ```\n\n## Important Definitions\n- **Hono Framework**: A lightweight framework for building HTTP servers.\n- **Codebase Class**: A class responsible for parsing a directory of code, generating nodes and links, and simplifying the graph representation.\n- **Routes**: Endpoints provided by the server to interact with the codebase graphs.\n\nThis file essentially sets up a server that can parse codebases, generate graph representations, and provide endpoints for accessing these graphs. It uses the Hono framework for routing and middleware, and Node.js for file operations.",
    "importStatements": "import { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { prettyJSON } from \"hono/pretty-json\";\nimport { createGraph } from \"./routes/create_graph\";\nimport { createGraphTest } from \"./routes/create_graph-test\";\nimport { graphs } from \"./routes/graphs\";\nimport { Codebase } from \"./model/codebase\";\nimport { writeFile } from \"node:fs/promises\";"
  },
  {
    "id": "b5b444cd-6340-40da-8563-05d4c1c8c3eb",
    "fullName": "\\src\\llamaindex::main",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function main() {\r\n  // Load file\r\n  const path = \"node_modules/llamaindex/examples/abramov.txt\";\r\n  const essay = await fs.readFile(path, \"utf-8\");\r\n\r\n  const vectorStores = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n  });\r\n\r\n  // Create Document object with file\r\n  const document = new Document({ text: essay, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments([document], {\r\n    vectorStores,\r\n  });\r\n\r\n  // Query the index\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  const response = await queryEngine.query({\r\n    query: \"What did the author do in college?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}",
    "codeNoBody": "async function main() {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "main",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\llamaindex.ts",
    "generatedDocumentation": "The `main` function loads a text file, creates a QdrantVectorStore, generates embeddings from the text, and stores them in a VectorStoreIndex. It then queries the index with a specific question using a query engine and outputs the response to the console.",
    "importStatements": ""
  },
  {
    "id": "2d7316a3-509d-4eca-8c02-63190fcf7b81",
    "fullName": "\\src\\llamaindex",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport * as dotenv from \"dotenv\";\r\nasync function main() {\r\n  // Load file\r\n  const path = \"node_modules/llamaindex/examples/abramov.txt\";\r\n  const essay = await fs.readFile(path, \"utf-8\");\r\n\r\n  const vectorStores = new QdrantVectorStore({\r\n    url: \"http://localhost:8004\",\r\n  });\r\n\r\n  // Create Document object with file\r\n  const document = new Document({ text: essay, id_: path });\r\n\r\n  // Split text and create embeddings. Store them in a VectorStoreIndex\r\n  const index = await VectorStoreIndex.fromDocuments([document], {\r\n    vectorStores,\r\n  });\r\n\r\n  // Query the index\r\n  const queryEngine = index.asQueryEngine();\r\n\r\n  const response = await queryEngine.query({\r\n    query: \"What did the author do in college?\",\r\n  });\r\n\r\n  // Output response\r\n  console.log(response.toString());\r\n}\r\n\r\nmain().catch(console.error);\r\n",
    "codeNoBody": "import fs from \"node:fs/promises\";\r\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\r\nimport * as dotenv from \"dotenv\";\r\nasync function main() {\n//...\n}\r\nmain().catch(console.error);",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\llamaindex.ts",
    "originFile": "",
    "generatedDocumentation": "# llamaindex.ts\n\n## Overview\nThe `llamaindex.ts` file is a script designed to demonstrate the process of creating and querying a vector store index using the `llamaindex` library. This script is part of a larger TypeScript codebase and serves as an example of how to handle text data, generate embeddings, and perform queries on those embeddings.\n\n## Main Features\n- **File Handling**: The script uses Node.js's `fs/promises` module to handle file operations asynchronously.\n- **Environment Configuration**: The script loads environment variables using the `dotenv` package, which is essential for managing configuration settings securely.\n- **Llamaindex Library**: The script utilizes the `llamaindex` library, specifically the `Document`, `VectorStoreIndex`, and `QdrantVectorStore` classes, to manage and query text data.\n\n## Important Definitions\n### Imports\n- **fs**: The Node.js file system module for handling file operations.\n- **Document, VectorStoreIndex, QdrantVectorStore**: Classes from the `llamaindex` library used for creating documents, managing vector store indices, and interfacing with the Qdrant vector store.\n- **dotenv**: A module to load environment variables from a `.env` file.\n\n### Main Function\nThe `main` function is the core of the script and performs the following steps:\n1. **Load Text File**: Reads a text file from the file system.\n2. **Create QdrantVectorStore**: Initializes a Qdrant vector store to manage embeddings.\n3. **Generate Embeddings**: Converts the text data into embeddings and stores them in a `VectorStoreIndex`.\n4. **Query the Index**: Uses a query engine to ask a specific question and retrieves the response from the index.\n5. **Output Response**: Prints the response to the console.\n\n### Error Handling\nThe `main` function includes a catch block to handle and log any errors that occur during execution.\n\n## Purpose\nThe primary purpose of the `llamaindex.ts` file is to provide a practical example of how to use the `llamaindex` library for text data processing, embedding generation, and querying. This script can be used as a reference or starting point for developers looking to implement similar functionality in their own projects.",
    "importStatements": "import fs from \"node:fs/promises\";\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\nimport * as dotenv from \"dotenv\";"
  },
  {
    "id": "f93afd07-d895-4a59-a6c6-45850d2090d9",
    "fullName": "\\src\\model\\calls::CallsCapturer.getCallsFromNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.getCallsFromNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer.getCallsFromNode\" method within the \"CallsCapturer\" class takes a \"node\" parameter representing a specific node in the code. It replaces import names with aliases, captures variable assignments, and then replaces them in the code. Finally, it captures calls from the modified code related to the given node, returning a dictionary where each key is a node identifier and the value is an array of line numbers where calls are made within that node.",
    "importStatements": ""
  },
  {
    "id": "f86b4f47-1a93-4c67-8ab4-68f5b8c9fd46",
    "fullName": "\\src\\model\\calls::CallsCapturer.captureCalls",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.captureCalls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The `captureCalls` method in the `CallsCapturer` class captures calls within the provided code, sorting them by position and ensuring uniqueness. It processes the captured calls, cleans and splits the content, and maps the call names to corresponding nodes. If a match is found, it creates a `CallIdentifier` instance with the node ID and start line, adding it to the results array. Additionally, it handles nested calls by splitting and checking for matches at each level, ultimately returning an array of `CallIdentifier` instances representing the identified calls.",
    "importStatements": ""
  },
  {
    "id": "ea2c1714-0546-427f-adb1-852132e087b3",
    "fullName": "\\src\\model\\calls::CallsCapturer.captureAssignments",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.captureAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The method `captureAssignments` in the `CallsCapturer` class takes a `code` string and a `language` string as parameters. It utilizes the `captureQuery` function to extract variable assignments from the provided code based on the specified language. The method processes the captured assignments, identifies variable names and values, removes unnecessary characters, and organizes the results into an array of `VariableAssignment` objects sorted by their start line in reverse order before returning it.",
    "importStatements": ""
  },
  {
    "id": "e4842b56-49d4-420d-8c78-6d364fc916d3",
    "fullName": "\\src\\model\\calls::CallsCapturer.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }",
    "codeNoBody": "class CallsCapturer\n    ...\n    constructor(fileNode: Node, verbose: boolean = false) {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer\" class constructor takes a \"fileNode\" and a \"verbose\" boolean as parameters, capturing nodes and import statements to create a nodesMap, excluding specific types. It allows capturing assignments, calls, and retrieving calls from a specific node, returning VariableAssignment and CallIdentifier arrays, and a dictionary of call identifiers, respectively.",
    "importStatements": ""
  },
  {
    "id": "b111935c-4c26-4a9a-a5f1-5e222cd3831b",
    "fullName": "\\src\\model\\calls::CallsCapturer",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "codeNoBody": "class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\n        //...\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\n        //...\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\n        //...\n    }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallsCapturer",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallsCapturer\" class takes a \"fileNode\" and a \"verbose\" boolean as parameters, capturing nodes and import statements from the fileNode to create a nodesMap. It provides methods to capture assignments, calls, and get calls from a specific node, returning VariableAssignment and CallIdentifier arrays, and a dictionary of call identifiers respectively.",
    "importStatements": ""
  },
  {
    "id": "ba6469c3-5e3b-40e3-af24-977aeee9dcca",
    "fullName": "\\src\\model\\calls::CallIdentifier.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }",
    "codeNoBody": "class CallIdentifier\n    ...\n    constructor(nodeId: string, line: number) {\n    //...\n    }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallIdentifier.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallIdentifier\" class constructor initializes the \"nodeId\" parameter with a string and the \"line\" parameter with a number (defaulting to 0 if not provided). This class is used to create instances with a unique identifier for a node and a line number, facilitating the identification and tracking of calls within the codebase.",
    "importStatements": ""
  },
  {
    "id": "2dd5c359-e23d-4d2e-ab29-55c1d00942e0",
    "fullName": "\\src\\model\\calls::CallIdentifier",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "codeNoBody": "class CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "CallIdentifier",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"CallIdentifier\" class contains a constructor that initializes the \"nodeId\" parameter with a string and the \"line\" parameter with a number, defaulting to 0 if not provided. The class is used to create instances with a unique identifier for a node and a line number, allowing for easy identification and tracking of calls within the codebase.",
    "importStatements": ""
  },
  {
    "id": "741defd3-d5b1-4817-973f-6ffd1760c35b",
    "fullName": "\\src\\model\\calls::VariableAssignment",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}",
    "codeNoBody": "class VariableAssignment {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "VariableAssignment",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "generatedDocumentation": "The \"VariableAssignment\" class in the calls model directory is responsible for representing a variable assignment operation in the codebase. It includes methods for setting and retrieving the assigned value, variable name, and type. The class allows for creating and manipulating variable assignments within the codebase.",
    "importStatements": ""
  },
  {
    "id": "e63f4f9d-f4cd-43ca-96ab-f16f43699b53",
    "fullName": "\\src\\model\\calls",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\n\r\nclass VariableAssignment {\r\n    left: string = ''\r\n    right: string = ''\r\n    startLine: number = 0\r\n    endLine: number = 99999\r\n}\r\n\r\nclass CallIdentifier {\r\n    nodeId: string\r\n    line: number = 0\r\n\r\n    constructor(nodeId: string, line: number) {\r\n        this.nodeId = nodeId\r\n        this.line = line\r\n    }\r\n}\r\n\r\nexport class CallsCapturer {\r\n    fileNode: Node\r\n    verbose: boolean = true\r\n    nodesMap: {[key: string]: Node} = {}\r\n\r\n    constructor(fileNode: Node, verbose: boolean = false) {\r\n        this.fileNode = fileNode\r\n        this.verbose = verbose\r\n        fileNode.getAllChildren().forEach( c => {\r\n            if (['namespace', 'package', 'mod'].includes(c.type)) return\r\n            this.nodesMap[c.alias] = c \r\n        })\r\n        fileNode.importStatements.forEach( i => {\r\n            i.names.forEach(n => {\r\n                if (n.node) {\r\n                    this.nodesMap[n.alias] = n.node\r\n                }\r\n            })\r\n        })\r\n        // console.log(`/////${fileNode.id}`)\r\n        // console.log({keys: Object.keys(this.nodesMap)})\r\n        // Object.keys(this.nodesMap).forEach(k => console.log(k, this.nodesMap[k].id))\r\n    }\r\n\r\n    captureAssignments(code: string, language: string): VariableAssignment[] {\r\n        const captures = captureQuery(language, 'assignments', code)\r\n        const results: { [key: string]: VariableAssignment[] } = {}\r\n        let varAssignment = new VariableAssignment()\r\n        let varAssignmentIdentifier = ''\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            switch (c.name) {\r\n                case 'assignment':\r\n                    varAssignment = new VariableAssignment()\r\n                    varAssignment.startLine = startLine\r\n                    // varAssignment.endLine = c.node.parent?.endPosition.row || 99999\r\n                    break\r\n                case 'left':\r\n                    varAssignmentIdentifier = content\r\n                    varAssignment.left = varAssignmentIdentifier\r\n                    if (Object.keys(results).includes(content) && c.name === 'left') {\r\n                        results[content].slice(-1)[0].endLine = startLine - 1\r\n                    }\r\n                    break\r\n                case 'right':\r\n                    if (content.startsWith('(') && content.endsWith(')')) content = content.slice(1, -1)\r\n                    // Remove parentheses and their contents\r\n                    content = content.replace(/\\(.*?\\)/gs, '');\r\n                    // Replace newlines and double spaces\r\n        \r\n                    content = content.replace(/\\n/g, '').replace(/  /g, '').trim();\r\n                    // Check for any quotation marks, brackets, or braces\r\n                    if ([\"\\\"\", \"'\", \"[\", \"]\", \"{\", \"}\"].some(char => content.includes(char))) {\r\n                        break\r\n                    }\r\n                    varAssignment.right = content\r\n                    if (!Object.keys(results).includes(varAssignmentIdentifier)) results[varAssignmentIdentifier] = [] \r\n                    results[varAssignmentIdentifier].push(varAssignment)\r\n                    break\r\n            }\r\n        })\r\n        const resultsArray: VariableAssignment[] = []\r\n        Object.keys(results).forEach(key  =>  resultsArray.push(...results[key]))\r\n        // sort resultsArray by startLine in reverse\r\n        resultsArray.sort((a, b) => b.startLine - a.startLine)\r\n        return resultsArray\r\n    }\r\n\r\n    captureCalls(code: string, nodeRef: Node): CallIdentifier[]  {\r\n        const captures  = captureQuery(nodeRef.language, 'calls', code)\r\n        captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row || a.node.startPosition.column - b.node.startPosition.column)\r\n        const results: CallIdentifier[]  = []\r\n        const nodesSeen: Set<string> = new Set()\r\n\r\n        captures.forEach(c => {\r\n            let content = c.node.text\r\n            const startLine = c.node.startPosition.row\r\n            const endLine =  c.node.endPosition.row\r\n            // const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            const nodeIdenfier = `${c.name}#L${startLine}.${c.node.startPosition.column}|${endLine}.${c.node.endPosition.column}`\r\n            if (nodesSeen.has(nodeIdenfier)) return\r\n            nodesSeen.add(nodeIdenfier)\r\n            // console.log(c.name, content)\r\n            if ([\"identifier.name\", \"parameter_type\", \"return_type\"].includes(c.name)) {\r\n                for ( const c of cleanAndSplitContent(content)) {\r\n                    // Remove \"?\" for js\r\n                    // Remove \"$\" and change \"->\" to \".\" for php\r\n                    let callName = c.replace(/\\?/g, '').replace(/\\$/g, '').replace(/\\-\\>/g, '.')\r\n                    const calledNode = this.nodesMap[callName]\r\n                    // console.log({nodeRef: nodeRef.id, callName, id: calledNode?.id ?? ''})\r\n                    if (calledNode) {\r\n                        results.push(new CallIdentifier(calledNode.id, startLine))\r\n                    }\r\n                    if (callName.includes('.')) {\r\n                        const callNameSplit = callName.split('.')\r\n                        for ( let i = 2; i < callNameSplit.length; i++) {\r\n                            const calledNode =  this.nodesMap[callNameSplit.slice(0, i).join('.')]\r\n                            if (calledNode) {\r\n                                results.push(new CallIdentifier(calledNode.id, startLine))\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        })\r\n        return results\r\n    }\r\n\r\n    getCallsFromNode(node: Node) : {[key: string]: number[]} {\r\n        // console.log(`///${node.name}///`)\r\n        let code  = Object.keys(node.children).length > 0 ? node.getCodeWithoutBody(true, true) : node.code\r\n        const nameAliasReplacements: { [key: string]: string }  = {}\r\n        Object.values(this.fileNode.importStatements).forEach(i  =>  {\r\n\r\n            if (i.names.length === 0) {\r\n                let moduleAlias = i.moduleAlias\r\n                let module = i.module\r\n                if (['php'].includes(node.language)) {\r\n                    moduleAlias = moduleAlias.replace(/\\./g, '->')\r\n                    module = module.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[moduleAlias] = module\r\n            }\r\n            for (const importName of i.names) {\r\n                let nameAlias = importName.alias\r\n                let name = importName.name\r\n                if (['php'].includes(node.language)) {\r\n                    nameAlias = nameAlias.replace(/\\./g, '->')\r\n                    name = name.replace(/\\./g, '->')\r\n                }\r\n                nameAliasReplacements[nameAlias] = name\r\n            }\r\n        })\r\n        // Replace itself calls by the parent if its a method\r\n        if (node.type === 'method') {\r\n            const itself = itselfClassMap[node.language]\r\n            const parentName = node.parent?.name || itself\r\n            nameAliasReplacements[itself] = parentName\r\n            // this solves a bug\r\n            if (['javascript', 'typescript', 'tsx'].includes(node.language)) code = `function ${code}`\r\n        }\r\n\r\n        // 1. Replace import names with aliases\r\n        Object.entries(nameAliasReplacements).forEach(([k, v]) => {\r\n            const leftPattern = new RegExp(`(^|\\\\W)${k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            code = code.replace(leftPattern, (match, p1) => p1 + v);\r\n        });\r\n\r\n        // 2. Get Assignments\r\n        const varReplacements = this.captureAssignments(code, node.language)\r\n        const codeLines = code.split('\\n')\r\n        const lenCodeLines = codeLines.length\r\n\r\n        // 3. Replace variable Assignments\r\n        varReplacements.forEach(v  =>  {\r\n            const startLine = v.startLine\r\n            const endLine  = v.endLine\r\n            const leftPattern = new RegExp(`(^|\\\\W)${v.left.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'g');\r\n            let i = 0\r\n            try {\r\n                for (i = startLine; i < Math.min(endLine + 1, lenCodeLines); i++) {\r\n                    codeLines[i] = codeLines[i].replace(leftPattern, (match, p1) => p1 + v.right);\r\n                }\r\n            } catch (error: any) {\r\n                if (this.verbose) {\r\n                    console.log(`Error in line ${i} (${v.left.slice(0,20)}, ${v.right.slice(0,20)})}): ${error.message}`)\r\n                }\r\n            }\r\n\r\n        })\r\n        code = codeLines.join('\\n')\r\n        const capturedCalls = this.captureCalls(code, node)\r\n        const results: {[key: string]: number[]} = {}\r\n        capturedCalls.forEach(c  =>  {\r\n            if (!Object.keys(results).includes(c.nodeId)) {\r\n                results[c.nodeId] = []\r\n            } \r\n            results[c.nodeId].push(c.line)\r\n        })\r\n        return results\r\n    }\r\n}",
    "codeNoBody": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\r\nimport { Node, ImportStatement} from \"./codebase\"\r\nimport { itselfClassMap } from \"./consts\"\r\nclass VariableAssignment {\n//...\n}\r\n\r\nclass CallIdentifier {\n//...\n}\r\n\r\nexport class CallsCapturer {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\calls.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/model/calls.ts` - Wiki\n\n## Overview\nThe `calls.ts` file in the `src/model` directory is a critical component of the codebase that focuses on capturing and managing function calls and variable assignments within a given file node. It provides classes and utilities to identify and track these elements, facilitating the analysis and representation of code structure and dependencies.\n\n## Main Features\n\n### Classes\n\n#### `VariableAssignment`\n- **Purpose**: This class is designed to encapsulate information about variable assignments within the code. Although the detailed implementation is not provided, it is likely used to store and manage data related to variable assignments.\n\n#### `CallIdentifier`\n- **Purpose**: This class is used to create instances that uniquely identify a function call within the codebase.\n- **Constructor**: \n  - `nodeId`: A string representing the unique identifier of a node.\n  - `line`: A number representing the line number where the call is made, defaulting to 0 if not provided.\n- **Usage**: Instances of this class help in tracking and identifying calls within the code, making it easier to analyze and manage code dependencies.\n\n#### `CallsCapturer`\n- **Purpose**: This is the primary class in the file, responsible for capturing and managing function calls and variable assignments from a given file node.\n- **Constructor**:\n  - `fileNode`: The node representing the file from which calls and assignments are to be captured.\n  - `verbose`: A boolean flag for enabling verbose logging or output.\n- **Methods**:\n  - **capture assignments**: Captures variable assignments within the file node.\n  - **capture calls**: Identifies and captures function calls within the file node.\n  - **get calls from a specific node**: Retrieves calls from a specific node, returning arrays of `VariableAssignment` and `CallIdentifier` instances, and a dictionary of call identifiers.\n\n### Imports\n- **Utilities**: \n  - `cleanAndSplitContent`\n  - `captureQuery`\n- **Classes**:\n  - `Node`\n  - `ImportStatement`\n- **Constants**:\n  - `itselfClassMap`\n\nThese imports suggest that the file relies on various utilities and constants to perform its operations, such as cleaning and splitting content, capturing queries, and using predefined mappings.\n\n## Important Definitions\n- **Node**: Represents a node in the codebase, likely used to structure and navigate the code.\n- **ImportStatement**: Represents import statements within the code, which are crucial for understanding dependencies.\n- **itselfClassMap**: A constant that might be used to map classes to themselves, possibly for identification or categorization purposes.\n\n## Purpose\nThe primary purpose of `calls.ts` is to provide a structured way to capture and manage function calls and variable assignments within a codebase. By doing so, it enables better analysis and understanding of code dependencies, structure, and behavior. This functionality is essential for tasks such as code analysis, refactoring, and documentation.\n\nIn summary, `calls.ts` is a vital part of the codebase that helps in identifying and managing key elements of the code, facilitating a deeper understanding and more efficient handling of the code structure.",
    "importStatements": "import { cleanAndSplitContent, captureQuery } from \"./utils\"\nimport { Node, ImportStatement} from \"./codebase\"\nimport { itselfClassMap } from \"./consts\""
  },
  {
    "id": "71077495-61ed-4b10-923a-5ac2122d7e3d",
    "fullName": "\\src\\model\\codebase::Codebase.resolveHeaderC",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.inDegree++\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveHeaderC(fileNode: Node, headerNode: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveHeaderC",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"resolveHeaderC\" in the \"Codebase\" class takes in a \"fileNode\" and a \"headerNode\" of type Node, where the \"headerNode\" represents a header file with a language attribute of 'c' or 'cpp'. If the headerNode is not of type 'header' or the language is not 'c' or 'cpp', the method returns early. It then retrieves the child ids from the headerNode, finds the corresponding nodes in the fileNode, removes them from the nodesMap, and adds them back to the headerNode without changing the parent, incrementing the inDegree property for each added node.",
    "importStatements": ""
  },
  {
    "id": "5d741c33-ab5a-4371-9ade-014919726582",
    "fullName": "\\src\\model\\codebase::Codebase.resolveImportStatementsNodes",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveImportStatementsNodes() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveImportStatementsNodes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Codebase.resolveImportStatementsNodes` method iterates over the nodes in the codebase, identifies import statements in files or headers, resolves the imported names by mapping them to corresponding nodes, handles different import scenarios like wildcard imports or module imports, and resolves header files for C and C++ languages. If an import statement has no specific names, it retrieves all relevant children nodes like files, classes, interfaces, mods, namespaces, or headers and adds them as import names. This method leverages the `ImportName` class to represent import statements with names, aliases, and contextual nodes.",
    "importStatements": ""
  },
  {
    "id": "8277a9d7-7ce5-4808-a912-e7e40157810e",
    "fullName": "\\src\\model\\codebase::Codebase.resolvePythonInitImportStatements",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolvePythonInitImportStatements() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolvePythonInitImportStatements",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method Codebase.resolvePythonInitImportStatements iterates through all nodes in the codebase, filters out Python files, and updates their import statements by resolving any references to \"__init__.py\" files. If an import statement path ends with \"__init__\", it removes the statement from the current node and appends the import statements from the referenced \"__init__.py\" file.",
    "importStatements": ""
  },
  {
    "id": "991885a8-a256-45a4-a25b-3598ab17a58e",
    "fullName": "\\src\\model\\codebase::Codebase.getLinks",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = 'defines'\r\n        links.push({ source: n.parent.id, target: n.id, label, line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({ source: n.id, target: c.node.id, label: 'calls', line: c.lines[0] + 1 })\r\n        )\r\n    }\r\n    return links\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getLinks(): Link[] {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getLinks",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `getLinks` method in the `Codebase` class retrieves an array of links between nodes based on their relationships within the codebase structure. It iterates through the nodes, creating links for parent-child relationships with a label of 'defines' and for method calls with a label of 'calls'. The links include the source node ID, target node ID, label, and line number where the relationship occurs.",
    "importStatements": ""
  },
  {
    "id": "0e3cdf29-643a-4893-8ed6-c964f05c17ca",
    "fullName": "\\src\\model\\codebase::Codebase.simplify",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes))\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.simplify",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Codebase.simplify` method in the `Codebase` class takes an optional array of attributes as parameters and simplifies the codebase by returning an array of simplified nodes based on the provided attributes. It iterates over the nodes in the `nodesMap` and calls the `simplify` method on each node, passing the provided attributes to filter the node's properties. This method is useful for reducing the complexity of the codebase structure by focusing on specific attributes of the nodes.",
    "importStatements": ""
  },
  {
    "id": "4fcba6b1-cf9c-431b-8ecb-cea248244600",
    "fullName": "\\src\\model\\codebase::Codebase.getCalls",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getCalls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Codebase.getCalls\" in the \"\\src\\model\\codebase\" file iterates over the provided fileNodesMap, capturing calls from each node using a CallsCapturer instance. It then adds these calls to the corresponding nodes in the codebase, considering the verbose flag to log details if enabled. The method utilizes the Node class to manage nodes within the codebase, handling attributes, relationships, and calls, while the Codebase class manages the overall codebase structure, including node manipulation, import resolution, and file parsing functionalities.",
    "importStatements": ""
  },
  {
    "id": "2313ceb9-4435-4b85-97c9-ab30fd1539ee",
    "fullName": "\\src\\model\\codebase::Codebase.parseFolder",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    async parseFolder(): Promise<{ [id: string]: Node }> {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.parseFolder",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Codebase.parseFolder` method in the \"Codebase\" class parses all files in the specified root folder path, generating nodes for each file, resolving import statements, handling Python special cases, and returning a map of file nodes indexed by their IDs. The method iterates through all files, generates nodes, resolves import statements, and handles errors if any occur during the parsing process.",
    "importStatements": ""
  },
  {
    "id": "0fadc3c7-0fd0-41e4-9494-529586be0122",
    "fullName": "\\src\\model\\codebase::Codebase.resolveSpaces",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].inDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    resolveSpaces() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.resolveSpaces",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Codebase.resolveSpaces\" method iterates through each space in the codebase, creating a global node for each space that consolidates the nodes within it. It updates the nodes' ids, parent relationships, and code content, merging children nodes into the global node while maintaining the parent-child hierarchy. Additionally, it updates the codebase's space map to reflect the changes made during the space resolution process.",
    "importStatements": ""
  },
  {
    "id": "78711076-5008-4e45-8589-ed12a3eb48a7",
    "fullName": "\\src\\model\\codebase::Codebase.generateNodesFromFilePath",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.generateNodesFromFilePath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method \"Codebase.generateNodesFromFilePath\" in the codebase structure creates nodes representing code files or headers using the provided file path. It reads the file, generates a node with an id, code, type, and language based on the file extension, handles special cases for header files, and populates the nodes map. It calculates the total tokens for each node, identifies and adds space nodes, and performs additional parsing tasks like generating imports and parsing export clauses. The method returns an object containing the nodes map and a boolean indicating if the file is a header.",
    "importStatements": ""
  },
  {
    "id": "19de7d83-140b-4cd1-958f-f3aaaec62326",
    "fullName": "\\src\\model\\codebase::Codebase.addNodeToSpaceMap",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNodeToSpaceMap(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNodeToSpaceMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method Codebase.addNodeToSpaceMap takes a Node object as a parameter and adds it to the spaceMap property of the Codebase class. If the node's name does not exist in the spaceMap, a new array is created for that name. The method then appends the node to the corresponding array in the spaceMap based on the node's name.",
    "importStatements": ""
  },
  {
    "id": "fdf78afe-9e77-4bc8-8a27-8ee244b589c0",
    "fullName": "\\src\\model\\codebase::Codebase.addNodeMap",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNodeMap(nodeMap: { [id: string]: Node }) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNodeMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `addNodeMap` method in the `Codebase` class adds multiple nodes to the existing nodes map of the codebase. It takes a parameter `nodeMap` containing nodes with unique IDs as keys and `Node` objects as values. By spreading the existing `nodesMap` and the new `nodeMap`, the method merges the nodes into the codebase, updating or adding new nodes. This functionality allows for efficient management and manipulation of nodes within the codebase structure.",
    "importStatements": ""
  },
  {
    "id": "bb5981c3-e2f5-41bb-905f-69fb62600199",
    "fullName": "\\src\\model\\codebase::Codebase.getNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    getNode(id: string): Node | undefined {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.getNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The method Codebase.getNode takes a string parameter representing the id of a node in the codebase and returns the corresponding Node object if found in the nodesMap property of the Codebase instance; otherwise, it returns undefined. The Node class represents a node in the codebase with various properties and functionalities for managing relationships, imports, and attributes. The Codebase class manages the codebase structure, including features for manipulating nodes and spaces, resolving imports, and handling header files.",
    "importStatements": ""
  },
  {
    "id": "b6b2a6cb-9203-4f8c-95db-94b268d016d0",
    "fullName": "\\src\\model\\codebase::Codebase.addNode",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    addNode(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.addNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Codebase.addNode` method takes a `Node` object as a parameter and adds it to the `nodesMap` property of the `Codebase` class, using the node's `id` as the key. This method is part of the `Codebase` class, which manages a codebase structure by handling nodes, spaces, and various codebase-related operations. The `Node` class represents a node in the codebase with properties like id, type, name, code, and documentation, and provides methods to manipulate node relationships, imports, and attributes.",
    "importStatements": ""
  },
  {
    "id": "ec5d45d9-2547-49a6-b081-35f315980de8",
    "fullName": "\\src\\model\\codebase::Codebase.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }",
    "codeNoBody": "class Codebase\n    ...\n    constructor(rootFolderPath: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Codebase.constructor` method initializes the root folder path for the codebase structure, allowing access to features like managing nodes, spaces, resolving import statements, handling Python init imports, and header files. Other methods within the class such as `addNode`, `getNode`, `addNodeMap`, and `addNodeToSpaceMap` are utilized to manipulate nodes and spaces within the codebase, along with functionalities for generating nodes from file paths, parsing folders, extracting calls, simplifying attributes, retrieving links, and resolving spaces.",
    "importStatements": ""
  },
  {
    "id": "bec7b3b5-10ae-49d0-82fe-813aa30e33b5",
    "fullName": "\\src\\model\\codebase::Codebase",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].inDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = 'defines'\r\n        links.push({ source: n.parent.id, target: n.id, label, line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({ source: n.id, target: c.node.id, label: 'calls', line: c.lines[0] + 1 })\r\n        )\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.inDegree++\r\n      }\r\n    })\r\n  }\r\n}",
    "codeNoBody": "class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\n      //...\n  }\r\n  getNode(id: string): Node | undefined {\n      //...\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\n      //...\n  }\r\n  addNodeToSpaceMap(node: Node) {\n      //...\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\n      //...\n  }\r\n\r\n  resolveSpaces() {\n      //...\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\n      //...\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n\r\n  getLinks(): Link[] {\n      //...\n  }\r\n\r\n  resolvePythonInitImportStatements() {\n      //...\n  }\r\n\r\n  resolveImportStatementsNodes() {\n      //...\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\n      //...\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Codebase",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The class \"Codebase\" represents a codebase structure with features such as managing nodes, spaces, generating nodes from file paths, resolving spaces, parsing folders, extracting calls, simplifying attributes, retrieving links, resolving Python import statements, and handling header files. The constructor initializes the root folder path, and methods like addNode, getNode, addNodeMap, addNodeToSpaceMap, and others are used to manipulate nodes and spaces within the codebase. The class also provides functionalities to resolve import statements, handle Python init imports, and resolve header files.",
    "importStatements": ""
  },
  {
    "id": "39b2cffc-002d-4e8e-94d9-6cd10d401a57",
    "fullName": "\\src\\model\\codebase::Node.simplify",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }",
    "codeNoBody": "class Node\n    ...\n    simplify(attributes: string[] = []) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.simplify",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Node.simplify` method in the \"Node\" class simplifies the node's attributes by returning a subset of attributes specified in the `attributes` parameter or all attributes if no specific attributes are provided. The method constructs an object containing various properties of the node such as id, type, name, code, and documentation, among others. If `attributes` is empty, it returns all attributes; otherwise, it filters and returns only the specified attributes.",
    "importStatements": ""
  },
  {
    "id": "d9cac777-a46a-49e4-bdea-a029f1747cc0",
    "fullName": "\\src\\model\\codebase::Node.getChildrenDefinitions",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getChildrenDefinitions(): { [id: string]: Node } {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getChildrenDefinitions",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Node.getChildrenDefinitions\" method in the \"Node\" class analyzes the node's code to extract child nodes' definitions, considering the node's type and language. It iterates through captured queries, creates new nodes based on specific criteria, sets positions, handles decorators, and adjusts code based on the language. The method identifies modifiers, names, aliases, documentation, and bodies for each child node, ensuring proper formatting and content extraction. It also manages assignments, filters nodes without names, identifies package or namespace declarations, establishes relationships between nodes, and constructs a map of child nodes by their IDs for further processing.",
    "importStatements": ""
  },
  {
    "id": "59b86022-0482-4b7b-a854-3ca6aeefdc00",
    "fullName": "\\src\\model\\codebase::Node.resolveImportStatementsPath",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Node\n    ...\n    resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.resolveImportStatementsPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Node.resolveImportStatementsPath` method in the \"Node\" class resolves import statements' paths by checking possible file paths based on the root folder path and all files in the codebase. It handles different scenarios by considering index files, language-specific suffixes, and various import statement configurations. The method iterates over import statements, constructs possible paths, and updates the import statement path if a matching file path is found. Additionally, it handles special cases where import paths start with '@/'.",
    "importStatements": ""
  },
  {
    "id": "4dd09a1a-9357-41f3-9396-0dc0c23f6ef5",
    "fullName": "\\src\\model\\codebase::Node.parseExportClauses",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }",
    "codeNoBody": "class Node\n    ...\n    parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.parseExportClauses",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.parseExportClauses\" method in the \"Node\" class parses export clauses in JavaScript and TypeScript code, handling the extraction of export statements, module names, aliases, and names. It updates the codebase and file node maps accordingly, allowing for the correct resolution of imports and calls within the codebase. The method identifies exported nodes, assigns aliases if present, and manages the exportation of nodes within the same file or from external modules.",
    "importStatements": ""
  },
  {
    "id": "28fc0eea-5b12-4454-8165-2e925f4716d1",
    "fullName": "\\src\\model\\codebase::Node.generateImports",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }",
    "codeNoBody": "class Node\n    ...\n    generateImports() {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.generateImports",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.generateImports\" method in the codebase-index-ts repository is used to extract import statements from a file node's code. It sorts captured import statements based on their positions, processes each import statement's module, name, and alias, and generates ImportStatement objects with ImportName objects for each import. The method handles module aliases, paths, and code trimming, populates importStatements array with the generated ImportStatement objects, and assigns it to the node.",
    "importStatements": ""
  },
  {
    "id": "bbffc1aa-120d-47dc-9742-709964cdb9f6",
    "fullName": "\\src\\model\\codebase::Node.getCodeWithoutBody",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getCodeWithoutBody",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "This method in the \"Node\" class, getCodeWithoutBody, takes two optional parameters: considerLines and excludeAssignmentsFile. It removes the body of the current node from its code while preserving the structure, handling different languages' syntax accordingly. It also skips specific nodes based on their type and properties, such as assignments or specific methods. Additionally, it considers the parent node's body if it is a class or interface, appending the modified code appropriately.",
    "importStatements": ""
  },
  {
    "id": "222f2d1b-74ca-447d-88a6-2a309b779d58",
    "fullName": "\\src\\model\\codebase::Node.addNodeRelationship",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addNodeRelationship(node: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addNodeRelationship",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `addNodeRelationship` method in the `Node` class is used to establish a relationship between nodes by adding a child node if certain conditions are met. It checks if the provided node is within the current node, handles export clauses, updates documentation, and modifies node types accordingly. Additionally, it adjusts the node's name and ID based on the relationship type and structure.",
    "importStatements": ""
  },
  {
    "id": "e1a6c99e-1eeb-4dc3-a1dc-a00bbcc3ba6c",
    "fullName": "\\src\\model\\codebase::Node.isWithin",
    "type": "method",
    "language": "typescript",
    "documentation": "// Checks if this node is within another node\r",
    "code": "class Node\n    ...\n    isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }",
    "codeNoBody": "class Node\n    ...\n    isWithin(node: Node): boolean {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.isWithin",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.isWithin\" method in the Node class checks if the current node is within the boundaries of the provided node by comparing their start and end row positions. This method returns a boolean value indicating whether the current node's start row is greater than or equal to the provided node's start row and its end row is less than or equal to the provided node's end row, determining if the current node is contained within the specified node.",
    "importStatements": ""
  },
  {
    "id": "6567d01d-e56e-4f3c-8f94-08e69eea7d81",
    "fullName": "\\src\\model\\codebase::Node.addImportStatement",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addImportStatement(importStatement: ImportStatement) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addImportStatement",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.addImportStatement\" method adds an import statement to the node's list of import statements. It takes an instance of the \"ImportStatement\" class as a parameter, representing an import statement with a module, an array of ImportName objects, a module alias, a path, and optional code. The method pushes the provided import statement to the node's importStatements array, allowing the node to manage its imports effectively within the codebase.",
    "importStatements": ""
  },
  {
    "id": "f326177c-6931-48b3-855c-ac2fdf83f0e0",
    "fullName": "\\src\\model\\codebase::Node.addCall",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addCall(node: Node, lines: number[] = []) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addCall",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node.addCall\" method in the \"Node\" class adds a call to another node, incrementing the outDegree of the current node and the inDegree of the called node. The method takes a \"node\" parameter representing the node being called and an optional \"lines\" parameter indicating the lines of code where the call occurs.",
    "importStatements": ""
  },
  {
    "id": "36360a23-74ce-45c8-9653-bde96d5d81ab",
    "fullName": "\\src\\model\\codebase::Node.removeChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }",
    "codeNoBody": "class Node\n    ...\n    removeChild(child: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.removeChild",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"\\src\\model\\codebase::Node.removeChild\" method in the Node class removes a child node from the parent node by taking the child node as a parameter. It checks if the child node exists in the parent's children collection, then deletes it, updates the inDegree and outDegree properties, and sets the child's parent to undefined.",
    "importStatements": ""
  },
  {
    "id": "a3f827e6-8c2a-4ccd-8a88-c92463582a1c",
    "fullName": "\\src\\model\\codebase::Node.addChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.inDegree++\r\n    child.outDegree++\r\n  }",
    "codeNoBody": "class Node\n    ...\n    addChild(child: Node) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.addChild",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "Adds a child node to the current node in the codebase. The method takes a \"child\" parameter of type Node, which is then added to the children property of the current node using the child's id as the key. Additionally, the parent-child relationship is established by setting the child's parent to be the current node. The inDegree and outDegree properties of both nodes are incremented to maintain the graph structure.",
    "importStatements": ""
  },
  {
    "id": "89d897c9-2ead-4548-b25d-1a21410cf161",
    "fullName": "\\src\\model\\codebase::Node.getAllChildren",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getAllChildren",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `getAllChildren` method in the `Node` class retrieves all children nodes recursively, considering optional parent types to filter the results. It iterates through the current node's children, adding them to the result array and calling `getAllChildren` on each child to include their descendants. If `parentTypes` are provided, only children with types included in the `parentTypes` array are returned.",
    "importStatements": ""
  },
  {
    "id": "22e7fd8a-c8cb-41b6-93ac-fcca3a16ab48",
    "fullName": "\\src\\model\\codebase::Node.getChild",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }",
    "codeNoBody": "class Node\n    ...\n    getChild(childId: string): Node | undefined {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.getChild",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Node.getChild` method in the \"Node\" class recursively searches for a child node by its id within the node's children. If the child with the specified id is found and it is a file, the method returns the child node. If the current node is a file but the child is not found, it iterates over all children nodes to search for the child node. This method is used to navigate the node tree structure and retrieve specific child nodes based on their ids.",
    "importStatements": ""
  },
  {
    "id": "1d90c4dc-1680-4ac8-804e-ada46f15afe9",
    "fullName": "\\src\\model\\codebase::Node.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }",
    "codeNoBody": "class Node\n    ...\n    constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `Node.constructor` method initializes a node in the codebase with an id, code, type, and language, setting default values if not provided. The `id` parameter is required, while `code`, `type`, and `language` are optional and default to an empty string, 'function', and 'js' respectively. This method is part of the \"Node\" class that manages properties like id, type, name, code, and documentation, as well as relationships, imports, and exports within the codebase.",
    "importStatements": ""
  },
  {
    "id": "2d4116ec-6e88-4a5f-b71f-d279de501d04",
    "fullName": "\\src\\model\\codebase::Node",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.inDegree++\r\n    child.outDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}",
    "codeNoBody": "class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\n      //...\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\n      //...\n  }\r\n\r\n  addChild(child: Node) {\n      //...\n  }\r\n\r\n  removeChild(child: Node) {\n      //...\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\n      //...\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\n      //...\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\n      //...\n  }\r\n\r\n  addNodeRelationship(node: Node) {\n      //...\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\n      //...\n  }\r\n\r\n  generateImports() {\n      //...\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\n      //...\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\n      //...\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\n      //...\n  }\r\n\r\n  simplify(attributes: string[] = []) {\n      //...\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Node",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"Node\" class represents a node in the codebase with properties like id, type, name, code, and documentation. It can have parent and children nodes, manage imports, relationships, and export clauses, and calculate degrees. The class provides methods to add, remove, and get children, handle calls and import statements, check node containment, and simplify attributes. The constructor initializes the node with an id, code, type, and language.",
    "importStatements": ""
  },
  {
    "id": "d387c97b-f613-4bfe-960b-8e3dcb3a41ae",
    "fullName": "\\src\\model\\codebase::NodeCallTuple",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r",
    "codeNoBody": "type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "NodeCallTuple",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "Code: type NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r",
    "importStatements": ""
  },
  {
    "id": "1f61ac32-c2ae-4c3c-bcc3-018c650074ef",
    "fullName": "\\src\\model\\codebase::Link",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}",
    "codeNoBody": "interface Link {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Link",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "Interface \"Link\" defines a data structure with properties for the source and target nodes, a label, and a line number, representing a connection between nodes in a graph or network.",
    "importStatements": ""
  },
  {
    "id": "c183c7ce-5eb0-4483-a162-a62e32c9a7ad",
    "fullName": "\\src\\model\\codebase::ImportStatement.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }",
    "codeNoBody": "class ImportStatement\n    ...\n    constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportStatement.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The ImportStatement constructor initializes a new import statement with a module, an array of ImportName objects representing names and aliases, a path, an optional module alias (defaults to the module if not provided), and optional code. The constructor sets the module, names, path, module alias, and code properties based on the provided parameters. Each ImportName object includes a name, an optional alias (defaults to the name if not specified), and a node property for additional context.",
    "importStatements": ""
  },
  {
    "id": "441a8f60-c044-4c4b-b595-5a568cf7b82e",
    "fullName": "\\src\\model\\codebase::ImportStatement",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
    "codeNoBody": "class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportStatement",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"ImportStatement\" class represents an import statement with a module, an array of ImportName objects, a module alias, a path, and optional code. The constructor initializes the module, names, path, module alias (defaults to module if not provided), and code properties. The ImportName class defines an import statement with a name and optional alias, where the alias defaults to the name if not specified.",
    "importStatements": ""
  },
  {
    "id": "720b44e5-7bac-4f5d-a7a1-0eccb9e9710e",
    "fullName": "\\src\\model\\codebase::ImportName.constructor",
    "type": "method",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }",
    "codeNoBody": "class ImportName\n    ...\n    constructor(name: string, alias?: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportName.constructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The `ImportName.constructor` method initializes a new instance of the `ImportName` class with a primary `name` parameter representing the import statement's identifier and an optional `alias` parameter that defaults to the `name` if not provided. This method sets the `name` and `alias` properties of the `ImportName` instance accordingly.",
    "importStatements": ""
  },
  {
    "id": "0d836079-a9d6-4263-904c-48a415234b64",
    "fullName": "\\src\\model\\codebase::ImportName",
    "type": "class",
    "language": "typescript",
    "documentation": "",
    "code": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
    "codeNoBody": "class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ImportName",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "The \"ImportName\" class represents an import statement with a name and an optional alias, where the name is the primary identifier and the alias can be provided or defaults to the name if not specified. It includes a node property for additional context.",
    "importStatements": ""
  },
  {
    "id": "92c8ef68-da5e-4a74-802e-0786317b6664",
    "fullName": "\\src\\model\\codebase::const",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const enc = encoding_for_model('gpt-4-turbo')",
    "codeNoBody": "const enc = encoding_for_model('gpt-4-turbo')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "const",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "generatedDocumentation": "Code: const enc = encoding_for_model('gpt-4-turbo')",
    "importStatements": ""
  },
  {
    "id": "2c0883b0-bcae-4df9-b687-400de686fcb5",
    "fullName": "\\src\\model\\codebase",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\n\r\nexport class ImportName {\r\n  name: string = ''\r\n  alias: string = ''\r\n  node?: Node\r\n  // subpath: string = ''\r\n\r\n  constructor(name: string, alias?: string) {\r\n    this.name = name\r\n    this.alias = alias || name\r\n  }\r\n}\r\nexport class ImportStatement {\r\n  module: string\r\n  names: ImportName[]\r\n  moduleAlias: string\r\n  path: string\r\n  code?: string\r\n\r\n  constructor(\r\n    module: string = '',\r\n    names: ImportName[] = [],\r\n    path: string = '',\r\n    moduleAlias?: string,\r\n    code?: string\r\n  ) {\r\n    this.module = module\r\n    this.names = names\r\n    this.moduleAlias = moduleAlias || module\r\n    this.path = path\r\n    this.code = code\r\n  }\r\n}\r\n\r\ninterface Link {\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line: number\r\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\r\n  id: string = '' // id is like /home/user/repo/file.extension::nodeName\r\n  type: AllowedTypes = 'function'\r\n  name: string = ''\r\n  alias: string = ''\r\n  language: string = ''\r\n  importStatements: ImportStatement[] = [] // only for files\r\n  totalTokens: number = 0\r\n  documentation: string = ''\r\n  code: string = ''\r\n  body: string = ''\r\n  exportable: boolean = false\r\n  parent?: Node\r\n  children: { [key: string]: Node } = {}\r\n  calls: NodeCallTuple[] = []\r\n  startPosition: Point = { row: 0, column: 0 }\r\n  endPosition: Point = { row: 99999, column: 0 }\r\n  inDegree: number = 0\r\n  outDegree: number = 0\r\n  // originFile is the file where the node is defined\r\n  originFile: string = ''\r\n\r\n  constructor(id: string, code?: string, type?: AllowedTypes, language?: string) {\r\n    this.id = id\r\n    this.code = code || ''\r\n    this.type = type || 'function'\r\n    this.language = language || 'js'\r\n  }\r\n\r\n  getChild(childId: string): Node | undefined {\r\n    // recursive search over children, only if is a file\r\n    if (this.children[childId]) {\r\n      return this.children[childId]\r\n    } else if (this.type === 'file') {\r\n      for (const child of Object.values(this.children)) {\r\n        const result = child.getChild(childId)\r\n        if (result) return result\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  getAllChildren(parentTypes?: AllowedTypes[]): Node[] {\r\n    // get childrens recursively\r\n    const children: Node[] = []\r\n    if (parentTypes && !parentTypes.includes(this.type)) return []\r\n    for (const child of Object.values(this.children)) {\r\n      children.push(child)\r\n      children.push(...child.getAllChildren())\r\n    }\r\n    return children\r\n  }\r\n\r\n  addChild(child: Node) {\r\n    // child -> this\r\n    this.children[child.id] = child\r\n    child.parent = this\r\n    this.inDegree++\r\n    child.outDegree++\r\n  }\r\n\r\n  removeChild(child: Node) {\r\n    if (Object.keys(this.children).includes(child.id)) {\r\n      // child.parent = undefined\r\n      delete this.children[child.id]\r\n      this.inDegree--\r\n      child.outDegree--\r\n    }\r\n  }\r\n\r\n  addCall(node: Node, lines: number[] = []) {\r\n    // this -> node\r\n    this.calls.push({ node, lines })\r\n    node.inDegree++\r\n    this.outDegree++\r\n  }\r\n\r\n  addImportStatement(importStatement: ImportStatement) {\r\n    this.importStatements.push(importStatement)\r\n  }\r\n\r\n  // Checks if this node is within another node\r\n  isWithin(node: Node): boolean {\r\n    return (\r\n      this.startPosition.row >= node.startPosition.row &&\r\n      this.endPosition.row <= node.endPosition.row\r\n    )\r\n  }\r\n\r\n  addNodeRelationship(node: Node) {\r\n    // if (node.type === this.type && node.name === this.name) return\r\n    if (this.isWithin(node) && !this.parent) {\r\n      if (node.type === 'export') {\r\n        // in js, ts the export clause is parent\r\n        this.exportable = true\r\n        if (!this.documentation) this.documentation = node.documentation\r\n        return\r\n      }\r\n      if (this.type === 'export') return // export are not added as nodes\r\n\r\n      // const parentCode = node.code.replace(node.body, '')\r\n      // this.code = `${parentCode}\\n${this.code}`\r\n\r\n      // Case for py, js and ts\r\n      if (['class', 'interface'].includes(node.type) && this.type === 'function') {\r\n        this.type = 'method'\r\n        this.name = `${node.name}.${this.name}`\r\n        this.alias = this.name // methods has no alias\r\n      }\r\n      this.id = `${this.id.split('::')[0]}::${this.name}`\r\n      node.addChild(this)\r\n    }\r\n  }\r\n\r\n  getCodeWithoutBody(considerLines: boolean = false, excludeAssignmentsFile: boolean = false) {\r\n    let code = this.code\r\n\r\n    if (\r\n      (this.body || this.type === 'file') &&\r\n      !['assignment', 'type', 'enum'].includes(this.type)\r\n    ) {\r\n      if (Object.keys(this.children).length > 0) {\r\n        // const extension = this.id.split('::')[0].split('.').pop() || '';\r\n        const classMethodInit =\r\n          this.language !== 'java' ? newClassMethodsMap[this.language] : this.name\r\n        Object.values(this.children).forEach((n) => {\r\n          if (classMethodInit && this.type === 'class') {\r\n            // do not remove init methods\r\n            if (n.name?.endsWith(classMethodInit)) return\r\n\r\n            if (n.body) {\r\n              let bodyToRemove = n.body\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `\\n${spaces}    ...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  `{\\n${spaces}    //...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          } else if (this.type === 'file') {\r\n            const isAssignment = ['assignment', 'type', 'enum'].includes(n.type)\r\n            if (!excludeAssignmentsFile && isAssignment) {\r\n              return\r\n            }\r\n            let bodyToRemove = isAssignment ? n.code : n.body\r\n            if (bodyToRemove) {\r\n              bodyToRemove = bodyToRemove.replace(n.documentation, '')\r\n              let bodyTotalLines = considerLines ? bodyToRemove.split('\\n').length : 1\r\n              const spaces = ' '.repeat(n.startPosition.column)\r\n              if (this.language === 'python') {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `${n.alias} = `: '') + `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n                )\r\n              } else {\r\n                code = code.replace(\r\n                  bodyToRemove,\r\n                  (isAssignment ? `\\n${n.alias} = ...\\n` : `{\\n${spaces}//...\\n${spaces}}`) + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n                )\r\n              }\r\n            }\r\n          }\r\n        })\r\n      } else if (this.body) {\r\n        const spaces = ' '.repeat(this.startPosition.column)\r\n        let bodyTotalLines = considerLines ? this.body.split('\\n').length : 1\r\n        if (this.language === 'python') {\r\n          code = code.replace(\r\n            this.body,\r\n            `${spaces}...` + '\\n'.repeat(Math.max(bodyTotalLines - 1, 0))\r\n          )\r\n        } else {\r\n          code = code.replace(\r\n            this.body,\r\n            `{\\n${spaces}//...\\n${spaces}}` + '\\n'.repeat(Math.max(bodyTotalLines - 3, 0))\r\n          )\r\n        }\r\n      }\r\n    }\r\n    code = considerLines ? code : code.trim().replace(/\\n\\s*\\n/, '\\n')\r\n    if (this.parent && ['class', 'interface'].includes(this.parent?.type)) {\r\n      if (considerLines) {\r\n        const bodyTotalLines = considerLines ? this.parent.body.split('\\n').length : 1\r\n        code =\r\n          `${this.parent.code.replace(this.parent.body, '')}` +\r\n          '\\n'.repeat(Math.max(bodyTotalLines - 3, 0)) +\r\n          `\\n    ...\\n    ${code}`\r\n      } else {\r\n        code = `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${code}`\r\n      }\r\n    }\r\n    return code\r\n  }\r\n\r\n  generateImports() {\r\n    if (this.type !== 'file') return\r\n    const captures = captureQuery(this.language, 'importStatements', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    // console.log({ captures: captures.map(c => {return {name : c.name, text : c.node.text}}) })\r\n    const importStatements: ImportStatement[] = []\r\n    let newImportStatement = new ImportStatement()\r\n    let alias: string\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'module':\r\n          newImportStatement.module = c.node.text\r\n          break\r\n        case 'name':\r\n          const name = c.node.text\r\n          if (!alias) alias = name\r\n          const newImportName = new ImportName(name, alias)\r\n          newImportStatement.names.push(newImportName)\r\n          alias = ''\r\n          break\r\n        // case 'submodule':\r\n        //     break\r\n        // case 'wildcard':\r\n        //     break\r\n        case 'import_statement':\r\n          if (alias && newImportStatement.names.length === 0) {\r\n            newImportStatement.moduleAlias = alias\r\n            alias = ''\r\n          } else {\r\n            newImportStatement.moduleAlias = newImportStatement.module\r\n          }\r\n\r\n          newImportStatement.path = renameSource(this.id, newImportStatement.module, this.language)\r\n          newImportStatement.code = c.node.text.trimEnd()\r\n          // newImportStatement.startPosition = c.node.startPosition\r\n          // newImportStatement.endPosition = c.node.endPosition\r\n          importStatements.push(newImportStatement)\r\n          newImportStatement = new ImportStatement()\r\n          break\r\n      }\r\n    })\r\n    this.importStatements = importStatements.reverse()\r\n  }\r\n\r\n  parseExportClauses(codebaseNodesMap: { [id: string]: Node }, fileNodesMap: { [id: string]: Node }) {\r\n    // only js, ts have the \"export { ... }\" clause\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) return\r\n    const captures = captureQuery(this.language, 'exportClauses', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let name = ''\r\n    let alias = ''\r\n    let moduleName = this.id\r\n    let exportCode = ''\r\n    let node: Node\r\n    captures.forEach((c) => {\r\n      switch (c.name) {\r\n        case 'export_clause':\r\n          exportCode = c.node.text\r\n          if (node) node.code += `\\n\\n${exportCode}`\r\n          break\r\n        case 'module':\r\n          moduleName = path.join(this.id.split('/').slice(0, -1).join('/'), c.node.text)\r\n          break\r\n        case 'alias':\r\n          alias = c.node.text\r\n          break\r\n        case 'name':\r\n          name = c.node.text\r\n          // the name is imported\r\n          const importedName = this.importStatements.filter((i) =>\r\n            i.names.map((n) => n.alias).includes(name)\r\n          )[0]\r\n          if (importedName) moduleName = importedName.path\r\n          node = this.children[`${this.id}::${name}`] || codebaseNodesMap[`${moduleName}::${name}`]\r\n          if (node) {\r\n            node.exportable = true\r\n            node.alias = alias ? alias : name\r\n            // if the export clause includes an alias, then we have to update the id\r\n            // since this is used to resolve imports and get calls\r\n            delete fileNodesMap[node.id]\r\n            node.id = `${this.id}::${node.alias}`\r\n            const prevNode = this.children[node.id] || codebaseNodesMap[node.id]\r\n            const previousCode = prevNode ? `${prevNode.code}\\n\\n` : ''\r\n            node.code = `${previousCode}${node.code}`\r\n            fileNodesMap[node.id] = node\r\n\r\n            // the node is exported from the same file\r\n            if (moduleName === this.id) {\r\n              delete this.children[`${this.id}::${name}`]\r\n              this.children[node.id] = node\r\n              const childrenNodes = Object.values(node.children)\r\n              childrenNodes.forEach((n) => {\r\n                n.alias = n.name.replace(name, alias)\r\n                delete node.children[n.id]\r\n                n.id = `${this.id}::${n.alias}`\r\n                node.children[n.id] = n\r\n              })\r\n\r\n              // it's using export { ... } from 'file'\r\n            }\r\n            // } else {\r\n            //     node.exportable = true\r\n            //     node.alias = alias? alias : name\r\n            //     // add the node to the file node\r\n            //     node.id = `${this.id}::${node.alias}`\r\n            //     this.children[node.id] = node\r\n            // }\r\n          }\r\n        // else {\r\n        //     console.log(`Export clause ${name} not found in ${this.id}`)\r\n        // }\r\n      }\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsPath(rootFolderPath: string, allFiles: string[]) {\r\n    if (this.type !== 'file') return\r\n    // In some cases the import statement is related to index files such as index.ts or __init__.py\r\n    const suffix = indexSuffixesMap[this.language]\r\n    const fileSet = new Set(allFiles.map((p) => p.split('.').slice(0, -1).join('.')))\r\n\r\n    this.importStatements.forEach((importStatement) => {\r\n      const possiblePaths = [\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${rootFolderPath}/${importStatement.path}/${name.name}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}${suffix}`)\r\n        ),\r\n        ...importStatement.names.map((name) =>\r\n          path.resolve(`${importStatement.path}/${name.name}`)\r\n        ),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}${suffix}`),\r\n        path.resolve(`${rootFolderPath}/${importStatement.path}`),\r\n        path.resolve(`${importStatement.path}${suffix}`),\r\n        path.resolve(importStatement.path)\r\n      ]\r\n\r\n      for (const possiblePath of possiblePaths) {\r\n        if (fileSet.has(possiblePath)) {\r\n          importStatement.path = possiblePath\r\n          break\r\n        }\r\n      }\r\n\r\n      if (importStatement.path.startsWith('@/')) {\r\n        importStatement.path = path.join(rootFolderPath, importStatement.path.slice(2))\r\n      }\r\n    })\r\n  }\r\n\r\n  getChildrenDefinitions(): { [id: string]: Node } {\r\n    if (!['file', 'header'].includes(this.type)) return {}\r\n    const unnecessaryNodeTypes = ['export'] // exclude it from the analysis\r\n    const captures = captureQuery(this.language, 'constructorDefinitions', this.code)\r\n    captures.sort(\r\n      (a, b) =>\r\n        b.node.startPosition.row - a.node.startPosition.row ||\r\n        b.node.startPosition.column - a.node.startPosition.column\r\n    )\r\n    let exportable = ['python', 'php'].includes(this.language) ? true : false\r\n    let childrenNodes: Node[] = []\r\n\r\n    captures.forEach((c) => {\r\n      if (AllowedTypesArray.includes(c.name as AllowedTypes)) {\r\n        const newNode = new Node(this.id, c.node.text, c.name as AllowedTypes, this.language)\r\n\r\n        newNode.startPosition = c.node.startPosition\r\n        newNode.endPosition = c.node.endPosition\r\n        newNode.exportable = exportable\r\n        newNode.originFile = this.name\r\n\r\n        // In many languages the documentation is the prev sibling\r\n        let prevTreeSitterNode = c.node.previousNamedSibling\r\n        if (prevTreeSitterNode) {\r\n          // if the previous node is a comment and it's in the previous line\r\n          if (\r\n            treeSitterCommentTypes.includes(prevTreeSitterNode.type) &&\r\n            prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n          ) {\r\n            newNode.documentation = prevTreeSitterNode.text\r\n          }\r\n        }\r\n        childrenNodes.push(newNode)\r\n\r\n        // In python the decorator is the prev sibling\r\n        if (this.language === 'python') {\r\n          prevTreeSitterNode = c.node.previousSibling\r\n          if (prevTreeSitterNode) {\r\n            if (\r\n              ['decorator'].includes(prevTreeSitterNode.type) &&\r\n              prevTreeSitterNode.endPosition.row === newNode.startPosition.row - 1\r\n            ) {\r\n              // include the decorator\r\n              newNode.code = prevTreeSitterNode.text + '\\n' + newNode.code\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    childrenNodes.forEach((n) => {\r\n      // if (unnecessaryNodeTypes.includes(n.type)) return\r\n      let code = n.code\r\n      if (['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n        if (n.type === 'method') {\r\n          // Fix bug with methods\r\n          code = `function ${n.code}`\r\n          n.type = 'function'\r\n        } else if (n.type === 'assignment') code = `const ${n.code}`\r\n      } else if (['java'].includes(this.language)) {\r\n        if (n.type == 'function') {\r\n          const firstLine = code.split('(')[0]\r\n          const firstLineSplit = firstLine.split(' ')\r\n          // if has no return type, add void between modifier and name\r\n          if (firstLineSplit.length !== 3) {\r\n            code = code.replace(\r\n              firstLine,\r\n              `${firstLineSplit[0]} void ${firstLineSplit.slice(-1)[0]}`\r\n            )\r\n          }\r\n        }\r\n      }\r\n\r\n      let captures = captureQuery(this.language, 'definitionTemplate', code)\r\n      // console.log(`/////${n.type}, ${n.language}/////`)\r\n      // console.log(`${code}`)\r\n      // console.log('--------------')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 30), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures = cleanDefCaptures(captures, n.language === 'java' ? 'modifier' : 'name')\r\n      // console.log(captures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'modifier': // java, php only\r\n            if (['php', 'java'].includes(n.language) && c.node.text.includes('public'))\r\n              n.exportable = true\r\n            break\r\n          case 'name':\r\n            n.name = c.node.text\r\n            n.id = `${n.id}::${n.name}`\r\n            break\r\n          case 'alias':\r\n            n.alias = c.node.text\r\n            break\r\n          case 'documentation':\r\n            n.documentation = c.node.text\r\n            if (n.language === 'python') {\r\n              n.code = n.code.replace(n.documentation, '')\r\n              n.body = n.body.replace(n.documentation, '')\r\n            }\r\n            break\r\n          case 'body':\r\n            n.body = c.node.text\r\n            break\r\n        }\r\n      })\r\n      if (!n.alias) n.alias = n.name\r\n\r\n      if (n.type === 'assignment') {\r\n        const assignmentCaptures = captureQuery(\r\n          this.language,\r\n          'extraAssignmentCode',\r\n          this.code,\r\n          n.name\r\n        )\r\n        // console.log(assignmentCaptures.map(c => { return {name: c.name, text: c.node.text?.slice(0, 60), start: c.node.startPosition, end: c.node.endPosition } }))\r\n        assignmentCaptures.forEach((c) => {\r\n          if (c.name === 'code') n.code += '\\n' + c.node.text\r\n        })\r\n      }\r\n    })\r\n\r\n    // must have a name\r\n    childrenNodes = childrenNodes.filter((c) => c.name)\r\n\r\n    // find \"package\" or \"namespace\"\r\n    let spaceNode = null\r\n    if (['java', 'php'].includes(this.language)) {\r\n      const captures = captureQuery(this.language, 'spaceDeclaration', this.code)\r\n      captures.forEach((c) => {\r\n        switch (c.name) {\r\n          case 'spaceName':\r\n            const spaceName = c.node.text\r\n            const initialLine = c.node.startPosition.row\r\n            const type = 'java' == this.language ? 'package' : 'namespace'\r\n            spaceNode = new Node(\r\n              `${this.id}::${spaceName}`,\r\n              this.code.split('\\n').slice(initialLine, -1).join('\\n'),\r\n              type,\r\n              this.language\r\n            )\r\n            spaceNode.name = spaceName\r\n            spaceNode.alias = spaceName\r\n            spaceNode.exportable = true\r\n            break\r\n        }\r\n      })\r\n    }\r\n\r\n    if (spaceNode) childrenNodes.push(spaceNode)\r\n\r\n    childrenNodes.forEach((n, i) => {\r\n      for (let j = i + 1; j < childrenNodes.length; j++) {\r\n        n.addNodeRelationship(childrenNodes[j])\r\n        childrenNodes[j].addNodeRelationship(n)\r\n      }\r\n      if (!unnecessaryNodeTypes.includes(n.type) && !n.parent) this.addChild(n)\r\n    })\r\n\r\n    // childrenNodes.sort((a,b) => a.startPosition.row - b.startPosition.row || a.startPosition.column  - b.startPosition.column)\r\n    const nodesMap = childrenNodes.reduce<{ [id: string]: Node }>((map, n) => {\r\n      if (!unnecessaryNodeTypes.includes(n.type)) map[n.id] = n\r\n      return map\r\n    }, {})\r\n    return nodesMap\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    const allAttributes: { [key: string]: any } = {\r\n      id: this.id,\r\n      type: this.type,\r\n      name: this.name,\r\n      label: this.alias,\r\n      language: this.language,\r\n      exportable: this.exportable,\r\n      totalTokens: this.totalTokens,\r\n      documentation: this.documentation,\r\n      code:\r\n        this.parent && ['class', 'interface'].includes(this.parent?.type)\r\n          ? `${this.parent.code.replace(this.parent.body, '').trim()}\\n    ...\\n    ${this.code}`\r\n          : this.code,\r\n      codeNoBody: this.getCodeWithoutBody(),\r\n      importStatements: this.importStatements.map((i) => i.code),\r\n      parent: this.parent?.id,\r\n      children: Object.keys(this.children),\r\n      calls: this.calls.map((c) => c.node.id),\r\n      inDegree: this.inDegree,\r\n      outDegree: this.outDegree,\r\n      originFile: this.originFile\r\n    }\r\n\r\n    if (attributes.length === 0) {\r\n      return allAttributes\r\n    }\r\n\r\n    return attributes.reduce((acc: { [key: string]: any }, attr: string) => {\r\n      if (allAttributes.hasOwnProperty(attr)) {\r\n        acc[attr] = allAttributes[attr]\r\n      }\r\n      return acc\r\n    }, {})\r\n  }\r\n}\r\n\r\nexport class Codebase {\r\n  // NOTE: rootFolderPath should be an absolute path\r\n  rootFolderPath: string = ''\r\n  nodesMap: { [id: string]: Node } = {}\r\n  // an space can be defined in multiples files (for example namespaces in C#)\r\n  spaceMap: { [spaceName: string]: Node[] } = {}\r\n\r\n  constructor(rootFolderPath: string) {\r\n    this.rootFolderPath = rootFolderPath\r\n  }\r\n  addNode(node: Node) {\r\n    this.nodesMap[node.id] = node\r\n  }\r\n  getNode(id: string): Node | undefined {\r\n    return this.nodesMap[id]\r\n  }\r\n  addNodeMap(nodeMap: { [id: string]: Node }) {\r\n    this.nodesMap = { ...this.nodesMap, ...nodeMap }\r\n  }\r\n  addNodeToSpaceMap(node: Node) {\r\n    if (!this.spaceMap[node.name]) this.spaceMap[node.name] = []\r\n    this.spaceMap[node.name].push(node)\r\n  }\r\n\r\n  async generateNodesFromFilePath(\r\n    filePath: string\r\n  ): Promise<{ nodesMap: { [id: string]: Node }; isHeader: boolean }> {\r\n    const fileExtension = filePath.split('.').pop()\r\n    if (!fileExtension) return { nodesMap: {}, isHeader: false }\r\n    const data = await fs.readFile(filePath)\r\n    const dataString = Buffer.from(data).toString()\r\n    // Nodes are created using id, code, type, language. The id does not include the extension\r\n    const filePathNoExtension = filePath.split('.').slice(0, -1).join('.')\r\n\r\n    let fileNode\r\n    let isHeader = false\r\n    // Special case: .h files (headers)\r\n    if (fileExtension === 'h') {\r\n      fileNode = new Node(\r\n        `${filePathNoExtension}::header`,\r\n        dataString,\r\n        'header',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n      isHeader = true\r\n    } else {\r\n      fileNode = new Node(\r\n        filePathNoExtension,\r\n        dataString,\r\n        'file',\r\n        languageExtensionMap[fileExtension]\r\n      )\r\n    }\r\n    fileNode.name = filePath\r\n    fileNode.alias = filePath.split('/').pop() || ''\r\n    const nodesMap = fileNode.getChildrenDefinitions()\r\n    fileNode.generateImports()\r\n    fileNode.parseExportClauses(this.nodesMap, nodesMap)\r\n    nodesMap[fileNode.id] = fileNode\r\n\r\n    Object.values(nodesMap).forEach((n) => {\r\n      // get tokens\r\n      n.totalTokens = enc.encode(n.code, 'all', []).length\r\n      // save space nodes\r\n      if (['namespace', 'package', 'mod'].includes(n.type)) this.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    return { nodesMap, isHeader }\r\n  }\r\n\r\n  resolveSpaces() {\r\n    const globalSpaceMap: { [spaceName: string]: Node[] } = {}\r\n    Object.entries(this.spaceMap).forEach(([spaceName, nodes]) => {\r\n      const globalNode = new Node(`${spaceName}`, '', nodes[0].type, nodes[0].language)\r\n      globalNode.name = spaceName\r\n      globalNode.alias = spaceName\r\n      globalNode.parent = nodes[0].parent\r\n      // globalNode.originFile = nodes[0].originFile\r\n      nodes.forEach((n) => {\r\n        globalNode.code += n.code + '\\n\\n'\r\n        for (const c of n.getAllChildren()) {\r\n          const oldId = c.id\r\n          delete this.nodesMap[oldId]\r\n          c.id = `${spaceName}::${c.name}`\r\n          if (c.parent && ['file', 'package', 'mod', 'namespace'].includes(c.parent.type))\r\n            globalNode.addChild(c)\r\n\r\n          this.nodesMap[c.id] = c\r\n        }\r\n        if (n.parent) {\r\n          this.nodesMap[n.parent.id].removeChild(n)\r\n          // add it to parent without changing the parent\r\n          this.nodesMap[n.parent.id].children[globalNode.id] = globalNode\r\n          this.nodesMap[n.parent.id].inDegree++\r\n          delete this.nodesMap[n.id]\r\n          this.nodesMap[globalNode.id] = globalNode\r\n        }\r\n      })\r\n      globalSpaceMap[spaceName] = [globalNode]\r\n    })\r\n\r\n    this.spaceMap = globalSpaceMap\r\n  }\r\n\r\n  async parseFolder(): Promise<{ [id: string]: Node }> {\r\n    if (!this.rootFolderPath) return {}\r\n    const fileNodesMap: { [id: string]: Node } = {}\r\n    const allFiles = await getAllFiles(this.rootFolderPath)\r\n    for (const filePath of allFiles) {\r\n      // can't be forEach\r\n      let id = filePath.split('.').slice(0, -1).join('.')\r\n      try {\r\n        const { nodesMap, isHeader } = await this.generateNodesFromFilePath(filePath)\r\n        this.addNodeMap(nodesMap)\r\n        id = isHeader ? `${id}::header` : id\r\n        const fileNode = nodesMap[id]\r\n        fileNodesMap[id] = fileNode\r\n        fileNode.resolveImportStatementsPath(this.rootFolderPath, allFiles)\r\n      } catch (error: any) {\r\n        console.log(`Cannot parse file Id ${id}`)\r\n        console.log(error.message)\r\n        throw error\r\n      }\r\n    }\r\n    // python special case\r\n    this.resolvePythonInitImportStatements()\r\n    this.resolveSpaces()\r\n    this.resolveImportStatementsNodes()\r\n    return fileNodesMap\r\n  }\r\n\r\n  getCalls(fileNodesMap: { [id: string]: Node }, verbose: boolean = false) {\r\n    Object.keys(fileNodesMap).forEach((fileId) => {\r\n      const fileNode = fileNodesMap[fileId]\r\n      if (Object.values(fileNode.children).length === 0) {\r\n        if (verbose) console.log(`File ${fileId} has no children`)\r\n        return\r\n      }\r\n\r\n      const callsCapturer = new CallsCapturer(fileNode, verbose)\r\n      const nodes: Node[] = [fileNode, ...fileNode.getAllChildren()]\r\n      nodes.forEach((n: Node) => {\r\n        const callNodeIds = callsCapturer.getCallsFromNode(n)\r\n        // const importFromFailed: Set<string> = new Set()\r\n        // console.log( `### ${n.id}`)\r\n        // console.log(n.code)\r\n        // console.log(calls)\r\n        Object.entries(callNodeIds).forEach(([nodeId, lines]) => {\r\n          // if (importFromFailed.has(c.importFrom)) return\r\n          const calledNode = this.nodesMap[nodeId]\r\n          if (calledNode && !['package', 'mod', 'namespace'].includes(calledNode.type)) {\r\n            // console.log({calledNode: calledNode.id, type: calledNode.type})\r\n            n.addCall(calledNode, lines) // first line\r\n            // console.log(`Added call from ${n.id} to ${calledNode.id}`)\r\n          } else {\r\n            if (verbose)\r\n              console.log(\r\n                `Failed to add call for node ${n.id}: ${nodeId} (line ${lines}) not found`\r\n              )\r\n            // importFromFailed.add(c.importFrom)\r\n          }\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  simplify(attributes: string[] = []) {\r\n    return Object.values(this.nodesMap).map((n) => n.simplify(attributes))\r\n  }\r\n\r\n  getLinks(): Link[] {\r\n    const links: Link[] = []\r\n    const nodes = Object.values(this.nodesMap)\r\n    for (const n of nodes) {\r\n      if (n.parent) {\r\n        // const label = n.parent.type === 'file' ? `defines`: `from ${n.parent.type}`\r\n        const label = 'defines'\r\n        links.push({ source: n.parent.id, target: n.id, label, line: n.startPosition.row + 1 })\r\n      }\r\n      if (n.calls.length > 0)\r\n        n.calls.forEach((c) =>\r\n          links.push({ source: n.id, target: c.node.id, label: 'calls', line: c.lines[0] + 1 })\r\n        )\r\n    }\r\n    return links\r\n  }\r\n\r\n  resolvePythonInitImportStatements() {\r\n    // THIS IS A TEMPORARY FIX\r\n    // In many cases, the __init__.py file just contains the import statements for the other files\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (n.type !== 'file' || n.language !== 'python') return\r\n      let newImportStatements: ImportStatement[] = [...n.importStatements]\r\n      n.importStatements.forEach((i) => {\r\n        if (i.path.endsWith('__init__')) {\r\n          newImportStatements = newImportStatements.filter((s) => s.path != i.path)\r\n          newImportStatements = [...this.nodesMap[i.path].importStatements, ...newImportStatements]\r\n        }\r\n      })\r\n      n.importStatements = newImportStatements\r\n    })\r\n  }\r\n\r\n  resolveImportStatementsNodes() {\r\n    const nodes = Object.values(this.nodesMap)\r\n    nodes.forEach((n) => {\r\n      if (!['file', 'header'].includes(n.type)) return\r\n      n.importStatements.forEach((i) => {\r\n        i.names.forEach((n) => {\r\n          n.node = this.nodesMap[`${i.path}::${n.name}`] || this.nodesMap[`${i.module}::${n.name}`]\r\n        })\r\n        const namesIds = i.names.map((n) => n.node?.id || '')\r\n        namesIds.forEach((id) => {\r\n          this.nodesMap[id]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'package'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        })\r\n        if (['c', 'cpp'].includes(n.language)) {\r\n          const headerNode = this.nodesMap[i.path]\r\n          if (headerNode) {\r\n            this.resolveHeaderC(n, headerNode)\r\n          }\r\n        }\r\n        // cases like import *, #define \"file\", etc.\r\n        if (i.names.length === 0) {\r\n          this.nodesMap[i.path]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n          this.nodesMap[i.module]\r\n            ?.getAllChildren(['file', 'class', 'interface', 'mod', 'namespace', 'header'])\r\n            .forEach((c) => {\r\n              const newName = new ImportName(c.alias, c.alias)\r\n              newName.node = c\r\n              i.names.push(newName)\r\n            })\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  resolveHeaderC(fileNode: Node, headerNode: Node) {\r\n    if (headerNode.type !== 'header' || !['c', 'cpp'].includes(headerNode.language)) return\r\n    const childIds = headerNode.getAllChildren().map((c) => c.id)\r\n    childIds.forEach((id) => {\r\n      const nodeRef = fileNode.getAllChildren().find((c) => c.id === id.replace('::header', ''))\r\n      // nodeRef is the headerNode.children[id] but already defined\r\n      if (nodeRef) {\r\n        // remove that node\r\n        delete this.nodesMap[id]\r\n        headerNode.removeChild(headerNode.children[id])\r\n        // headerNode.addChild(nodeRef)\r\n        // add it to headerNode without changing the parent\r\n        headerNode.children[nodeRef.id] = nodeRef\r\n        headerNode.inDegree++\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "codeNoBody": "import fs from 'node:fs/promises'\r\nimport { Point } from 'tree-sitter'\r\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\r\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\r\nimport { CallsCapturer } from './calls'\r\nimport path from 'path'\r\nimport { encoding_for_model } from 'tiktoken'\r\nconst enc = encoding_for_model('gpt-4-turbo')\r\nexport class ImportName {\n       //...\n       }\r\nexport class ImportStatement {\n       //...\n       }\r\n\r\ninterface Link {\n//...\n}\r\n\r\ntype NodeCallTuple = { node: Node; lines: number[] } // nodeId, first line\r\n\r\nexport class Node {\n       //...\n       }\r\n\r\nexport class Codebase {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\codebase.ts",
    "originFile": "",
    "generatedDocumentation": "# Wiki for `codebase.ts`\n\n## Overview\nThe `codebase.ts` file is a core component of the `codebase-index-ts` repository. It primarily defines the structure and functionality for representing and managing a codebase. This file includes classes and types that facilitate the handling of nodes, import statements, and various operations within a codebase.\n\n## Main Features and Purpose\nThe primary purpose of `codebase.ts` is to provide a structured way to represent and manipulate a codebase. It includes several key classes and types that enable the following functionalities:\n\n### Classes and Types\n\n#### 1. `Codebase`\nThe `Codebase` class is the central component of this file. It represents a codebase and provides various methods to manage and interact with nodes and spaces within the codebase.\n\n- **Constructor**: Initializes the root folder path of the codebase.\n- **Methods**: \n  - `addNode`, `getNode`: Add and retrieve nodes.\n  - `addNodeMap`, `addNodeToSpaceMap`: Manage mappings of nodes and spaces.\n  - `generateNodesFromFilePaths`: Create nodes based on file paths.\n  - `resolveSpaces`, `parseFolders`: Handle spaces and folders within the codebase.\n  - `extractCalls`: Extract function or method calls.\n  - `simplifyAttributes`: Simplify node attributes for easier processing.\n  - `retrieveLinks`: Get links between nodes.\n  - `resolvePythonImportStatements`, `handleHeaderFiles`: Specialized methods for handling Python imports and header files.\n\n#### 2. `Node`\nThe `Node` class represents an individual node within the codebase. Nodes can be files, classes, functions, or other code elements.\n\n- **Properties**: \n  - `id`, `type`, `name`, `code`, `documentation`: Basic attributes of the node.\n  - `parent`, `children`: Relationships with other nodes.\n  - `imports`, `relationships`, `exportClauses`: Manage imports and relationships.\n- **Methods**: \n  - `addChild`, `removeChild`, `getChild`: Manage child nodes.\n  - `handleCalls`, `handleImportStatements`: Process calls and import statements.\n  - `calculateDegrees`: Compute degrees of relationships.\n  - `checkContainment`: Verify if a node contains another node.\n  - `simplifyAttributes`: Simplify node attributes.\n\n#### 3. `ImportStatement`\nThe `ImportStatement` class represents an import statement within a code file.\n\n- **Constructor**: Initializes the import statement with a module, an array of `ImportName` objects, a module alias, a path, and optional code.\n- **Properties**: \n  - `module`, `names`, `path`, `moduleAlias`, `code`: Define the import statement.\n\n#### 4. `ImportName`\nThe `ImportName` class represents an individual name within an import statement.\n\n- **Constructor**: Initializes the name and optional alias.\n- **Properties**: \n  - `name`, `alias`: Define the import name and its alias.\n  - `node`: Additional context for the import.\n\n#### 5. `NodeCallTuple`\nA type definition representing a tuple with a node and an array of line numbers.\n\n- **Type**: `{ node: Node; lines: number[] }`\n\n### Constants\n- **Encoding**: `const enc = encoding_for_model('gpt-4-turbo')` - Defines the encoding model used for processing.\n\n## Important Definitions\n- **Node**: Represents an element of the codebase, such as a file or function.\n- **Codebase**: Manages the overall structure and operations within the codebase.\n- **ImportStatement**: Represents import statements in the code.\n- **ImportName**: Represents individual names within import statements.\n- **NodeCallTuple**: A tuple type for nodes and their associated line numbers.\n\n## Conclusion\nThe `codebase.ts` file is crucial for managing and interacting with a codebase in a structured and efficient manner. It defines classes and methods that facilitate the representation of code elements, handling of import statements, and various operations necessary for codebase management. This file serves as the backbone for the codebase indexing and manipulation functionalities provided by the `codebase-index-ts` repository.",
    "importStatements": "import fs from 'node:fs/promises'\nimport { Point } from 'tree-sitter'\nimport { captureQuery, getAllFiles, renameSource, getCalledNode, cleanDefCaptures } from './utils'\nimport {\r\n  languageExtensionMap,\r\n  AllowedTypes,\r\n  newClassMethodsMap,\r\n  indexSuffixesMap,\r\n  AllowedTypesArray,\r\n  treeSitterCommentTypes\r\n} from './consts'\nimport { CallsCapturer } from './calls'\nimport path from 'path'\nimport { encoding_for_model } from 'tiktoken'"
  },
  {
    "id": "90715f1b-ca49-4852-9ee5-be36aa4e5eeb",
    "fullName": "\\src\\model\\consts::treeSitterCommentTypes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "codeNoBody": "export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "treeSitterCommentTypes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "Code: export const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "importStatements": ""
  },
  {
    "id": "43e29482-b483-4517-9cbc-56ed4c75b022",
    "fullName": "\\src\\model\\consts::indexSuffixesMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
    "codeNoBody": "export const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "indexSuffixesMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "Defines a constant object `indexSuffixesMap` that maps file extensions to default index file names, including common extensions like Python, JavaScript, TypeScript, and TSX, with specific default index names, while Java, Rust, and PHP have empty strings as they do not have default index files.",
    "importStatements": ""
  },
  {
    "id": "2a85baf7-bd44-4c3d-bbf0-1c305b598980",
    "fullName": "\\src\\model\\consts::itselfClassMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
    "codeNoBody": "export const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "itselfClassMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The \"itselfClassMap\" constant is a TypeScript record that maps programming languages to their corresponding class instance keywords, such as 'this' for JavaScript and TypeScript, 'self' for Python and Rust, and '$this' for PHP.",
    "importStatements": ""
  },
  {
    "id": "a1f4cf94-7e52-477a-bbe4-41b2a3d4b41c",
    "fullName": "\\src\\model\\consts::newClassMethodsMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
    "codeNoBody": "export const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "newClassMethodsMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `newClassMethodsMap` constant stores mappings between programming languages and their corresponding class method names, including common constructor method names for languages like Python, JavaScript, TypeScript, TSX, Java, Rust, and PHP.",
    "importStatements": ""
  },
  {
    "id": "3a20f07b-a014-4388-9dde-9bfa7a51f26d",
    "fullName": "\\src\\model\\consts::languageExtensionMap",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
    "codeNoBody": "export const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languageExtensionMap",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `languageExtensionMap` constant is a TypeScript object that maps file extensions to their corresponding programming languages, including mappings for Python, C, TypeScript, Java, and PHP, facilitating language identification based on file extensions within the codebase.",
    "importStatements": ""
  },
  {
    "id": "32cad0ef-b728-4b56-929e-83616eb67b8c",
    "fullName": "\\src\\model\\consts::languages",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
    "codeNoBody": "export const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languages",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The code exports a constant object containing various programming languages as properties, including JavaScript, Python, TypeScript, TSX, Java, C, and PHP.",
    "importStatements": ""
  },
  {
    "id": "7fb42c98-fcc5-49af-a029-578348096a64",
    "fullName": "\\src\\model\\consts::excludedExtensions",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
    "codeNoBody": "export const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "excludedExtensions",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `excludedExtensions` constant in the codebase contains an array of file extensions that are excluded from certain processes, including 'min.js', 'min.css', 'min.css.map', 'min.js.map', 'd.ts', and '.config.js'.",
    "importStatements": ""
  },
  {
    "id": "15667787-a287-40b7-aa44-5d1c5ad2a6f0",
    "fullName": "\\src\\model\\consts::excludedFolders",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__',\r\n  'tmp'\r\n]",
    "codeNoBody": "export const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__',\r\n  'tmp'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "excludedFolders",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `excludedFolders` constant in the codebase contains an array of folder names that are typically excluded from processes like file system operations, build tasks, and testing, including common folders like `.git`, `node_modules`, and `dist`, among others.",
    "importStatements": ""
  },
  {
    "id": "f8535c42-6785-44f6-9cfa-ca0c2b7d390d",
    "fullName": "\\src\\model\\consts::AllowedTypesArray",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
    "codeNoBody": "export const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "AllowedTypesArray",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `AllowedTypesArray` constant is an array of string literals representing various programming entities such as functions, classes, interfaces, methods, enums, structs, exports, types, assignments, files, unions, namespaces, modules, headers, and packages, defined by the `AllowedTypes` type.",
    "importStatements": ""
  },
  {
    "id": "aa167d36-1118-45e8-9d11-731e77782d3c",
    "fullName": "\\src\\model\\consts::AllowedTypes",
    "type": "type",
    "language": "typescript",
    "documentation": "// - a header is a file that contains a set of declarations\r",
    "code": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "codeNoBody": "type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "AllowedTypes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "generatedDocumentation": "The `AllowedTypes` type defines a set of string literals representing various programming entities like functions, classes, interfaces, methods, enums, structs, exports, types, assignments, files, unions, namespaces, modules, headers, and packages.",
    "importStatements": ""
  },
  {
    "id": "b7d3adad-f881-46e9-b43f-29d594fff2d1",
    "fullName": "\\src\\model\\consts",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__',\r\n  'tmp'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']\r\n",
    "codeNoBody": "// const Ruby = require(\"tree-sitter-ruby\");\r\n// const Rust = require(\"tree-sitter-rust\");\r\nconst JavaScript = require('tree-sitter-javascript')\r\nconst Python = require('tree-sitter-python')\r\nconst TypeScript = require('tree-sitter-typescript').typescript\r\nconst TSX = require('tree-sitter-typescript').tsx\r\nconst Java = require('tree-sitter-java')\r\nconst C = require('tree-sitter-c')\r\nconst PHP = require('tree-sitter-php').php\r\n// namespace, mod and header are equivalent:\r\n// - a namespace define a scope that contains a set of declarations\r\n// - a mod defined a module, which contains a set of declarations\r\n// - a header is a file that contains a set of declarations\r\nexport type AllowedTypes =\r\n  | 'function'\r\n  | 'class'\r\n  | 'interface'\r\n  | 'method'\r\n  | 'enum'\r\n  | 'struct'\r\n  | 'export'\r\n  | 'type'\r\n  | 'assignment'\r\n  | 'file'\r\n  | 'union'\r\n  | 'namespace'\r\n  | 'mod'\r\n  | 'header'\r\n  | 'package'\r\n\r\nexport const AllowedTypesArray: AllowedTypes[] = [\r\n  'function',\r\n  'class',\r\n  'interface',\r\n  'method',\r\n  'enum',\r\n  'struct',\r\n  'export',\r\n  'type',\r\n  'assignment',\r\n  'file',\r\n  'union',\r\n  'namespace',\r\n  'mod',\r\n  'header',\r\n  'package'\r\n]\r\n\r\nexport const excludedFolders = [\r\n  '.git',\r\n  '.vscode',\r\n  'venv',\r\n  'node_modules',\r\n  'dist',\r\n  '__pycache__',\r\n  'tests',\r\n  'build',\r\n  '_static',\r\n  'jest',\r\n  '__tests__',\r\n  'tmp'\r\n]\r\nexport const excludedExtensions = [\r\n  'min.js',\r\n  'min.css',\r\n  'min.css.map',\r\n  'min.js.map',\r\n  'd.ts',\r\n  '.config.js'\r\n]\r\n\r\nexport const languages = {\r\n  JavaScript,\r\n  Python,\r\n  TypeScript,\r\n  TSX,\r\n  Java,\r\n  C,\r\n  PHP\r\n}\r\n\r\nexport const languageExtensionMap: Record<string, string> = {\r\n  py: 'python',\r\n  c: 'c',\r\n  h: 'c',\r\n  // 'ipynb': 'python',\r\n  js: 'typescript',\r\n  mjs: 'typescript',\r\n  jsx: 'typescript',\r\n  ts: 'typescript',\r\n  tsx: 'tsx',\r\n  java: 'java',\r\n  php: 'php'\r\n}\r\n\r\nexport const newClassMethodsMap: Record<string, string> = {\r\n  python: '__init__',\r\n  javascript: 'constructor',\r\n  typescript: 'constructor',\r\n  tsx: 'constructor',\r\n  java: '', // java constructor has the same name as the class\r\n  rust: 'new',\r\n  php: '__construct'\r\n}\r\n\r\nexport const itselfClassMap: Record<string, string> = {\r\n  python: 'self',\r\n  javascript: 'this',\r\n  typescript: 'this',\r\n  tsx: 'this',\r\n  java: 'this',\r\n  rust: 'self',\r\n  php: '$this'\r\n}\r\n\r\nexport const indexSuffixesMap: Record<string, string> = {\r\n  python: '/__init__',\r\n  javascript: '/index',\r\n  typescript: '/index',\r\n  tsx: '/index',\r\n  java: '', // java has no index\r\n  rust: '', // rust has no index\r\n  php: '' // php has no index\r\n}\r\n\r\nexport const treeSitterCommentTypes = ['comment', 'line_comment', 'block_comment']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\consts.ts",
    "originFile": "",
    "generatedDocumentation": "## Overview of `consts.ts`\n\nThe `consts.ts` file in the `src/model` directory serves as a central repository for various constants and type definitions used throughout the codebase. These constants facilitate the handling of different programming languages, file types, and directory structures within the project. By consolidating these constants in one file, the codebase ensures consistency and ease of maintenance.\n\n## Main Features and Purpose\n\n### Language Parsers\n\nThe file imports language parsers from the `tree-sitter` library for various programming languages:\n- JavaScript\n- Python\n- TypeScript\n- TSX\n- Java\n- C\n- PHP\n\nThese parsers are stored in the `languages` object, allowing the codebase to easily access and utilize them for syntax tree parsing and analysis.\n\n### Allowed Types\n\nThe `AllowedTypes` type and `AllowedTypesArray` constant define a set of permissible programming entities. These include:\n- `function`\n- `class`\n- `interface`\n- `method`\n- `enum`\n- `struct`\n- `export`\n- `type`\n- `assignment`\n- `file`\n- `union`\n- `namespace`\n- `mod`\n- `header`\n- `package`\n\nThese types are used to categorize and manage different code elements within the project.\n\n### Excluded Folders and Extensions\n\nThe `excludedFolders` and `excludedExtensions` constants list directories and file extensions that should be ignored during various operations, such as file system traversal or build processes. Commonly excluded items include:\n- Folders: `.git`, `node_modules`, `dist`, etc.\n- Extensions: `min.js`, `min.css`, `d.ts`, etc.\n\n### Language Extension Mapping\n\nThe `languageExtensionMap` constant maps file extensions to their corresponding programming languages. This mapping helps in identifying the language of a file based on its extension, which is crucial for syntax parsing and analysis.\n\n### Class and Method Mappings\n\nSeveral constants map programming languages to specific keywords and conventions:\n- `newClassMethodsMap`: Maps languages to their constructor method names (e.g., `__init__` for Python, `constructor` for JavaScript/TypeScript).\n- `itselfClassMap`: Maps languages to their class instance keywords (e.g., `self` for Python, `this` for JavaScript/TypeScript).\n- `indexSuffixesMap`: Maps languages to their default index file names (e.g., `/index` for JavaScript/TypeScript, `/__init__` for Python).\n\n### Tree-Sitter Comment Types\n\nThe `treeSitterCommentTypes` constant lists the types of comments recognized by the `tree-sitter` parsers, including:\n- `comment`\n- `line_comment`\n- `block_comment`\n\n## Important Definitions\n\n- **AllowedTypes**: A TypeScript type defining permissible programming entities.\n- **AllowedTypesArray**: An array of strings representing the allowed types.\n- **excludedFolders**: An array of folder names to be excluded from certain operations.\n- **excludedExtensions**: An array of file extensions to be excluded from certain operations.\n- **languages**: An object containing language parsers from the `tree-sitter` library.\n- **languageExtensionMap**: A mapping of file extensions to programming languages.\n- **newClassMethodsMap**: A mapping of languages to their constructor method names.\n- **itselfClassMap**: A mapping of languages to their class instance keywords.\n- **indexSuffixesMap**: A mapping of languages to their default index file names.\n- **treeSitterCommentTypes**: An array of comment types recognized by `tree-sitter`.\n\n## Purpose\n\nThe `consts.ts` file centralizes the definitions and mappings necessary for language parsing, file handling, and code analysis within the project. By maintaining these constants in a single location, the codebase ensures consistency, reduces redundancy, and simplifies maintenance and updates.",
    "importStatements": "const JavaScript = require('tree-sitter-javascript')\nconst Python = require('tree-sitter-python')\nconst TypeScript = require('tree-sitter-typescript').typescript\nconst TSX = require('tree-sitter-typescript').tsx\nconst Java = require('tree-sitter-java')\nconst C = require('tree-sitter-c')\nconst PHP = require('tree-sitter-php').php"
  },
  {
    "id": "9e00cd44-393b-40a0-bbf2-0b7c2aabb2b5",
    "fullName": "\\src\\model\\utils::getCalledNode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}",
    "codeNoBody": "function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCalledNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "The `getCalledNode` function takes in a `callName` string, an `importFrom` string, and a `importedFileNodes` object containing file nodes and import statements. It retrieves the file node from the specified `importFrom`, then locates and returns the child node with the concatenated ID of the file and the `callName`.",
    "importStatements": ""
  },
  {
    "id": "69e91b9f-7293-4825-a7a2-7f55061e6dc5",
    "fullName": "\\src\\model\\utils::cleanAndSplitContent",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};",
    "codeNoBody": "const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cleanAndSplitContent",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This function `cleanAndSplitContent` takes a `content` string as input, removes parentheses, newlines, and unwanted characters, replaces ':' and '|' with ',', splits the content by commas, removes surrounding brackets/braces, and trims each part, returning an array of cleaned and split strings.",
    "importStatements": ""
  },
  {
    "id": "63f515c9-ee5c-44d4-9b53-4c95b8e9a04d",
    "fullName": "\\src\\model\\utils::firstConsecutiveDots",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}",
    "codeNoBody": "function firstConsecutiveDots(s: string): number {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "firstConsecutiveDots",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This function takes a string `s` as a parameter and returns the number of consecutive dots at the beginning of the string. It uses a regular expression to match one or more consecutive dots at the start of the string and returns the length of the matched substring, or 0 if no consecutive dots are found.",
    "importStatements": ""
  },
  {
    "id": "330b945e-74d4-4144-b890-b4330a049b84",
    "fullName": "\\src\\model\\utils::renameSource",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */",
    "code": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}",
    "codeNoBody": "function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "renameSource",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "The `renameSource` function takes in a `filePath` string, a `sourceName` string, and a `language` string as parameters. It processes the `sourceName` based on the provided `language` and returns the modified `newSourceName`. The function handles different scenarios such as removing file extensions, adjusting file paths, and transforming source names according to specific language requirements like C++, Python, and more. Additionally, it utilizes the `firstConsecutiveDots` function to determine the number of consecutive dots at the beginning of the `newSourceName` string in Python files.",
    "importStatements": ""
  },
  {
    "id": "04d1bbec-23f8-4275-a496-808b680046b0",
    "fullName": "\\src\\model\\utils::cleanDefCaptures",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */",
    "code": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}",
    "codeNoBody": "function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cleanDefCaptures",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This function `cleanDefCaptures` takes an array of `captures` and an optional `keyword` parameter, defaulting to \"name\", then sorts the captures based on their node positions, filters out duplicates of the specified `keyword`, and returns the updated array of captures.",
    "importStatements": ""
  },
  {
    "id": "6b97a948-4911-4e6c-b68b-bbb35639f0f6",
    "fullName": "\\src\\model\\utils::captureQuery",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */",
    "code": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}",
    "codeNoBody": "function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "captureQuery",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "The `captureQuery` function takes in a `language` string, a `queryName` key of `treeSitterQueries`, a `code` string, and an optional `queryArg` string. It uses the `getRequiredDefinitions` function to get the necessary parser and queries based on the `language`. The function then creates a `Parser.Query` object with the specified language and query, parses the `code`, and captures unique elements based on the query. If an error occurs during this process, it throws an error message.",
    "importStatements": ""
  },
  {
    "id": "78980184-1b5d-4ab6-b674-d1b28ab71a29",
    "fullName": "\\src\\model\\utils::getRequiredDefinitions",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */",
    "code": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}",
    "codeNoBody": "function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getRequiredDefinitions",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This function `getRequiredDefinitions` takes a `language` parameter to determine the language-specific parser and queries to be used, returning an object with a `parser` and `queries` properties. It initializes a `Parser` object, sets the language based on the input `language`, and assigns the corresponding language-specific queries before returning them as an object. If the provided `language` is not supported, it throws an error indicating the unsupported language.",
    "importStatements": ""
  },
  {
    "id": "7c2a5c33-df68-4098-b1cb-90377dcc748c",
    "fullName": "\\src\\model\\utils::getTotalSize",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */",
    "code": "async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}",
    "codeNoBody": "async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getTotalSize",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This async function \"getTotalSize\" takes a rootFolderPath parameter and returns a Promise<number> representing the total size in bytes of all valid files within the specified folder. It utilizes the getAllFiles function to retrieve a list of valid files based on specified criteria, then asynchronously calculates the size of each file using fs.stat, sums up the sizes, and returns the total size.",
    "importStatements": ""
  },
  {
    "id": "8b6ddc0c-6527-4434-ae79-9810ae90cbc5",
    "fullName": "\\src\\model\\utils::getAllFiles",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */",
    "code": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}",
    "codeNoBody": "async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getAllFiles",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "generatedDocumentation": "This async function \"getAllFiles\" takes a rootFolderPath parameter and returns a Promise<string[]> of valid files in the specified folder. It uses regular expressions to filter files based on language extensions, excluded extensions, and excluded folders. The function utilizes glob to retrieve all files, fs.lstat to check if a file is valid, and then filters and sorts the matching files based on the defined criteria before returning them.",
    "importStatements": ""
  },
  {
    "id": "e89c5801-0528-4103-ae5b-eb581bdf67d5",
    "fullName": "\\src\\model\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\r\n  const extensionsPattern = Object.keys(languageExtensionMap)\r\n    .map((ext) => `\\\\.${ext}$`)\r\n    .join(\"|\");\r\n  const regex = new RegExp(extensionsPattern);\r\n  const excludedExtensionPattern = new RegExp(\r\n    excludedExtensions.map((ext) => `\\\\.${ext}$`).join(\"|\")\r\n  );\r\n  const excludedFolderPattern = new RegExp(\r\n    excludedFolders.map((f) => `${f}/`).join(\"|\")\r\n  );\r\n  const files = await glob(`**/*`, {\r\n    cwd: rootFolderPath,\r\n    absolute: true,\r\n  });\r\n  // no sync\r\n  const validFiles = await Promise.all(\r\n    files.map(async (file) => (await fs.lstat(file)).isFile())\r\n  );\r\n  const matchingFiles = files.filter(\r\n    (file, i) =>\r\n      regex.test(file) &&\r\n      validFiles[i] &&\r\n      !excludedExtensionPattern.test(file) &&\r\n      !excludedFolderPattern.test(file) &&\r\n      !file.includes(\"@\") &&\r\n      !file.includes(\"node_modules\")\r\n  );\r\n  matchingFiles.sort(); // sorted\r\n  return matchingFiles;\r\n}\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\r\n  const matchingFiles = await getAllFiles(rootFolderPath);\r\n  const sizes = await Promise.all(\r\n    matchingFiles.map(async (file) => {\r\n      const { size } = await fs.stat(file);\r\n      return size;\r\n    })\r\n  );\r\n  const totalSize = sizes.reduce((acc, size) => acc + size, 0);\r\n  return totalSize;\r\n}\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\r\n  const parser = new Parser();\r\n  let queries;\r\n  switch (language) {\r\n    case \"javascript\":\r\n      parser.setLanguage(languages.JavaScript);\r\n      queries = languageQueries.Javascript;\r\n      break;\r\n    case \"python\":\r\n      parser.setLanguage(languages.Python);\r\n      queries = languageQueries.Python;\r\n      break;\r\n    case \"typescript\":\r\n      parser.setLanguage(languages.TypeScript);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"tsx\":\r\n      parser.setLanguage(languages.TSX);\r\n      queries = languageQueries.Typescript;\r\n      break;\r\n    case \"java\":\r\n      parser.setLanguage(languages.Java);\r\n      queries = languageQueries.Java;\r\n      break;\r\n    case \"c\":\r\n      parser.setLanguage(languages.C);\r\n      queries = languageQueries.C;\r\n      break;\r\n    case \"php\":\r\n      parser.setLanguage(languages.PHP);\r\n      queries = languageQueries.PHP;\r\n      break;\r\n    default:\r\n      throw new Error(`Language ${language} not supported.`);\r\n  }\r\n  return { parser, queries };\r\n}\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\r\n  const { parser, queries } = getRequiredDefinitions(language);\r\n  const treeSitterQuery =\r\n    queryName === \"extraAssignmentCode\"\r\n      ? queries[queryName](queryArg || \"\")\r\n      : (queries[queryName] as string);\r\n  let uniqueCaptures = [];\r\n  try {\r\n    const query = new Parser.Query(parser.getLanguage(), treeSitterQuery);\r\n    if (language === \"php\" && !code.includes(\"<?php\")) {\r\n      code = `<?php\\n${code}`;\r\n    }\r\n    const tree = parser.parse(code, undefined, { bufferSize: 512 * 1024 });\r\n    const captures = query.captures(tree.rootNode);\r\n    const uniqueMap = new Map();\r\n    captures.forEach((c) => {\r\n      const key = `${c.name}|${c.node.text}|${c.node.startPosition.row}|${c.node.startPosition.column}`; // Create a unique key based on `name` and `text`\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, c);\r\n      }\r\n    });\r\n\r\n    uniqueCaptures = Array.from(uniqueMap.values());\r\n  } catch (error: any) {\r\n    const errorMessage = `${language} captureQuery ${queryName}${\r\n      queryArg ? \"(\" + queryArg + \")\" : \"\"\r\n    }: ${error.message}`;\r\n    throw Error(errorMessage);\r\n  }\r\n  return uniqueCaptures;\r\n}\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\r\n  captures.sort(\r\n    (a, b) =>\r\n      a.node.startPosition.row - b.node.startPosition.row ||\r\n      a.node.startPosition.column - b.node.startPosition.column\r\n  );\r\n  let keywordSeen = false;\r\n\r\n  const updatedCaptures = [];\r\n  for (let i = 0; i < captures.length; i++) {\r\n    if (captures[i].name === keyword) {\r\n      if (!keywordSeen) {\r\n        updatedCaptures.push(captures[i]);\r\n        keywordSeen = true;\r\n      } else break;\r\n    } else {\r\n      updatedCaptures.push(captures[i]);\r\n    }\r\n  }\r\n  return updatedCaptures;\r\n}\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\r\n  let newSourceName = sourceName;\r\n  const sourceNameSplit = sourceName.split(\".\");\r\n  const sourceNameExtension = sourceNameSplit.slice(-1)[0];\r\n  // remove extension if is in languageExtensionMap\r\n  if (Object.keys(languageExtensionMap).includes(sourceNameExtension))\r\n    newSourceName = sourceNameSplit.slice(0, -1).join(\".\");\r\n  const fileDirectory = filePath.split(\"/\").slice(0, -1).join(\"/\");\r\n\r\n  if (\r\n    ([\"javascript\", \"typescript\", \"tsx\", \"java\", \"c\", \"cpp\", \"csharp\"].includes(\r\n      language\r\n    ) &&\r\n      newSourceName.startsWith(\".\")) ||\r\n    ([\"c\", \"cpp\", \"csharp\"].includes(language) &&\r\n      !newSourceName.startsWith(\"<\"))\r\n  ) {\r\n    newSourceName = path.join(fileDirectory, newSourceName);\r\n    if ([\"c\", \"cpp\"].includes(language) && sourceNameExtension == \"h\") {\r\n      newSourceName += \"::header\";\r\n    }\r\n  } else if (language == \"python\") {\r\n    const dotCount = firstConsecutiveDots(newSourceName);\r\n    newSourceName = newSourceName.replace(/\\./g, \"/\");\r\n    if (dotCount) {\r\n      if (dotCount == 1) {\r\n        newSourceName = path.join(fileDirectory, newSourceName);\r\n      } else {\r\n        const moveUpCount = dotCount - 1;\r\n        const newDirectory = fileDirectory\r\n          .split(\"/\")\r\n          .slice(0, -moveUpCount)\r\n          .join(\"/\");\r\n        newSourceName = path.join(newDirectory, newSourceName);\r\n      }\r\n    }\r\n  }\r\n  return newSourceName;\r\n}\r\n\r\nfunction firstConsecutiveDots(s: string): number {\r\n  const match = s.match(/^\\.{1,}/);\r\n  return match ? match[0].length : 0;\r\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\r\n  // Remove parentheses and their contents, newlines, and unwanted characters\r\n  // Replace ':' and '|' with ','\r\n  content = content\r\n    .replace(/\\(|\\)|\\n|\\s{2,}/gs, \"\")\r\n    .replace(/[:|]/g, \",\")\r\n    .trim();\r\n\r\n  // Split the content by commas, remove surrounding brackets/braces, and trim each part\r\n  return content\r\n    .split(\",\")\r\n    .map((item) => item.replace(/[\\[\\]\\{\\}]/g, \"\").trim());\r\n};\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\r\n  const importedFile = importedFileNodes[importFrom].fileNode;\r\n  const calledNode = importedFile?.getChild(`${importedFile.id}::${callName}`);\r\n  return calledNode;\r\n}\r\n",
    "codeNoBody": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\r\nimport { treeSitterQueries, languageQueries } from \"../queries\";\r\nimport { glob } from \"glob\";\r\nimport fs from \"node:fs/promises\";\r\nimport path from \"path\";\r\nimport Parser from \"tree-sitter\";\r\nimport { Node, ImportStatement } from \"./codebase\";\r\n/**\r\n * Get a list of all files in a given folder, including only files with the given extensions\r\n * from languageExtensionMap, and excluding from excludedExtensions\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The list of files from the given folder\r\n */\r\nexport async function getAllFiles(rootFolderPath: string): Promise<string[]> {\n       //...\n       }\r\n\r\n/**\r\n * Get the total size of all files returned by getAllFiles\r\n *\r\n * @param rootFolderPath - The root folder to search in\r\n * @returns - The total size in bytes of the matching files\r\n */\r\nexport async function getTotalSize(rootFolderPath: string): Promise<number> {\n       //...\n       }\r\n\r\n/**\r\n * Returns the Tree-Sitter parser and queries for a given language\r\n * @param language - The language to use\r\n * @returns - The parser and queries for the given language\r\n */\r\nexport function getRequiredDefinitions(language: string): {\r\n  parser: Parser;\r\n  queries: treeSitterQueries;\r\n} {\n       //...\n       }\r\n\r\n/**\r\n * Use Tree-Sitter to capture a query from treeSitterQueries for a given language and code\r\n *\r\n * @param language - The language to use\r\n * @param queryName - The name of the query to use, must be a key in treeSitterQueries\r\n * @param code - The code to parse\r\n * @param queryArg - The argument to pass to the query, only used for the extraAssignmentCode query\r\n * @returns\r\n */\r\nexport function captureQuery(\r\n  language: string,\r\n  queryName: keyof treeSitterQueries,\r\n  code: string,\r\n  queryArg?: string\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Returns a cleaned list of captures up to the first occurence of the given keyword\r\n * @param captures - The captures to clean\r\n * @param keyword - The keyword to stop at\r\n */\r\nexport function cleanDefCaptures(\r\n  captures: Parser.QueryCapture[],\r\n  keyword: string = \"name\"\r\n): Parser.QueryCapture[] {\n       //...\n       }\r\n\r\n/**\r\n * Rename the sourceName if it is a relative to filePath\r\n * @param filePath - The filePath to rename from\r\n * @param sourceName - The sourceName to rename to\r\n * @param language - The language to rename from\r\n * @returns The renamed sourceName\r\n */\r\nexport function renameSource(\r\n  filePath: string,\r\n  sourceName: string,\r\n  language: string\r\n): string {\n       //...\n       }\r\n\r\nfunction firstConsecutiveDots(s: string): number {\n//...\n}\r\n\r\nexport const cleanAndSplitContent = (content: string): string[] => {\n       //...\n       };\r\n\r\nexport function getCalledNode(\r\n  callName: string,\r\n  importFrom: string,\r\n  importedFileNodes: Record<\r\n    string,\r\n    { fileNode: Node; importStatement: ImportStatement }\r\n  >\r\n) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\model\\utils.ts",
    "originFile": "",
    "generatedDocumentation": "## Overview of `utils.ts`\n\nThe `utils.ts` file in the `src/model` directory is a utility module that provides various helper functions for file handling, code parsing, and content processing within the codebase. This file leverages several external libraries and internal modules to perform its tasks efficiently.\n\n## Main Features and Purpose\n\n### File Handling Functions\n\n1. **getAllFiles**:\n   - **Purpose**: Retrieves a list of all valid files in a specified folder.\n   - **Details**: Uses regular expressions to filter files based on language extensions, excluded extensions, and excluded folders. Utilizes the `glob` library to retrieve files and `fs.lstat` to validate them.\n\n2. **getTotalSize**:\n   - **Purpose**: Computes the total size of all valid files within a specified folder.\n   - **Details**: Uses the `getAllFiles` function to get the list of files and then calculates their total size asynchronously using `fs.stat`.\n\n### Code Parsing and Querying Functions\n\n3. **getRequiredDefinitions**:\n   - **Purpose**: Provides the Tree-Sitter parser and queries for a given programming language.\n   - **Details**: Initializes a `Parser` object and sets the language-specific parser and queries. Throws an error if the language is unsupported.\n\n4. **captureQuery**:\n   - **Purpose**: Uses Tree-Sitter to capture elements from code based on specified queries.\n   - **Details**: Retrieves the necessary parser and queries using `getRequiredDefinitions`, then parses the code and captures elements based on the query.\n\n5. **cleanDefCaptures**:\n   - **Purpose**: Cleans and sorts captured elements from code.\n   - **Details**: Sorts captures based on node positions, filters out duplicates of a specified keyword, and returns the cleaned captures.\n\n### Content Processing Functions\n\n6. **cleanAndSplitContent**:\n   - **Purpose**: Cleans and splits a content string into an array of strings.\n   - **Details**: Removes unwanted characters, replaces certain characters, splits the content by commas, and trims each part.\n\n### Source and Node Handling Functions\n\n7. **renameSource**:\n   - **Purpose**: Renames a source name based on the file path and programming language.\n   - **Details**: Processes the source name according to language-specific rules, handling scenarios like removing file extensions and adjusting file paths.\n\n8. **getCalledNode**:\n   - **Purpose**: Retrieves a specific node from imported file nodes based on a call name.\n   - **Details**: Locates and returns the child node with the concatenated ID of the file and the call name.\n\n### Utility Functions\n\n9. **firstConsecutiveDots**:\n   - **Purpose**: Counts the number of consecutive dots at the beginning of a string.\n   - **Details**: Uses a regular expression to match consecutive dots and returns their count.\n\n## Important Definitions Inside the File\n\n- **languageExtensionMap, excludedFolders, excludedExtensions, languages**: Constants imported from `./consts` that define language-specific extensions, folders, and files to exclude.\n- **treeSitterQueries, languageQueries**: Queries imported from `../queries` used for parsing code with Tree-Sitter.\n- **Node, ImportStatement**: Types imported from `./codebase` representing nodes and import statements in the codebase.\n\n## Conclusion\n\nThe `utils.ts` file is a crucial utility module that provides essential functions for file handling, code parsing, content processing, and source management within the codebase. By leveraging external libraries like `glob` and `tree-sitter`, along with internal constants and types, it ensures efficient and accurate processing of files and code elements.",
    "importStatements": "import {\r\n  languageExtensionMap,\r\n  excludedFolders,\r\n  excludedExtensions,\r\n  languages,\r\n} from \"./consts\";\nimport { treeSitterQueries, languageQueries } from \"../queries\";\nimport { glob } from \"glob\";\nimport fs from \"node:fs/promises\";\nimport path from \"path\";\nimport Parser from \"tree-sitter\";\nimport { Node, ImportStatement } from \"./codebase\";"
  },
  {
    "id": "60313eb2-21bd-4c5b-b78e-0d62ea6c8644",
    "fullName": "\\src\\queries\\c::cQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "cQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "The `cQueries` object in this assignment defines various tree-sitter queries for the C programming language, including import statements, constructor definitions, a template for definitions, export clauses, extra assignment code, function calls, any assignment declarations, and space declarations. The `anyAssignments` query captures assignment declarations with an identifier on the left side and an optional pointer declarator on the right side, extracting both the identifier and the assignment itself.",
    "importStatements": ""
  },
  {
    "id": "1e342d18-5457-4077-8b4d-b739d106d017",
    "fullName": "\\src\\queries\\c::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// > my_class.my_method()\r",
    "code": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "Defines a template for matching any assignment declaration with an identifier on the left side and an optional pointer declarator on the right side, capturing the identifier on the left as well as the assignment itself.",
    "importStatements": ""
  },
  {
    "id": "53730b19-7f3d-4c30-a8e5-fdd18066740e",
    "fullName": "\\src\\queries\\c::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "codeNoBody": "const calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "The \"calls\" assignment in the codebase contains a template string that represents a call expression with a function identifier and its arguments, using the specified syntax for identifying and extracting function names and argument identifiers.",
    "importStatements": ""
  },
  {
    "id": "995be1dc-0247-403b-832b-f5ec14fabffa",
    "fullName": "\\src\\queries\\c::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// ASSIGNMENT SPECIAL CASE\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    `",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "The function `extraAssignmentCode` takes a `name` parameter and generates a string template representing an AST node for an expression statement with a call expression. The function inserts the provided `name` into the generated AST node, which is used for creating extra assignment code in the codebase.",
    "importStatements": ""
  },
  {
    "id": "ea486fcb-208f-44e5-9868-04c5e17b8a41",
    "fullName": "\\src\\queries\\c::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// modifier can be public, private or protected. By default is private\r",
    "code": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "The `definitionTemplate` in the code defines a template for function and global variable declarations in a C-like language, including return type, name, parameters, and body for functions, as well as name and initial value for global variables.",
    "importStatements": ""
  },
  {
    "id": "690d9f07-fe43-42b2-b2a3-f7daabd5d569",
    "fullName": "\\src\\queries\\c::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Java has no global assignments\r",
    "code": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "generatedDocumentation": "The code in \"\\src\\queries\\c::signments\" defines a query template for identifying assignment declarations within a C language translation unit, focusing on declarations with an initializer value.",
    "importStatements": ""
  },
  {
    "id": "860d16b4-54bd-4732-93b5-79d55f92358d",
    "fullName": "\\src\\queries\\c",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => `\r\n( translation_unit\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (field_expression (identifier)  @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n)\r\n    ` \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n( preproc_include path: (system_lib_string) @module) @import_statement\r\n( preproc_include path: (string_literal (_) @module)) @import_statement\r\n\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = `\r\n(translation_unit\r\n\t(declaration\r\n    \tdeclarator: (init_declarator\r\n        \t\tdeclarator: (_)\r\n                value: (_)\r\n        \t) \r\n    ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n    type: (_)? @return_type\r\n    [\r\n     name: (_) @name\r\n     declarator: (function_declarator declarator: (identifier) @name) \r\n    ]\r\n    parameters: (parameter_list (_) @param)?\r\n    body: (_)? @body\r\n)?\r\n\r\n; For global assignments\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @name\r\n                (pointer_declarator declarator: (identifier) @name)\r\n                ]\r\n            value: (_) @body\r\n        ) \r\n) \r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(declaration (function_declarator)) @function\r\n(struct_specifier) @struct\r\n(union_specifier) @union\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\nconst extraAssignmentCode = (name: string) => {\n//...\n} \r\n\r\nconst calls = `\r\n(call_expression function: _ @identifier.name)\r\n( _ arguments: (argument_list (identifier) @identifier.name) )\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(declaration\r\n    declarator: (\r\n        init_declarator\r\n            declarator: [\r\n                (identifier) @left\r\n                (pointer_declarator declarator: (identifier) @left)\r\n                ]\r\n            value: (_) @right\r\n        ) \r\n) @assignment\r\n`\r\n\r\nexport const cQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\c.ts",
    "originFile": "",
    "generatedDocumentation": "# Wiki: `c.ts` in `src/queries`\n\n## Overview\nThe `c.ts` file in the `src/queries` folder is designed to define tree-sitter queries for parsing and analyzing C programming language code. Tree-sitter is a parser generator tool and an incremental parsing library that can build concrete syntax trees for source code. This file provides a set of queries that help identify various code constructs in C, such as import statements, assignments, function definitions, and function calls.\n\n## Main Features and Purpose\nThe primary purpose of the `c.ts` file is to define a series of queries that can be used to analyze C code. These queries are encapsulated in the `cQueries` object, which includes the following key components:\n\n### Import Statements\n```typescript\nconst importStatements = `\n( preproc_include path: (system_lib_string) @module) @import_statement\n( preproc_include path: (string_literal (_) @module)) @import_statement\n`\n```\nThis query captures import statements in C, specifically preprocessor include directives, and labels them as `@import_statement`.\n\n### Assignments\n```typescript\nconst assignments = `\n(translation_unit\n\t(declaration\n    \tdeclarator: (init_declarator\n        \t\tdeclarator: (_)\n                value: (_)\n        \t) \n    ) @assignment\n)\n```\nDefines a template for identifying assignment declarations within a C translation unit, focusing on declarations with an initializer value.\n\n### Definition Template\n```typescript\nconst definitionTemplate = `\n( _\n    type: (_)? @return_type\n    [\n     name: (_) @name\n     declarator: (function_declarator declarator: (identifier) @name) \n    ]\n    parameters: (parameter_list (_) @param)?\n    body: (_)? @body\n)?\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @name\n                (pointer_declarator declarator: (identifier) @name)\n                ]\n            value: (_) @body\n        ) \n) \n```\nThis template is used for matching function and global variable declarations, capturing details such as return type, name, parameters, and body.\n\n### Constructor Definitions\n```typescript\nconst constructorDefinitions = `\n(function_definition) @function\n(declaration (function_declarator)) @function\n(struct_specifier) @struct\n(union_specifier) @union\n`\n```\nCaptures function definitions, struct specifications, and union specifications, labeling them appropriately.\n\n### Extra Assignment Code\n```typescript\nconst extraAssignmentCode = (name: string) => {\n    //...\n}\n```\nA function that generates a string template representing an AST node for an expression statement with a call expression, inserting the provided `name` into the generated AST node.\n\n### Calls\n```typescript\nconst calls = `\n(call_expression function: _ @identifier.name)\n( _ arguments: (argument_list (identifier) @identifier.name) )\n`\n```\nDefines a template for identifying function call expressions, capturing the function identifier and its arguments.\n\n### Any Assignments\n```typescript\nconst anyAssignments = `\n(declaration\n    declarator: (\n        init_declarator\n            declarator: [\n                (identifier) @left\n                (pointer_declarator declarator: (identifier) @left)\n                ]\n            value: (_) @right\n        ) \n) @assignment\n`\n```\nCaptures assignment declarations with an identifier on the left side and an optional pointer declarator on the right side, extracting both the identifier and the assignment itself.\n\n## Important Definitions\n- **cQueries**: An object that aggregates all the defined queries for parsing C code.\n- **importStatements**: Captures import statements in C code.\n- **assignments**: Identifies assignment declarations within a C translation unit.\n- **definitionTemplate**: Matches function and global variable declarations.\n- **constructorDefinitions**: Captures function definitions, struct specifications, and union specifications.\n- **extraAssignmentCode**: Generates extra assignment code templates.\n- **calls**: Identifies function call expressions.\n- **anyAssignments**: Captures any assignment declarations with an identifier on the left side.\n\n## Conclusion\nThe `c.ts` file is a crucial part of the `src/queries` folder, providing a comprehensive set of tree-sitter queries for analyzing C code. These queries enable the extraction of key code constructs, facilitating code analysis and manipulation tasks.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "85692623-c97a-4b73-9146-dc13e4a1bc1e",
    "fullName": "\\src\\queries\\index::treeSitterQueries",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "codeNoBody": "interface treeSitterQueries {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "treeSitterQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index.ts",
    "generatedDocumentation": "The `treeSitterQueries` interface in the `\\src\\queries\\index` file defines properties for extracting import statements, constructor definitions, definition templates, export clauses, assignments, additional assignment code, function calls, and space declarations within the codebase.",
    "importStatements": ""
  },
  {
    "id": "f4f4bd21-8cf5-493f-8377-223a2cf6e436",
    "fullName": "\\src\\queries\\index::languageQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "codeNoBody": "export const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "languageQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index.ts",
    "generatedDocumentation": "The `languageQueries` object exports queries for different programming languages including JavaScript, TypeScript, Python, Java, C, and PHP, allowing easy access to language-specific queries in the codebase.",
    "importStatements": ""
  },
  {
    "id": "d4848510-9224-485f-bc65-3f6fa41fa50b",
    "fullName": "\\src\\queries\\index",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\n\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\r\n    // found all import statements\r\n    importStatements: string\r\n    // found all definitions, such as classes, functions, etc\r\n    constructorDefinitions: string\r\n    // found name and body of each definition\r\n    definitionTemplate: string\r\n    // found export clauses, necessary for js, ts and tsx\r\n    exportClauses: string\r\n    // found all (global) assignments\r\n    assignments: string\r\n    // for instance, if the assignment is a class and the code uses a method globally, add it to the assignment code\r\n    extraAssignmentCode: (name: string) => string\r\n    // found all calls\r\n    calls: string\r\n    // found space declaration, such as using \"package\" in java, or \"namespace\" in PHP, C#, etc\r\n    spaceDeclaration: string\r\n}",
    "codeNoBody": "import { jsQueries } from \"./javascript\"\r\nimport { tsQueries } from \"./typescript\"\r\nimport { pyQueries } from \"./python\"\r\nimport { javaQueries } from \"./java\"\r\nimport { cQueries } from \"./c\"\r\nimport { phpQueries } from \"./php\"\r\nexport const languageQueries = {\r\n    Javascript: jsQueries,\r\n    Typescript: tsQueries,\r\n    Python: pyQueries,\r\n    Java: javaQueries,\r\n    C: cQueries,\r\n    PHP: phpQueries,\r\n}\r\n\r\n\r\nexport interface treeSitterQueries {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\index.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/queries/index.ts` Wiki\n\n## Overview\nThe `src/queries/index.ts` file serves as a central hub for managing language-specific queries within the codebase. It consolidates and exports queries tailored for different programming languages, making it easier to handle language-specific operations in a unified manner.\n\n## Main Features\n\n### Language Queries\nThe file imports query modules for various programming languages and combines them into a single object, `languageQueries`. This object provides a structured way to access queries specific to each language.\n\n- **JavaScript Queries (`jsQueries`)**: Contains queries related to JavaScript code analysis.\n- **TypeScript Queries (`tsQueries`)**: Contains queries for TypeScript code analysis.\n- **Python Queries (`pyQueries`)**: Contains queries for Python code analysis.\n- **Java Queries (`javaQueries`)**: Contains queries for Java code analysis.\n- **C Queries (`cQueries`)**: Contains queries for C code analysis.\n- **PHP Queries (`phpQueries`)**: Contains queries for PHP code analysis.\n\n### `languageQueries` Object\nThe `languageQueries` object is a key export of this file. It maps each programming language to its corresponding set of queries, allowing other parts of the codebase to easily access and utilize these queries.\n\n```typescript\nexport const languageQueries = {\n    Javascript: jsQueries,\n    Typescript: tsQueries,\n    Python: pyQueries,\n    Java: javaQueries,\n    C: cQueries,\n    PHP: phpQueries,\n}\n```\n\n### `treeSitterQueries` Interface\nThe `treeSitterQueries` interface defines the structure for query properties used to extract various elements from the codebase. This includes import statements, constructor definitions, function calls, and more. Although the detailed properties are not shown in the snippet, this interface ensures consistency and type safety for query definitions.\n\n```typescript\nexport interface treeSitterQueries {\n    // Interface properties for various code extraction queries\n}\n```\n\n## Purpose\nThe primary purpose of the `src/queries/index.ts` file is to provide a centralized and organized way to manage and access language-specific queries. By consolidating these queries into a single object, the file simplifies the process of performing language-specific code analysis and transformations across the codebase. This modular approach enhances maintainability and scalability, allowing for easy updates and additions of new languages or query types in the future.",
    "importStatements": "import { jsQueries } from \"./javascript\"\nimport { tsQueries } from \"./typescript\"\nimport { pyQueries } from \"./python\"\nimport { javaQueries } from \"./java\"\nimport { cQueries } from \"./c\"\nimport { phpQueries } from \"./php\""
  },
  {
    "id": "9899ea94-ca6a-487d-86d0-f20eab48348c",
    "fullName": "\\src\\queries\\java::javaQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "export const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "javaQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The `javaQueries` object in this code defines various tree-sitter queries for analyzing Java code, such as identifying import statements, constructor definitions, variable assignments, method calls, and space declarations. The `anyAssignments` query specifically captures variable assignments in Java code, including the variable name and corresponding value on the right-hand side.",
    "importStatements": ""
  },
  {
    "id": "91d51f3b-b772-4d16-b86e-b9b99d49da69",
    "fullName": "\\src\\queries\\java::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// > my_class.my_method()\r",
    "code": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The `anyAssignments` query identifies variable assignments in Java code, capturing the left-hand side variable name and the corresponding right-hand side value, which can be an identifier or an object creation expression.",
    "importStatements": ""
  },
  {
    "id": "96899855-79d8-4bc7-aea7-b701d657e3c3",
    "fullName": "\\src\\queries\\java::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The \"calls\" assignment in the queries folder defines patterns for method invocations and type identifiers using placeholders for identifier names and parameter types.",
    "importStatements": ""
  },
  {
    "id": "0c16c837-1a41-428d-ac93-e3a696f689b3",
    "fullName": "\\src\\queries\\java::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// No assignments\r",
    "code": "const extraAssignmentCode = (name: string) => ``",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The function \"extraAssignmentCode\" takes a parameter \"name\" of type string and returns an empty string. It is used to generate extra assignment code based on the provided name.",
    "importStatements": ""
  },
  {
    "id": "ffbd5836-169c-4b32-a968-3d192a4cd8fd",
    "fullName": "\\src\\queries\\java::spaceDeclaration",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Space Declaration: package\r",
    "code": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "codeNoBody": "const spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "spaceDeclaration",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The `spaceDeclaration` function generates a package declaration query for a given space name in Java, allowing users to easily create queries for space declarations in the codebase.",
    "importStatements": ""
  },
  {
    "id": "39a92653-9ee2-4396-9898-1da0a83ad844",
    "fullName": "\\src\\queries\\java::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// modifier can be public, private or protected. By default is private\r",
    "code": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "The `definitionTemplate` constant in this code snippet represents a template for defining Java methods, capturing modifiers, return type, method name, parameters, and method body using regular expressions.",
    "importStatements": ""
  },
  {
    "id": "d161171b-aca5-4e72-a71d-d1e065e60965",
    "fullName": "\\src\\queries\\java::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Java has no global assignments\r",
    "code": "const assignments = ``",
    "codeNoBody": "const assignments = ``",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "generatedDocumentation": "Code: const assignments = ``",
    "importStatements": ""
  },
  {
    "id": "964ec5b5-7339-47c3-81d9-36b6e74cd68b",
    "fullName": "\\src\\queries\\java",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for Java\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = ``\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for Java\r\n// It considers:\r\n// - Import statements\r\n// - Class definitions\r\n\r\n// - Class and methods\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\nconst importStatements = `\r\n(import_declaration \r\n\t[(scoped_identifier\r\n    \tscope: (_) @module\r\n        name: (_) @name)\r\n    (identifier) @module\r\n    ]\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Java has no global assignments\r\nconst assignments = {\n//...\n}\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n// modifier can be public, private or protected. By default is private\r\nconst definitionTemplate = `\r\n( _\r\n\t(modifiers) @modifier \r\n    type: (_)? @return_type\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    body: (_) @body\r\n)?\r\n`\r\n\r\n\r\n// constructor methods have the same name as the class\r\n// NOTE: @function is passed as method if is inside a class\r\nconst constructorDefinitions = `\r\n(constructor_declaration)? @function\r\n(method_declaration)? @function\r\n(class_declaration) @class\r\n`\r\n\r\n////////\r\n// Space Declaration: package\r\nconst spaceDeclaration = `\r\n(package_declaration (_) @spaceName)\r\n`\r\n\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// No assignments\r\nconst extraAssignmentCode = (name: string) => `` \r\n\r\n\r\nconst calls = `\r\n(method_invocation) @identifier.name\r\n(type_identifier) @parameter_type\r\n( _ object: _ @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\nconst anyAssignments = `\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (object_creation_expression type: _ @right) \r\n    ] \r\n) @assignment\r\n`\r\n\r\nexport const javaQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\java.ts",
    "originFile": "",
    "generatedDocumentation": "# Java Queries for Tree-Sitter\n\n## Overview\nThe `java.ts` file in the `src/queries` directory defines a set of queries for analyzing Java code using the Tree-sitter parsing library. These queries are used to identify various elements within Java source code, such as import statements, class definitions, method calls, and variable assignments. The primary purpose of this file is to facilitate the extraction and analysis of Java code structures, which can be useful for tasks like code indexing, static analysis, and code navigation.\n\n## Main Features\n### Import Statements\nThe `importStatements` query captures Java import declarations. It identifies both scoped and unscoped identifiers within import statements.\n\n```typescript\nconst importStatements = `\n(import_declaration \n\t[(scoped_identifier\n    \tscope: (_) @module\n        name: (_) @name)\n    (identifier) @module\n    ]\n) @import_statement\n`\n```\n\n### Assignments\nJava does not have global assignments, but the `anyAssignments` query captures variable assignments within methods or classes. It identifies the variable name on the left-hand side and the corresponding value on the right-hand side, which can be an identifier or an object creation expression.\n\n```typescript\nconst anyAssignments = `\n(variable_declarator\n\tname: (identifier) @left\n    value: [\n    (identifier) @right\n    (object_creation_expression type: _ @right) \n    ] \n) @assignment\n`\n```\n\n### Definitions Template\nThe `definitionTemplate` provides a generic template for defining Java methods, capturing modifiers (public, private, protected), return type, method name, parameters, and method body.\n\n```typescript\nconst definitionTemplate = `\n( _\n\t(modifiers) @modifier \n    type: (_)? @return_type\n    name: (_) @name\n    parameters: (formal_parameters (_) @param)?\n    body: (_) @body\n)?\n`\n```\n\n### Constructor Definitions\nThe `constructorDefinitions` query captures both constructor and method declarations within classes.\n\n```typescript\nconst constructorDefinitions = `\n(constructor_declaration)? @function\n(method_declaration)? @function\n(class_declaration) @class\n`\n```\n\n### Space Declaration\nThe `spaceDeclaration` query captures package declarations in Java code.\n\n```typescript\nconst spaceDeclaration = `\n(package_declaration (_) @spaceName)\n`\n```\n\n### Calls\nThe `calls` query identifies method invocations and type identifiers, capturing the names of the methods and parameter types.\n\n```typescript\nconst calls = `\n(method_invocation) @identifier.name\n(type_identifier) @parameter_type\n( _ object: _ @identifier.name)\n`\n```\n\n### Extra Assignment Code\nThe `extraAssignmentCode` function is designed to generate additional assignment code based on a provided name, although it currently returns an empty string.\n\n```typescript\nconst extraAssignmentCode = (name: string) => ``\n```\n\n## Exported Queries\nThe `javaQueries` object consolidates all the defined queries and exports them for use in other parts of the codebase.\n\n```typescript\nexport const javaQueries: treeSitterQueries = {\n    importStatements,\n    constructorDefinitions: assignments + constructorDefinitions,\n    definitionTemplate,\n    exportClauses: '',\n    extraAssignmentCode,\n    calls,\n    assignments: anyAssignments,\n    spaceDeclaration\n}\n```\n\n## Purpose\nThe `java.ts` file serves as a comprehensive set of Tree-sitter queries tailored for Java code. These queries enable the extraction of various code elements, facilitating tasks such as code indexing, static analysis, and code navigation. By defining these queries, the file provides a structured way to analyze and interact with Java source code programmatically.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "246f919b-dd8b-4fb5-8e6f-b2f6fbb0bd74",
    "fullName": "\\src\\queries\\javascript::jsQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "codeNoBody": "export const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "jsQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `jsQueries` assignment in the codebase-index-ts repository contains tree-sitter queries for JavaScript code analysis, including import statements, constructor definitions, definition templates, export clauses, extra assignment code, function calls, and various assignment patterns like assignment expressions, variable declarations, and specific call expressions such as forEach, map, and reduce, supporting comprehensive JavaScript code analysis.",
    "importStatements": ""
  },
  {
    "id": "c813dc4b-d97f-4738-8186-e375fca41306",
    "fullName": "\\src\\queries\\javascript::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
    "codeNoBody": "const anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `anyAssignments` assignment in the codebase-index-ts repository defines patterns for matching assignment expressions, variable declarations, and specific call expressions like forEach, map, and reduce, using AST node structures with identifiers, member expressions, and arrow functions, supporting various assignment scenarios in JavaScript code analysis.",
    "importStatements": ""
  },
  {
    "id": "a0bac960-3ccc-4715-9eaf-33283e969a66",
    "fullName": "\\src\\queries\\javascript::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifer.name\r\n\r\n`;",
    "codeNoBody": "const calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifer.name\r\n\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `calls` assignment in this codebase contains a series of structured patterns for identifying and extracting call expressions, member expressions, arguments, new expressions, keyword arguments, object properties, format strings, and shorthand identifiers within JavaScript code, using AST patterns with identifiers as the main focus for each pattern.",
    "importStatements": ""
  },
  {
    "id": "60acbc56-181c-426e-95b3-6936a49b0dc0",
    "fullName": "\\src\\queries\\javascript::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// It will include the myEndpoint.get to the code of the assignment\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `extraAssignmentCode` function takes a `name` parameter and generates a JavaScript AST representing an assignment expression with the provided `name`. The function constructs an AST node for an assignment statement using the input `name` parameter and returns the resulting AST as a string.",
    "importStatements": ""
  },
  {
    "id": "4a55f166-8519-4894-9a33-2e2205e168cd",
    "fullName": "\\src\\queries\\javascript::exportClauses",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Export clauses can contain an alias\r",
    "code": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
    "codeNoBody": "const exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "exportClauses",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `exportClauses` assignment defines a pattern for extracting export clauses from JavaScript code, capturing the name and alias of the export specifier along with the module name if present.",
    "importStatements": ""
  },
  {
    "id": "89868afb-7b2e-433d-80b3-03cb65ebeed4",
    "fullName": "\\src\\queries\\javascript::arrowFunctionConstructor",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
    "codeNoBody": "const arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "arrowFunctionConstructor",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The \"arrowFunctionConstructor\" in the codebase-index-ts repository defines a string representation of an arrow function using a specific syntax for a lexical declaration with a variable declarator and an arrow function value.",
    "importStatements": ""
  },
  {
    "id": "958005ff-6a0d-4094-befd-f2725ecb2611",
    "fullName": "\\src\\queries\\javascript::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "generatedDocumentation": "The `definitionTemplate` constant defines a template for capturing the structure of a function or arrow function in JavaScript, including elements like name, parameters, body, and value, providing a clear representation of these components in a concise format.",
    "importStatements": ""
  },
  {
    "id": "0087b89b-3264-4842-af79-f038736e099f",
    "fullName": "\\src\\queries\\javascript",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for JavaScript\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n( program\r\n    (expression_statement\r\n        (call_expression function:\r\n        \t[(identifier) @identifier.name\r\n             (member_expression object: (identifier) @identifier.name  ) \r\n            ]\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n    )\r\n) \r\n`;\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifer.name\r\n\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};\r\n",
    "codeNoBody": "// Tree-sitter definition + call queries for JavaScript\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from \"./index\";\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(import_statement \r\n    (import_clause [\r\n    (namespace_import (identifier) @alias)\r\n    (identifier) @name\r\n    (named_imports (import_specifier\r\n\t\t    name: (_) @name\r\n    \t\talias: (_)? @alias))\r\n    ])?\r\n\tsource: (string (string_fragment) @module)\r\n) @import_statement\r\n\r\n\r\n(lexical_declaration\r\n    (variable_declarator\r\n      name: [\r\n          (identifier) @alias\r\n          (object_pattern (_) @alias)\r\n      ]\r\n      value: [(call_expression\r\n                  function: _ @function\r\n                  arguments: (arguments (string (string_fragment) @module))\r\n                  (#eq? @function \"require\"))\r\n              ( member_expression\r\n                (call_expression\r\n                    function: _ @function\r\n                    arguments: (arguments (string (string_fragment) @module))\r\n                    (#eq? @function \"require\")\r\n                )\r\n                (property_identifier) @name\r\n               )\r\n              ]\r\n    )           \r\n  ) @import_statement\r\n`;\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n    (_\r\n        (variable_declarator\r\n            name: (identifier)\r\n            value: (_ !body) @v ; !body to exclude arrow functions\r\n            (#not-match? @v \"require*\") ; to exclude require imports\r\n        ) \r\n    ) @assignment\r\n) \r\n\r\n; exportables\r\n(program\r\n    (export_statement\r\n        (_\r\n            (variable_declarator\r\n                name: (identifier)\r\n                value: (_ !body)\r\n            ) \r\n        ) \r\n    ) @assignment\r\n)\r\n`;\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`;\r\n\r\nconst arrowFunctionConstructor =\r\n  \"(lexical_declaration (variable_declarator value: (arrow_function) ) )\";\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\nconst constructorDefinitions = `\r\n; export\r\n(export_statement) @export\r\n\r\n; functions\r\n(function_declaration) @function\r\n\r\n; arrow functions\r\n${arrowFunctionConstructor} @function\r\n\r\n; classes\r\n(method_definition)? @method\r\n(class_declaration) @class\r\n`;\r\n\r\n////////////////////\r\n// EXPORTS_CLAUSES //\r\n////////////////////\r\n// Export clauses can contain an alias\r\nconst exportClauses = `\r\n( export_statement \r\n (export_clause (\r\n    export_specifier\r\n        name: (_) @name\r\n          alias: (_)? @alias\r\n          )\r\n    )\r\n  (string (string_fragment) @module)?\r\n) @export_clause\r\n`;\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n};\r\n\r\nconst calls = `\r\n; any call\r\n(call_expression function: (_) @identifier.name)\r\n\r\n; calls to member expressions \r\n(assignment_expression right: (member_expression) @identifier.name)\r\n\r\n; arguments\r\n(arguments (identifier) @identifier.name)\r\n\r\n; any member_expression\r\n( _ (member_expression) @identifier.name)\r\n\r\n; new_expression\r\n(new_expression (identifier) @identifier.name)\r\n\r\n; keyword arguments\r\n(pair value: [(identifier) @identifier.name\r\n               ; bynary_expressions, different levels\r\n\t\t\t   (( _ (identifier) @identifier.name )) \r\n               (( _ ( _ (identifier) @identifier.name )))\r\n               (( _ ( _ ( _ (identifier) @identifier.name ))))\r\n\t\t\t ])\r\n( variable_declarator value: (identifier) @identifier.name)\r\n\r\n; any object\r\n( _ object: _ @identifier.name)\r\n\r\n; format strings\r\n(template_substitution _ @identifier.name)\r\n\r\n; shorthand identifier\r\n(shorthand_property_identifier) @identifer.name\r\n\r\n`;\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(assignment_expression\r\n\tleft: (identifier) @left\r\n    right: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n(variable_declarator\r\n\tname: (identifier) @left\r\n    value: [\r\n    (identifier) @right\r\n    (member_expression) @right\r\n    (new_expression constructor: _ @right )\r\n    ] \r\n) @assignment\r\n\r\n; experimental, cases like object.forEach( o => ...), supports forEach, map and reduce\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"forEach\" \"map\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters . ((_) @right) ;first param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n\r\n(call_expression\r\n    function:\r\n    ( member_expression .\r\n      object: (identifier) @left\r\n      property: (property_identifier) @property\r\n      (#any-of? @property \"reduce\")\r\n    )\r\n     arguments:\r\n     (arguments\r\n          (arrow_function parameters:\r\n            (formal_parameters  ( (_) @right) . ;last param\r\n           )\r\n         )\r\n    ) \r\n) @assignment\r\n`;\r\n\r\nexport const jsQueries: treeSitterQueries = {\r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  exportClauses,\r\n  extraAssignmentCode,\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: \"\",\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\javascript.ts",
    "originFile": "",
    "generatedDocumentation": "# JavaScript Queries for Codebase Analysis\n\n## Overview\nThe `javascript.ts` file in the `codebase-index-ts` repository is designed to define and export a set of tree-sitter queries specifically tailored for analyzing JavaScript code. These queries are used to parse and extract various code constructs and patterns, facilitating comprehensive code analysis.\n\n## Main Features\n\n### Import Statements\nThe `importStatements` query identifies and captures different forms of import statements in JavaScript:\n- Namespace imports\n- Named imports\n- Default imports\n- Imports using `require`\n\n### Assignments\nThe `assignments` query focuses on capturing global variable assignments while excluding arrow functions and `require` imports. It also includes exportable assignments.\n\n### Definitions Template\nThe `definitionTemplate` provides a structure for capturing function and arrow function definitions, including:\n- Function name\n- Parameters\n- Body\n\n### Constructor Definitions\nThe `constructorDefinitions` query captures various constructs such as:\n- Export statements\n- Function declarations\n- Arrow functions\n- Class declarations\n- Method definitions\n\n### Export Clauses\nThe `exportClauses` query captures export statements, including:\n- Export specifiers with optional aliases\n- Module names\n\n### Function Calls\nThe `calls` query identifies various call expressions and member expressions, including:\n- Function calls\n- Member expressions\n- Arguments\n- New expressions\n- Keyword arguments\n- Object properties\n- Format strings\n- Shorthand identifiers\n\n### Extra Assignment Code\nThe `extraAssignmentCode` function generates additional assignment code for specific scenarios, enhancing the analysis of assignments.\n\n### Any Assignments\nThe `anyAssignments` query captures a wide range of assignment patterns, including:\n- Assignment expressions\n- Variable declarations\n- Specific call expressions like `forEach`, `map`, and `reduce`\n\n## Purpose\nThe purpose of the `javascript.ts` file is to provide a comprehensive set of tree-sitter queries for analyzing JavaScript code. These queries help in identifying and extracting various code constructs, enabling detailed code analysis and understanding. This is particularly useful for tasks such as code indexing, refactoring, and static analysis.\n\nBy leveraging these queries, developers can gain insights into the structure and behavior of JavaScript code, facilitating better code management and maintenance.",
    "importStatements": "import { treeSitterQueries } from \"./index\";"
  },
  {
    "id": "925be8c1-1865-4bc7-b36c-7ade0a2794cf",
    "fullName": "\\src\\queries\\php::phpQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "export const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "phpQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The `phpQueries` assignment in the codebase-index-ts repository contains tree-sitter queries for parsing PHP code, including import statements, constructor definitions, definition templates, extra assignment code, function calls, any assignments, and space declarations, facilitating the analysis of PHP code structures and elements.",
    "importStatements": ""
  },
  {
    "id": "95fa76bd-ca7d-4385-9fac-8d40eca0908f",
    "fullName": "\\src\\queries\\php::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The `anyAssignments` assignment in the codebase-index-ts repository defines a template for parsing assignment expressions in a specified format, including variable names, member access expressions, object creation expressions, and formal parameters.",
    "importStatements": ""
  },
  {
    "id": "ea461af9-2f48-4946-bb95-3fbd7256b74d",
    "fullName": "\\src\\queries\\php::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The \"calls\" assignment in the codebase extracts identifiers from function calls, parameter types, member calls, and member accesses using specific patterns defined in the provided typescript code.",
    "importStatements": ""
  },
  {
    "id": "12299dde-5296-491d-ad97-11712e655a55",
    "fullName": "\\src\\queries\\php::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// It will include the myEndpoint.get to the code of the assignment\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The `extraAssignmentCode` function takes a `name` parameter and generates a program code snippet that checks if a variable name matches the provided `name` parameter using an equality comparison operator.",
    "importStatements": ""
  },
  {
    "id": "782725c2-62bd-46bb-ae4e-795b6b25ea3b",
    "fullName": "\\src\\queries\\php::spaceDeclaration",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Space Declaration: namespace\r",
    "code": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "codeNoBody": "const spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "spaceDeclaration",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The `spaceDeclaration` constant defines a namespace with a specified name and body, using a template string with placeholders for the namespace name and content.",
    "importStatements": ""
  },
  {
    "id": "7d587664-c92d-4237-a490-a6bacaaf137a",
    "fullName": "\\src\\queries\\php::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The `definitionTemplate` in the codebase provides a structured template for defining functions or methods with optional visibility modifiers, parameters, return types, and bodies, as well as a separate template for global assignments using variable names.",
    "importStatements": ""
  },
  {
    "id": "cfbf74e3-c5d2-41b4-b337-bad6a6a73907",
    "fullName": "\\src\\queries\\php::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Global only\r",
    "code": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "generatedDocumentation": "The code in \"\\src\\queries\\php::signments\" defines a program structure with an assignment expression that assigns a variable name to an underscore, capturing it as an assignment.",
    "importStatements": ""
  },
  {
    "id": "0a01c189-66fa-4d61-92d7-60f7944665f1",
    "fullName": "\\src\\queries\\php",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition + call queries for PHP\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => `\r\n(program\r\n\t(expression_statement\r\n\t\t(binary_expression left: (_\r\n        \t\t(variable_name (name) @identifier.name))\r\n        (#eq? @identifier.name \"${name}\")\r\n        ) @code\r\n\t) \r\n)\r\n`\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "codeNoBody": "// Tree-sitter definition + call queries for PHP\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Export clauses\r\n\r\n// - Class, Method and Function calls\r\n// - member expressions like this.my_method and Class.my_method\r\n// - Arguments\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// If there is no import.name  then no component is really imported\r\n// import.module considers only the string fragment\r\nconst importStatements = `\r\n(expression_statement (include_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (include_once_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_expression (string (string_content) @module ))) @import_statement\r\n(expression_statement (require_once_expression (string (string_content) @module ))) @import_statement\r\n(namespace_use_declaration\r\n (namespace_use_clause\r\n\t(qualified_name \r\n    \t(namespace_name_as_prefix (namespace_name) @module) \r\n        (name) @name  \r\n \t)\r\n    (namespace_aliasing_clause (name) @alias)?\r\n )\r\n) @import_statement\r\n`\r\n\r\n/////////////////\r\n// ASSIGNMENTS //\r\n/////////////////\r\n// Arrow functions are like assignments but contains a body in value\r\n// Therefore, to remove them from assignments check if body exists in @right\r\n\r\n// Global only\r\nconst assignments = `\r\n(program\r\n\t(expression_statement\r\n\t\t(assignment_expression left: (variable_name)\r\n        \t\t\t\t\t   right: (_)\r\n        ) @assignment \r\n\t) \r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n  (visibility_modifier)? @modifier\r\n  name: (_) @name\r\n  parameters: (formal_parameters (_) @param)?\r\n  return_type: _? @return_type\r\n  body: (_) @body ; NOTE: interfaces do not have a body\r\n)\r\n\r\n; For global assignments   \r\n(assignment_expression left: (variable_name (name) @name))\r\n`\r\n\r\n\r\nconst constructorDefinitions = `\r\n(class_declaration) @class\r\n(method_declaration) @function ; also considered as a function\r\n(function_definition) @function\r\n(interface_declaration) @interface\r\n(namespace_definition body: (_) ) @namespace\r\n`\r\n\r\n////////\r\n// Space Declaration: namespace\r\nconst spaceDeclaration = `\r\n(namespace_definition name: (_) @spaceName !body)\r\n`\r\n\r\n// ASSIGNMENT SPECIAL CASE\r\n// this is for example if I use something like\r\n// ```\r\n// const myEndpoint = new Hono()\r\n// myEndpoint.get('/', (c) => c.text('Hello World'))\r\n// ```\r\n// It will include the myEndpoint.get to the code of the assignment\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n(function_call_expression (name) @identifier.name)\r\n(named_type) @parameter_type\r\n(member_call_expression) @identifier.name\r\n(member_access_expression) @identifier.name\r\n(_ object: (name) @identifier.name)\r\n`\r\n\r\n///////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = `\r\n(expression_statement\r\n  (assignment_expression left: (variable_name) @left\r\n                  right: [\r\n                  (member_access_expression) @right\r\n                  (variable_name) @right\r\n                  (object_creation_expression (name) @right)\r\n                  ]\r\n    ) @assignment \r\n) \r\n\r\n(_\r\n  parameters: (formal_parameters\r\n          (_ (named_type) @right (variable_name) @left) @assignment)?\r\n)\r\n`\r\n\r\nexport const phpQueries: treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions: assignments + constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses: '',\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\php.ts",
    "originFile": "",
    "generatedDocumentation": "# PHP Queries Module\n\n## Overview\nThe `php.ts` file in the `codebase-index-ts` repository is designed to facilitate the analysis and parsing of PHP code structures and elements using Tree-sitter queries. This module provides a comprehensive set of queries to identify and extract various PHP code constructs such as import statements, assignments, function and class definitions, and function calls.\n\n## Main Features\n\n### Import Statements\nThe `importStatements` query captures different types of PHP import expressions, including `include`, `include_once`, `require`, and `require_once`. It also handles namespace use declarations.\n\n### Assignments\nThe `assignments` query identifies global assignment expressions. It ensures that arrow functions, which are similar to assignments but contain a body, are excluded from this category.\n\n### Definitions Template\nThe `definitionTemplate` provides a structured template for defining functions or methods. It includes optional visibility modifiers, parameters, return types, and bodies. It also includes a template for global assignments using variable names.\n\n### Constructor Definitions\nThe `constructorDefinitions` query captures class declarations, method declarations, function definitions, interface declarations, and namespace definitions.\n\n### Space Declaration\nThe `spaceDeclaration` query defines a namespace with a specified name and body.\n\n### Extra Assignment Code\nThe `extraAssignmentCode` function generates a program code snippet that includes additional assignment code for specific cases, such as when using member expressions.\n\n### Calls\nThe `calls` query extracts identifiers from function calls, parameter types, member calls, and member accesses.\n\n### Any Assignments\nThe `anyAssignments` query defines a template for parsing assignment expressions, including variable names, member access expressions, object creation expressions, and formal parameters.\n\n## Important Definitions\n\n- **phpQueries**: An object that consolidates all the defined queries, making them accessible for parsing and analyzing PHP code.\n- **importStatements**: Captures various PHP import expressions.\n- **assignments**: Identifies global assignment expressions.\n- **definitionTemplate**: Provides a template for function and method definitions.\n- **constructorDefinitions**: Captures various PHP declarations including classes and functions.\n- **spaceDeclaration**: Defines a namespace with a specified name.\n- **extraAssignmentCode**: Generates additional assignment code for specific cases.\n- **calls**: Extracts identifiers from various types of function and member calls.\n- **anyAssignments**: Defines a template for parsing assignment expressions.\n\n## Purpose\nThe purpose of the `php.ts` file is to provide a set of Tree-sitter queries that can be used to parse and analyze PHP code. These queries help in identifying and extracting various code constructs, which can be useful for tasks such as code indexing, static analysis, and code navigation. By providing a structured way to capture these elements, the module aids in the efficient processing and understanding of PHP codebases.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "565f0bc7-0dfc-42a4-8ae3-6c995fb06836",
    "fullName": "\\src\\queries\\python::pyQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "pyQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The `pyQueries` module in the repository provides tree-sitter queries for Python code, including identifying import statements, constructor definitions, function calls, and assignments within the abstract syntax tree (AST), utilizing the `anyAssignments` query to capture assignment operations and function parameters.",
    "importStatements": ""
  },
  {
    "id": "2dd3420c-2986-4d99-bc55-4039cca87405",
    "fullName": "\\src\\queries\\python::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "codeNoBody": "const anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The `anyAssignments` query identifies assignments within an abstract syntax tree (AST) by capturing the left and right sides of the assignment operation, as well as parameters within function definitions.",
    "importStatements": ""
  },
  {
    "id": "c16abfe7-85cb-4a1d-8051-e85f8544ca81",
    "fullName": "\\src\\queries\\python::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "codeNoBody": "const calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The `calls` assignment in the codebase provides patterns to extract information related to class and function calls, method calls, self.parameter calls, class extensions, pydantic-like parameters, typed parameters and return types, assignments with identifiers, keyword arguments, attributes, object names, format strings, and arguments, facilitating the analysis and processing of Python code for various functionalities and structures.",
    "importStatements": ""
  },
  {
    "id": "1082a3dd-7416-4628-857d-86ea30342c15",
    "fullName": "\\src\\queries\\python::extraAssignmentCode",
    "type": "function",
    "language": "typescript",
    "documentation": "// We need to know the assignment name\r",
    "code": "const extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`",
    "codeNoBody": "const extraAssignmentCode = (name: string) => {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The `extraAssignmentCode` function takes a `name` parameter and generates a code snippet that checks for a specific identifier name within a module's expression statement. The function creates a call function with the provided identifier name and checks for equality with the given `name`. The commented-out section shows an alternative implementation using a decorated definition.",
    "importStatements": ""
  },
  {
    "id": "868358e7-f4f4-47f3-a31f-96d7dc444956",
    "fullName": "\\src\\queries\\python::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The `definitionTemplate` constant in the code defines a template for capturing function definitions with properties like name, parameters, return type, body, and documentation, as well as global assignments using identifiers.",
    "importStatements": ""
  },
  {
    "id": "9fce9a56-c74b-4891-9761-6bad542c8691",
    "fullName": "\\src\\queries\\python::signments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// Globals only\r",
    "code": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "codeNoBody": "const assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "signments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "generatedDocumentation": "The \"assignments\" code defines a module with an expression statement that assigns a value to an identifier, providing a structured representation of assignment operations in Python code.",
    "importStatements": ""
  },
  {
    "id": "3b0b9f96-33f7-40bb-97bf-bc5d10ce3e88",
    "fullName": "\\src\\queries\\python",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition queries for Python\r\n\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => `\r\n( module\r\n  (expression_statement\r\n      (call function:\r\n        [(identifier) @identifier.name\r\n           (attribute object: (identifier) @identifier.name  ) \r\n          ]\r\n      (#eq? @identifier.name \"${name}\")\r\n      ) @code\r\n  )\r\n) \r\n\r\n; not used\r\n;( module\r\n;  ( decorated_definition\r\n;\t(decorator [\r\n;    \t( call (attribute object: _ @identifier.name)) \r\n;        (attribute object: _ @identifier.name)\r\n;    \t]) @code\r\n;    (#eq? @identifier.name \"${name}\")\r\n;  )\r\n;)\r\n`\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}\r\n",
    "codeNoBody": "// Tree-sitter definition queries for Python\r\n// It considers:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n\r\n// - Class and Function calls\r\n// - Method and self.parameter calls\r\n// - Class extensions\r\n// - Pydantic like parameters\r\n// - Typed parameters and return types of methods and functions\r\n\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// Future imports have __future__ as module name\r\n// if import.has_wildcard exists then it is a wildcard (*) import of name \r\nconst importStatements = `\r\n(import_statement\r\n\tname: [\r\n      (dotted_name) @module\r\n      (aliased_import name: _ @module alias: _ @alias)\r\n    ] ) @import_statement\r\n\r\n(import_from_statement\r\n\tmodule_name: _ @module\r\n\tname: [\r\n      (dotted_name) @name\r\n      (aliased_import name: _ @name alias: _ @alias)\r\n    ]?\r\n    (wildcard_import _ @wildcard)?\r\n    ) @import_statement\r\n    \r\n(future_import_statement \r\n\tname: [\r\n\t\t(dotted_name) @name\r\n\t\t(aliased_import name: _ @name alias: _ @alias)\r\n    ]) @import_statement\r\n`\r\n\r\n//////////////////////////////\r\n// ASSIGNMENTS //\r\n//////////////////////////////\r\n// Globals only\r\nconst assignments = `\r\n(module (expression_statement\r\n\t(assignment left: (identifier)\r\n    \t\t      right: (_)) \r\n      ) @assignment\r\n)\r\n`\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\n\r\nconst definitionTemplate = `\r\n( _\r\n      name: (identifier) @name\r\n      parameters: (parameters (_) @param)?\r\n      return_type: _? @return_type\r\n      body: (block . (expression_statement (string) @documentation)? .\r\n          _ ) @body )\r\n\r\n; For global assignments   \r\n(expression_statement\r\n\t(assignment left: (identifier) @name)\r\n      )\r\n`\r\n\r\n// The only way to detect if is async is to check if the function definition contains \"async\"\r\n// In Python all constructor are exportable by default\r\nconst constructorDefinitions = `\r\n(function_definition) @function\r\n(class_definition) @class\r\n`\r\n\r\n//// ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = (name: string) => {\n//...\n}\r\n\r\nconst calls = `\r\n; class and function calls\r\n(call function: ( (identifier) @identifier.name))\r\n\r\n; method calls like Class.method\r\n(call function: ( (attribute) @identifier.name))\r\n\r\n; self.parameter calls like self.parameter\r\n((attribute\r\n    object: (identifier) @object\r\n    attribute: (identifier) @property\r\n    (#eq? @object \"self\")) @identifier.name)\r\n\r\n\r\n; class extensions\r\n(class_definition\r\n    superclasses : (argument_list (_) @class.extends)?\r\n    body: (block\r\n            (function_definition name: _ @class.method)?)) @class.definition\r\n\r\n; pydantic like parameters                                        \r\n(class_definition\r\n        superclasses : (argument_list (_) @class.extends)?\r\n        body: (block\r\n                (expression_statement\r\n                    (assignment type: (_)? @parameter_type) @assignment))\r\n        ) @class.definition\r\n\r\n; typed parameters and return types\r\n(function_definition\r\n    parameters: (parameters( typed_parameter type: _ @parameter_type)?)\r\n    return_type: (_)? @return_type) @function.definiton\r\n\r\n; assignments where they are identifiers\r\n(expression_statement\r\n\t(assignment right: (identifier) @identifier.name)\r\n)\r\n\r\n; keyword arguments\r\n(keyword_argument  value: (identifier) @identifier.name)\r\n\r\n; any attribute\r\n(_ (attribute) @identifier.name)\r\n\r\n; arguments (identifier only)\r\n(argument_list (identifier) @identifier.name)\r\n\r\n; any object name\r\n( _ object: _ @identifier.name)\r\n\r\n; format string\r\n(interpolation expression: _  @identifier.name)\r\n`\r\n\r\n/////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\n\r\nconst anyAssignments = `\r\n(assignment\r\n    left: (identifier) @left\r\n    right: (_) @right\r\n) @assignment\r\n                          \r\n(function_definition\r\n  parameters: (\r\n  parameters( typed_parameter (\r\n              (identifier) @left)\r\n                  type: _ @right)\r\n  @assignment)\r\n)\r\n`\r\n\r\nexport const pyQueries: treeSitterQueries = { \r\n  importStatements,\r\n  constructorDefinitions: assignments + constructorDefinitions,\r\n  definitionTemplate,\r\n  extraAssignmentCode,\r\n  exportClauses: '',\r\n  calls,\r\n  assignments: anyAssignments,\r\n  spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\python.ts",
    "originFile": "",
    "generatedDocumentation": "## Overview of `python.ts`\n\nThe `python.ts` file in the `src/queries` directory of the `codebase-index-ts` repository provides a set of tree-sitter queries specifically designed to analyze Python code. The purpose of this file is to define patterns that can be used to identify various elements within Python's abstract syntax tree (AST), such as import statements, assignments, function and class definitions, and calls. These queries facilitate the parsing and understanding of Python code structures, enabling further analysis and processing.\n\n## Main Features and Purpose\n\n### Import Statements\n\n- **`importStatements`**: This query captures different types of import statements in Python, including standard imports, wildcard imports, and future imports. It identifies the module names and aliases used in these import statements.\n\n### Assignments\n\n- **`assignments`**: This query focuses on global assignments within a Python module. It captures the left-hand side (identifier) and the right-hand side (value) of assignment operations.\n\n### Definitions Template\n\n- **`definitionTemplate`**: This template is used to capture function and class definitions. It extracts the name, parameters, return type, body, and documentation of functions and classes. It also handles global assignments.\n\n### Constructor Definitions\n\n- **`constructorDefinitions`**: This query identifies function and class definitions, including constructors. It is designed to detect if a function is asynchronous by checking for the presence of the \"async\" keyword.\n\n### Calls\n\n- **`calls`**: This comprehensive query captures various types of calls in Python code, including:\n  - Class and function calls\n  - Method calls (e.g., `Class.method`)\n  - `self.parameter` calls\n  - Class extensions\n  - Pydantic-like parameters\n  - Typed parameters and return types\n  - Assignments with identifiers\n  - Keyword arguments\n  - Attributes\n  - Object names\n  - Format strings\n  - Arguments (identifiers only)\n\n### Any Assignments\n\n- **`anyAssignments`**: This query captures assignment operations within the AST, including the left-hand side (identifier) and the right-hand side (value). It also captures parameters within function definitions.\n\n### Extra Assignment Code\n\n- **`extraAssignmentCode`**: This function generates a code snippet that checks for a specific identifier name within a module's expression statement. It is used to handle special cases of assignments.\n\n## Important Definitions\n\n- **`pyQueries`**: This exported object aggregates all the defined queries, including `importStatements`, `constructorDefinitions`, `definitionTemplate`, `extraAssignmentCode`, `calls`, `assignments`, and `anyAssignments`. This object serves as the main interface for accessing the tree-sitter queries defined in this file.\n\n## Purpose of the File\n\nThe `python.ts` file is essential for analyzing Python code within the `codebase-index-ts` repository. By defining tree-sitter queries, it enables the extraction of meaningful information from Python's AST, such as import statements, assignments, function and class definitions, and various types of calls. This information is crucial for tasks like code indexing, code analysis, and building tools that require an understanding of Python code structures.",
    "importStatements": "import { treeSitterQueries } from './index';"
  },
  {
    "id": "c21411ce-6239-44f5-a9d7-5d5bcbb267b9",
    "fullName": "\\src\\queries\\typescript::tsQueries",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "export const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "tsQueries",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `tsQueries` object in this assignment contains various tree-sitter queries for TypeScript code, including import statements, constructor definitions, definition templates, export clauses, additional assignment code, function calls, and function assignments. The `anyAssignments` function extends the existing assignments query to extract function declarations with parameters and type annotations from the codebase.",
    "importStatements": ""
  },
  {
    "id": "2883e250-dd69-4a33-851d-3889cb9b7472",
    "fullName": "\\src\\queries\\typescript::anyAssignments",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// should be considered as a call to MyClass.my_method()\r",
    "code": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "codeNoBody": "const anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "anyAssignments",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The \"anyAssignments\" function appends a query to retrieve function declarations with their parameters and type annotations to the existing \"assignments\" query in the jsQueries object, enabling the extraction of this specific type of information from the codebase.",
    "importStatements": ""
  },
  {
    "id": "e0337e21-b012-42ce-8ec1-0f34797e36ca",
    "fullName": "\\src\\queries\\typescript::calls",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "codeNoBody": "const calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calls",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `calls` assignment in the codebase includes JavaScript queries for extracting type identifiers from parameter types, with a specific note to remove self-calls for classes.",
    "importStatements": ""
  },
  {
    "id": "7897c11f-002b-422a-add1-9582b66d985e",
    "fullName": "\\src\\queries\\typescript::extraAssignmentCode",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// We need to know the assignment name\r",
    "code": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "codeNoBody": "const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "extraAssignmentCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "Code: const extraAssignmentCode = jsQueries.extraAssignmentCode",
    "importStatements": ""
  },
  {
    "id": "43b32c77-a1f8-42bb-bf4d-e010bd671ab9",
    "fullName": "\\src\\queries\\typescript::exportClauses",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//The same as for JavaScript\r",
    "code": "const exportClauses = jsQueries.exportClauses",
    "codeNoBody": "const exportClauses = jsQueries.exportClauses",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "exportClauses",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "Code: const exportClauses = jsQueries.exportClauses",
    "importStatements": ""
  },
  {
    "id": "886acc17-200d-4bc1-b5bc-0ddedc12002a",
    "fullName": "\\src\\queries\\typescript::definitionTemplate",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//////////////////////////\r",
    "code": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "codeNoBody": "const definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "definitionTemplate",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "generatedDocumentation": "The `definitionTemplate` assignment in the codebase provides a template for defining method signatures and arrow functions in TypeScript, including optional parameters, return types, and function bodies. It outlines the structure for method signatures without bodies and arrow functions with parameters, return types, and optional bodies.",
    "importStatements": ""
  },
  {
    "id": "08a21424-8e1d-4960-844e-2c1248ed8227",
    "fullName": "\\src\\queries\\typescript",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "// Tree-sitter definition queries for Typescript\r\n\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "codeNoBody": "// Tree-sitter definition queries for Typescript\r\n// It consider:\r\n// - Import statements\r\n// - Global Assignments\r\n// - Function definitions\r\n// - Class definitions\r\n// - Interface definitions\r\n// - Enums definitions\r\n// - Export clauses\r\n\r\nimport { jsQueries } from './javascript';\r\nimport { treeSitterQueries } from './index';\r\n\r\n///////////////////////\r\n// IMPORT_STATEMENTS //\r\n///////////////////////\r\n// The same as for JavaScript\r\nconst importStatements = jsQueries.importStatements\r\n\r\n\r\n//////////////////////////\r\n// DEFINITIONS TEMPLATE //\r\n//////////////////////////\r\nconst definitionTemplate = `\r\n( _\r\n    name: (_) @name\r\n    parameters: (formal_parameters (_) @param)?\r\n    return_type: (type_annotation)? @return_type\r\n    ; method signatures has no body\r\n    [body: (_)\r\n    ; for types\r\n    value: (_)] @body\r\n)?\r\n\r\n; arrow function\r\n(variable_declarator\r\n\tname: (_) @name\r\n\tvalue: (arrow_function\r\n    \tparameters: (formal_parameters (_) @param)?\r\n        return_type: (type_annotation)? @return_type\r\n        body: (_)? @body\r\n\t\t\t)\r\n)?\r\n`\r\n\r\n\r\n// The same as for JavaScript, but with interfaces and enums\r\nconst constructorDefinitions = jsQueries.constructorDefinitions + `\r\n; interfaces\r\n(method_signature)? @function\r\n(interface_declaration) @interface\r\n\r\n; enums\r\n(enum_declaration) @enum\r\n\r\n; type\r\n(program\r\n    ( type_alias_declaration\r\n        name: (_)\r\n        value: (_ !body)\r\n    ) @type\r\n) \r\n\r\n; type exportables\r\n(program\r\n    (export_statement\r\n        ( type_alias_declaration\r\n            name: (_)\r\n            value: (_ !body)\r\n        ) @type\r\n    )\r\n)\r\n`\r\n\r\n\r\n/////////////////////\r\n// EXPORTS_CLAUSES //\r\n/////////////////////\r\n//The same as for JavaScript\r\nconst exportClauses = jsQueries.exportClauses\r\n\r\n////////////////////\r\n////ASSIGNMENT SPECIAL CASE\r\n// We need to know the assignment name\r\nconst extraAssignmentCode = jsQueries.extraAssignmentCode\r\n\r\n\r\nconst calls = jsQueries.calls + `\r\n; type identifiers: IMPORTANT! for classes this means a call to itself! we need to remove it\r\n(type_identifier) @parameter_type\r\n`\r\n\r\n////////////////\r\n// Assignments are necessary to get the correct calls. For example:\r\n// > my_class = MyClass()\r\n// > my_class.my_method()\r\n// should be considered as a call to MyClass.my_method()\r\nconst anyAssignments = jsQueries.assignments + `\r\n(function_declaration\r\n\tparameters: (formal_parameters \r\n    \t(_\r\n        \t(identifier) @left\r\n        \t(type_annotation (type_identifier) @right)\r\n        ) @assignment) \r\n)\r\n`\r\n\r\nexport const tsQueries : treeSitterQueries = {\r\n    importStatements,\r\n    constructorDefinitions,\r\n    definitionTemplate,\r\n    exportClauses,\r\n    extraAssignmentCode,\r\n    calls,\r\n    assignments: anyAssignments,\r\n    spaceDeclaration: ''\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\queries\\typescript.ts",
    "originFile": "",
    "generatedDocumentation": "# TypeScript Queries File Overview\n\nThe `typescript.ts` file in the `src/queries` directory is designed to define and export tree-sitter queries specifically tailored for TypeScript code. These queries are used to parse and extract various elements from TypeScript codebases, such as import statements, function definitions, class definitions, and more. This file extends and adapts the queries defined for JavaScript to accommodate TypeScript's additional syntax and features.\n\n## Main Features and Purpose\n\n### Import Statements\n- **importStatements**: This query is identical to the one used for JavaScript and is designed to capture all import statements in a TypeScript file.\n\n### Definition Template\n- **definitionTemplate**: This template is used to define method signatures and arrow functions in TypeScript. It includes optional parameters, return types, and function bodies. It outlines the structure for method signatures without bodies and arrow functions with parameters, return types, and optional bodies.\n\n### Constructor Definitions\n- **constructorDefinitions**: This query extends the JavaScript constructor definitions to include TypeScript-specific constructs such as interfaces, enums, and type aliases. It captures method signatures, interface declarations, enum declarations, and type alias declarations.\n\n### Export Clauses\n- **exportClauses**: This query is the same as the one used for JavaScript and is designed to capture all export statements in a TypeScript file.\n\n### Extra Assignment Code\n- **extraAssignmentCode**: This is a direct import from the JavaScript queries and is used to handle special cases in assignments.\n\n### Calls\n- **calls**: This query extends the JavaScript calls query to include type identifiers from parameter types. It specifically notes the need to remove self-calls for classes to avoid incorrect parsing.\n\n### Assignments\n- **anyAssignments**: This query extends the existing JavaScript assignments query to include function declarations with parameters and type annotations. This allows the extraction of these specific types of assignments from the codebase.\n\n## Important Definitions\n\n- **tsQueries**: This is the main export of the file. It is an object containing all the tree-sitter queries tailored for TypeScript. It includes:\n  - `importStatements`\n  - `constructorDefinitions`\n  - `definitionTemplate`\n  - `exportClauses`\n  - `extraAssignmentCode`\n  - `calls`\n  - `assignments` (extended as `anyAssignments`)\n  - `spaceDeclaration` (currently an empty string)\n\nBy defining these queries, the `typescript.ts` file enables the parsing and analysis of TypeScript codebases, facilitating tasks such as code navigation, refactoring, and static analysis.",
    "importStatements": "import { jsQueries } from './javascript';\nimport { treeSitterQueries } from './index';"
  },
  {
    "id": "072d628b-3469-43ad-8410-f410dcb3f6fc",
    "fullName": "\\src\\routes\\create_graph-test::repoRequestValidator",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
    "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "repoRequestValidator",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test.ts",
    "generatedDocumentation": "The \"repoRequestValidator\" function validates a JSON object with properties for user, repo, branch, and token using zod schema validation.",
    "importStatements": ""
  },
  {
    "id": "d9f58c65-da92-4d75-bebd-a2ccaec2f915",
    "fullName": "\\src\\routes\\create_graph-test::createGraphTest",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
    "codeNoBody": "const createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraphTest = new Hono()\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraphTest }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "createGraphTest",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test.ts",
    "generatedDocumentation": "The \"createGraphTest\" function initializes an HTTP POST route that handles incoming requests, validates the request body using the \"repoRequestValidator\" function, extracts user, repo, branch, and token information, retrieves commit hash from a Git provider, downloads and extracts a repository, parses its folder structure, simplifies the codebase, and generates nodes and links for a graph representation, returning the graph data in the response.",
    "importStatements": ""
  },
  {
    "id": "fea73c69-5aca-455f-91ce-fdfaabd3d82d",
    "fullName": "\\src\\routes\\create_graph-test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    user: z.string(),\r\n    repo: z.string(),\r\n    branch: z.string(),\r\n    token: z.string()\r\n  })\r\n)\r\n\r\nconst createGraphTest = new Hono()\r\n\r\ncreateGraphTest.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    user: repoOrg,\r\n    repo: repoName,\r\n    branch,\r\n    token: gitAccessToken\r\n  } = request\r\n  console.time(repoName)\r\n  const gitProvider = 'github'\r\n  console.log({ gitProvider, repoOrg, repoName, branch })\r\n\r\n  const commitHash = await getCommitRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, '', '')\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(gitProvider, repoOrg, repoName, branch, gitAccessToken, commitHash)\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return c.json({ message: 'Failed to download repo' }, 500)\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n    const links = codebase.getLinks()\r\n  \r\n    console.timeEnd(repoName)\r\n    return c.json({ graph: { nodes, links } })\r\n  } catch (error: any) {\r\n    console.log(error)\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nexport { createGraphTest }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph-test.ts",
    "originFile": "",
    "generatedDocumentation": "# `create_graph-test.ts` Wiki\n\n## Overview\n\nThe `create_graph-test.ts` file is part of the `src/routes` directory in the `codebase-index-ts` repository. This file defines an HTTP POST route that handles requests to generate a graph representation of a codebase from a specified GitHub repository. It leverages several utilities and models to validate requests, interact with GitHub, and process the codebase.\n\n## Main Features\n\n### 1. Request Validation\n- **repoRequestValidator**: This function uses the `zod` library to validate incoming JSON requests. It ensures that the request contains the necessary properties: `user`, `repo`, `branch`, and `token`.\n\n### 2. Route Initialization\n- **createGraphTest**: This is an instance of the `Hono` framework, which is used to define and handle the HTTP POST route. The route is set up to process incoming requests at the root endpoint (`'/'`).\n\n### 3. Request Handling\n- **POST Route**: The route accepts a POST request, validates the request body using `repoRequestValidator`, and extracts the necessary information (`user`, `repo`, `branch`, `token`).\n\n### 4. GitHub Interaction\n- **getCommitRepo**: This utility function retrieves the latest commit hash from the specified GitHub repository.\n- **downloadAndExtractRepo**: This function downloads and extracts the repository at the specified commit hash.\n\n### 5. Codebase Processing\n- **Codebase Class**: An instance of the `Codebase` class is created to parse the folder structure of the downloaded repository. It then generates a simplified representation of the codebase, including nodes and links for graph visualization.\n\n### 6. Response Generation\n- **Graph Data**: The processed nodes and links are returned as a JSON response, representing the graph structure of the codebase.\n\n## Important Definitions\n\n- **repoRequestValidator**: Validates the incoming request to ensure it contains `user`, `repo`, `branch`, and `token` properties.\n- **createGraphTest**: Initializes the HTTP POST route and handles the entire process from request validation to response generation.\n- **getCommitRepo**: Retrieves the latest commit hash from the specified repository.\n- **downloadAndExtractRepo**: Downloads and extracts the repository at the specified commit hash.\n- **Codebase Class**: Parses the repository's folder structure and generates a simplified graph representation.\n\n## Purpose\n\nThe primary purpose of the `create_graph-test.ts` file is to provide an endpoint that allows users to generate a graph representation of a specified GitHub repository. This graph includes nodes and links that represent the structure and relationships within the codebase, which can be useful for visualizing and understanding the codebase's architecture.",
    "importStatements": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { downloadAndExtractRepo, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'"
  },
  {
    "id": "a3bd41c9-e9d4-49c3-b376-69fb977e1840",
    "fullName": "\\src\\routes\\create_graph::processGraphCreation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "codeNoBody": "async function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n}) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "processGraphCreation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "This async function `processGraphCreation` takes in parameters `gitProvider`, `repoId`, `userOrgId`, `userId`, `graphExists`, `connectionId`, and `codebasePath`. It creates a graph in the database based on the provided data, handling different scenarios based on the existence of the graph and the git provider. It generates a unique graph ID, inserts nodes and links into the database, and updates the graph status accordingly. In case of errors, it logs the issue and updates the graph status to 'failed'.",
    "importStatements": ""
  },
  {
    "id": "d432e02d-dee7-4992-b429-0e926eddefe4",
    "fullName": "\\src\\routes\\create_graph::repoRequestValidator",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "codeNoBody": "const repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "repoRequestValidator",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "The \"repoRequestValidator\" function defines a JSON schema validator using zod for validating requests containing properties such as \"git_provider\" (with values 'github', 'gitlab', or 'bitbucket'), \"repo_org\", \"repo_name\", \"branch\", \"connection_id\", and an optional \"gitlab_repo_id\" which is a number.",
    "importStatements": ""
  },
  {
    "id": "59406306-d647-45bd-9ac1-77884b409b61",
    "fullName": "\\src\\routes\\create_graph::secret",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const secret = getEnv('SUPABASE_JWT')",
    "codeNoBody": "const secret = getEnv('SUPABASE_JWT')",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "secret",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "Code: const secret = getEnv('SUPABASE_JWT')",
    "importStatements": ""
  },
  {
    "id": "150e94c1-7e99-4b51-b595-a46181d94c6c",
    "fullName": "\\src\\routes\\create_graph::createGraph",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
    "codeNoBody": "const createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nconst createGraph = new Hono()\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\n\nexport { createGraph }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "createGraph",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "generatedDocumentation": "The `createGraph` function, utilizing the `repoRequestValidator` for request validation, processes incoming requests to create a graph based on the provided Git repository information. It handles authentication, retrieves access tokens, fetches commit hashes, checks repository existence, and initiates the graph creation process by downloading and extracting the repository code. Additionally, it checks for existing graphs, prevents duplicate graph creation, and triggers the `processGraphCreation` function to manage graph creation tasks, updating the database with the graph status accordingly.",
    "importStatements": ""
  },
  {
    "id": "73be33f1-0249-4d27-8c84-26b37da51418",
    "fullName": "\\src\\routes\\create_graph",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nconst secret = getEnv('SUPABASE_JWT')\r\n\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n}) {\r\n  let graphId = crypto.randomUUID()\r\n  try {\r\n    const status = graphExists ? 'completed' : 'pending'\r\n\r\n    // graph does not exist\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      return\r\n    }\r\n\r\n    const graph: Record<string, string | number> = {\r\n      id: graphId,\r\n      repo_id: repoId,\r\n      status,\r\n      org_id: userOrgId,\r\n      user_id: userId\r\n    }\r\n\r\n    if (gitProvider === 'github') graph.github_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'gitlab') graph.gitlab_connection_id = Number(connectionId)\r\n    else if (gitProvider === 'bitbucket') graph.bitbucket_connection_id = connectionId\r\n\r\n    await sql`INSERT INTO graphs ${sql([graph])}`\r\n\r\n    if (graphExists) {\r\n      console.log('Graph creation completed:', graphId)\r\n      return\r\n    }\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: Record<string, string> = {}\r\n\r\n    const set = new Set()\r\n    for (const node of nodes) {\r\n      set.add(node.id)\r\n      nodeDBIds[node.id] = crypto.randomUUID()\r\n    }\r\n\r\n    if (set.size !== nodes.length) {\r\n      console.log('Duplicate nodes found for graph creation with id:', graphId)\r\n      return\r\n    }\r\n\r\n    // Insert nodes into the database, note that the node.id is now the full_name\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n      return sql`\r\n          INSERT INTO nodes (\r\n            id,\r\n            repo_id,\r\n            type,\r\n            language,\r\n            total_tokens,\r\n            documentation,\r\n            code,\r\n            code_no_body,\r\n            in_degree,\r\n            out_degree,\r\n            full_name,\r\n            label\r\n          )\r\n          VALUES (\r\n            ${nodeDBIds[node.id]},\r\n            ${repoId},\r\n            ${node.type},\r\n            ${node.language},\r\n            ${node.totalTokens},\r\n            ${node.documentation},\r\n            ${node.code},\r\n            ${node.codeNoBody},\r\n            ${node.inDegree},\r\n            ${node.outDegree},\r\n            ${fullName},\r\n            ${node.label}\r\n          )\r\n        `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n    // Insert links into the database\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id,\r\n          node_target_id,\r\n          repo_id,\r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]},\r\n          ${nodeDBIds[link.target]},\r\n          ${repoId},\r\n          ${link.label},\r\n          ${link.line}\r\n        )\r\n      `\r\n    })\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n    await sql`UPDATE graphs SET status = 'completed' WHERE id = ${graphId}`\r\n    console.log('Graph creation completed:', graphId)\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { createGraph }\r\n",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { z } from 'zod'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { sql } from '../utils/db'\r\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { jwtVerify } from 'jose'\r\nimport { getEnv } from '../utils/utils'\r\nimport { GitServiceType } from '../utils/git'\r\nconst secret = getEnv('SUPABASE_JWT')\r\nconst repoRequestValidator = zValidator(\r\n  'json',\r\n  z.object({\r\n    git_provider: z.enum(['github', 'gitlab', 'bitbucket']),\r\n    repo_org: z.string(),\r\n    repo_name: z.string(),\r\n    branch: z.string(),\r\n    connection_id: z.string(),\r\n    gitlab_repo_id: z.number().optional()\r\n  })\r\n)\r\n\r\nconst createGraph = new Hono()\r\n\r\ncreateGraph.post('/', repoRequestValidator, async (c) => {\r\n  const request = c.req.valid('json')\r\n  const {\r\n    git_provider: gitProvider,\r\n    repo_org: repoOrg,\r\n    repo_name: repoName,\r\n    branch,\r\n    connection_id: connectionId,\r\n    gitlab_repo_id: gitlabRepoId\r\n  } = request\r\n\r\n  const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n  if (!jwt) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const { payload } = await jwtVerify(jwt, new TextEncoder().encode(secret))\r\n  const userId = payload.sub\r\n\r\n  if (!userId) {\r\n    return c.json(\r\n      {\r\n        message: 'Unauthorized'\r\n      },\r\n      401\r\n    )\r\n  }\r\n\r\n  const resOrg = await sql`SELECT org_sel_id FROM profiles WHERE id = ${userId}`\r\n  const userOrgId = resOrg[0].org_sel_id\r\n\r\n  const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n  if (!tokens) {\r\n    console.log('Failed to get access token')\r\n    return c.json({ message: 'Failed to get access token' }, 500)\r\n  }\r\n\r\n  const { accessToken, refreshToken } = tokens\r\n\r\n  const commitHash = await getCommitRepo(\r\n    gitProvider,\r\n    repoOrg,\r\n    repoName,\r\n    branch,\r\n    accessToken,\r\n    refreshToken,\r\n    connectionId,\r\n    gitlabRepoId\r\n  )\r\n  if (!commitHash) {\r\n    console.log('Failed to get commit')\r\n    return c.json({ message: 'Failed to get commit' }, 500)\r\n  }\r\n\r\n  // check if repo exists\r\n  const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE \r\n        git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n  let repoId = crypto.randomUUID()\r\n\r\n  if (rows.length == 0) {\r\n    const respository: Record<string, string | number> = {\r\n      id: repoId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])}`\r\n\r\n    if (!res) {\r\n      console.log('Failed to create repository')\r\n      return c.json({ message: 'Failed to create repository' }, 500)\r\n    }\r\n  } else {\r\n    repoId = rows[0].id\r\n  }\r\n\r\n  const graphUsersData = await sql`\r\n    SELECT g.org_id, g.user_id\r\n    FROM nodes n -- must have at least one node\r\n    LEFT JOIN repositories r \r\n      ON n.repo_id = r.id\r\n    LEFT JOIN graphs g\r\n      ON g.repo_id = n.repo_id\r\n    WHERE\r\n      n.repo_id = ${repoId}\r\n      AND r.git_provider = ${gitProvider}\r\n      AND r.commit_hash = ${commitHash}`\r\n\r\n  let graphExists = false\r\n\r\n  // graph already exists with that commit\r\n  if (graphUsersData.length > 0) {\r\n    const orgIds = graphUsersData.map((row) => row.org_id)\r\n    const userIds = graphUsersData.map((row) => row.user_id)\r\n    // the user and org already have this graph\r\n    if (orgIds.includes(userOrgId) && userIds.includes(userId)) {\r\n      console.log('Graph already exists')\r\n      return c.json({ message: 'Graph already exists' }, 500)\r\n    }\r\n    graphExists = true\r\n  }\r\n\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n    // Perform background task\r\n    processGraphCreation({\r\n      gitProvider,\r\n      repoId,\r\n      userOrgId,\r\n      userId,\r\n      graphExists,\r\n      connectionId,\r\n      codebasePath\r\n    })\r\n\r\n    return c.json({ message: 'Graph creation started' })\r\n  } catch (error: any) {\r\n    return c.json({ message: error.message }, 500)\r\n  }\r\n})\r\n\r\nasync function processGraphCreation({\r\n  gitProvider,\r\n  repoId,\r\n  userOrgId,\r\n  userId,\r\n  graphExists,\r\n  connectionId,\r\n  codebasePath\r\n}: {\r\n  gitProvider: GitServiceType\r\n  repoId: string\r\n  userOrgId: string\r\n  userId: string\r\n  graphExists: boolean\r\n  connectionId: string\r\n  codebasePath: string\r\n}) {\n//...\n}\r\n\r\nexport { createGraph }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\create_graph.ts",
    "originFile": "",
    "generatedDocumentation": "# `create_graph.ts` Wiki\n\n## Overview\nThe `create_graph.ts` file is part of the `codebase-index-ts` project and is located in the `src/routes` directory. This file defines an API endpoint for creating a graph representation of a Git repository. The endpoint handles request validation, authentication, repository data retrieval, and initiates the graph creation process.\n\n## Main Features\n### API Endpoint Definition\n- **`createGraph`**: This is the main Hono application instance that defines the POST endpoint for creating a graph. It uses middleware for request validation and handles the core logic for processing the request.\n\n### Request Validation\n- **`repoRequestValidator`**: This function uses the `zod` library to define a JSON schema validator. It ensures that incoming requests contain the required properties: `git_provider`, `repo_org`, `repo_name`, `branch`, `connection_id`, and optionally `gitlab_repo_id`.\n\n### Authentication\n- **`secret`**: The JWT secret is retrieved from the environment variables using `getEnv('SUPABASE_JWT')`.\n- **JWT Verification**: The endpoint extracts and verifies the JWT from the request headers to authenticate the user.\n\n### Repository Data Retrieval\n- **Access Token Retrieval**: The endpoint fetches access tokens for the specified Git provider using the `getAccessToken` function.\n- **Commit Hash Retrieval**: It retrieves the latest commit hash for the specified repository and branch using the `getCommitRepo` function.\n\n### Database Operations\n- **Repository Existence Check**: The endpoint checks if the repository already exists in the database.\n- **Graph Existence Check**: It checks if a graph already exists for the specified commit hash and user organization.\n\n### Graph Creation\n- **`processGraphCreation`**: This asynchronous function is responsible for creating the graph. It handles different scenarios based on the existence of the graph and the git provider. It generates a unique graph ID, inserts nodes and links into the database, and updates the graph status accordingly.\n\n## Important Definitions\n- **`Hono`**: A lightweight web framework used to define the API endpoint.\n- **`zValidator`**: Middleware for validating requests against a schema defined using `zod`.\n- **`sql`**: Utility for interacting with the database.\n- **`downloadAndExtractRepo`**: Function to download and extract the repository code.\n- **`getAccessToken`**: Function to retrieve access tokens for the specified Git provider.\n- **`getCommitRepo`**: Function to fetch the latest commit hash for the repository.\n- **`jwtVerify`**: Function from the `jose` library to verify JWT tokens.\n- **`getEnv`**: Utility function to retrieve environment variables.\n- **`GitServiceType`**: Type definition for supported Git service providers.\n\n## Purpose\nThe primary purpose of the `create_graph.ts` file is to provide an API endpoint that allows users to create a graph representation of a Git repository. This involves validating the request, authenticating the user, retrieving necessary repository data, and initiating the graph creation process. The graph creation involves downloading the repository code, processing it, and updating the database with the graph status. This functionality is crucial for applications that need to visualize or analyze the structure and dependencies within a codebase.",
    "importStatements": "import { Hono } from 'hono'\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\nimport { sql } from '../utils/db'\nimport { downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { jwtVerify } from 'jose'\nimport { getEnv } from '../utils/utils'\nimport { GitServiceType } from '../utils/git'"
  },
  {
    "id": "26f755b1-8dbb-47d5-9e4f-2bb25dd5d8e3",
    "fullName": "\\src\\routes\\graphs::updateGraph",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName}, ${node.label}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}",
    "codeNoBody": "async function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "updateGraph",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
    "generatedDocumentation": "The \"updateGraph\" function, using the properties from the \"UpdateGraph\" interface, downloads and extracts a repository based on the provided parameters, creates a repository entry in the database, parses the codebase, simplifies the nodes, generates unique IDs for each node, inserts nodes and links into the database, and updates the graph status to 'completed' upon successful completion. If any error occurs during the process, it logs the error and updates the graph status to 'failed'.",
    "importStatements": ""
  },
  {
    "id": "ed899d20-9b5d-4148-ad96-845338afac68",
    "fullName": "\\src\\routes\\graphs::UpdateGraph",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n}",
    "codeNoBody": "interface UpdateGraph {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "UpdateGraph",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
    "generatedDocumentation": "Interface \"UpdateGraph\" defines a structure with properties for interacting with a Git provider, specifying repository details, branch, access token, commit hash, optional GitLab repository ID, and a graph identifier.",
    "importStatements": ""
  },
  {
    "id": "8f3abb73-d84b-4d96-9285-e3f98459ddc9",
    "fullName": "\\src\\routes\\graphs::graphs",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
    "codeNoBody": "const graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nconst graphs = new Hono()\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\n\nexport { graphs }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "graphs",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
    "generatedDocumentation": "The \"graphs\" route handles the PATCH request to update a specific graph by verifying the user's authorization, fetching necessary data from the database, retrieving access tokens, getting the latest commit from a repository, and updating the graph status accordingly. If the graph is already up to date, it returns a success message; otherwise, it initiates the update process by calling the \"updateGraph\" function, which downloads and processes the repository, updates the graph status to 'completed' upon success, or 'failed' if an error occurs.",
    "importStatements": ""
  },
  {
    "id": "caf88fb2-db79-488d-964d-e5ca5a40abde",
    "fullName": "\\src\\routes\\graphs",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Hono } from 'hono'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\r\n  gitProvider: GitServiceType\r\n  repoOrg: string\r\n  repoName: string\r\n  branch: string\r\n  accessToken: string\r\n  commitHash: string\r\n  gitlabRepoId?: number\r\n  graphId: string\r\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\r\n  try {\r\n    const codebasePath = await downloadAndExtractRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!codebasePath) {\r\n      console.log('Failed to download repo')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const respository: Record<string, string | number> = {\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      branch: branch,\r\n      commit_hash: commitHash\r\n    }\r\n\r\n    if (gitProvider === 'gitlab' && gitlabRepoId) respository.gitlab_repo_id = gitlabRepoId\r\n\r\n    const res = await sql`INSERT INTO repositories ${sql([respository])} RETURNING id`\r\n\r\n    if (res.length === 0) {\r\n      console.log('Failed to create repository')\r\n      await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n      return\r\n    }\r\n\r\n    const repoId = res[0].id\r\n\r\n    const codebase = new Codebase(codebasePath)\r\n    const fileNodesMap = await codebase.parseFolder()\r\n    codebase.getCalls(fileNodesMap, false)\r\n    const nodes = codebase.simplify()\r\n\r\n    const nodeDBIds: { [key: string]: string } = {}\r\n\r\n    for (const node of nodes) {\r\n      nodeDBIds[node.id] = uuidv4()\r\n    }\r\n\r\n    const insertNodePromises = nodes.map((node) => {\r\n      const fullName = node.id.replace(codebasePath, '')\r\n\r\n      return sql`\r\n        INSERT INTO nodes (\r\n          id, \r\n          repo_id, \r\n          type, \r\n          language, \r\n          total_tokens, \r\n          documentation, \r\n          code, \r\n          code_no_body, \r\n          in_degree, \r\n          out_degree, \r\n          full_name, \r\n          label\r\n        ) VALUES (\r\n          ${nodeDBIds[node.id]},\r\n          ${repoId},\r\n          ${node.type},\r\n          ${node.language},\r\n          ${node.totalTokens},\r\n          ${node.documentation},\r\n          ${node.code},\r\n          ${node.codeNoBody},\r\n          ${node.inDegree},\r\n          ${node.outDegree},\r\n          ${fullName}, ${node.label}\r\n        )\r\n      `\r\n    })\r\n\r\n    const links = codebase.getLinks()\r\n\r\n    const insertLinkPromises = links.map((link) => {\r\n      return sql`\r\n        INSERT INTO links (\r\n          node_source_id, \r\n          node_target_id, \r\n          repo_id, \r\n          label,\r\n          line\r\n        ) VALUES (\r\n          ${nodeDBIds[link.source]}, \r\n          ${nodeDBIds[link.target]}, \r\n          ${repoId}, \r\n          ${link.label},\r\n          ${link.line}\r\n        ) \r\n      `\r\n    })\r\n\r\n    await Promise.all([...insertNodePromises, ...insertLinkPromises])\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'completed',\r\n        repo_id = ${repoId}\r\n      WHERE id = ${graphId}`\r\n  } catch (error) {\r\n    console.error('Error in background processing:', error)\r\n    await sql`UPDATE graphs SET status = 'failed' WHERE id = ${graphId}`\r\n  }\r\n}\r\n\r\nexport { graphs }\r\n",
    "codeNoBody": "import { Hono } from 'hono'\r\nimport { sql } from '../utils/db'\r\nimport { getEnv } from '../utils/utils'\r\nimport { jwtVerify } from 'jose'\r\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\r\nimport { Codebase } from '../model/codebase'\r\nimport { v4 as uuidv4 } from 'uuid'\r\nconst graphs = new Hono()\r\n\r\ngraphs.patch('/:id', async (c) => {\r\n  try {\r\n    const jwt = c.req.header('Authorization')?.split('Bearer ')[1]\r\n\r\n    if (!jwt) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const { payload } = await jwtVerify(jwt, new TextEncoder().encode(getEnv('SUPABASE_JWT')))\r\n\r\n    const userId = payload.sub\r\n\r\n    if (!userId) {\r\n      return c.json(\r\n        {\r\n          error: 'Unauthorized'\r\n        },\r\n        401\r\n      )\r\n    }\r\n\r\n    const graphId = c.req.param('id')\r\n\r\n    const graph = await sql`\r\n      SELECT\r\n        r.git_provider,\r\n        r.repo_org,\r\n        r.repo_name,\r\n        r.branch,\r\n        r.commit_hash,\r\n        r.gitlab_repo_id,\r\n        g.github_connection_id,\r\n        g.gitlab_connection_id,\r\n        g.bitbucket_connection_id,\r\n        p.org_sel_id\r\n      FROM profiles p\r\n      JOIN graphs g ON g.org_id = p.org_sel_id\r\n      JOIN repositories r ON g.repo_id = r.id\r\n      WHERE p.id = ${userId}\r\n        AND g.id = ${graphId}\r\n    `\r\n\r\n    if (graph.length === 0) {\r\n      return c.json(\r\n        {\r\n          error: 'Graph not found'\r\n        },\r\n        404\r\n      )\r\n    }\r\n\r\n    const {\r\n      org_sel_id: userOrgId,\r\n      git_provider: gitProvider,\r\n      repo_org: repoOrg,\r\n      repo_name: repoName,\r\n      commit_hash: repoCommitHash,\r\n      branch,\r\n      gitlab_repo_id: gitlabRepoId,\r\n      github_connection_id,\r\n      gitlab_connection_id,\r\n      bitbucket_connection_id\r\n    } = graph[0]\r\n\r\n    const connections: Record<string, string | number> = {\r\n      github: github_connection_id,\r\n      gitlab: gitlab_connection_id,\r\n      bitbucket: bitbucket_connection_id\r\n    }\r\n\r\n    const connectionId = String(connections[gitProvider])\r\n\r\n    const tokens = await getAccessToken(gitProvider, connectionId, userOrgId)\r\n\r\n    if (!tokens) {\r\n      console.log('Failed to get access token')\r\n      return c.json({ message: 'Failed to get access token' }, 500)\r\n    }\r\n\r\n    const { accessToken, refreshToken } = tokens\r\n\r\n    const commitHash = await getCommitRepo(\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      refreshToken,\r\n      connectionId,\r\n      gitlabRepoId\r\n    )\r\n\r\n    if (!commitHash) {\r\n      console.log('Failed to get commit')\r\n      return c.json({ error: 'Failed to get commit' }, 400)\r\n    }\r\n\r\n    if (commitHash === repoCommitHash) {\r\n      return c.json({ message: 'Graph already up to date' }, 200)\r\n    }\r\n\r\n    await sql`\r\n      UPDATE graphs \r\n      SET \r\n        status = 'updating'\r\n      WHERE id = ${graphId}\r\n    `\r\n\r\n    const rows = await sql`\r\n      SELECT \r\n        id\r\n      FROM repositories\r\n      WHERE git_provider = ${gitProvider}\r\n        AND repo_org = ${repoOrg}\r\n        AND repo_name = ${repoName}\r\n        AND branch = ${branch}\r\n        AND commit_hash = ${commitHash}\r\n    `\r\n\r\n    if (rows.length > 0) {\r\n      await sql`\r\n        UPDATE graphs \r\n        SET \r\n          status = 'completed',\r\n          repo_id = ${rows[0].id}\r\n        WHERE id = ${graphId}\r\n      `\r\n\r\n      return c.json({ message: 'Graph updated' }, 200)\r\n    }\r\n\r\n    updateGraph({\r\n      gitProvider,\r\n      repoOrg,\r\n      repoName,\r\n      branch,\r\n      accessToken,\r\n      commitHash,\r\n      gitlabRepoId,\r\n      graphId\r\n    })\r\n\r\n    return c.json({ message: 'Graph updating' }, 200)\r\n  } catch (error) {\r\n    console.log('Error updating graph', error)\r\n    return c.json({ error: 'Error updating graph' }, 500)\r\n  }\r\n})\r\n\r\ninterface UpdateGraph {\n//...\n}\r\n\r\nasync function updateGraph({\r\n  gitProvider,\r\n  repoOrg,\r\n  repoName,\r\n  branch,\r\n  accessToken,\r\n  commitHash,\r\n  gitlabRepoId,\r\n  graphId\r\n}: UpdateGraph) {\n//...\n}\r\n\r\nexport { graphs }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\routes\\graphs.ts",
    "originFile": "",
    "generatedDocumentation": "# `graphs.ts` File Overview\n\n## Purpose\nThe `graphs.ts` file is part of the `codebase-index-ts` project and is responsible for handling the updating of graph data related to code repositories. It defines a route for updating a specific graph by verifying user authorization, fetching necessary repository data, and updating the graph status accordingly.\n\n## Main Features\n\n### Route Definition\n- **`graphs.patch('/:id')`**: This route handles PATCH requests to update a specific graph identified by its ID. It performs several operations to ensure the graph is up-to-date with the latest commit from the repository.\n\n### Key Operations\n1. **Authorization Verification**: \n   - Extracts and verifies the JWT token from the request header to authenticate the user.\n   - Ensures the user is authorized to update the graph.\n\n2. **Database Queries**:\n   - Fetches graph and repository details from the database using the provided graph ID and user ID.\n   - Checks if the graph exists and retrieves necessary repository information.\n\n3. **Access Token Retrieval**:\n   - Obtains access tokens for the respective Git provider (GitHub, GitLab, Bitbucket) using the connection ID and user organization ID.\n\n4. **Commit Verification**:\n   - Retrieves the latest commit hash from the repository.\n   - Compares the latest commit hash with the stored commit hash to determine if an update is necessary.\n\n5. **Graph Status Update**:\n   - Updates the graph status in the database to 'updating' if a new commit is found.\n   - If the repository with the latest commit already exists in the database, updates the graph status to 'completed'.\n   - Otherwise, initiates the graph update process by calling the `updateGraph` function.\n\n### `updateGraph` Function\n- **Purpose**: The `updateGraph` function is responsible for downloading and extracting the repository, creating a repository entry in the database, parsing the codebase, simplifying nodes, generating unique IDs for each node, inserting nodes and links into the database, and updating the graph status to 'completed' upon successful completion.\n- **Error Handling**: If any error occurs during the process, it logs the error and updates the graph status to 'failed'.\n\n### `UpdateGraph` Interface\n- **Structure**: Defines the properties required for interacting with a Git provider, specifying repository details, branch, access token, commit hash, optional GitLab repository ID, and a graph identifier.\n\n## Summary\nThe `graphs.ts` file is a crucial part of the `codebase-index-ts` project, providing functionality to update graph data related to code repositories. It ensures that the graph data is synchronized with the latest commits from the repositories by handling authorization, database interactions, and invoking the `updateGraph` function to process and update the graph status.",
    "importStatements": "import { Hono } from 'hono'\nimport { sql } from '../utils/db'\nimport { getEnv } from '../utils/utils'\nimport { jwtVerify } from 'jose'\nimport { GitServiceType, downloadAndExtractRepo, getAccessToken, getCommitRepo } from '../utils/git'\nimport { Codebase } from '../model/codebase'\nimport { v4 as uuidv4 } from 'uuid'"
  },
  {
    "id": "c918ce7c-c56c-432c-97ac-a8c7b66e537c",
    "fullName": "\\src\\tools\\function_tools::similarToDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const similarToDescription: FunctionDefinition = {\n  name: 'similar_to',\n  description:\n    'Find similar node names by a name. It returns a list of node Ids.',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The node name to search for similar nodes',\n      },\n    },\n    required: ['node_name'],\n  },\n}",
    "codeNoBody": "export const similarToDescription: FunctionDefinition = {\n  name: 'similar_to',\n  description:\n    'Find similar node names by a name. It returns a list of node Ids.',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The node name to search for similar nodes',\n      },\n    },\n    required: ['node_name'],\n  },\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarToDescription",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"similarToDescription\" function is a FunctionDefinition named \"similar_to\" that finds similar node names based on a provided name, returning a list of node Ids. It takes an object parameter with a required property \"node_name\" specifying the name to search for similar nodes.",
    "importStatements": ""
  },
  {
    "id": "0e20f046-2a46-45b6-aaf4-0332deda7fde",
    "fullName": "\\src\\tools\\function_tools::getCodebyNodeIdDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const getCodebyNodeIdDescription: FunctionDefinition = {\n  name: 'get_code_by_node_id',\n  description:\n    'Get the code of a node by its id in the form my/path/file::node_name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_id: {\n        type: 'string',\n        description:\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\n      },\n    },\n    required: ['node_id'],\n  },\n}",
    "codeNoBody": "export const getCodebyNodeIdDescription: FunctionDefinition = {\n  name: 'get_code_by_node_id',\n  description:\n    'Get the code of a node by its id in the form my/path/file::node_name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_id: {\n        type: 'string',\n        description:\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\n      },\n    },\n    required: ['node_id'],\n  },\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodebyNodeIdDescription",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "Defines a function named \"get_code_by_node_id\" that retrieves the code of a node based on its unique identifier in the format \"my/path/file::node_name\", with a required parameter \"node_id\" specifying the node to fetch the code from.",
    "importStatements": ""
  },
  {
    "id": "3238e520-823b-4f30-adea-9dfb299e2008",
    "fullName": "\\src\\tools\\function_tools::getCodeDescription",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const getCodeDescription: FunctionDefinition = {\n  name: 'get_code',\n  description: 'Get the code of a node by its name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The name of the node to get the code of',\n      },\n    },\n    required: ['node_name'],\n  },\n}",
    "codeNoBody": "export const getCodeDescription: FunctionDefinition = {\n  name: 'get_code',\n  description: 'Get the code of a node by its name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The name of the node to get the code of',\n      },\n    },\n    required: ['node_name'],\n  },\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodeDescription",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The `getCodeDescription` function defines a function named 'get_code' that retrieves the code of a node based on its name, with a required parameter 'node_name' of type string.",
    "importStatements": ""
  },
  {
    "id": "3877946b-f3bd-4a2d-a8b4-4e00daf1186e",
    "fullName": "\\src\\tools\\function_tools::similarToTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function similarToTool(\n    nodeName: string,\n    type: NodeType | undefined = undefined,\n  ) {\n    return similarTo(nodeName, nodes, type)\n  }",
    "codeNoBody": "function similarToTool(\n    nodeName: string,\n    type: NodeType | undefined = undefined,\n  ) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarToTool",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The function similarToTool takes a nodeName string and a type NodeType or undefined as parameters. It calls the similarTo function with the provided nodeName, nodes array, and type to calculate the similarity between the nodeName and each GraphNode label based on the specified type, returning an object with the top similar items for files, classes, functions, methods, interfaces, and assignments based on the type or 'all'.",
    "importStatements": ""
  },
  {
    "id": "d7476909-bf5e-492c-bf3d-35d213610dda",
    "fullName": "\\src\\tools\\function_tools::getCodenbyNodeIdTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCodenbyNodeIdTool(nodeId: string) {\n    return getCode(nodes, links, undefined, nodeId)\n  }",
    "codeNoBody": "function getCodenbyNodeIdTool(nodeId: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodenbyNodeIdTool",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCodenbyNodeIdTool\" function takes a nodeId as a parameter and calls the \"getCode\" function with the provided nodeId to retrieve code snippets and documentation from the specified node or similar nodes based on the ID, following links to related nodes within the specified deep level.",
    "importStatements": ""
  },
  {
    "id": "eb373045-bcfa-4985-ad89-cbd77ef41eb0",
    "fullName": "\\src\\tools\\function_tools::getCodeTool",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCodeTool(nodeName: string) {\n    return getCode(nodes, links, nodeName)\n  }",
    "codeNoBody": "function getCodeTool(nodeName: string) {\n  //...\n  }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCodeTool",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCodeTool\" function takes a nodeName as a parameter and calls the \"getCode\" function with the provided nodeName, returning code snippets and documentation related to the specified node or similar nodes based on the name. The \"getCode\" function uses arrays of GraphNode and GraphLink objects, a maxTokens limit, a nodeSeen object to track visited nodes, and a maxDeepLevel for recursion to retrieve information and follow links to related nodes within the specified deep level, also utilizing the \"similarTo\" function to find similar nodes based on the provided name.",
    "importStatements": ""
  },
  {
    "id": "8f2df333-d59e-4a89-a1ab-6ef97f5863ad",
    "fullName": "\\src\\tools\\function_tools::getUserToolsAndPrompt",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getUserToolsAndPrompt(\n  userOrgId: string,\n  graphId: string,\n) {\n  const [nodes, links] = await Promise.all([\n    getGraphNodesById({ userOrgId, graphId }),\n    getGraphLinksById({ userOrgId, graphId }),\n  ])\n\n  const nodesPerType = nodes.reduce((acc, node) => {\n    if (!acc[node.type]) {\n      acc[node.type] = []\n    }\n    acc[node.type].push(node)\n    return acc\n  }, {} as Record<NodeType, GraphNode[]>)\n\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\n    ).slice(0, 5).map((n) => n.full_name)\n    return acc\n  }, {} as Record<NodeType, (string | number)[]>)\n\n  const allLanguages = calculateLanguagePercentages(\n    nodesPerType['file'].map((n) => n.language),\n  )\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\n    `${name}: ${pct}`\n  ).join(', ')\n\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\n      mostUsedNodesPerType[type as NodeType]\n    }`\n  }).join('\\n')\n\n  prompt = `Languages: ${allLanguagesString}\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\n  These are the most common nodes Ids from the repository:\\n${prompt}`\n\n  function getCodeTool(nodeName: string) {\n    return getCode(nodes, links, nodeName)\n  }\n\n  function getCodenbyNodeIdTool(nodeId: string) {\n    return getCode(nodes, links, undefined, nodeId)\n  }\n\n  function similarToTool(\n    nodeName: string,\n    type: NodeType | undefined = undefined,\n  ) {\n    return similarTo(nodeName, nodes, type)\n  }\n\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\n}",
    "codeNoBody": "async function getUserToolsAndPrompt(\n  userOrgId: string,\n  graphId: string,\n) {\n  const [nodes, links] = await Promise.all([\n    getGraphNodesById({ userOrgId, graphId }),\n    getGraphLinksById({ userOrgId, graphId }),\n  ])\n  const nodesPerType = nodes.reduce((acc, node) => {\n    if (!acc[node.type]) {\n      acc[node.type] = []\n    }\n    acc[node.type].push(node)\n    return acc\n  }, {} as Record<NodeType, GraphNode[]>)\n\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\n    ).slice(0, 5).map((n) => n.full_name)\n    return acc\n  }, {} as Record<NodeType, (string | number)[]>)\n\n  const allLanguages = calculateLanguagePercentages(\n    nodesPerType['file'].map((n) => n.language),\n  )\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\n    `${name}: ${pct}`\n  ).join(', ')\n\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\n      mostUsedNodesPerType[type as NodeType]\n    }`\n  }).join('\\n')\n\n  prompt = `Languages: ${allLanguagesString}\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\n  These are the most common nodes Ids from the repository:\\n${prompt}`\n\n  function getCodeTool(nodeName: string) {\n    return getCode(nodes, links, nodeName)\n  }\n\n  function getCodenbyNodeIdTool(nodeId: string) {\n    return getCode(nodes, links, undefined, nodeId)\n  }\n\n  function similarToTool(\n    nodeName: string,\n    type: NodeType | undefined = undefined,\n  ) {\n    return similarTo(nodeName, nodes, type)\n  }\n\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getUserToolsAndPrompt",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getUserToolsAndPrompt\" function asynchronously retrieves graph nodes and links based on the provided userOrgId and graphId, categorizes nodes by type, identifies the most used nodes per type based on in_degree and out_degree, calculates language percentages, and generates a prompt displaying the most common node IDs. It also provides tools to get code snippets and documentation for a specified node name or ID, find similar nodes based on name or type, and retrieve similar items for files, classes, functions, methods, interfaces, and assignments.",
    "importStatements": ""
  },
  {
    "id": "f19849c2-a66f-4e8e-9795-eb92c7c83fed",
    "fullName": "\\src\\tools\\function_tools::getCode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getCode(\n  nodes: GraphNode[],\n  links: GraphLink[],\n  nodeName?: string,\n  nodeId?: string,\n  maxTokens = 4096,\n  nodesSeen: nodeSeen = {},\n  maxDeepLevel = 2,\n  // deno-lint-ignore no-explicit-any\n): Promise<any> {\n  if (!nodesSeen) {\n    nodesSeen = {}\n  }\n\n  let node: GraphNode | undefined\n  if (nodeId) {\n    node = nodes.find((node) => node.id === nodeId)\n    if (node) {\n      nodeName = node.label\n    }\n  } else if (nodeName) {\n    node = nodes.find((node) => node.label === nodeName) ||\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\n  }\n\n  let toReturn = ''\n  if (maxTokens < 0) {\n    return toReturn\n  }\n\n  if (Object.keys(nodesSeen).length > 0) {\n    toReturn += '\\n\\n-------\\n\\n'\n  }\n\n  if (node) {\n    nodesSeen[node.id] = true\n    const language = node.language\n    toReturn += `From ${node.full_name}:\\n`\n    if (node.documentation) {\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\n    }\n    if (node.total_tokens > maxTokens || node.type === 'file') {\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\n    } else {\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\n    }\n\n    if (maxDeepLevel > 0) {\n      maxDeepLevel -= 1\n      const calls = links.filter((link) =>\n        link.node_source_id === node!.id && link.label === 'calls'\n      )\n      for (const call of calls) {\n        if (nodesSeen[call.node_target_id]) {\n          continue\n        }\n        nodesSeen[call.node_target_id] = true\n        const callNode = await getCode(\n          nodes,\n          links,\n          undefined,\n          call.node_target_id,\n          maxTokens - node.total_tokens,\n          nodesSeen,\n          maxDeepLevel,\n        )\n        toReturn += callNode\n      }\n    }\n  } else {\n    toReturn = `There is no node named ${nodeName}.\\n`\n    if (nodeName) {\n      const res = similarTo(nodeName, nodes)\n      return {\n        ...res,\n        content: toReturn + res.content,\n        targetNodes: [],\n        sourceNodes: [],\n      }\n    }\n  }\n\n  let targetNodes: GraphNode[] = []\n  let sourceNodes: GraphNode[] = []\n\n  if (node) {\n    const targetLinks = links.filter((link) => {\n      return link.node_source_id === node.id\n    }) ?? []\n\n    const sourceLinks = links.filter((link) => {\n      return link.node_target_id === node.id\n    }) ?? []\n\n    sourceNodes = nodes.filter((node) => {\n      return sourceLinks.some((link) => link.node_source_id === node.id)\n    }) ?? []\n\n    targetNodes = nodes.filter((node) => {\n      return targetLinks.some((link) => link.node_target_id === node.id)\n    }) ?? []\n  }\n\n  return {\n    content: toReturn,\n    match: nodeName,\n    topFiles: [],\n    topClasses: [],\n    topFunctions: [],\n    topMethods: [],\n    topInterfaces: [],\n    topAssignments: [],\n    targetNodes,\n    sourceNodes,\n  }\n}",
    "codeNoBody": "async function getCode(\n  nodes: GraphNode[],\n  links: GraphLink[],\n  nodeName?: string,\n  nodeId?: string,\n  maxTokens = 4096,\n  nodesSeen: nodeSeen = {},\n  maxDeepLevel = 2,\n  // deno-lint-ignore no-explicit-any\n): Promise<any> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"getCode\" function takes in an array of GraphNode objects, an array of GraphLink objects, an optional nodeName or nodeId, a maxTokens limit, a nodeSeen object to track visited nodes, and a maxDeepLevel for recursion. It retrieves code snippets and documentation from the specified node or similar nodes based on name or ID, following links to related nodes within the specified deep level. The function also utilizes the \"similarTo\" function to find similar nodes based on the provided name.",
    "importStatements": ""
  },
  {
    "id": "8db0d08a-ea2a-4d2b-899f-8c2984fc82f0",
    "fullName": "\\src\\tools\\function_tools::nodeSeen",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface nodeSeen {\n  [key: string]: boolean\n}",
    "codeNoBody": "interface nodeSeen {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeSeen",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The \"nodeSeen\" interface defines an object where keys are strings and values are booleans, used to track the presence of nodes in a data structure.",
    "importStatements": ""
  },
  {
    "id": "3af8ea2b-875b-420e-a3e3-094888fe3227",
    "fullName": "\\src\\tools\\function_tools::similarTo",
    "type": "function",
    "language": "typescript",
    "documentation": "/**\n * Finds the most similar nodes to the given name based on their type.\n *\n * @param {string} name - The name to compare against.\n * @param {GraphNode[]} nodes - The array of nodes to search.\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\n */",
    "code": "function similarTo(\n  name: string,\n  nodes: GraphNode[],\n  type: NodeType | 'all' = 'all',\n  n = 10,\n) {\n  const similarNodes = []\n  let topFiles: string[] = []\n  let topClasses: string[] = []\n  let topFunctions: string[] = []\n  let topMethods: string[] = []\n  let topInterfaces: string[] = []\n  let topAssignments: string[] = []\n  let similars: string[] = []\n\n  if (type === 'all') {\n    topFiles = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'file'),\n      n,\n    )\n\n    topClasses = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'class'),\n      n,\n    )\n    topFunctions = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'function'),\n      n,\n    )\n    topMethods = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'method'),\n      n,\n    )\n    topInterfaces = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'interface'),\n      n,\n    )\n    topAssignments = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'assignment'),\n      n,\n    )\n\n    if (topFiles.length > 0) {\n      similarNodes.push(` - Files: ${topFiles}`)\n    }\n    if (topClasses.length > 0) {\n      similarNodes.push(` - Classes: ${topClasses}`)\n    }\n    if (topFunctions.length > 0) {\n      similarNodes.push(` - Functions: ${topFunctions}`)\n    }\n    if (topMethods.length > 0) {\n      similarNodes.push(` - Methods: ${topMethods}`)\n    }\n    if (topInterfaces.length > 0) {\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\n    }\n    if (topAssignments.length > 0) {\n      similarNodes.push(` - Assignments: ${topAssignments}`)\n    }\n  } else {\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\n    if (similars.length > 0) {\n      similarNodes.push(\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\n      )\n    }\n  }\n\n  if (similarNodes.length === 0) {\n    return {\n      content: `No similar node IDs found for ${name}.`,\n      match: '',\n      similars: similarNodes.slice(0, 1),\n      topFiles: topFiles.slice(0, 1),\n      topClasses: topClasses.slice(0, 1),\n      topFunctions: topFunctions.slice(0, 1),\n      topMethods: topMethods.slice(0, 1),\n      topInterfaces: topInterfaces.slice(0, 1),\n      topAssignments: topAssignments.slice(0, 1),\n    }\n  } else {\n    return {\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\n      match: '',\n      similars: similarNodes.slice(0, 1),\n      topFiles: topFiles.slice(0, 1),\n      topClasses: topClasses.slice(0, 1),\n      topFunctions: topFunctions.slice(0, 1),\n      topMethods: topMethods.slice(0, 1),\n      topInterfaces: topInterfaces.slice(0, 1),\n      topAssignments: topAssignments.slice(0, 1),\n    }\n  }\n}",
    "codeNoBody": "function similarTo(\n  name: string,\n  nodes: GraphNode[],\n  type: NodeType | 'all' = 'all',\n  n = 10,\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "similarTo",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The function similarTo takes a name string, an array of GraphNode objects, a type string or 'all' (default 'all'), and an optional number n (default 10) as parameters. It calculates the similarity between the name and each GraphNode label based on the specified type, retrieves the top similar items for each type, and returns an object containing the content with the similar node IDs found for the name, along with the top similar files, classes, functions, methods, interfaces, and assignments based on the type or 'all'.",
    "importStatements": ""
  },
  {
    "id": "4360b230-b521-4bdf-b7af-e047f78508ea",
    "fullName": "\\src\\tools\\function_tools::topNSimilar",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function topNSimilar(\n  targetName: string,\n  nodes: GraphNode[],\n  n: number = 10,\n): string[] {\n  const similarities: Similarity[] = nodes.map((n) => ({\n    id: n.full_name,\n    score: distance(targetName, n.label),\n  }))\n\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\n\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\n    .map((item) => item.id)\n}",
    "codeNoBody": "function topNSimilar(\n  targetName: string,\n  nodes: GraphNode[],\n  n: number = 10,\n): string[] {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "topNSimilar",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The function topNSimilar takes a targetName string, an array of GraphNode objects, and an optional number n (default value 10) as parameters. It calculates the similarity score between the targetName and each GraphNode label, stores the results in an array of Similarity objects, sorts them by score, selects the top n similar items, and returns an array of their ids that have a score below the defined threshold in the CONFIGURATION.",
    "importStatements": ""
  },
  {
    "id": "dac47d7a-21db-4b06-bd70-0220330d54b5",
    "fullName": "\\src\\tools\\function_tools::getGraphLinksById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphLinksById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphLink[]> {\n  try {\n    const rows = await sql<GraphLink[]>`\n      SELECT\n        l.id,\n        l.node_source_id,\n        l.node_target_id,\n        l.label\n      FROM graphs g\n      JOIN repositories r\n        ON r.id = g.repo_id\n      JOIN links l\n        ON l.repo_id = r.id\n      WHERE g.id = ${graphId}\n        AND g.org_id = ${userOrgId}\n        AND g.status = 'completed'\n    `\n\n    return rows\n  } catch (error) {\n    console.log('Error getting graph links by id', error)\n    return []\n  }\n}",
    "codeNoBody": "async function getGraphLinksById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphLink[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphLinksById",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This async function \"getGraphLinksById\" retrieves an array of GraphLink objects based on the provided userOrgId and graphId parameters. It queries the database to select specific fields from the \"links\" table by joining \"graphs,\" \"repositories,\" and \"links\" tables. The function returns the fetched rows as an array of GraphLink objects or an empty array if an error occurs during the database query.",
    "importStatements": ""
  },
  {
    "id": "d424b7f2-88de-45cc-9fba-282b744b7ec3",
    "fullName": "\\src\\tools\\function_tools::getGraphNodesById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphNodesById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphNode[]> {\n  try {\n    const rows = await sql<GraphNode[]>`\n      SELECT\n        n.id,\n        n.full_name,\n        n.type,\n        n.language,\n        n.documentation,\n        n.code,\n        n.code_no_body,\n        n.total_tokens,\n        n.in_degree,\n        n.out_degree,\n        n.label\n      FROM graphs g\n      JOIN repositories r\n        ON r.id = g.repo_id\n      JOIN nodes n\n        ON n.repo_id = r.id\n      WHERE g.id = ${graphId}\n        AND g.org_id = ${userOrgId}\n        AND g.status = 'completed'\n    `\n\n    return rows\n  } catch (error) {\n    console.log('Error getting graph nodes by id', error)\n    return []\n  }\n}",
    "codeNoBody": "async function getGraphNodesById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphNode[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphNodesById",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This async function \"getGraphNodesById\" retrieves an array of graph nodes based on the provided \"userOrgId\" and \"graphId\" parameters by querying the database for specific node attributes like id, full_name, type, language, documentation, code, code_no_body, total_tokens, in_degree, out_degree, and label. If successful, it returns the fetched rows as an array of GraphNode objects; otherwise, it logs an error message and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "7f04501e-fd25-4537-a98a-0cb6df19d327",
    "fullName": "\\src\\tools\\function_tools::Similarity",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface Similarity {\n  id: string\n  score: number\n}",
    "codeNoBody": "interface Similarity {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Similarity",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "The interface \"Similarity\" defines a structure with two properties: \"id\" of type string and \"score\" of type number, representing an object that stores an identifier and a numerical value to measure similarity.",
    "importStatements": ""
  },
  {
    "id": "3576825a-7cdb-4aa5-95d2-72c6ec3231cf",
    "fullName": "\\src\\tools\\function_tools::calculateLanguagePercentages",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function calculateLanguagePercentages(languages: string[]) {\n  const total = languages.length\n  const counts: Record<string, number> = {}\n\n  languages.forEach((language) => {\n    counts[language] = (counts[language] || 0) + 1\n  })\n\n  const percentages: Record<string, string> = {}\n  for (const [language, count] of Object.entries(counts)) {\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\n  }\n\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\n    parseFloat(b[1]) - parseFloat(a[1])\n  )\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\n\n  return sortedPercentages\n}",
    "codeNoBody": "function calculateLanguagePercentages(languages: string[]) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "calculateLanguagePercentages",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "generatedDocumentation": "This function takes an array of strings representing programming languages as a parameter and calculates the percentage of each language occurrence in the array. It returns an object where the keys are the languages and the values are the percentages. The function first counts the occurrences of each language, then calculates the percentage based on the total count, sorts the percentages in descending order, and returns the sorted object.",
    "importStatements": ""
  },
  {
    "id": "f3e27f75-a99b-40ca-9da0-158c36552a67",
    "fullName": "\\src\\tools\\function_tools",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\n\nfunction calculateLanguagePercentages(languages: string[]) {\n  const total = languages.length\n  const counts: Record<string, number> = {}\n\n  languages.forEach((language) => {\n    counts[language] = (counts[language] || 0) + 1\n  })\n\n  const percentages: Record<string, string> = {}\n  for (const [language, count] of Object.entries(counts)) {\n    percentages[language] = (count / total * 100).toFixed(2) + '%'\n  }\n\n  const sortedPercentagesArray = Object.entries(percentages).sort((a, b) =>\n    parseFloat(b[1]) - parseFloat(a[1])\n  )\n  const sortedPercentages = Object.fromEntries(sortedPercentagesArray)\n\n  return sortedPercentages\n}\n\ninterface Similarity {\n  id: string\n  score: number\n}\n\nexport async function getGraphNodesById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphNode[]> {\n  try {\n    const rows = await sql<GraphNode[]>`\n      SELECT\n        n.id,\n        n.full_name,\n        n.type,\n        n.language,\n        n.documentation,\n        n.code,\n        n.code_no_body,\n        n.total_tokens,\n        n.in_degree,\n        n.out_degree,\n        n.label\n      FROM graphs g\n      JOIN repositories r\n        ON r.id = g.repo_id\n      JOIN nodes n\n        ON n.repo_id = r.id\n      WHERE g.id = ${graphId}\n        AND g.org_id = ${userOrgId}\n        AND g.status = 'completed'\n    `\n\n    return rows\n  } catch (error) {\n    console.log('Error getting graph nodes by id', error)\n    return []\n  }\n}\n\nexport async function getGraphLinksById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphLink[]> {\n  try {\n    const rows = await sql<GraphLink[]>`\n      SELECT\n        l.id,\n        l.node_source_id,\n        l.node_target_id,\n        l.label\n      FROM graphs g\n      JOIN repositories r\n        ON r.id = g.repo_id\n      JOIN links l\n        ON l.repo_id = r.id\n      WHERE g.id = ${graphId}\n        AND g.org_id = ${userOrgId}\n        AND g.status = 'completed'\n    `\n\n    return rows\n  } catch (error) {\n    console.log('Error getting graph links by id', error)\n    return []\n  }\n}\n\nfunction topNSimilar(\n  targetName: string,\n  nodes: GraphNode[],\n  n: number = 10,\n): string[] {\n  const similarities: Similarity[] = nodes.map((n) => ({\n    id: n.full_name,\n    score: distance(targetName, n.label),\n  }))\n\n  const topN = similarities.sort((a, b) => a.score - b.score).slice(0, n)\n\n  return topN.filter((item) => item.score <= CONFIGURATION.DISTANCE_THRESHOLD)\n    .map((item) => item.id)\n}\n\n/**\n * Finds the most similar nodes to the given name based on their type.\n *\n * @param {string} name - The name to compare against.\n * @param {GraphNode[]} nodes - The array of nodes to search.\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\n */\nfunction similarTo(\n  name: string,\n  nodes: GraphNode[],\n  type: NodeType | 'all' = 'all',\n  n = 10,\n) {\n  const similarNodes = []\n  let topFiles: string[] = []\n  let topClasses: string[] = []\n  let topFunctions: string[] = []\n  let topMethods: string[] = []\n  let topInterfaces: string[] = []\n  let topAssignments: string[] = []\n  let similars: string[] = []\n\n  if (type === 'all') {\n    topFiles = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'file'),\n      n,\n    )\n\n    topClasses = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'class'),\n      n,\n    )\n    topFunctions = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'function'),\n      n,\n    )\n    topMethods = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'method'),\n      n,\n    )\n    topInterfaces = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'interface'),\n      n,\n    )\n    topAssignments = topNSimilar(\n      name,\n      nodes.filter((n) => n.type === 'assignment'),\n      n,\n    )\n\n    if (topFiles.length > 0) {\n      similarNodes.push(` - Files: ${topFiles}`)\n    }\n    if (topClasses.length > 0) {\n      similarNodes.push(` - Classes: ${topClasses}`)\n    }\n    if (topFunctions.length > 0) {\n      similarNodes.push(` - Functions: ${topFunctions}`)\n    }\n    if (topMethods.length > 0) {\n      similarNodes.push(` - Methods: ${topMethods}`)\n    }\n    if (topInterfaces.length > 0) {\n      similarNodes.push(` - Interfaces: ${topInterfaces}`)\n    }\n    if (topAssignments.length > 0) {\n      similarNodes.push(` - Assignments: ${topAssignments}`)\n    }\n  } else {\n    similars = topNSimilar(name, nodes.filter((n) => n.type === type), n)\n    if (similars.length > 0) {\n      similarNodes.push(\n        ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${similars}`,\n      )\n    }\n  }\n\n  if (similarNodes.length === 0) {\n    return {\n      content: `No similar node IDs found for ${name}.`,\n      match: '',\n      similars: similarNodes.slice(0, 1),\n      topFiles: topFiles.slice(0, 1),\n      topClasses: topClasses.slice(0, 1),\n      topFunctions: topFunctions.slice(0, 1),\n      topMethods: topMethods.slice(0, 1),\n      topInterfaces: topInterfaces.slice(0, 1),\n      topAssignments: topAssignments.slice(0, 1),\n    }\n  } else {\n    return {\n      content: `Similar node IDs to ${name}:\\n${similarNodes.join('\\n')}`,\n      match: '',\n      similars: similarNodes.slice(0, 1),\n      topFiles: topFiles.slice(0, 1),\n      topClasses: topClasses.slice(0, 1),\n      topFunctions: topFunctions.slice(0, 1),\n      topMethods: topMethods.slice(0, 1),\n      topInterfaces: topInterfaces.slice(0, 1),\n      topAssignments: topAssignments.slice(0, 1),\n    }\n  }\n}\n\ninterface nodeSeen {\n  [key: string]: boolean\n}\n\nasync function getCode(\n  nodes: GraphNode[],\n  links: GraphLink[],\n  nodeName?: string,\n  nodeId?: string,\n  maxTokens = 4096,\n  nodesSeen: nodeSeen = {},\n  maxDeepLevel = 2,\n  // deno-lint-ignore no-explicit-any\n): Promise<any> {\n  if (!nodesSeen) {\n    nodesSeen = {}\n  }\n\n  let node: GraphNode | undefined\n  if (nodeId) {\n    node = nodes.find((node) => node.id === nodeId)\n    if (node) {\n      nodeName = node.label\n    }\n  } else if (nodeName) {\n    node = nodes.find((node) => node.label === nodeName) ||\n      nodes.find((node) => node.full_name.endsWith(nodeName ?? '_NOTFOUND_'))\n  }\n\n  let toReturn = ''\n  if (maxTokens < 0) {\n    return toReturn\n  }\n\n  if (Object.keys(nodesSeen).length > 0) {\n    toReturn += '\\n\\n-------\\n\\n'\n  }\n\n  if (node) {\n    nodesSeen[node.id] = true\n    const language = node.language\n    toReturn += `From ${node.full_name}:\\n`\n    if (node.documentation) {\n      toReturn += `\\nDocumentation of ${node.label}:\\n\\n${node.documentation}\\n`\n    }\n    if (node.total_tokens > maxTokens || node.type === 'file') {\n      toReturn += `\\`\\`\\`${language}\\n${node.code_no_body}\\n\\`\\`\\``\n    } else {\n      toReturn += `\\`\\`\\`${language}\\n${node.code}\\n\\`\\`\\``\n    }\n\n    if (maxDeepLevel > 0) {\n      maxDeepLevel -= 1\n      const calls = links.filter((link) =>\n        link.node_source_id === node!.id && link.label === 'calls'\n      )\n      for (const call of calls) {\n        if (nodesSeen[call.node_target_id]) {\n          continue\n        }\n        nodesSeen[call.node_target_id] = true\n        const callNode = await getCode(\n          nodes,\n          links,\n          undefined,\n          call.node_target_id,\n          maxTokens - node.total_tokens,\n          nodesSeen,\n          maxDeepLevel,\n        )\n        toReturn += callNode\n      }\n    }\n  } else {\n    toReturn = `There is no node named ${nodeName}.\\n`\n    if (nodeName) {\n      const res = similarTo(nodeName, nodes)\n      return {\n        ...res,\n        content: toReturn + res.content,\n        targetNodes: [],\n        sourceNodes: [],\n      }\n    }\n  }\n\n  let targetNodes: GraphNode[] = []\n  let sourceNodes: GraphNode[] = []\n\n  if (node) {\n    const targetLinks = links.filter((link) => {\n      return link.node_source_id === node.id\n    }) ?? []\n\n    const sourceLinks = links.filter((link) => {\n      return link.node_target_id === node.id\n    }) ?? []\n\n    sourceNodes = nodes.filter((node) => {\n      return sourceLinks.some((link) => link.node_source_id === node.id)\n    }) ?? []\n\n    targetNodes = nodes.filter((node) => {\n      return targetLinks.some((link) => link.node_target_id === node.id)\n    }) ?? []\n  }\n\n  return {\n    content: toReturn,\n    match: nodeName,\n    topFiles: [],\n    topClasses: [],\n    topFunctions: [],\n    topMethods: [],\n    topInterfaces: [],\n    topAssignments: [],\n    targetNodes,\n    sourceNodes,\n  }\n}\n\nexport async function getUserToolsAndPrompt(\n  userOrgId: string,\n  graphId: string,\n) {\n  const [nodes, links] = await Promise.all([\n    getGraphNodesById({ userOrgId, graphId }),\n    getGraphLinksById({ userOrgId, graphId }),\n  ])\n\n  const nodesPerType = nodes.reduce((acc, node) => {\n    if (!acc[node.type]) {\n      acc[node.type] = []\n    }\n    acc[node.type].push(node)\n    return acc\n  }, {} as Record<NodeType, GraphNode[]>)\n\n  // sort mostUsedNodesPerType by in_degree + out_degree and return 5 max values\n  const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\n    acc[type as NodeType] = nodesPerType[type as NodeType].sort(\n      (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree),\n    ).slice(0, 5).map((n) => n.full_name)\n    return acc\n  }, {} as Record<NodeType, (string | number)[]>)\n\n  const allLanguages = calculateLanguagePercentages(\n    nodesPerType['file'].map((n) => n.language),\n  )\n  const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) =>\n    `${name}: ${pct}`\n  ).join(', ')\n\n  let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\n    return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${\n      mostUsedNodesPerType[type as NodeType]\n    }`\n  }).join('\\n')\n\n  prompt = `Languages: ${allLanguagesString}\n  The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\n  These are the most common nodes Ids from the repository:\\n${prompt}`\n\n  function getCodeTool(nodeName: string) {\n    return getCode(nodes, links, nodeName)\n  }\n\n  function getCodenbyNodeIdTool(nodeId: string) {\n    return getCode(nodes, links, undefined, nodeId)\n  }\n\n  function similarToTool(\n    nodeName: string,\n    type: NodeType | undefined = undefined,\n  ) {\n    return similarTo(nodeName, nodes, type)\n  }\n\n  return { getCodeTool, similarToTool, getCodenbyNodeIdTool, prompt }\n}\n\nexport const getCodeDescription: FunctionDefinition = {\n  name: 'get_code',\n  description: 'Get the code of a node by its name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The name of the node to get the code of',\n      },\n    },\n    required: ['node_name'],\n  },\n}\n\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\n  name: 'get_code_by_node_id',\n  description:\n    'Get the code of a node by its id in the form my/path/file::node_name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_id: {\n        type: 'string',\n        description:\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\n      },\n    },\n    required: ['node_id'],\n  },\n}\n\nexport const similarToDescription: FunctionDefinition = {\n  name: 'similar_to',\n  description:\n    'Find similar node names by a name. It returns a list of node Ids.',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The node name to search for similar nodes',\n      },\n    },\n    required: ['node_name'],\n  },\n}\n\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\n\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\n// const links = await getGraphLinksById({ userOrgId, graphId })\n\n// console.log(await getCode(nodes, links, 'langchain_utils'))\n\n// // console.log(similarTo('Props', nodes, 'all'))\n// const nodesPerType = nodes.reduce((acc, node) => {\n//   if (!acc[node.type]) {\n//     acc[node.type] = []\n//   }\n//   acc[node.type].push(node)\n//   return acc\n// }, {} as Record<NodeType, GraphNode[]>)\n\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\n\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\n// console.log(allLanguagesString)\n\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\n//     ).slice(0, 5).map((n) => n.full_name)\n//   return acc\n// }, {} as Record<NodeType, (string | number)[]>)\n\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\n// }).join('\\n')\n\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\n// These are the most common nodes Ids from the repository:\\n${prompt}`\n\n// console.log(prompt)\n",
    "codeNoBody": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'\nfunction calculateLanguagePercentages(languages: string[]) {\n//...\n}\n\ninterface Similarity {\n//...\n}\n\nexport async function getGraphNodesById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphNode[]> {\n       //...\n       }\n\nexport async function getGraphLinksById({\n  userOrgId,\n  graphId,\n}: {\n  userOrgId: string\n  graphId: string\n}): Promise<GraphLink[]> {\n       //...\n       }\n\nfunction topNSimilar(\n  targetName: string,\n  nodes: GraphNode[],\n  n: number = 10,\n): string[] {\n//...\n}\n\n/**\n * Finds the most similar nodes to the given name based on their type.\n *\n * @param {string} name - The name to compare against.\n * @param {GraphNode[]} nodes - The array of nodes to search.\n * @param {number} [n=10] - The maximum number of similar nodes to return for each type.\n * @returns {SimilarNodes} An object containing the most similar nodes grouped by type.\n */\nfunction similarTo(\n  name: string,\n  nodes: GraphNode[],\n  type: NodeType | 'all' = 'all',\n  n = 10,\n) {\n//...\n}\n\ninterface nodeSeen {\n//...\n}\n\nasync function getCode(\n  nodes: GraphNode[],\n  links: GraphLink[],\n  nodeName?: string,\n  nodeId?: string,\n  maxTokens = 4096,\n  nodesSeen: nodeSeen = {},\n  maxDeepLevel = 2,\n  // deno-lint-ignore no-explicit-any\n): Promise<any> {\n//...\n}\n\nexport async function getUserToolsAndPrompt(\n  userOrgId: string,\n  graphId: string,\n) {\n       //...\n       }\n\nexport const getCodeDescription: FunctionDefinition = {\n  name: 'get_code',\n  description: 'Get the code of a node by its name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The name of the node to get the code of',\n      },\n    },\n    required: ['node_name'],\n  },\n}\n\nexport const getCodebyNodeIdDescription: FunctionDefinition = {\n  name: 'get_code_by_node_id',\n  description:\n    'Get the code of a node by its id in the form my/path/file::node_name',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_id: {\n        type: 'string',\n        description:\n          'The id of the node to get the code of. Must be in the format my/path/file::node_name',\n      },\n    },\n    required: ['node_id'],\n  },\n}\n\nexport const similarToDescription: FunctionDefinition = {\n  name: 'similar_to',\n  description:\n    'Find similar node names by a name. It returns a list of node Ids.',\n  parameters: {\n    type: 'object',\n    properties: {\n      node_name: {\n        type: 'string',\n        description: 'The node name to search for similar nodes',\n      },\n    },\n    required: ['node_name'],\n  },\n}\n\n// const userOrgId = '0e2473ff-b3c3-4a92-a94d-8f2e72ef672c'\n// const graphId = 'b0203565-40cc-4474-b56a-1368272fdd2d'\n\n// const nodes: GraphNode[] = await getGraphNodesById({ userOrgId, graphId })\n// const links = await getGraphLinksById({ userOrgId, graphId })\n\n// console.log(await getCode(nodes, links, 'langchain_utils'))\n\n// // console.log(similarTo('Props', nodes, 'all'))\n// const nodesPerType = nodes.reduce((acc, node) => {\n//   if (!acc[node.type]) {\n//     acc[node.type] = []\n//   }\n//   acc[node.type].push(node)\n//   return acc\n// }, {} as Record<NodeType, GraphNode[]>)\n\n// const allLanguages = calculateLanguagePercentages(nodesPerType['file'].map((n) => n.language))\n\n// const allLanguagesString = Object.entries(allLanguages).map(([name, pct]) => `${name}: ${pct}` ).join(', ')\n// console.log(allLanguagesString)\n\n// // sort mostUsedNodesPerType by in_degree + out_degree and return 10 max values\n// const mostUsedNodesPerType = Object.keys(nodesPerType).reduce((acc, type) => {\n//   acc[type as NodeType] = nodesPerType[type as NodeType].sort(\n//       (a, b) => (b.out_degree + b.in_degree) - (a.out_degree + a.in_degree)\n//     ).slice(0, 5).map((n) => n.full_name)\n//   return acc\n// }, {} as Record<NodeType, (string | number)[]>)\n\n// let prompt = Object.keys(mostUsedNodesPerType).map((type) => {\n//   return ` - ${type.charAt(0).toUpperCase() + type.slice(1)}: ${mostUsedNodesPerType[type as NodeType]}`\n// }).join('\\n')\n\n// prompt = `The repository is represented by nodes and links, having a node name, type, code and ID. The node ID is represented by the parent file and name in the form my/path/file::node_name, where my/path/file is the ID of the file, which is also a node.\n// These are the most common nodes Ids from the repository:\\n${prompt}`\n\n// console.log(prompt)",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\tools\\function_tools.ts",
    "originFile": "",
    "generatedDocumentation": "# function_tools.ts\n\n## Overview\n\nThe `function_tools.ts` file is a part of the `codebase-index-ts` repository, located in the `src/tools` directory. This file provides a set of utility functions and definitions for working with graph nodes and links within a codebase. These utilities are essential for retrieving, analyzing, and manipulating graph data, which represents the structure and relationships within a code repository.\n\n## Main Features and Purpose\n\n### 1. Graph Data Retrieval\n\n- **getGraphNodesById**: This asynchronous function retrieves an array of `GraphNode` objects based on the provided `userOrgId` and `graphId`. It queries a database to fetch specific node attributes such as `id`, `full_name`, `type`, `language`, `documentation`, `code`, `code_no_body`, `total_tokens`, `in_degree`, `out_degree`, and `label`.\n\n- **getGraphLinksById**: Similar to `getGraphNodesById`, this asynchronous function retrieves an array of `GraphLink` objects based on the provided `userOrgId` and `graphId`. It queries the database to select specific fields from the \"links\" table by joining \"graphs,\" \"repositories,\" and \"links\" tables.\n\n### 2. Code Retrieval and Description\n\n- **getCode**: This function retrieves code snippets and documentation from a specified node or similar nodes based on name or ID. It takes an array of `GraphNode` objects, an array of `GraphLink` objects, an optional `nodeName` or `nodeId`, a `maxTokens` limit, a `nodeSeen` object to track visited nodes, and a `maxDeepLevel` for recursion.\n\n- **getCodeDescription**: Defines a function named 'get_code' that retrieves the code of a node based on its name, with a required parameter 'node_name' of type string.\n\n- **getCodebyNodeIdDescription**: Defines a function named \"get_code_by_node_id\" that retrieves the code of a node based on its unique identifier in the format \"my/path/file::node_name\", with a required parameter \"node_id\" specifying the node to fetch the code from.\n\n### 3. Similarity and Analysis\n\n- **similarTo**: This function finds the most similar nodes to a given name based on their type. It takes a name string, an array of `GraphNode` objects, a type string or 'all' (default 'all'), and an optional number `n` (default 10) as parameters. It calculates the similarity between the name and each `GraphNode` label and returns an object containing the most similar nodes grouped by type.\n\n- **similarToDescription**: Defines a function named \"similar_to\" that finds similar node names based on a provided name, returning a list of node IDs. It takes an object parameter with a required property \"node_name\" specifying the name to search for similar nodes.\n\n- **topNSimilar**: This function calculates the similarity score between a target name and each `GraphNode` label, stores the results in an array of `Similarity` objects, sorts them by score, selects the top `n` similar items, and returns an array of their IDs.\n\n### 4. Utility Functions\n\n- **calculateLanguagePercentages**: This function calculates the percentage of each programming language occurrence in an array of languages. It returns an object where the keys are the languages and the values are the percentages.\n\n### 5. User Tools and Prompt Generation\n\n- **getUserToolsAndPrompt**: This function asynchronously retrieves graph nodes and links based on the provided `userOrgId` and `graphId`, categorizes nodes by type, identifies the most used nodes per type based on `in_degree` and `out_degree`, calculates language percentages, and generates a prompt displaying the most common node IDs. It also provides tools to get code snippets and documentation for a specified node name or ID, find similar nodes based on name or type, and retrieve similar items for files, classes, functions, methods, interfaces, and assignments.\n\n## Important Definitions\n\n- **GraphNode**: Represents a node in the graph, with attributes such as `id`, `full_name`, `type`, `language`, `documentation`, `code`, `code_no_body`, `total_tokens`, `in_degree`, `out_degree`, and `label`.\n\n- **GraphLink**: Represents a link between nodes in the graph.\n\n- **FunctionDefinition**: Defines the structure of a function, including its name, description, and parameters.\n\n- **Similarity**: An interface defining a structure with two properties: `id` (string) and `score` (number), representing an object that stores an identifier and a numerical value to measure similarity.\n\n- **nodeSeen**: An interface defining an object where keys are strings and values are booleans, used to track the presence of nodes in a data structure.\n\n## Conclusion\n\nThe `function_tools.ts` file is crucial for managing and analyzing graph data within the `codebase-index-ts` repository. It provides functions for retrieving graph nodes and links, calculating similarities between nodes, and generating descriptive prompts. These utilities facilitate a deeper understanding of the codebase structure and relationships, aiding in tasks such as code retrieval, documentation, and analysis.",
    "importStatements": "import { distance } from 'https://deno.land/x/fastest_levenshtein@1.0.10/mod.ts'\nimport { sql } from '@/lib/db/index.ts'\nimport { GraphLink, GraphNode, NodeType } from '@/types/graph.ts'\nimport { FunctionDefinition } from 'npm:@azure/openai@1.0.0-beta.11'\nimport { CONFIGURATION } from '@/lib/ai/consts.ts'"
  },
  {
    "id": "4eab64c1-ddf5-4f10-a171-6ac0a9767e2b",
    "fullName": "\\src\\utils\\ai::getOpenAIChatCompletion",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-3.5-turbo') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
    "codeNoBody": "async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-3.5-turbo') : Promise<chatResponse> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getOpenAIChatCompletion",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
    "generatedDocumentation": "This async function \"getOpenAIChatCompletion\" utilizes the OpenAI API to generate chat completions based on the provided messages and model (defaulting to 'gpt-3.5-turbo') with a temperature of 0.3. It returns a Promise resolving to a chatResponse object containing the generated response and, if available, the total tokens used during the completion process.",
    "importStatements": ""
  },
  {
    "id": "8e61e35c-c9f5-4d8f-8dd7-a9fa89ffad3e",
    "fullName": "\\src\\utils\\ai::chatResponse",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}",
    "codeNoBody": "interface chatResponse {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "chatResponse",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
    "generatedDocumentation": "The interface \"chatResponse\" defines an object with a required \"response\" property of type string and an optional \"tokens\" property of type number, allowing for structured representation of chatbot responses with the possibility of including token information.",
    "importStatements": ""
  },
  {
    "id": "f4620739-cff3-48d8-aa9e-1bd528b4b594",
    "fullName": "\\src\\utils\\ai::chatCompletionMessages",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "codeNoBody": "type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "chatCompletionMessages",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
    "generatedDocumentation": "Code: type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]",
    "importStatements": ""
  },
  {
    "id": "91422857-e6fa-4421-b8c2-5ba82af12953",
    "fullName": "\\src\\utils\\ai",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import OpenAI from 'openai';\r\n\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\r\n    response: string\r\n    tokens?: number\r\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-3.5-turbo') : Promise<chatResponse> {\r\n    const openai = new OpenAI({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n    });\r\n\r\n    const chatCompletion = await openai.chat.completions.create({\r\n        model: model,\r\n        messages: messages,\r\n        temperature: 0.3\r\n    })\r\n\r\n    if (chatCompletion.choices[0].message.content) {\r\n        return {\r\n            response: chatCompletion.choices[0].message.content,\r\n            tokens: chatCompletion.usage?.total_tokens\r\n        }\r\n    } else {\r\n        return {\r\n            response: ''\r\n        }\r\n    }\r\n}",
    "codeNoBody": "import OpenAI from 'openai';\r\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[]\r\n\r\n\r\n\r\ninterface chatResponse {\n//...\n}\r\n\r\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-3.5-turbo') : Promise<chatResponse> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\ai.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/utils/ai.ts` Wiki\n\n## Overview\nThe `ai.ts` file located in the `src/utils` directory serves as a utility for interacting with the OpenAI API. Its primary purpose is to facilitate the generation of chat completions by leveraging OpenAI's language models. This file defines types and functions that structure and manage the interaction with the API, ensuring that responses are handled in a consistent and efficient manner.\n\n## Main Features\n\n### Type Definitions\n\n#### `chatCompletionMessages`\n```typescript\nexport type chatCompletionMessages = OpenAI.Chat.Completions.ChatCompletionMessageParam[];\n```\n- **Purpose**: This type alias defines an array of message parameters that are used as input for the chat completion function. It ensures that the messages conform to the structure expected by the OpenAI API.\n\n#### `chatResponse`\n```typescript\ninterface chatResponse {\n    response: string;\n    tokens?: number;\n}\n```\n- **Purpose**: The `chatResponse` interface defines the structure of the response object returned by the chat completion function. It includes:\n  - `response`: A required property of type `string` that contains the generated chat response.\n  - `tokens`: An optional property of type `number` that indicates the total number of tokens used during the completion process.\n\n### Functions\n\n#### `getOpenAIChatCompletion`\n```typescript\nexport async function getOpenAIChatCompletion(messages: chatCompletionMessages, model: string = 'gpt-3.5-turbo') : Promise<chatResponse> {\n    //...\n}\n```\n- **Purpose**: This asynchronous function interacts with the OpenAI API to generate chat completions. It takes in:\n  - `messages`: An array of message parameters that guide the completion process.\n  - `model`: An optional string parameter specifying the model to use, defaulting to `'gpt-3.5-turbo'`.\n- **Functionality**: The function sends the provided messages to the OpenAI API and retrieves a completion. It then returns a `Promise` that resolves to a `chatResponse` object, which includes the generated response and optionally, the total tokens used.\n\n## Important Definitions\n\n- **`chatCompletionMessages`**: This type ensures that the input messages to the OpenAI API are correctly structured.\n- **`chatResponse`**: This interface provides a standardized way to handle and represent the responses from the OpenAI API, including both the generated text and token usage information.\n\n## Purpose of the File\nThe `ai.ts` file is designed to streamline the process of generating chat completions using OpenAI's models. By defining clear types and a robust function for API interaction, it simplifies the integration of advanced language models into applications, ensuring that developers can easily obtain and manage AI-generated responses.",
    "importStatements": "import OpenAI from 'openai';"
  },
  {
    "id": "f370361a-4eee-4c98-889a-fea4fb98c5c9",
    "fullName": "\\src\\utils\\bitbucket\\refresh-token::refreshAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "refreshAccessToken",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts",
    "generatedDocumentation": "This async function \"refreshAccessToken\" takes a refresh token as a parameter, sends a POST request to Bitbucket's access token endpoint with the provided refresh token, Bitbucket client ID, and client secret to get a new access token and refresh token. If the request is successful, it returns an object with the new access token and refresh token; otherwise, it logs an error message and returns null.",
    "importStatements": ""
  },
  {
    "id": "da94cd21-ea66-4434-85f4-a3cca0163e5f",
    "fullName": "\\src\\utils\\bitbucket\\refresh-token",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const rawBody = {\r\n      refresh_token: refreshToken,\r\n      grant_type: 'refresh_token',\r\n      client_id: getEnv('BITBUCKET_KEY'),\r\n      client_secret: getEnv('BITBUCKET_SECRET')\r\n    }\r\n\r\n    const body = Object.entries(rawBody)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&')\r\n\r\n    const res = await fetch('https://bitbucket.org/site/oauth2/access_token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      body\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\bitbucket\\refresh-token.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/utils/bitbucket/refresh-token.ts`\n\n## Overview\nThe `refresh-token.ts` file is part of the `utils` folder within the `codebase-index-ts` repository. This file contains utility functions specifically designed to interact with Bitbucket's API, focusing on refreshing access tokens.\n\n## Purpose\nThe primary purpose of this file is to handle the process of obtaining a new access token from Bitbucket using a provided refresh token. This is crucial for maintaining authenticated sessions without requiring the user to re-authenticate frequently.\n\n## Main Features\n### `refreshAccessToken`\n- **Function Definition**: `export async function refreshAccessToken(refreshToken: string): Promise<any>`\n- **Parameters**: \n  - `refreshToken` (string): The refresh token used to obtain a new access token.\n- **Functionality**:\n  - Sends a POST request to Bitbucket's access token endpoint.\n  - Includes the provided refresh token, Bitbucket client ID, and client secret in the request.\n  - If the request is successful, it returns an object containing the new access token and refresh token.\n  - If the request fails, it logs an error message and returns `null`.\n\n### Dependencies\n- **getEnv**: This utility function is imported from `../utils` and is likely used to retrieve environment variables such as Bitbucket client ID and client secret.\n\n## Important Definitions\n- **Access Token**: A token that allows access to Bitbucket's API.\n- **Refresh Token**: A token used to obtain a new access token once the current one expires.\n\n## Usage\nThis file is essential for applications that need to maintain continuous access to Bitbucket's API without requiring frequent user re-authentication. It ensures that the application can seamlessly refresh its access tokens using the provided refresh tokens.\n\nBy handling token refreshes in this utility file, the codebase maintains a clean separation of concerns, making it easier to manage and debug authentication-related issues.",
    "importStatements": "import { getEnv } from \"../utils\""
  },
  {
    "id": "3b22a521-d1a8-4757-b0d1-d7cea9d25826",
    "fullName": "\\src\\utils\\db::getGraphLinksById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphLinksById",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "generatedDocumentation": "The `getGraphLinksById` function retrieves graph links based on the provided `userOrgId` and `graphId`. It queries the database to select link properties such as id, source, target, label, and line number from the graphs, repositories, and links tables, filtering by the specified `userOrgId`, `graphId`, and ensuring the graph's status is 'completed'. If successful, it returns an array of objects conforming to the GraphLink interface; otherwise, it logs an error and returns an empty array.",
    "importStatements": ""
  },
  {
    "id": "6bddee9d-5039-4024-b4c7-fb9230a0a01e",
    "fullName": "\\src\\utils\\db::getGraphNodesById",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS fullName,\r\n        n.type as,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS codeNoBody,\r\n        n.total_tokens AS totalTokens,\r\n        n.in_degree AS inDegree,\r\n        n.out_degree AS outDegree,\r\n        n.label,\r\n        n.origin_file AS originFile,\r\n        n.generated_documentation AS generatedDocumentation,\r\n        n.import_statements AS importStatements\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getGraphNodesById",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "generatedDocumentation": "The function getGraphNodesById retrieves graph nodes based on the provided user organization ID and graph ID, returning an array of GraphNode objects containing properties such as id, fullName, type, language, documentation, code, codeNoBody, totalTokens, inDegree, outDegree, label, originFile, generatedDocumentation, and importStatements. It executes a SQL query to fetch the relevant nodes from the database associated with the specified graph and organization, handling potential errors by logging them and returning an empty array.",
    "importStatements": ""
  },
  {
    "id": "d6e57476-00cd-43ea-93a0-be880624212c",
    "fullName": "\\src\\utils\\db::GraphLink",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}",
    "codeNoBody": "interface GraphLink {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GraphLink",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "generatedDocumentation": "The \"GraphLink\" interface defines the structure for representing links in a graph, including properties like id, source, target, label, and an optional line number.",
    "importStatements": ""
  },
  {
    "id": "a6ecc526-7461-498b-8c52-a2a583ef6846",
    "fullName": "\\src\\utils\\db::GraphNode",
    "type": "interface",
    "language": "typescript",
    "documentation": "",
    "code": "interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}",
    "codeNoBody": "interface GraphNode {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GraphNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "generatedDocumentation": "Interface \"GraphNode\" defines properties for representing a node in a graph structure, including id, fullName, type, language, documentation, code, codeNoBody, totalTokens, inDegree, outDegree, label, originFile, generatedDocumentation, and importStatements.",
    "importStatements": ""
  },
  {
    "id": "afdb85eb-7ab6-4758-8972-c9b698b2a999",
    "fullName": "\\src\\utils\\db::sql",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "codeNoBody": "export const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "sql",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "generatedDocumentation": "The \"sql\" function in this code snippet sets up a PostgreSQL connection using environment variables for the host, database name, port, username, password, and SSL certificate. It includes options for connection and idle timeouts, as well as SSL configuration.",
    "importStatements": ""
  },
  {
    "id": "c3b1d092-2625-44c0-a3b7-53a45cd4d8d8",
    "fullName": "\\src\\utils\\db",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\n\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\r\n  id: string\r\n  fullName: string\r\n  type: AllowedTypes\r\n  language: string\r\n  documentation?: string\r\n  code: string\r\n  codeNoBody: string\r\n  totalTokens: number\r\n  inDegree: number\r\n  outDegree: number\r\n  label: string\r\n  originFile?: string\r\n  generatedDocumentation?: string\r\n  importStatements?: string\r\n}\r\n\r\nexport interface GraphLink {\r\n  id: string\r\n  source: string\r\n  target: string\r\n  label: string\r\n  line?: number\r\n}\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\r\n  try {\r\n    const rows = await sql<GraphNode[]>`\r\n      SELECT\r\n        n.id,\r\n        n.full_name AS fullName,\r\n        n.type as,\r\n        n.language,\r\n        n.documentation,\r\n        n.code,\r\n        n.code_no_body AS codeNoBody,\r\n        n.total_tokens AS totalTokens,\r\n        n.in_degree AS inDegree,\r\n        n.out_degree AS outDegree,\r\n        n.label,\r\n        n.origin_file AS originFile,\r\n        n.generated_documentation AS generatedDocumentation,\r\n        n.import_statements AS importStatements\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN nodes n\r\n        ON n.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph nodes by id', error)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\r\n  try {\r\n    const rows = await sql<GraphLink[]>`\r\n      SELECT\r\n        l.id,\r\n        l.node_source_id AS source,\r\n        l.node_target_id AS target,\r\n        l.label,\r\n        l.line\r\n      FROM graphs g\r\n      JOIN repositories r\r\n        ON r.id = g.repo_id\r\n      JOIN links l\r\n        ON l.repo_id = r.id\r\n      WHERE g.id = ${graphId}\r\n        AND g.org_id = ${userOrgId}\r\n        AND g.status = 'completed'\r\n    `\r\n\r\n    return rows\r\n  } catch (error) {\r\n    console.log('Error getting graph links by id', error)\r\n    return []\r\n  }\r\n}",
    "codeNoBody": "import { AllowedTypes } from '../model/consts'\r\nimport { getEnv } from './utils'\r\nimport postgres from 'postgres'\r\nexport const sql = postgres({\r\n  host: getEnv('DATABASE_HOST'),\r\n  database: getEnv('DATABASE_NAME'),\r\n  port: Number(getEnv('DATABASE_PORT')),\r\n  user: getEnv('DATABASE_USERNAME'),\r\n  password: getEnv('DATABASE_PASSWORD'),\r\n  prepare: false,\r\n  connect_timeout: 60,\r\n  idle_timeout: 60,\r\n  ssl: {\r\n    ca: getEnv('SUPABASE_CA_CERTIFICATE')\r\n  }\r\n  // ssl: {\r\n  //   rejectUnauthorized: false\r\n  // }\r\n})\r\n\r\n\r\nexport interface GraphNode {\n       //...\n       }\r\n\r\nexport interface GraphLink {\n       //...\n       }\r\n\r\nexport async function getGraphNodesById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphNode[]> {\n       //...\n       }\r\n\r\nexport async function getGraphLinksById({\r\n  userOrgId,\r\n  graphId,\r\n}: {\r\n  userOrgId: string\r\n  graphId: string\r\n}): Promise<GraphLink[]> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\db.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/utils/db.ts` Wiki\n\n## Overview\nThe `db.ts` file in the `src/utils` directory is responsible for setting up and managing database interactions within the codebase. It primarily focuses on establishing a connection to a PostgreSQL database and providing functions to retrieve graph-related data.\n\n## Main Features and Purpose\nThe main purpose of this file is to handle database connectivity and provide utility functions for fetching graph nodes and links from the database. Below are the key components and their functionalities:\n\n### PostgreSQL Connection Setup\n- **`sql`**: This constant sets up a connection to a PostgreSQL database using the `postgres` library. It utilizes environment variables to configure the connection details such as host, database name, port, username, password, and SSL certificate. The connection is configured with specific timeouts and SSL settings to ensure secure and reliable communication with the database.\n\n### Interfaces\n- **`GraphNode`**: This interface defines the structure of a graph node. It includes properties such as `id`, `fullName`, `type`, `language`, `documentation`, `code`, `codeNoBody`, `totalTokens`, `inDegree`, `outDegree`, `label`, `originFile`, `generatedDocumentation`, and `importStatements`.\n- **`GraphLink`**: This interface defines the structure of a graph link. It includes properties such as `id`, `source`, `target`, `label`, and an optional `lineNumber`.\n\n### Functions\n- **`getGraphNodesById`**: This asynchronous function retrieves graph nodes based on the provided `userOrgId` and `graphId`. It executes a SQL query to fetch relevant nodes from the database, handling potential errors by logging them and returning an empty array if any issues occur. The returned data conforms to the `GraphNode` interface.\n- **`getGraphLinksById`**: This asynchronous function retrieves graph links based on the provided `userOrgId` and `graphId`. It queries the database to select link properties such as `id`, `source`, `target`, `label`, and `lineNumber` from the graphs, repositories, and links tables. The function ensures the graph's status is 'completed' and returns an array of objects conforming to the `GraphLink` interface, logging errors and returning an empty array if necessary.\n\n## Important Definitions\n- **Environment Variables**: The database connection relies on several environment variables (`DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_PORT`, `DATABASE_USERNAME`, `DATABASE_PASSWORD`, `SUPABASE_CA_CERTIFICATE`) to configure the connection settings securely.\n- **SQL Queries**: The functions `getGraphNodesById` and `getGraphLinksById` execute SQL queries to fetch data from the database. These queries are tailored to retrieve specific graph-related information based on the provided identifiers (`userOrgId` and `graphId`).\n\n## Conclusion\nThe `db.ts` file is a crucial part of the codebase, facilitating secure and efficient database interactions. By setting up a PostgreSQL connection and providing utility functions to fetch graph nodes and links, it plays a vital role in managing and retrieving graph data within the application.",
    "importStatements": "import { AllowedTypes } from '../model/consts'\nimport { getEnv } from './utils'\nimport postgres from 'postgres'"
  },
  {
    "id": "69466794-029a-4875-82ce-b3c241aace12",
    "fullName": "\\src\\utils\\git::getAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getAccessToken",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "This async function `getAccessToken` retrieves the access token and refresh token from the specified `gitProvider` service, using the `connectionId` and `UserOrgId` as parameters. If the `connectionId` is '-1', it returns a default access token. Otherwise, it queries the database table corresponding to the `gitProvider` service to fetch the access and refresh tokens associated with the provided `connectionId` and `UserOrgId`, returning them if found, or null if not.",
    "importStatements": ""
  },
  {
    "id": "62c4b006-6a34-4040-92f6-1d9ba4c338d0",
    "fullName": "\\src\\utils\\git::getCommitHash",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}",
    "codeNoBody": "function getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCommitHash",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "The `getCommitHash` function takes a `provider` parameter specifying the source control platform ('github', 'gitlab', or 'bitbucket') and a `data` parameter containing the commit information. It returns the commit hash based on the provider: for 'github', it retrieves the SHA from the first element of the data array; for 'gitlab', it returns the ID from the first element of the data array; and for 'bitbucket', it extracts the hash from the values array within the data object. If the provider is not recognized, it returns an empty string.",
    "importStatements": ""
  },
  {
    "id": "514e6c42-7e87-400d-b022-3ed6459f3565",
    "fullName": "\\src\\utils\\git::getCommitRepo",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "codeNoBody": "async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getCommitRepo",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "This async function `getCommitRepo` takes in parameters `gitService`, `repoOrg`, `repoName`, `branch`, `accessToken`, `refreshToken`, `connectionId`, and optional `gitlabRepoId`. It constructs a commit URL based on the `gitService` type ('github', 'gitlab', or 'bitbucket') and makes a fetch request with the necessary headers. If an error occurs due to token issues, it refreshes the access token and retries the fetch. It then calls `getCommitHash` to extract and return the commit SHA based on the `gitService` type from the fetched data.",
    "importStatements": ""
  },
  {
    "id": "9ba005d2-19d4-4abb-864d-ab3599947337",
    "fullName": "\\src\\utils\\git::downloadAndExtractRepo",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}",
    "codeNoBody": "async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "downloadAndExtractRepo",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "This async function \"downloadAndExtractRepo\" downloads a repository from GitHub, GitLab, or Bitbucket based on the provided Git service type, extracts it to a temporary folder, and returns the path to the extracted repository. It requires parameters such as the Git service type (github, gitlab, or bitbucket), repository organization, repository name, branch, access token, commit SHA, and optionally GitLab repository ID. The function handles authentication, downloading, extracting, and checking the repository size against a maximum size limit of 2 MB before returning the final path.",
    "importStatements": ""
  },
  {
    "id": "eab58925-5d90-4aec-b6f9-7223fa78ba2b",
    "fullName": "\\src\\utils\\git::MAXSIZE",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const MAXSIZE = 2 // MB\r",
    "codeNoBody": "const MAXSIZE = 2 // MB",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "MAXSIZE",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "Code: const MAXSIZE = 2 // MB\r",
    "importStatements": ""
  },
  {
    "id": "56a62643-f11b-4f5c-8671-3e094ce1dd9e",
    "fullName": "\\src\\utils\\git::GitServiceType",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "codeNoBody": "type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "GitServiceType",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "generatedDocumentation": "Code: type GitServiceType = 'github' | 'gitlab' | 'bitbucket'",
    "importStatements": ""
  },
  {
    "id": "dfbfaafa-8f02-4c8f-9d71-d90988dc557c",
    "fullName": "\\src\\utils\\git",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\n\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let url\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      url = `https://api.github.com/repos/${repoOrg}/${repoName}/zipball/${branch}`\r\n\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      break\r\n    case 'gitlab':\r\n      url = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/archive.zip?sha=${branch}`\r\n\r\n      break\r\n    case 'bitbucket':\r\n      url = `https://bitbucket.org/${repoOrg}/${repoName}/get/${branch}.zip`\r\n\r\n      break\r\n  }\r\n\r\n  try {\r\n    const response = await axios({\r\n      method: 'GET',\r\n      url,\r\n      responseType: 'arraybuffer',\r\n      headers\r\n    })\r\n\r\n    const tmpFolderPath = `${process.cwd()}/tmp`\r\n    await fs.mkdir(tmpFolderPath, { recursive: true })\r\n\r\n    const extractPath = path.join(\r\n      tmpFolderPath,\r\n      `${commitSha}_${repoOrg}_${repoName}_${branch}_${performance.now()}`\r\n    )\r\n\r\n    // Save zip\r\n    const zipPath = `${extractPath}.zip`\r\n    await fs.writeFile(zipPath, response.data)\r\n\r\n    // Extract zip\r\n    const zip = new AdmZip(zipPath)\r\n\r\n    const zipEntries = zip.getEntries()\r\n\r\n    const mainFolderPath = zipEntries.find(\r\n      (entry: any) =>\r\n        entry.isDirectory &&\r\n        entry.entryName.endsWith('/') &&\r\n        (entry.entryName.match(/\\//g) || []).length == 1\r\n    )?.entryName\r\n    zip.extractAllTo(extractPath, true)\r\n\r\n    // Delete zip\r\n    await fs.unlink(zipPath)\r\n\r\n    const finalPath = path.join(extractPath, mainFolderPath ?? '')\r\n    const totalSize = (await getTotalSize(finalPath)) / 1024 / 1024\r\n    console.log(`${totalSize} MB`)\r\n    if (totalSize >= MAXSIZE) {\r\n      await fs.rm(extractPath, { recursive: true, force: true })\r\n      throw new Error(\r\n        `Repository size is too large: ${totalSize.toFixed(2)} MB. Max size is ${MAXSIZE} MB.`\r\n      )\r\n    }\r\n    return finalPath\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\r\n  let commitUrl\r\n\r\n  const headers: Record<string, string> = {\r\n    Authorization: `Bearer ${accessToken}`\r\n  }\r\n\r\n  switch (gitService) {\r\n    case 'github':\r\n      commitUrl = `https://api.github.com/repos/${repoOrg}/${repoName}/commits?sha=${branch}&per_page=1`\r\n\r\n      headers['X-GitHub-Api-Version'] = '2022-11-28'\r\n      headers['Accept'] = 'application/vnd.github+json'\r\n\r\n      break\r\n    case 'gitlab':\r\n      commitUrl = `https://gitlab.com/api/v4/projects/${gitlabRepoId}/repository/commits?ref_name=${branch}`\r\n      break\r\n    case 'bitbucket':\r\n      commitUrl = `https://api.bitbucket.org/2.0/repositories/${repoOrg}/${repoName}/commits/${branch}`\r\n      break\r\n  }\r\n  try {\r\n    const res = await fetch(commitUrl, {\r\n      headers\r\n    })\r\n\r\n    let data\r\n\r\n    if (!res.ok) {\r\n      const error = await res.json()\r\n\r\n      if (gitService === 'gitlab' && error.error === 'invalid_token') {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenGitlab(refreshToken)\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE gitlab_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${Number(connectionId)}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n        data = await res.json()\r\n      } else if (gitService === 'bitbucket' && res.status === 401) {\r\n        const { newAccessToken, newRefreshToken } = await refreshAccessTokenBitbucket(refreshToken)\r\n\r\n        if (newAccessToken && newRefreshToken) {\r\n          await sql`\r\n            UPDATE bitbucket_connections\r\n            SET \r\n              access_token = ${newAccessToken}, \r\n              refresh_token = ${newRefreshToken}\r\n            WHERE id = ${connectionId}\r\n          `\r\n        }\r\n\r\n        const res = await fetch(commitUrl, {\r\n          headers: {\r\n            Authorization: `Bearer ${newAccessToken}`\r\n          }\r\n        })\r\n\r\n        data = await res.json()\r\n      } else {\r\n        console.log({ error })\r\n        throw new Error('Error fetching commit')\r\n      }\r\n    } else {\r\n      data = await res.json()\r\n    }\r\n\r\n    const commitSha = getCommitHash(gitService, data)\r\n    return commitSha\r\n  } catch (error) {\r\n    console.log(error)\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\r\n  if (provider === 'github') {\r\n    return data[0].sha\r\n  } else if (provider === 'gitlab') {\r\n    return data[0].id\r\n  } else if (provider === 'bitbucket') {\r\n    return data.values[0].hash\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\r\n  if (connectionId === '-1') {\r\n    return {\r\n      accessToken: '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',\r\n      refreshToken: ''\r\n    }\r\n  }\r\n\r\n  try {\r\n    const table = `${gitProvider}_connections`\r\n    const rows = await sql`\r\n      SELECT \r\n        access_token,\r\n        refresh_token\r\n      FROM ${sql(table)}\r\n      WHERE \r\n        id = ${connectionId}\r\n        AND org_id = ${UserOrgId}\r\n    `\r\n\r\n    if (rows.length === 0) return null\r\n\r\n    return {\r\n      accessToken: rows[0].access_token,\r\n      refreshToken: rows[0].refresh_token\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n    return null\r\n  }\r\n}\r\n",
    "codeNoBody": "import axios from 'axios'\r\nimport fs from 'node:fs/promises'\r\nimport AdmZip from 'adm-zip'\r\nimport path from 'node:path'\r\nimport { sql } from './db'\r\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\r\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\r\nimport { getTotalSize } from '../model/utils'\r\nexport type GitServiceType = 'github' | 'gitlab' | 'bitbucket'\r\n\r\nconst MAXSIZE = 2 // MB\r\n\r\nexport async function downloadAndExtractRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  commitSha: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nexport async function getCommitRepo(\r\n  gitService: GitServiceType,\r\n  repoOrg: string,\r\n  repoName: string,\r\n  branch: string,\r\n  accessToken: string,\r\n  refreshToken: string,\r\n  connectionId: string,\r\n  gitlabRepoId?: number\r\n): Promise<string> {\n       //...\n       }\r\n\r\nfunction getCommitHash(provider: 'github' | 'gitlab' | 'bitbucket', data: any): string {\n//...\n}\r\n\r\nexport async function getAccessToken(\r\n  gitProvider: GitServiceType,\r\n  connectionId: string,\r\n  UserOrgId: string\r\n): Promise<{\r\n  accessToken: string\r\n  refreshToken: string\r\n} | null> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\git.ts",
    "originFile": "",
    "generatedDocumentation": "## Wiki: `src/utils/git.ts`\n\n### Overview\nThe `git.ts` file located in the `src/utils` directory is a utility module designed to handle various interactions with Git repositories hosted on popular platforms such as GitHub, GitLab, and Bitbucket. This file includes functions for downloading and extracting repositories, retrieving commit information, and managing access tokens.\n\n### Main Features and Functions\n\n#### 1. `downloadAndExtractRepo`\n- **Purpose**: Downloads a repository from GitHub, GitLab, or Bitbucket, extracts it to a temporary folder, and returns the path to the extracted repository.\n- **Parameters**:\n  - `gitService`: Type of Git service (`'github' | 'gitlab' | 'bitbucket'`).\n  - `repoOrg`: Repository organization.\n  - `repoName`: Repository name.\n  - `branch`: Branch name.\n  - `accessToken`: Access token for authentication.\n  - `commitSha`: Commit SHA.\n  - `gitlabRepoId` (optional): GitLab repository ID.\n- **Features**:\n  - Handles authentication.\n  - Downloads and extracts the repository.\n  - Checks the repository size against a maximum size limit of 2 MB.\n\n#### 2. `getCommitRepo`\n- **Purpose**: Retrieves the commit SHA for a specific repository and branch.\n- **Parameters**:\n  - `gitService`: Type of Git service (`'github' | 'gitlab' | 'bitbucket'`).\n  - `repoOrg`: Repository organization.\n  - `repoName`: Repository name.\n  - `branch`: Branch name.\n  - `accessToken`: Access token for authentication.\n  - `refreshToken`: Refresh token for authentication.\n  - `connectionId`: Connection ID.\n  - `gitlabRepoId` (optional): GitLab repository ID.\n- **Features**:\n  - Constructs a commit URL based on the Git service type.\n  - Makes a fetch request with necessary headers.\n  - Handles token refresh if an error occurs.\n  - Uses `getCommitHash` to extract and return the commit SHA.\n\n#### 3. `getCommitHash`\n- **Purpose**: Extracts the commit hash from the provided data based on the Git service provider.\n- **Parameters**:\n  - `provider`: Source control platform (`'github' | 'gitlab' | 'bitbucket'`).\n  - `data`: Commit information data.\n- **Features**:\n  - Returns the commit hash based on the provider.\n  - Handles different data structures for each provider.\n\n#### 4. `getAccessToken`\n- **Purpose**: Retrieves the access token and refresh token from the specified Git service.\n- **Parameters**:\n  - `gitProvider`: Type of Git service (`'github' | 'gitlab' | 'bitbucket'`).\n  - `connectionId`: Connection ID.\n  - `UserOrgId`: User organization ID.\n- **Features**:\n  - Returns a default access token if `connectionId` is '-1'.\n  - Queries the database to fetch tokens associated with the provided `connectionId` and `UserOrgId`.\n  - Returns the tokens if found, or null if not.\n\n### Important Definitions\n\n- **`GitServiceType`**: A TypeScript type defining the supported Git service providers (`'github' | 'gitlab' | 'bitbucket'`).\n- **`MAXSIZE`**: A constant defining the maximum allowed repository size for extraction, set to 2 MB.\n\n### Purpose of the File\nThe `git.ts` file serves as a utility module to facilitate seamless interactions with Git repositories across different platforms. It abstracts the complexities of authentication, downloading, extracting, and retrieving commit information, providing a unified interface for these operations. This is particularly useful in applications that need to manage and manipulate repositories programmatically, ensuring compatibility with multiple Git service providers.",
    "importStatements": "import axios from 'axios'\nimport fs from 'node:fs/promises'\nimport AdmZip from 'adm-zip'\nimport path from 'node:path'\nimport { sql } from './db'\nimport { refreshAccessToken as refreshAccessTokenGitlab } from './gitlab/refresh-token'\nimport { refreshAccessToken as refreshAccessTokenBitbucket } from './bitbucket/refresh-token'\nimport { getTotalSize } from '../model/utils'"
  },
  {
    "id": "63b62554-b0a4-45ea-982a-3d6d850e1fcb",
    "fullName": "\\src\\utils\\gitlab\\refresh-token::refreshAccessToken",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "refreshAccessToken",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts",
    "generatedDocumentation": "This async function \"refreshAccessToken\" takes a refresh token as a parameter, sends a POST request to the GitLab API to refresh the access token using the provided refresh token, client ID, and client secret, and returns a new access token and refresh token if successful. If there is an error during the process, it logs the error message and returns null.",
    "importStatements": ""
  },
  {
    "id": "efd76428-1455-4df6-adcd-55710eab0409",
    "fullName": "\\src\\utils\\gitlab\\refresh-token",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { getEnv } from \"../utils\"\r\n\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\r\n  try {\r\n    const url = new URL('https://gitlab.com/oauth/token')\r\n    url.searchParams.set('refresh_token', refreshToken)\r\n    url.searchParams.set('grant_type', 'refresh_token')\r\n    url.searchParams.set('client_id', getEnv('GITLAB_APP_ID'))\r\n    url.searchParams.set('client_secret', getEnv('GITLAB_SECRET_ID'))\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        Accept: 'application/json'\r\n      }\r\n    })\r\n\r\n    if (res.ok) {\r\n      const { access_token: newAccessToken, refresh_token: newRefreshToken } = await res.json()\r\n\r\n      return {\r\n        newAccessToken,\r\n        newRefreshToken\r\n      }\r\n    } else {\r\n      const data = await res.json()\r\n      console.error('Error al renovar el token de acceso:', data)\r\n      return null\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al renovar el token de acceso:', error)\r\n    return null\r\n  }\r\n}",
    "codeNoBody": "import { getEnv } from \"../utils\"\r\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\gitlab\\refresh-token.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/utils/gitlab/refresh-token.ts`\n\n## Overview\nThe `refresh-token.ts` file is part of the `utils` folder within the `gitlab` directory of the codebase. Its primary purpose is to handle the process of refreshing GitLab access tokens using a provided refresh token. This functionality is crucial for maintaining authenticated sessions with the GitLab API without requiring users to repeatedly log in.\n\n## Main Features\n- **Token Refreshing**: The core feature of this file is the `refreshAccessToken` function, which is responsible for obtaining a new access token and refresh token from GitLab's API.\n\n## Detailed Explanation\n\n### `refreshAccessToken` Function\n```typescript\nimport { getEnv } from \"../utils\"\n\nexport async function refreshAccessToken(refreshToken: string): Promise<any> {\n    //...\n}\n```\n- **Purpose**: This asynchronous function takes a `refreshToken` as an argument and interacts with the GitLab API to refresh the access token.\n- **Functionality**:\n  - **POST Request**: It sends a POST request to the GitLab API endpoint designed for token refreshing.\n  - **Parameters**: The request includes the `refreshToken`, `client ID`, and `client secret` which are necessary for authentication.\n  - **Response Handling**: If the request is successful, it returns a new access token and refresh token.\n  - **Error Handling**: In case of an error, it logs the error message and returns `null`.\n\n### Important Definitions\n- **`getEnv`**: This utility function is imported from `../utils` and is likely used to retrieve environment variables such as `client ID` and `client secret`.\n\n## Purpose of the File\nThe `refresh-token.ts` file is designed to ensure that the application can maintain continuous communication with the GitLab API by refreshing access tokens seamlessly. This is essential for applications that rely on long-term interactions with GitLab services, as it prevents the need for frequent re-authentication and enhances user experience by maintaining persistent sessions.\n\nBy encapsulating the token refresh logic within a dedicated utility function, the codebase promotes reusability and separation of concerns, making it easier to manage and maintain authentication processes.",
    "importStatements": "import { getEnv } from \"../utils\""
  },
  {
    "id": "0f195819-c35c-407e-9166-9f2129237a38",
    "fullName": "\\src\\utils\\utils::getEnv",
    "type": "function",
    "language": "typescript",
    "documentation": "//\r",
    "code": "function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "codeNoBody": "function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "getEnv",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils.ts",
    "generatedDocumentation": "The `getEnv` function takes a parameter `envKey` representing a key of the `ENV_VARS` object, which stores essential environment variables like database credentials, Supabase configuration, and authentication details for GitLab and Bitbucket. It retrieves the corresponding value from `ENV_VARS` based on the provided `envKey` and throws an error if the key is missing. The function then returns the environment variable value for further application usage.",
    "importStatements": ""
  },
  {
    "id": "f742c1d3-e837-41f8-aa7e-6da5eea912e4",
    "fullName": "\\src\\utils\\utils::ENV_VARS",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "ENV_VARS",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils.ts",
    "generatedDocumentation": "The `ENV_VARS` object in this code snippet contains key-value pairs for various environment variables related to database credentials, Supabase configuration, GitLab and Bitbucket authentication details, storing them for easy access throughout the application.",
    "importStatements": ""
  },
  {
    "id": "730a9d04-2e92-4ae7-9009-b26badf4cf94",
    "fullName": "\\src\\utils\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "export const ENV_VARS = {\r\n\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\r\n  const env = ENV_VARS[envKey]\r\n  if (env == null) {\r\n    throw new Error(`Missing environment variable ${envKey}`)\r\n  }\r\n\r\n  return env\r\n}",
    "codeNoBody": "export const ENV_VARS = {\r\n  DATABASE_USERNAME: process.env.DATABASE_USERNAME,\r\n  DATABASE_PASSWORD: process.env.DATABASE_PASSWORD,\r\n  DATABASE_HOST: process.env.DATABASE_HOST,\r\n  DATABASE_PORT: process.env.DATABASE_PORT,\r\n  DATABASE_NAME: process.env.DATABASE_NAME,\r\n  SUPABASE_CA_CERTIFICATE: process.env.SUPABASE_CA_CERTIFICATE,\r\n  SUPABASE_JWT: process.env.SUPABASE_JWT,\r\n  GITLAB_APP_ID: process.env.GITLAB_APP_ID,\r\n  GITLAB_SECRET_ID: process.env.GITLAB_SECRET_ID,\r\n  BITBUCKET_KEY: process.env.BITBUCKET_KEY,\r\n  BITBUCKET_SECRET: process.env.BITBUCKET_SECRET,\r\n}\r\n//\r\nexport function getEnv(envKey: keyof typeof ENV_VARS) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\utils\\utils.ts",
    "originFile": "",
    "generatedDocumentation": "# utils.ts\n\n## Overview\nThe `utils.ts` file, located in the `src/utils` directory of the `codebase-index-ts` repository, serves a crucial role in managing environment variables. This file provides a centralized and organized way to access and retrieve environment-specific configurations, ensuring that sensitive information such as database credentials and API keys are handled securely and efficiently.\n\n## Main Features\n### ENV_VARS\n- **Purpose**: The `ENV_VARS` object is a collection of key-value pairs where each key corresponds to an essential environment variable.\n- **Contents**: It includes variables for:\n  - Database credentials (`DATABASE_USERNAME`, `DATABASE_PASSWORD`, `DATABASE_HOST`, `DATABASE_PORT`, `DATABASE_NAME`)\n  - Supabase configuration (`SUPABASE_CA_CERTIFICATE`, `SUPABASE_JWT`)\n  - Authentication details for GitLab (`GITLAB_APP_ID`, `GITLAB_SECRET_ID`)\n  - Authentication details for Bitbucket (`BITBUCKET_KEY`, `BITBUCKET_SECRET`)\n- **Usage**: This object serves as a single source of truth for accessing environment variables throughout the application, promoting consistency and reducing the likelihood of errors.\n\n### getEnv Function\n- **Purpose**: The `getEnv` function is designed to retrieve the value of a specified environment variable from the `ENV_VARS` object.\n- **Parameters**: It takes a single parameter, `envKey`, which is a key of the `ENV_VARS` object.\n- **Functionality**:\n  - It looks up the corresponding value in the `ENV_VARS` object based on the provided `envKey`.\n  - If the key is missing, it throws an error to alert the developer of the missing configuration.\n  - It returns the value of the environment variable, making it available for further use in the application.\n- **Usage**: This function ensures that environment variables are accessed in a controlled manner, providing error handling and reducing the risk of missing configurations.\n\n## Important Definitions\n- **Environment Variables**: These are dynamic values that can affect the way running processes will behave on a computer. They are often used to store configuration settings and sensitive information such as API keys and database credentials.\n- **Supabase**: An open-source backend as a service (BaaS) that provides developers with a suite of tools to build applications quickly.\n- **GitLab and Bitbucket**: Popular platforms for version control and collaborative software development, which require authentication details for API access.\n\n## Purpose of the File\nThe `utils.ts` file is essential for managing and accessing environment variables in a secure and organized manner. By centralizing the environment variable definitions and providing a robust retrieval function, this file helps maintain the application's configuration integrity and enhances security by ensuring that sensitive information is handled correctly.",
    "importStatements": ""
  },
  {
    "id": "e300df28-b2c9-4cfb-b7a3-7660ee43d5b6",
    "fullName": "\\src\\wiki\\test-wiki",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();\r\n",
    "codeNoBody": "import { fstat } from \"fs\";\r\nimport { Codebase } from \"../model/codebase\";\r\nimport { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { generateDocumentation } from \"./wiki\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport fs from \"fs/promises\";\r\n(async () => {\r\n  // const codebasePath = '/home/pudu/MISC/judini/codebase-index-ts/'\r\n  const repoName = \"codebase-index-ts\";\r\n  const codebasePath = `C:\\\\Users\\\\gmasc\\\\OneDrive\\\\Documentos\\\\CodeGPT\\\\Graphs\\\\${repoName}`;\r\n  const codebase = new Codebase(codebasePath);\r\n  console.log(\"Parsing folders ..\");\r\n  const fileNodesMap = await codebase.parseFolder();\r\n  console.log(\"Getting calls ..\");\r\n  codebase.getCalls(fileNodesMap, false);\r\n  const nodes = codebase.simplify();\r\n\r\n  // create a uuid for each node\r\n  const nodeDBIds: { [key: string]: string } = {};\r\n  for (const node of nodes) {\r\n    nodeDBIds[node.id] = uuidv4();\r\n  }\r\n\r\n  const grapNodes: GraphNode[] = nodes.map((n) => {\r\n    return {\r\n      id: nodeDBIds[n.id],\r\n      fullName: n.id.replace(codebasePath, \"\"),\r\n      type: n.type,\r\n      language: n.language,\r\n      documentation: n.documentation,\r\n      code: n.code,\r\n      codeNoBody: n.codeNoBody,\r\n      totalTokens: 0,\r\n      inDegree: 0,\r\n      outDegree: 0,\r\n      label: n.label,\r\n      originFile: n.originFile,\r\n      generatedDocumentation: \"\",\r\n      importStatements: n.importStatements.join(\"\\n\"),\r\n    };\r\n  });\r\n\r\n  const links = codebase.getLinks();\r\n\r\n  const graphLinks: GraphLink[] = links.map((l) => {\r\n    return {\r\n      id: uuidv4(),\r\n      source: nodeDBIds[l.source],\r\n      target: nodeDBIds[l.target],\r\n      label: l.label,\r\n      line: l.line,\r\n    };\r\n  });\r\n\r\n  const model = \"gpt-3.5-turbo\";\r\n  // const model = 'gpt-4o'\r\n\r\n  const documentedFolders = await generateDocumentation(\r\n    grapNodes,\r\n    graphLinks,\r\n    repoName,\r\n    model\r\n  );\r\n\r\n  const modelNoDots = model.replaceAll(\".\", \"\");\r\n\r\n  fs.writeFile(\r\n    `./grapNodes-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(grapNodes, null, 2)\r\n  );\r\n  // fs.writeFile(\"./graphLinks.json\", JSON.stringify(graphLinks, null, 2))\r\n  fs.writeFile(\r\n    `./graphFolders-${repoName}-${modelNoDots}.json`,\r\n    JSON.stringify(documentedFolders, null, 2)\r\n  );\r\n})();",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\test-wiki.ts",
    "originFile": "",
    "generatedDocumentation": "## Test Wiki Script (`test-wiki.ts`)\n\n### Overview\nThe `test-wiki.ts` file is a script designed to generate documentation for a codebase by parsing its structure, identifying relationships between different parts of the code, and creating a graph representation of these relationships. The script uses various utilities and models to achieve this, ultimately producing JSON files that contain the nodes and links of the graph, as well as the generated documentation for the codebase.\n\n### Main Features\n1. **Codebase Parsing**:\n   - The script initializes a `Codebase` object with the path to the codebase directory.\n   - It parses the folders within the codebase to create a map of file nodes.\n\n2. **Call Graph Construction**:\n   - The script identifies function/method calls within the codebase to understand the relationships between different parts of the code.\n\n3. **Node and Link Generation**:\n   - Each parsed node (representing a file or a code entity) is assigned a unique UUID.\n   - Nodes are simplified and transformed into `GraphNode` objects, which include metadata such as type, language, documentation, and code snippets.\n   - Links (representing relationships between nodes) are transformed into `GraphLink` objects, each with a unique UUID.\n\n4. **Documentation Generation**:\n   - The script uses the `generateDocumentation` function to create documentation for the nodes and links using a specified model (e.g., `gpt-3.5-turbo`).\n\n5. **Output**:\n   - The generated nodes, links, and documentation are written to JSON files for further use or analysis.\n\n### Important Definitions\n- **Codebase**: Represents the entire codebase and provides methods to parse folders and identify calls within the code.\n- **GraphNode**: Represents a node in the graph, containing information about a code entity such as its type, language, and documentation.\n- **GraphLink**: Represents a link between two nodes in the graph, indicating a relationship such as a function call or import statement.\n- **generateDocumentation**: A function that generates documentation for the nodes and links using a specified model.\n\n### Usage\nThe script is executed as an asynchronous IIFE (Immediately Invoked Function Expression). It performs the following steps:\n1. Initializes the `Codebase` object with the path to the codebase.\n2. Parses the codebase to identify file nodes and their relationships.\n3. Generates unique identifiers for each node.\n4. Transforms nodes and links into `GraphNode` and `GraphLink` objects.\n5. Generates documentation using a specified model.\n6. Writes the resulting nodes, links, and documentation to JSON files.\n\n### Purpose\nThe primary purpose of the `test-wiki.ts` file is to automate the process of generating comprehensive documentation for a codebase. By creating a graph representation of the codebase and using advanced models to generate documentation, the script helps developers understand the structure and relationships within their code, making it easier to maintain and extend.",
    "importStatements": "import { fstat } from \"fs\";\nimport { Codebase } from \"../model/codebase\";\nimport { GraphLink, GraphNode } from \"../utils/db\";\nimport { generateDocumentation } from \"./wiki\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport fs from \"fs/promises\";"
  },
  {
    "id": "fdbdf259-e8ef-4ab7-b625-c491b45f039b",
    "fullName": "\\src\\wiki\\utils::documentFolders",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentFolders(nodes: GraphNode[], links: GraphLink[], repoName: string, model: string) {\r\n    console.log('Generating documentation for each folder ..')\r\n    const fileNodes = nodes.filter(n => n.type === 'file')\r\n    const folderNames = fileNodes.map(n => n.fullName.split('/').slice(0, -1).join('/'))\r\n    const uniqueFolderNames = [...new Set(folderNames)]\r\n\r\n    // sort by level (number of '/')\r\n    uniqueFolderNames.sort((a, b) => b.split('/').length - a.split('/').length || b.length - a.length)\r\n    const documentedFolders: {[key: string]: string} = {}\r\n    uniqueFolderNames.forEach(foldername => documentedFolders[foldername] = '')\r\n\r\n    for (const folderName of uniqueFolderNames) {\r\n        let systemPrompt = `You are a helpful code assistant that helps to write wikis for folders from repository ${repoName}. The user will pass you a sort of wiki of each file and subfolder, and you have to generate a final wiki..`\r\n        systemPrompt += `The wiki must describe the main features of the folder and the final purpose of the folder, i.e.:\r\n        \r\n        - An overview of the complete folder\r\n        - Main features of subfolders and files\r\n        - Important definitions inside files`\r\n        systemPrompt += '\\nThe idea is to explain how the different components are used inside the folder. You can add anything you also consider important to the wiki.'\r\n\r\n        \r\n        const fileNodesInFolder = fileNodes.filter(n => n.fullName.startsWith(folderName) && n.fullName.split('/').length == (folderName ? folderName.split('/').length + 1 : 1))\r\n        const subfoldersDocumentations = Object.fromEntries(\r\n            Object.entries(documentedFolders).filter(([key]) => {\r\n                return key.startsWith(folderName) && key != folderName  // && key.split('/').length == folderName.split('/').length + 1 && key != folderName \r\n            })\r\n        )\r\n\r\n        const folderContext = folderName.length > 0 ? `folder \"${folderName}\"` : `main folder of ${repoName}`\r\n        let userPrompt = `Generate a wiki for the ${folderContext}. Use the following information to generate a better response:\\n\\n`\r\n\r\n        for (const [subfolder, subfolderDoc] of Object.entries(subfoldersDocumentations)) {\r\n            if (subfolderDoc) {\r\n                userPrompt += `Wiki from subfolder ${subfolder}:\\n${subfolderDoc}`\r\n                userPrompt += `\\n------------------------------------------------\\n\\n`\r\n            }\r\n        }\r\n\r\n        for (const fileNode of fileNodesInFolder) {\r\n            userPrompt += `Documentation from file ${fileNode.label}:\\n${fileNode.generatedDocumentation ?? ''}\\n`\r\n            // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n            // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n            \r\n            // if (callLinks.length) {\r\n            //     userPrompt += `  ${fileNode.label} Calls:\\n`\r\n            //     callLinks.forEach(l => {\r\n            //         const calledNode = nodes.find(n => n.id === l.target)\r\n            //         if (calledNode) {\r\n            //             userPrompt += `   - ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n` \r\n            //         }\r\n            //     })\r\n            // }\r\n            \r\n            // if (defineLinks.length) {\r\n            //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n            //     defineLinks.forEach(l => {\r\n            //         const definingNode = nodes.find(n => n.id === l.target)\r\n            //         if (definingNode) {\r\n            //             userPrompt += `   - ${definingNode.label}${\": \" + definingNode.generatedDocumentation ?? ''}\\n`\r\n            //         }\r\n            //     })\r\n            // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n            // }\r\n            \r\n        }\r\n\r\n        const messages: chatCompletionMessages = [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userPrompt },\r\n        ]\r\n\r\n        // console.log(systemPrompt)\r\n        // console.log(userPrompt)\r\n\r\n        const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n        totalTokens += tokens ?? 0\r\n        documentedFolders[folderName ?? repoName] = response\r\n    }\r\n\r\n    console.log('Total used tokens: ', totalTokens)\r\n    return documentedFolders;\r\n}",
    "codeNoBody": "async function documentFolders(nodes: GraphNode[], links: GraphLink[], repoName: string, model: string) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentFolders",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `documentFolders` takes in an array of `nodes`, an array of `links`, the `repoName`, and the `model`. It generates documentation for each folder in the repository by filtering file nodes, extracting unique folder names, and sorting them by level. It then iterates over each folder to create a wiki describing the folder's content, subfolders, and files. The function utilizes a system prompt and user prompt to gather information and uses an external service to generate responses. The total number of tokens used during the process is tracked and returned along with the documented folders.",
    "importStatements": ""
  },
  {
    "id": "b0d73626-344f-4998-bc7b-0a7751548b6f",
    "fullName": "\\src\\wiki\\utils::documentNodesByLevels",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentNodesByLevels(nodeIdsByLevels: {[key: number]: string[]}, nodes: GraphNode[],\r\n                        graph: Graph, repoName: string, model: string) {\r\n    console.log('Generating documentation for each node ..')\r\n    const levels = Object.keys(nodeIdsByLevels)\r\n    levels.sort((a, b) => parseInt(b) - parseInt(a))\r\n\r\n    for (const l of levels) {\r\n        const level = parseInt(l);  // Convert the key back to a number if needed\r\n        const nodeIds = nodeIdsByLevels[level];\r\n        const promises = nodeIds.map(nodeId => {\r\n            const node = nodes.find(n => n.id === nodeId);\r\n            if (node) {\r\n                return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n            }\r\n        })\r\n        await Promise.all(promises);\r\n    }\r\n    console.log('Used tokens: ', totalTokens)\r\n}",
    "codeNoBody": "async function documentNodesByLevels(nodeIdsByLevels: {[key: number]: string[]}, nodes: GraphNode[],\r\n                        graph: Graph, repoName: string, model: string) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentNodesByLevels",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "This async function `documentNodesByLevels` takes `nodeIdsByLevels` as an object mapping numbers to arrays of strings, `nodes` as an array of `GraphNode`, `graph` as a Graph object, `repoName` and `model` as strings. It iterates over the levels in descending order, retrieves node IDs for each level, and generates documentation for each node using the `generateNodeDocumentation` function based on the node's type, content, and context. The function logs the total tokens used during the process.",
    "importStatements": ""
  },
  {
    "id": "b5855d49-ecbb-4f4c-abfd-63237bd4e873",
    "fullName": "\\src\\wiki\\utils::generateNodeDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function generateNodeDocumentation(node: GraphNode, nodes: GraphNode[], graph: Graph,\r\n                                                repoName: string, model: string) {\r\n    const { systemPrompt, userPrompt } = generateNodePrompts(node, nodes, graph, repoName);\r\n  \r\n    try {\r\n\r\n        const messages: chatCompletionMessages = [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userPrompt },\r\n        ]\r\n\r\n        if (['class', 'function', 'method'].includes(node.type) || node.code.split('\\n').length >= 2) {\r\n            const { response, tokens } = await getOpenAIChatCompletion(messages, node.type === 'file' ? 'gpt-4o' : model);\r\n            totalTokens += tokens ?? 0\r\n            node.generatedDocumentation = response;\r\n        } else {\r\n            node.generatedDocumentation = `Code: ${node.code}`\r\n        }\r\n        // console.log(`#### ${node.label} ####`)\r\n        // console.log({ systemPrompt, userPrompt } )\r\n        // console.log({ response, tokens })\r\n\r\n    } catch (error: any) {\r\n        console.error(`Error generating documentation for ${node.label}: ${error.message}`)\r\n    }\r\n}",
    "codeNoBody": "async function generateNodeDocumentation(node: GraphNode, nodes: GraphNode[], graph: Graph,\r\n                                                repoName: string, model: string) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodeDocumentation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The `generateNodeDocumentation` function takes a `node` of type `GraphNode`, an array of `nodes`, a `graph` object, the `repoName`, and a `model` as parameters. It generates prompts for system and user based on the `node` type, then uses OpenAI to generate documentation based on the node type or code content. It handles different node types like functions, classes, methods, and files, customizing prompts and documentation accordingly. If the node is a file or has multiple lines of code, it uses OpenAI's GPT-4o model; otherwise, it includes the code in the documentation. Any errors during the process are logged.",
    "importStatements": ""
  },
  {
    "id": "e0c659dc-57f4-45d4-9ed3-1301924031f2",
    "fullName": "\\src\\wiki\\utils::generateNodePrompts",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function generateNodePrompts(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string): { systemPrompt: string, userPrompt: string } {\r\n\r\n    const originFileNode = findFileParentNode(nodes, node);\r\n\r\n    let systemPrompt = '';\r\n    if (node.type !== 'file') {\r\n        systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code.`;\r\n    } else {\r\n        systemPrompt = `You are a helpful ${node.language} code assistant that helps to write wikis for files from the repository ${repoName}. I will pass a reduced version of the file content and you must explain the main features and purpose of the file.`;\r\n        systemPrompt += `The wiki must describe the main features of the folder and the final purpose of the folder, i.e.:\r\n        \r\n        - An overview of the complete folder\r\n        - Main features of subfolders and files\r\n        - Important definitions inside files`\r\n        systemPrompt += '\\nThe idea is to explain how the different components are used inside the folder. You can add anything you also consider important to the wiki.'\r\n    }\r\n\r\n    if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n        systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n    }\r\n\r\n    if (node.type !== 'file')\r\n        systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n    const parentFileString = originFileNode ? `from file \"${originFileNode.label}\" ` : ''\r\n\r\n    let userPrompt = '';\r\n    if (node.type !== 'file') {\r\n        userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mention it the principal features of the code:`\r\n    } else {\r\n        const folder = node.fullName.split('/').slice(0, -1).join('/');\r\n        userPrompt = `Write a wiki for the file \"${node.label}\" from folder \"${folder}\", explain it the main features and purpose of the file:`\r\n    }\r\n    \r\n    const code = ['method', 'function', 'interface', 'assignment', 'type', 'enum', 'struct', 'union'].includes(node.type) ? node.code : node.codeNoBody\r\n\r\n    if (originFileNode && graph[node.id].length > 0 && originFileNode.importStatements) {\r\n        userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`\r\n        systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`\r\n    } else {\r\n        userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`\r\n    }\r\n\r\n    const linkedNodes = graph[node.id].map(linkedNodeId => nodes.find(node => node.id === linkedNodeId));\r\n\r\n    if (graph[node.id].length > 0 && linkedNodes.some(n => n?.generatedDocumentation) ) {\r\n        userPrompt += `Use the following information to generate a better description of what ${node.label} does:`\r\n        systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`\r\n\r\n        graph[node.id].forEach(linkedNodeId => {\r\n            const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n            if (linkedNode && linkedNode.generatedDocumentation) {\r\n                userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n            }\r\n        })\r\n        \r\n    }\r\n\r\n    userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`\r\n    if (node.type === 'file') {\r\n        userPrompt += ' Remember also to explain the purpose of the file.'\r\n    }\r\n    return { systemPrompt, userPrompt }\r\n}",
    "codeNoBody": "function generateNodePrompts(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string): { systemPrompt: string, userPrompt: string } {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodePrompts",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function `generateNodePrompts` takes in a `node` of type `GraphNode`, an array of `nodes`, a `graph` object, and the `repoName` as parameters. It generates prompts for system and user based on the type of `node`, providing instructions for writing code documentation or wikis. It handles different types of nodes such as functions, classes, methods, and files, customizing prompts accordingly. It also utilizes the `findFileParentNode` function to determine the origin file node. The prompts guide the user to describe the main features and purpose of the code or file, including parameters usage, without mentioning the file directly.",
    "importStatements": ""
  },
  {
    "id": "0e2243b4-5491-4dc3-a0b3-bb48c72f86b8",
    "fullName": "\\src\\wiki\\utils::bfsLevels",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function bfsLevels(nodes: GraphNode[], graph: Graph): {[key: number]: string[]} {\r\n    console.log('Building BFS Levels ..')\r\n    const results: { [key: number]: string[] } = {};\r\n    const levels: { [key: string]: number } = {};\r\n    const inDegree: { [key: string]: number } = {};\r\n\r\n    // Initialize in-degree for each node\r\n    for (const node of nodes) {\r\n\r\n        inDegree[node.id] = 0;\r\n    }\r\n\r\n    // Calculate in-degree for each node\r\n    for (const [source, targets] of Object.entries(graph)) {\r\n        for (const target of targets) {\r\n            inDegree[target] = (inDegree[target] || 0) + 1;\r\n        }\r\n    }\r\n\r\n    // Find start nodes (nodes with in-degree 0)\r\n    const queue = nodes.filter(node => inDegree[node.id] === 0).map(node => node.id);\r\n    \r\n    // Perform topological sort and assign levels\r\n    let currentLevel = 0;\r\n    while (queue.length > 0) {\r\n        const levelSize = queue.length;\r\n        for (let i = 0; i < levelSize; i++) {\r\n            const nodeId = queue.shift()!;\r\n            levels[nodeId] = currentLevel;\r\n\r\n            if (!results[currentLevel]) {\r\n                results[currentLevel] = [];\r\n            }\r\n\r\n            results[currentLevel].push(nodeId);\r\n\r\n            for (const neighbor of graph[nodeId] || []) {\r\n                inDegree[neighbor]--;\r\n                if (inDegree[neighbor] === 0) {\r\n                    queue.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n        currentLevel++;\r\n    }\r\n\r\n    // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n    for (const node of nodes) {\r\n        if (levels[node.id] === undefined) {\r\n            const dependencyLevels = (graph[node.id] || [])\r\n                .map(dep => levels[dep] || 0)\r\n                .filter(level => level !== undefined);\r\n            const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n            levels[node.id] = maxDependencyLevel + 1;\r\n\r\n            if (!results[levels[node.id]]) {\r\n                results[levels[node.id]] = [];\r\n            }\r\n            results[levels[node.id]].push(node.id);\r\n        }\r\n    }\r\n\r\n    return results;\r\n}",
    "codeNoBody": "function bfsLevels(nodes: GraphNode[], graph: Graph): {[key: number]: string[]} {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "bfsLevels",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function bfsLevels takes an array of GraphNode objects and a graph represented as { [key: string]: string[] }, and returns an object where each key represents a level and its value is an array of node IDs at that level. It calculates the levels of nodes using a breadth-first search algorithm, handling cycles by assigning nodes to the highest level of their dependencies. The function initializes in-degree for each node, finds start nodes with in-degree 0, performs topological sort, and assigns levels based on dependencies.",
    "importStatements": ""
  },
  {
    "id": "1d3aced5-4a47-4821-9468-1b2e73a254f1",
    "fullName": "\\src\\wiki\\utils::buildGraphs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n    //all nodes appear on links?\r\n    const graph: Graph = {};\r\n    nodes.forEach((node) => {\r\n      graph[node.id] = [];\r\n    });\r\n  \r\n    for (const link of links) {\r\n        if (link.source === link.target) continue;\r\n        \r\n        // each link save the id node\r\n        const sourceNode = nodes.find((node) => node.id === link.source);\r\n        const targetNode = nodes.find((node) => node.id === link.target);\r\n        // only save the links between nodes and not files\r\n        if (sourceNode && targetNode) {\r\n                graph[link.source].push(link.target);\r\n      }\r\n    }\r\n  \r\n    return { graph };\r\n}",
    "codeNoBody": "function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildGraphs",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "The function \"buildGraphs\" takes in an array of nodes and an array of links to construct a graph where each node's ID is mapped to an array of its connected node IDs. It ensures that each link connects different nodes, finds the source and target nodes for each link, and populates the graph accordingly, excluding links that connect to non-existent nodes. The function returns the constructed graph as an object.",
    "importStatements": ""
  },
  {
    "id": "c65b0bb8-cefd-4855-b342-cc7d3f181c0a",
    "fullName": "\\src\\wiki\\utils::findFileParentNode",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n    let parentName = ''\r\n    if (node.originFile) {\r\n        parentName = node.originFile?.split('.').slice(0, -1).join('.');\r\n    } else {\r\n        parentName = node.fullName.includes('::') ? node.fullName.split('::')[0] : ''\r\n    }\r\n    const parent = nodes.find((node) => node.fullName === parentName);\r\n    if (parent && parent.type === \"file\") {\r\n        return parent;\r\n    } else if (parent && parent.type !== \"file\") {\r\n        return findFileParentNode(nodes, parent);\r\n    }\r\n}",
    "codeNoBody": "function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findFileParentNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "This function `findFileParentNode` takes an array of `nodes` and a `node` as parameters, then it finds the parent node of the given `node` based on the `fullName` and `originFile` properties. If the parent node is a file, it returns the parent node; otherwise, it recursively calls itself with the parent node until a file parent is found and returned.",
    "importStatements": ""
  },
  {
    "id": "8aacc7a8-5f59-40ec-9499-abc5e82750d2",
    "fullName": "\\src\\wiki\\utils::Graph",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type Graph = { [key: string]: string[] }",
    "codeNoBody": "type Graph = { [key: string]: string[] }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "Graph",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "Code: type Graph = { [key: string]: string[] }",
    "importStatements": ""
  },
  {
    "id": "e83b17b3-ebb2-4f9c-9819-801a47dbe17e",
    "fullName": "\\src\\wiki\\utils::totalTokens",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "let totalTokens = 0",
    "codeNoBody": "let totalTokens = 0",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "totalTokens",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "generatedDocumentation": "Code: let totalTokens = 0",
    "importStatements": ""
  },
  {
    "id": "aa9b8277-9f88-453a-9790-373436fcdd2d",
    "fullName": "\\src\\wiki\\utils",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\n\r\nlet totalTokens = 0\r\n\r\ntype Graph = { [key: string]: string[] }\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\r\n    let parentName = ''\r\n    if (node.originFile) {\r\n        parentName = node.originFile?.split('.').slice(0, -1).join('.');\r\n    } else {\r\n        parentName = node.fullName.includes('::') ? node.fullName.split('::')[0] : ''\r\n    }\r\n    const parent = nodes.find((node) => node.fullName === parentName);\r\n    if (parent && parent.type === \"file\") {\r\n        return parent;\r\n    } else if (parent && parent.type !== \"file\") {\r\n        return findFileParentNode(nodes, parent);\r\n    }\r\n}\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\r\n    //all nodes appear on links?\r\n    const graph: Graph = {};\r\n    nodes.forEach((node) => {\r\n      graph[node.id] = [];\r\n    });\r\n  \r\n    for (const link of links) {\r\n        if (link.source === link.target) continue;\r\n        \r\n        // each link save the id node\r\n        const sourceNode = nodes.find((node) => node.id === link.source);\r\n        const targetNode = nodes.find((node) => node.id === link.target);\r\n        // only save the links between nodes and not files\r\n        if (sourceNode && targetNode) {\r\n                graph[link.source].push(link.target);\r\n      }\r\n    }\r\n  \r\n    return { graph };\r\n}\r\n\r\n\r\nexport function bfsLevels(nodes: GraphNode[], graph: Graph): {[key: number]: string[]} {\r\n    console.log('Building BFS Levels ..')\r\n    const results: { [key: number]: string[] } = {};\r\n    const levels: { [key: string]: number } = {};\r\n    const inDegree: { [key: string]: number } = {};\r\n\r\n    // Initialize in-degree for each node\r\n    for (const node of nodes) {\r\n\r\n        inDegree[node.id] = 0;\r\n    }\r\n\r\n    // Calculate in-degree for each node\r\n    for (const [source, targets] of Object.entries(graph)) {\r\n        for (const target of targets) {\r\n            inDegree[target] = (inDegree[target] || 0) + 1;\r\n        }\r\n    }\r\n\r\n    // Find start nodes (nodes with in-degree 0)\r\n    const queue = nodes.filter(node => inDegree[node.id] === 0).map(node => node.id);\r\n    \r\n    // Perform topological sort and assign levels\r\n    let currentLevel = 0;\r\n    while (queue.length > 0) {\r\n        const levelSize = queue.length;\r\n        for (let i = 0; i < levelSize; i++) {\r\n            const nodeId = queue.shift()!;\r\n            levels[nodeId] = currentLevel;\r\n\r\n            if (!results[currentLevel]) {\r\n                results[currentLevel] = [];\r\n            }\r\n\r\n            results[currentLevel].push(nodeId);\r\n\r\n            for (const neighbor of graph[nodeId] || []) {\r\n                inDegree[neighbor]--;\r\n                if (inDegree[neighbor] === 0) {\r\n                    queue.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n        currentLevel++;\r\n    }\r\n\r\n    // Handle cycles by assigning remaining nodes to the highest level of their dependencies\r\n    for (const node of nodes) {\r\n        if (levels[node.id] === undefined) {\r\n            const dependencyLevels = (graph[node.id] || [])\r\n                .map(dep => levels[dep] || 0)\r\n                .filter(level => level !== undefined);\r\n            const maxDependencyLevel = Math.max(...dependencyLevels, -1);\r\n            levels[node.id] = maxDependencyLevel + 1;\r\n\r\n            if (!results[levels[node.id]]) {\r\n                results[levels[node.id]] = [];\r\n            }\r\n            results[levels[node.id]].push(node.id);\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n\r\nexport function generateNodePrompts(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string): { systemPrompt: string, userPrompt: string } {\r\n\r\n    const originFileNode = findFileParentNode(nodes, node);\r\n\r\n    let systemPrompt = '';\r\n    if (node.type !== 'file') {\r\n        systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation for the repository ${repoName} in just one paragraph, mentioning the principal features of the code.`;\r\n    } else {\r\n        systemPrompt = `You are a helpful ${node.language} code assistant that helps to write wikis for files from the repository ${repoName}. I will pass a reduced version of the file content and you must explain the main features and purpose of the file.`;\r\n        systemPrompt += `The wiki must describe the main features of the folder and the final purpose of the folder, i.e.:\r\n        \r\n        - An overview of the complete folder\r\n        - Main features of subfolders and files\r\n        - Important definitions inside files`\r\n        systemPrompt += '\\nThe idea is to explain how the different components are used inside the folder. You can add anything you also consider important to the wiki.'\r\n    }\r\n\r\n    if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n        systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n    }\r\n\r\n    if (node.type !== 'file')\r\n        systemPrompt += ` Prevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n    const parentFileString = originFileNode ? `from file \"${originFileNode.label}\" ` : ''\r\n\r\n    let userPrompt = '';\r\n    if (node.type !== 'file') {\r\n        userPrompt = `Write a documentation for the ${node.type} called \"${node.fullName}\" ${parentFileString}in just one paragraph, mention it the principal features of the code:`\r\n    } else {\r\n        const folder = node.fullName.split('/').slice(0, -1).join('/');\r\n        userPrompt = `Write a wiki for the file \"${node.label}\" from folder \"${folder}\", explain it the main features and purpose of the file:`\r\n    }\r\n    \r\n    const code = ['method', 'function', 'interface', 'assignment', 'type', 'enum', 'struct', 'union'].includes(node.type) ? node.code : node.codeNoBody\r\n\r\n    if (originFileNode && graph[node.id].length > 0 && originFileNode.importStatements) {\r\n        userPrompt += `\\n\\`\\`\\`${node.language}\\n${originFileNode.importStatements}\\n\\n${code}\\n\\`\\`\\`\\n\\n`\r\n        systemPrompt += ` Don't mention about the imports if \"${node.label}\" is not using it directly in its implementation.`\r\n    } else {\r\n        userPrompt += `\\n\\`\\`\\`${node.language}\\n${code}\\n\\`\\`\\`\\n\\n`\r\n    }\r\n\r\n    const linkedNodes = graph[node.id].map(linkedNodeId => nodes.find(node => node.id === linkedNodeId));\r\n\r\n    if (graph[node.id].length > 0 && linkedNodes.some(n => n?.generatedDocumentation) ) {\r\n        userPrompt += `Use the following information to generate a better description of what ${node.label} does:`\r\n        systemPrompt += ` Do not verbose about the extra information, just use them as a reference to explain what ${node.label} does.`\r\n\r\n        graph[node.id].forEach(linkedNodeId => {\r\n            const linkedNode = nodes.find((n) => n.id === linkedNodeId);\r\n            if (linkedNode && linkedNode.generatedDocumentation) {\r\n                userPrompt += `\\n- ${linkedNode.label}: ${linkedNode.generatedDocumentation}`;\r\n            }\r\n        })\r\n        \r\n    }\r\n\r\n    userPrompt += `Remember to not verbose about the extra information, just use them as a reference to explain what \"${node.label}\" does.`\r\n    if (node.type === 'file') {\r\n        userPrompt += ' Remember also to explain the purpose of the file.'\r\n    }\r\n    return { systemPrompt, userPrompt }\r\n}\r\n\r\nexport async function generateNodeDocumentation(node: GraphNode, nodes: GraphNode[], graph: Graph,\r\n                                                repoName: string, model: string) {\r\n    const { systemPrompt, userPrompt } = generateNodePrompts(node, nodes, graph, repoName);\r\n  \r\n    try {\r\n\r\n        const messages: chatCompletionMessages = [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userPrompt },\r\n        ]\r\n\r\n        if (['class', 'function', 'method'].includes(node.type) || node.code.split('\\n').length >= 2) {\r\n            const { response, tokens } = await getOpenAIChatCompletion(messages, node.type === 'file' ? 'gpt-4o' : model);\r\n            totalTokens += tokens ?? 0\r\n            node.generatedDocumentation = response;\r\n        } else {\r\n            node.generatedDocumentation = `Code: ${node.code}`\r\n        }\r\n        // console.log(`#### ${node.label} ####`)\r\n        // console.log({ systemPrompt, userPrompt } )\r\n        // console.log({ response, tokens })\r\n\r\n    } catch (error: any) {\r\n        console.error(`Error generating documentation for ${node.label}: ${error.message}`)\r\n    }\r\n}\r\n\r\nexport async function documentNodesByLevels(nodeIdsByLevels: {[key: number]: string[]}, nodes: GraphNode[],\r\n                        graph: Graph, repoName: string, model: string) {\r\n    console.log('Generating documentation for each node ..')\r\n    const levels = Object.keys(nodeIdsByLevels)\r\n    levels.sort((a, b) => parseInt(b) - parseInt(a))\r\n\r\n    for (const l of levels) {\r\n        const level = parseInt(l);  // Convert the key back to a number if needed\r\n        const nodeIds = nodeIdsByLevels[level];\r\n        const promises = nodeIds.map(nodeId => {\r\n            const node = nodes.find(n => n.id === nodeId);\r\n            if (node) {\r\n                return generateNodeDocumentation(node, nodes, graph, repoName, model);\r\n            }\r\n        })\r\n        await Promise.all(promises);\r\n    }\r\n    console.log('Used tokens: ', totalTokens)\r\n}\r\n\r\nexport async function documentFolders(nodes: GraphNode[], links: GraphLink[], repoName: string, model: string) {\r\n    console.log('Generating documentation for each folder ..')\r\n    const fileNodes = nodes.filter(n => n.type === 'file')\r\n    const folderNames = fileNodes.map(n => n.fullName.split('/').slice(0, -1).join('/'))\r\n    const uniqueFolderNames = [...new Set(folderNames)]\r\n\r\n    // sort by level (number of '/')\r\n    uniqueFolderNames.sort((a, b) => b.split('/').length - a.split('/').length || b.length - a.length)\r\n    const documentedFolders: {[key: string]: string} = {}\r\n    uniqueFolderNames.forEach(foldername => documentedFolders[foldername] = '')\r\n\r\n    for (const folderName of uniqueFolderNames) {\r\n        let systemPrompt = `You are a helpful code assistant that helps to write wikis for folders from repository ${repoName}. The user will pass you a sort of wiki of each file and subfolder, and you have to generate a final wiki..`\r\n        systemPrompt += `The wiki must describe the main features of the folder and the final purpose of the folder, i.e.:\r\n        \r\n        - An overview of the complete folder\r\n        - Main features of subfolders and files\r\n        - Important definitions inside files`\r\n        systemPrompt += '\\nThe idea is to explain how the different components are used inside the folder. You can add anything you also consider important to the wiki.'\r\n\r\n        \r\n        const fileNodesInFolder = fileNodes.filter(n => n.fullName.startsWith(folderName) && n.fullName.split('/').length == (folderName ? folderName.split('/').length + 1 : 1))\r\n        const subfoldersDocumentations = Object.fromEntries(\r\n            Object.entries(documentedFolders).filter(([key]) => {\r\n                return key.startsWith(folderName) && key != folderName  // && key.split('/').length == folderName.split('/').length + 1 && key != folderName \r\n            })\r\n        )\r\n\r\n        const folderContext = folderName.length > 0 ? `folder \"${folderName}\"` : `main folder of ${repoName}`\r\n        let userPrompt = `Generate a wiki for the ${folderContext}. Use the following information to generate a better response:\\n\\n`\r\n\r\n        for (const [subfolder, subfolderDoc] of Object.entries(subfoldersDocumentations)) {\r\n            if (subfolderDoc) {\r\n                userPrompt += `Wiki from subfolder ${subfolder}:\\n${subfolderDoc}`\r\n                userPrompt += `\\n------------------------------------------------\\n\\n`\r\n            }\r\n        }\r\n\r\n        for (const fileNode of fileNodesInFolder) {\r\n            userPrompt += `Documentation from file ${fileNode.label}:\\n${fileNode.generatedDocumentation ?? ''}\\n`\r\n            // const callLinks = links.filter(l => l.source === fileNode.id && l.label == 'calls')\r\n            // const defineLinks = links.filter(l => l.source === fileNode.id && l.label == 'defines')\r\n            \r\n            // if (callLinks.length) {\r\n            //     userPrompt += `  ${fileNode.label} Calls:\\n`\r\n            //     callLinks.forEach(l => {\r\n            //         const calledNode = nodes.find(n => n.id === l.target)\r\n            //         if (calledNode) {\r\n            //             userPrompt += `   - ${calledNode.label}${\": \" + calledNode.generatedDocumentation ?? ''}\\n` \r\n            //         }\r\n            //     })\r\n            // }\r\n            \r\n            // if (defineLinks.length) {\r\n            //     userPrompt += `  ${fileNode.label} Defines:\\n`\r\n            //     defineLinks.forEach(l => {\r\n            //         const definingNode = nodes.find(n => n.id === l.target)\r\n            //         if (definingNode) {\r\n            //             userPrompt += `   - ${definingNode.label}${\": \" + definingNode.generatedDocumentation ?? ''}\\n`\r\n            //         }\r\n            //     })\r\n            // userPrompt += `\\n------------------------------------------------\\n\\n`\r\n            // }\r\n            \r\n        }\r\n\r\n        const messages: chatCompletionMessages = [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userPrompt },\r\n        ]\r\n\r\n        // console.log(systemPrompt)\r\n        // console.log(userPrompt)\r\n\r\n        const { response, tokens } = await getOpenAIChatCompletion(messages, model);\r\n        totalTokens += tokens ?? 0\r\n        documentedFolders[folderName ?? repoName] = response\r\n    }\r\n\r\n    console.log('Total used tokens: ', totalTokens)\r\n    return documentedFolders;\r\n}",
    "codeNoBody": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";\r\nlet totalTokens = 0\r\n\r\ntype Graph = { [key: string]: string[] }\r\n\r\nexport function findFileParentNode(nodes: GraphNode[], node: GraphNode) {\n       //...\n       }\r\n\r\nexport function buildGraphs(nodes: GraphNode[], links: GraphLink[]) {\n       //...\n       }\r\n\r\n\r\nexport function bfsLevels(nodes: GraphNode[], graph: Graph): {[key: number]: string[]} {\n       //...\n       }\r\n\r\n\r\nexport function generateNodePrompts(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string): { systemPrompt: string, userPrompt: string } {\n       //...\n       }\r\n\r\nexport async function generateNodeDocumentation(node: GraphNode, nodes: GraphNode[], graph: Graph,\r\n                                                repoName: string, model: string) {\n       //...\n       }\r\n\r\nexport async function documentNodesByLevels(nodeIdsByLevels: {[key: number]: string[]}, nodes: GraphNode[],\r\n                        graph: Graph, repoName: string, model: string) {\n       //...\n       }\r\n\r\nexport async function documentFolders(nodes: GraphNode[], links: GraphLink[], repoName: string, model: string) {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\utils.ts",
    "originFile": "",
    "generatedDocumentation": "# `src/wiki/utils.ts` Wiki\n\n## Overview\nThe `utils.ts` file located in the `src/wiki` directory is a utility module designed to facilitate the generation of documentation for a codebase. It provides functions to build graphs from nodes and links, traverse these graphs, and generate detailed documentation for each node and folder within the repository. The file leverages OpenAI's services to create comprehensive and contextually accurate documentation.\n\n## Main Features and Purpose\n\n### Graph Construction and Traversal\n- **Graph Type Definition**\n  ```typescript\n  type Graph = { [key: string]: string[] }\n  ```\n  Defines a `Graph` type where each key is a node ID and its value is an array of connected node IDs.\n\n- **buildGraphs**\n  ```typescript\n  export function buildGraphs(nodes: GraphNode[], links: GraphLink[])\n  ```\n  Constructs a graph from an array of nodes and links, mapping each node to its connected nodes.\n\n- **bfsLevels**\n  ```typescript\n  export function bfsLevels(nodes: GraphNode[], graph: Graph): {[key: number]: string[]}\n  ```\n  Uses a breadth-first search algorithm to calculate the levels of nodes in the graph, returning an object where keys represent levels and values are arrays of node IDs at that level.\n\n### Node and Folder Documentation\n- **documentFolders**\n  ```typescript\n  export async function documentFolders(nodes: GraphNode[], links: GraphLink[], repoName: string, model: string)\n  ```\n  Generates documentation for each folder in the repository by filtering file nodes, extracting unique folder names, and sorting them by level. It iterates over each folder to create a wiki describing the folder's content, subfolders, and files.\n\n- **documentNodesByLevels**\n  ```typescript\n  export async function documentNodesByLevels(nodeIdsByLevels: {[key: number]: string[]}, nodes: GraphNode[], graph: Graph, repoName: string, model: string)\n  ```\n  Iterates over nodes by levels in descending order, generating documentation for each node using the `generateNodeDocumentation` function.\n\n- **generateNodeDocumentation**\n  ```typescript\n  export async function generateNodeDocumentation(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string, model: string)\n  ```\n  Generates detailed documentation for a given node based on its type, content, and context. It customizes prompts for different node types like functions, classes, methods, and files.\n\n- **generateNodePrompts**\n  ```typescript\n  export function generateNodePrompts(node: GraphNode, nodes: GraphNode[], graph: Graph, repoName: string): { systemPrompt: string, userPrompt: string }\n  ```\n  Generates system and user prompts for a given node, providing instructions for writing code documentation or wikis. It customizes prompts based on the node type.\n\n### Utility Functions\n- **findFileParentNode**\n  ```typescript\n  export function findFileParentNode(nodes: GraphNode[], node: GraphNode)\n  ```\n  Finds the parent node of a given node based on the `fullName` and `originFile` properties. It recursively searches until a file parent is found.\n\n### Token Tracking\n- **totalTokens**\n  ```typescript\n  let totalTokens = 0\n  ```\n  A variable to track the total number of tokens used during the documentation generation process.\n\n## Important Definitions\n- **GraphNode** and **GraphLink**: Types imported from `../utils/db` representing nodes and links in the graph.\n- **chatCompletionMessages** and **getOpenAIChatCompletion**: Functions imported from `../utils/ai` used to interact with OpenAI's services for generating documentation.\n\n## Purpose\nThe primary purpose of the `utils.ts` file is to automate the creation of detailed and structured documentation for a codebase. By constructing graphs from nodes and links, traversing these graphs, and generating prompts and documentation using OpenAI, this module ensures that each component of the codebase is thoroughly documented, enhancing the overall understanding and maintainability of the repository.",
    "importStatements": "import { GraphLink, GraphNode } from \"../utils/db\";\nimport { chatCompletionMessages, getOpenAIChatCompletion } from \"../utils/ai\";"
  },
  {
    "id": "3852431f-488b-4044-8911-310139ef14ff",
    "fullName": "\\src\\wiki\\wiki::generateDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-3.5-turbo') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}",
    "codeNoBody": "async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-3.5-turbo') {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateDocumentation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki.ts",
    "generatedDocumentation": "The function `generateDocumentation` takes an array of `nodes`, an array of `links`, a `repoName` string, and an optional `model` string as parameters. It builds a graph from the nodes and links, organizes nodes by levels using breadth-first search, and then asynchronously documents the nodes by levels and folders based on the repository name and model provided. Finally, it returns the documented folders.",
    "importStatements": ""
  },
  {
    "id": "48e90792-b75d-4fce-956b-5a9106703e78",
    "fullName": "\\src\\wiki\\wiki",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\n\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-3.5-turbo') {\r\n  const { graph } = buildGraphs(nodes, links)\r\n  const nodesByLevels = bfsLevels(nodes, graph)\r\n\r\n  await documentNodesByLevels(nodesByLevels, nodes, graph, repoName, model)\r\n  const documentedFolders = await documentFolders(nodes, links, repoName, 'gpt-4o')\r\n\r\n  return documentedFolders\r\n}",
    "codeNoBody": "import { GraphLink, GraphNode } from \"../utils/db\";\r\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";\r\nexport async function generateDocumentation(nodes: GraphNode[], links: GraphLink[],\r\n                                            repoName: string, model: string = 'gpt-3.5-turbo') {\n       //...\n       }",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wiki.ts",
    "originFile": "",
    "generatedDocumentation": "### Overview of the Folder\n\nThe `src/wiki` folder in the `codebase-index-ts` repository is designed to handle the generation of documentation for codebases. This folder contains utilities and functions that facilitate the creation of structured and detailed documentation based on the graph representation of the codebase.\n\n### Main Features of `wiki.ts`\n\nThe `wiki.ts` file is the core component within the `src/wiki` folder. Its primary purpose is to generate documentation for a given codebase by leveraging graph structures. The file imports necessary types and utility functions and defines the main function `generateDocumentation`.\n\n### Important Definitions Inside `wiki.ts`\n\n- **Imports**:\n  - `GraphLink` and `GraphNode` from `../utils/db`: These are types representing the nodes and links in the graph.\n  - `bfsLevels`, `buildGraphs`, `documentFolders`, and `documentNodesByLevels` from `./utils`: These are utility functions used to process the graph and generate documentation.\n\n- **Function: `generateDocumentation`**:\n  - **Parameters**:\n    - `nodes`: An array of `GraphNode` objects representing the nodes in the graph.\n    - `links`: An array of `GraphLink` objects representing the links between nodes in the graph.\n    - `repoName`: A string representing the name of the repository.\n    - `model`: An optional string parameter with a default value of `'gpt-3.5-turbo'`, representing the model used for documentation generation.\n  - **Functionality**:\n    - Builds a graph from the provided nodes and links.\n    - Organizes the nodes by levels using a breadth-first search (BFS) algorithm.\n    - Asynchronously documents the nodes by levels and folders based on the provided repository name and model.\n    - Returns the documented folders.\n\n### Purpose of `wiki.ts`\n\nThe `wiki.ts` file is essential for transforming a graph representation of a codebase into structured documentation. By organizing nodes and links into levels and documenting them accordingly, it helps in creating a comprehensive and navigable documentation structure. This is particularly useful for large codebases where understanding the relationships and hierarchy of different components is crucial.\n\nIn summary, `wiki.ts` serves as the backbone for generating detailed and organized documentation for codebases, making it easier for developers to understand and navigate the code.",
    "importStatements": "import { GraphLink, GraphNode } from \"../utils/db\";\nimport { bfsLevels, buildGraphs, documentFolders, documentNodesByLevels } from \"./utils\";"
  },
  {
    "id": "27038bd9-3209-4d13-a523-fd9912e42674",
    "fullName": "\\src\\wiki\\wikiGuille::buildWiki",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}",
    "codeNoBody": "async function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildWiki",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `buildWiki` function utilizes the OpenAI2 client initialized as `client2` with the model \"gpt-3.5-turbo\" to generate a Wikipedia-style markdown page for repository documentation. It takes in dictionaries representing folder and file documentation, then constructs a structured wiki page by combining system and user prompts, ensuring accurate and organized documentation of the repository components.",
    "importStatements": ""
  },
  {
    "id": "ad4f70f3-9492-4aee-835d-4083ebb656fa",
    "fullName": "\\src\\wiki\\wikiGuille::generateFolderDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r",
    "code": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "codeNoBody": "async function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateFolderDocumentation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This async function `generateFolderDocumentation` takes in `folderPath` and `folderContent` as parameters, then generates documentation based on the content of files inside the specified folder. It utilizes the OpenAI2 client to create completions for system and user prompts, calculates and logs the total tokens used, and returns the generated documentation as a string. Additionally, it measures the time elapsed using the `timeElapsedInSecconds` function, providing insights into the processing duration.",
    "importStatements": ""
  },
  {
    "id": "56db6134-0c10-4de4-a8cc-d9a8908603bc",
    "fullName": "\\src\\wiki\\wikiGuille::documentFolders",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}",
    "codeNoBody": "async function documentFolders(filesDocumentation: any) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "documentFolders",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This async function `documentFolders` takes in `filesDocumentation` as a parameter and organizes the documentation of files into folders based on their paths, excluding those not related to the specified `projectId`. It then generates documentation for each folder by concatenating the file documentation within each folder, using the `generateFolderDocumentation` function, and returns an object containing the folder paths as keys and the generated documentation as values.",
    "importStatements": ""
  },
  {
    "id": "3ad0f8a0-a56b-4212-b99e-5a5324f7e529",
    "fullName": "\\src\\wiki\\wikiGuille::generateFileDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r",
    "code": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}",
    "codeNoBody": "async function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateFileDocumentation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This async function `generateFileDocumentation` takes in a `fileNode` representing a node in the wiki, `filePath` as a string, and `fileContent` as a string, then generates a system and user prompt based on the file's content and sub-components. It utilizes the `client2` instance to interact with an API for completions, calculates and logs the time elapsed using `timeElapsedInSecconds`, and returns the content of the response as a string.",
    "importStatements": ""
  },
  {
    "id": "cb33c307-786d-4177-802d-cd712f117803",
    "fullName": "\\src\\wiki\\wikiGuille::classifyAndDocumentFiles",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}",
    "codeNoBody": "async function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "classifyAndDocumentFiles",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `classifyAndDocumentFiles` function takes in three parameters: `fileToNodes`, `nodesWithFiles`, and `usedNodes`, where `fileToNodes` is a mapping of file paths to wikiNodes, `nodesWithFiles` is an array of wikiNodes representing files, and `usedNodes` is an array of wikiNodes used for classification. It populates `fileToNodes` with nodes from `usedNodes`, writes the updated mapping to a JSON file, generates documentation for each file based on its wikiNodes' summaries, and returns a mapping of file paths to their respective documentation strings using the `generateFileDocumentation` function.",
    "importStatements": ""
  },
  {
    "id": "6fc89310-d3d8-47b1-9b7a-e6da10b0fe97",
    "fullName": "\\src\\wiki\\wikiGuille::generateNodeDocumentation",
    "type": "function",
    "language": "typescript",
    "documentation": "// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r",
    "code": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}",
    "codeNoBody": "async function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "generateNodeDocumentation",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This `generateNodeDocumentation` function takes in an array of `wikiNode` objects `nodesWithFiles`, a specific `wikiNode` object `node`, and a `calledNodesSummary` string. It finds the parent node of the given `node` using the `findFileParent` function, retrieves import statements from the parent node, and constructs prompts based on the node's type and language. It then generates a response using the OpenAI2 client, calculates the total tokens used, logs the elapsed time, and returns the generated documentation content.",
    "importStatements": ""
  },
  {
    "id": "6e980320-55c4-40ab-9aca-fd2940daac29",
    "fullName": "\\src\\wiki\\wikiGuille::bfs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}",
    "codeNoBody": "async function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "bfs",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `bfs` function performs a breadth-first search traversal on a graph represented by `nodesWithFiles`, `startNodes`, `wholeGraph`, and `nodes`, where `nodesWithFiles` are wiki nodes, `startNodes` are the initial nodes to start the search, `wholeGraph` is the adjacency list of the graph, and `nodes` are all nodes in the graph. It iterates through the graph, generates documentation for non-file nodes based on their relationships with other nodes, and returns an array of `wikiNode` objects that have been processed during the traversal.",
    "importStatements": ""
  },
  {
    "id": "3e1acebe-3981-467c-b9c7-199c7c3f090b",
    "fullName": "\\src\\wiki\\wikiGuille::findStartNodes",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}",
    "codeNoBody": "function findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findStartNodes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This function `findStartNodes` takes a callGraph object as a parameter and returns an array of nodes that do not call any other nodes by filtering the keys of the callGraph object based on the length of their corresponding arrays of called nodes.",
    "importStatements": ""
  },
  {
    "id": "0fdbfc7d-ff15-4287-b29e-f699162f4d43",
    "fullName": "\\src\\wiki\\wikiGuille::buildGraphs",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}",
    "codeNoBody": "function buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "buildGraphs",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `buildGraphs` function takes an array of `wikiNode` objects and an array of `wikiLink` objects as parameters. It creates three graphs: `callGraph`, `defineGraph`, and `wholeGraph`, where nodes that are not files are added. It populates these graphs based on the links provided, considering only links that involve nodes (sources and targets) without files and categorizing them according to their label as \"calls\" or \"defines\". The function then returns an object containing these three graphs.",
    "importStatements": ""
  },
  {
    "id": "374c9a5e-afa8-4a2c-9b7c-65f37ee07043",
    "fullName": "\\src\\wiki\\wikiGuille::readJson",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "async function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}",
    "codeNoBody": "async function readJson(filePath: string) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "readJson",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The \"readJson\" function is an asynchronous function that reads a JSON file specified by the \"filePath\" parameter using the fs2 module, parses the data into an array named \"nodeInfo,\" and returns it. If successful, it returns the parsed JSON data; otherwise, it logs an error message and exits the process with code 1.",
    "importStatements": ""
  },
  {
    "id": "bf403544-ce55-4431-a6b8-0aa58aca8740",
    "fullName": "\\src\\wiki\\wikiGuille::findFileParent",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}",
    "codeNoBody": "function findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "findFileParent",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `findFileParent` function takes an array of `wikiNode` objects and a specific `wikiNode` object as parameters. It recursively searches for and returns the parent node that is of type \"file\" by comparing the parent's id with the node's parent property. If the parent node is not of type \"file,\" the function calls itself with the parent node until a file parent is found. If no file parent is found, it logs a message indicating that the parent was not found.",
    "importStatements": ""
  },
  {
    "id": "45619685-4ba3-4cf5-8bd8-a56ff701bdc1",
    "fullName": "\\src\\wiki\\wikiGuille::tokenizer",
    "type": "function",
    "language": "typescript",
    "documentation": "",
    "code": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};",
    "codeNoBody": "const tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "tokenizer",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The \"tokenizer\" function takes an object with \"fnName\" and \"content\" parameters, where \"fnName\" is a string representing a function name and \"content\" is a string containing text to be tokenized. It uses the Tiktoken class to encode the content into tokens based on predefined parameters, logs the function name and the length of the tokens array, and then frees the encoding resources.",
    "importStatements": ""
  },
  {
    "id": "618496ff-c90e-4fc4-ab29-0197f1e2ed85",
    "fullName": "\\src\\wiki\\wikiGuille::timeElapsedInSecconds",
    "type": "function",
    "language": "typescript",
    "documentation": "// Utils\r",
    "code": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};",
    "codeNoBody": "const timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "timeElapsedInSecconds",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "This function calculates the time elapsed in seconds between two given Date objects, logs the function name and the elapsed time in seconds to the console, and returns the elapsed time as a string with two decimal places. The `fnName` parameter is used to identify the function, `startTime` represents the starting time, and `endTime` represents the ending time for the calculation.",
    "importStatements": ""
  },
  {
    "id": "810bfa3c-d9a9-4bed-b067-c1267666d320",
    "fullName": "\\src\\wiki\\wikiGuille::totalTokensUsed",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "let totalTokensUsed = 0;",
    "codeNoBody": "let totalTokensUsed = 0;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "totalTokensUsed",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: let totalTokensUsed = 0;",
    "importStatements": ""
  },
  {
    "id": "9848866e-f5e7-42f0-9f76-0801f9d20af0",
    "fullName": "\\src\\wiki\\wikiGuille::linksPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "codeNoBody": "const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "linksPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const linksPath: string = `${folder_path}/${projectId}/links.json`;",
    "importStatements": ""
  },
  {
    "id": "7baef035-ffa3-465a-94a0-0bd6c4ec88a8",
    "fullName": "\\src\\wiki\\wikiGuille::nodesPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "codeNoBody": "const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodesPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const nodesPath: string = `${folder_path}/${projectId}/nodes.json`;",
    "importStatements": ""
  },
  {
    "id": "71dcfc75-e7c3-43b6-bbe1-36a21cf05ec9",
    "fullName": "\\src\\wiki\\wikiGuille::folder_path",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const folder_path = `../../test_files/`;",
    "codeNoBody": "const folder_path = `../../test_files/`;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "folder_path",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const folder_path = `../../test_files/`;",
    "importStatements": ""
  },
  {
    "id": "096fe56a-104c-491a-a16a-30b296262a23",
    "fullName": "\\src\\wiki\\wikiGuille::projectId",
    "type": "assignment",
    "language": "typescript",
    "documentation": "//const projectId = \"codebase-index-ts\";\r",
    "code": "const projectId = \"judini-python-main\";",
    "codeNoBody": "const projectId = \"judini-python-main\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "projectId",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const projectId = \"judini-python-main\";",
    "importStatements": ""
  },
  {
    "id": "cfef5f9e-1c64-4e89-954c-faab69d51ff4",
    "fullName": "\\src\\wiki\\wikiGuille::onlyLogs",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const onlyLogs = false;",
    "codeNoBody": "const onlyLogs = false;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "onlyLogs",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const onlyLogs = false;",
    "importStatements": ""
  },
  {
    "id": "e5e074d1-0eb9-4f26-a27a-868e8bdcbdd9",
    "fullName": "\\src\\wiki\\wikiGuille::response_format",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const response_format = { type: \"json_object\" };",
    "codeNoBody": "const response_format = { type: \"json_object\" };",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "response_format",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const response_format = { type: \"json_object\" };",
    "importStatements": ""
  },
  {
    "id": "d1b59dc8-d11d-4f13-8ed0-f58310c1b644",
    "fullName": "\\src\\wiki\\wikiGuille::max_tokens",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const max_tokens = 1024;",
    "codeNoBody": "const max_tokens = 1024;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "max_tokens",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const max_tokens = 1024;",
    "importStatements": ""
  },
  {
    "id": "d61c0ab3-d92d-4bb9-aa06-aba511e181fd",
    "fullName": "\\src\\wiki\\wikiGuille::temperature",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const temperature = 0;",
    "codeNoBody": "const temperature = 0;",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "temperature",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const temperature = 0;",
    "importStatements": ""
  },
  {
    "id": "645fb2b5-61c6-4ac0-a5c7-3d1a055b8987",
    "fullName": "\\src\\wiki\\wikiGuille::model",
    "type": "assignment",
    "language": "typescript",
    "documentation": "// LLM settings\r",
    "code": "const model = \"gpt-3.5-turbo\";",
    "codeNoBody": "const model = \"gpt-3.5-turbo\";",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "model",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "Code: const model = \"gpt-3.5-turbo\";",
    "importStatements": ""
  },
  {
    "id": "def6b3f7-1394-425c-8051-5dea6a65eb2d",
    "fullName": "\\src\\wiki\\wikiGuille::client2",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
    "codeNoBody": "const client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "client2",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The code initializes a new instance of the OpenAI2 client using a specific API key for authentication.",
    "importStatements": ""
  },
  {
    "id": "cf3e2077-cbc6-4ff7-bbdf-93a8fc595cd1",
    "fullName": "\\src\\wiki\\wikiGuille::wikiLink",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "codeNoBody": "type wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiLink",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `wikiLink` type defines an object with three properties: `source`, `target`, and `label`, each of type string, representing the source URL, target URL, and label text for a hyperlink in a wiki.",
    "importStatements": ""
  },
  {
    "id": "70da3fcb-02e8-450a-88cc-5a97eac7d2ec",
    "fullName": "\\src\\wiki\\wikiGuille::wikiNode",
    "type": "type",
    "language": "typescript",
    "documentation": "",
    "code": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "codeNoBody": "type wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "wikiNode",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "generatedDocumentation": "The `wikiNode` type represents a node in the wiki with properties such as id, alias, language, label, type, parent (optional), totalTokens, inDegree, outDegree, code, summary (optional), importStatements, codeNoBody, and originFile.",
    "importStatements": ""
  },
  {
    "id": "76393ac9-140b-422d-bc10-8974122ff06b",
    "fullName": "\\src\\wiki\\wikiGuille",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { AllowedTypes } from \"../model/consts\";\r\n\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\r\n  const timeElapsed = (endTime.getTime() - startTime.getTime()) / 1000;\r\n  console.log(fnName, timeElapsed);\r\n  return timeElapsed.toFixed(2);\r\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\r\n  const encoding = new Tiktoken(\r\n    cl100k_base.bpe_ranks,\r\n    cl100k_base.special_tokens,\r\n    cl100k_base.pat_str\r\n  );\r\n  const tokens = encoding.encode(content);\r\n  console.log(fnName, tokens.length);\r\n  encoding.free();\r\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\r\n  const parent = nodesWithFiles.filter((n) => n.id == node.parent)[0];\r\n  if (parent && parent.type === \"file\") {\r\n    return parent;\r\n  } else if (parent.type !== \"file\") {\r\n    return findFileParent(nodesWithFiles, parent);\r\n  } else {\r\n    console.log(\"Parent not found :(\");\r\n  }\r\n}\r\n\r\nasync function readJson(filePath: string) {\r\n  let nodeInfo: any[] = [];\r\n\r\n  try {\r\n    const data = await fs2.readFile(filePath, \"utf8\");\r\n    nodeInfo = JSON.parse(data);\r\n    //console.log(nodes);\r\n  } catch (err) {\r\n    console.error(`Error reading ${filePath}:`, err);\r\n    process.exit(1);\r\n  }\r\n  return nodeInfo;\r\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\r\n  //all nodes appear on links?\r\n  const callGraph: { [key: string]: string[] } = {};\r\n  const defineGraph: { [key: string]: string[] } = {};\r\n  const wholeGraph: { [key: string]: string[] } = {};\r\n  nodes.forEach((node) => {\r\n    //nodes that are not files!!!\r\n    callGraph[node.id] = [];\r\n    defineGraph[node.id] = [];\r\n    wholeGraph[node.id] = [];\r\n  });\r\n\r\n  for (const link of links) {\r\n    if (\r\n      link.source.includes(\"::\") && //so that links that include files are not included\r\n      link.target.includes(\"::\")\r\n    ) {\r\n      if (link.label === \"calls\") {\r\n        callGraph[link.source].push(link.target);\r\n      } else if (link.label === \"defines\") {\r\n        defineGraph[link.source].push(link.target);\r\n      }\r\n      wholeGraph[link.source].push(link.target);\r\n    }\r\n  }\r\n\r\n  return { callGraph, defineGraph, wholeGraph };\r\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\r\n  return Object.keys(callGraph).filter((node) => callGraph[node].length === 0); //get nodes that don't call anyone.\r\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\r\n  const queue: string[] = startNodes;\r\n  const visited: Set<string> = new Set();\r\n  const usedNodes: wikiNode[] = [];\r\n  if (queue.length === 0) {\r\n    console.log(\"There is no start node (no node that doesn't call anyone).\");\r\n  }\r\n  while (queue.length > 0) {\r\n    console.log(\"HERE:\", queue.length);\r\n    const currentNodeId = queue.shift()!;\r\n    if (visited.has(currentNodeId)) continue;\r\n\r\n    visited.add(currentNodeId);\r\n    const currentNode = nodes.find((node) => node.id === currentNodeId);\r\n\r\n    if (currentNode && currentNode.type !== \"file\") {\r\n      const calledNodes = wholeGraph[currentNodeId] || []; //defined or called by the current node\r\n      const calledNodesInfo = calledNodes.map((id) =>\r\n        nodes.find((node) => node.id === id && node.type !== \"file\")\r\n      );\r\n      const calledNodesSummary = calledNodesInfo\r\n        .map((node) => node?.summary)\r\n        .join(\"\\n\");\r\n\r\n      const documentation = await generateNodeDocumentation(\r\n        nodesWithFiles,\r\n        currentNode,\r\n        calledNodesSummary\r\n      );\r\n      currentNode.summary = documentation;\r\n\r\n      usedNodes.push(currentNode);\r\n      //console.log(`Documentation for ${currentNode}: `, documentation);\r\n\r\n      for (const calledNodeId of calledNodes) {\r\n        if (!visited.has(calledNodeId)) {\r\n          queue.push(calledNodeId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.log(\"FINISHED BFS\");\r\n  return usedNodes;\r\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateNodeDocumentation\", FunctionStartTime);\r\n\r\n  const parentNode = findFileParent(nodesWithFiles, node);\r\n\r\n  const importStatements = parentNode\r\n    ? parentNode.importStatements.join(\"\\n\")\r\n    : \"\";\r\n\r\n  let systemPrompt = `You are a helpful ${node.language} code assistant that helps to write code documentation in just one paragraph.`;\r\n\r\n  if ([\"function\", \"class\", \"method\"].includes(node.type)) {\r\n    systemPrompt += ` The documentation must include how each parameter is used and what the ${node.type} does.`;\r\n  }\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise and don't talk about the file.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${node.type} called \"${node.label}\" in just one paragraph:\r\n\t\r\n\\`\\`\\`${node.language}\r\n${node.code}\r\n\\`\\`\\`\r\n`;\r\n\r\n  if (importStatements) {\r\n    //include only import statements q se usan en el nodo. O hacer regex para verificar.\r\n    //console.log(`IMPORTS of Node ${node.code}: `, importStatements);\r\n    userPrompt += `You may require to know the import statements of the file where ${node.type} is defined:\r\n\r\n\\`\\`\\`${node.language}\r\n${importStatements}\r\n\\`\\`\\`\r\n\r\nIf the code uses an import statement, mention it in the documentation.\r\n`;\r\n  }\r\n\r\n  if (calledNodesSummary) {\r\n    userPrompt += `\\nTo put more context, here is the documentation of each component used by the code:\\n${calledNodesSummary}`;\r\n  }\r\n\r\n  try {\r\n    let response;\r\n\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n\r\n    const tokensUsed = response.usage.total_tokens || 0;\r\n    totalTokensUsed += tokensUsed;\r\n\r\n    const FunctionEndTime = new Date();\r\n\r\n    timeElapsedInSecconds({\r\n      fnName: \"generateNodeDocumentation\",\r\n      startTime: FunctionStartTime,\r\n      endTime: FunctionEndTime,\r\n    });\r\n\r\n    /*console.log(\r\n      \"generateNodeDocumentation time\",\r\n      (FunctionEndTime.getTime() - FunctionStartTime.getTime()).toFixed(2)\r\n    );\r\n\r\n    console.log(\r\n      \"\\ngenerateNodeDocumentation\",\r\n      \"systemPrompt:\",\r\n      systemPrompt,\r\n      \"\\n\",\r\n      \"userPrompt:\",\r\n      userPrompt,\r\n      \"\\n\",\r\n      \"response:\",\r\n      response.choices[0].message.content,\r\n      \"\\n\",\r\n      \"total_tokens:\",\r\n      response.usage.total_tokens,\r\n      \"\\n\\n\"\r\n    );*/\r\n\r\n    return response.choices[0].message.content;\r\n  } catch (err) {\r\n    console.error(`Error generating documentation for ${node.id}:`, err);\r\n    return \"\";\r\n  }\r\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\r\n  //const files: { [filePath: string]: wikiNode[] } = {};\r\n  for (const node of usedNodes) {\r\n    const correspondingFile = node.originFile;\r\n    //console.log(\"CF: \", correspondingFile);\r\n\r\n    fileToNodes[correspondingFile].push(node);\r\n  }\r\n  //console.log(\"FTN: \", fileToNodes);\r\n  await fs2.writeFile(\"fileToNodes.json\", JSON.stringify(fileToNodes, null, 2));\r\n  const filesDocumentation: { [filePath: string]: string } = {};\r\n\r\n  for (const filePath in fileToNodes) {\r\n    const wikiNodes = fileToNodes[filePath];\r\n    const fileContent = wikiNodes.map((node) => node.summary).join(\"\\n\");\r\n    const fileNode = nodesWithFiles.find((node) => node.label === filePath)!; //it should always be there (.label as it includes extension)\r\n    await generateFileDocumentation(fileNode, filePath, fileContent).then(\r\n      (res) => {\r\n        filesDocumentation[filePath] = res;\r\n        //console.log(\"Updated filesDocumentation:\", filesDocumentation);\r\n      }\r\n    );\r\n  }\r\n  //console.log(\"FILESSSS\", filesDocumentation);\r\n  return filesDocumentation;\r\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  //console.log(\"FILE CONTENT: \", fileContent, filePath);\r\n  //console.log(\"FILE NODE LANGUAGE: \", fileNode.language);\r\n  console.log(\"start generateFileDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful ${fileNode.language} code assistant that helps to write documentation in just one paragraph\r\n  based on the documentation of the sub components of a file. By sub components I mean the functions, classes, methods, etc. that are in the file`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n\r\n  let userPrompt = `Write a documentation for the following ${fileNode.type} called \"${fileNode.label}\" in a concise manner.`;\r\n  userPrompt += `I am going to give you the code of the file in a way that it is digestible for you. \r\n  The code of the file is the following:\\n\r\n  \\`\\`\\`${fileNode.codeNoBody}\\`\\`\\``;\r\n\r\n  if (fileContent) {\r\n    userPrompt += `Lucky for you, I also have individual documentation of the sub components (parts) of the ${fileNode.type}. \r\n    The documentation of the \"sub components\" of the ${fileNode.type} corresponds to the collection of documentations of the sub parts (methods, functions, definition or more that are inside the file).\r\n     So, the individual documentation of the sub components (parts) is the following:\\n\\n\r\n     ${fileContent}`;\r\n  }\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFileDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFileDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFileDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFileDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\r\n  const folders: { [folderPath: string]: string[] } = {};\r\n  for (const filePath in filesDocumentation) {\r\n    let currentFolderPath = path2.dirname(filePath);\r\n    //console.log(\"Processing filePath:\", filePath);\r\n\r\n    while (\r\n      currentFolderPath &&\r\n      currentFolderPath.includes(projectId) && // Only process files that are in the project we want\r\n      currentFolderPath !== path2.parse(currentFolderPath).root //do not go past root folder\r\n    ) {\r\n      //console.log(\"Adding to folder:\", currentFolderPath);\r\n      if (!folders[currentFolderPath]) {\r\n        folders[currentFolderPath] = [];\r\n      }\r\n      folders[currentFolderPath].push(filesDocumentation[filePath]); // Push the documentation of the file\r\n\r\n      const nextPath = path2.dirname(currentFolderPath);\r\n      if (nextPath === currentFolderPath) {\r\n        break; //Prevent inf loop\r\n      }\r\n      currentFolderPath = nextPath;\r\n    }\r\n  }\r\n\r\n  const foldersDocumentation: { [folderPath: string]: string } = {};\r\n\r\n  for (const folderPath in folders) {\r\n    //console.log(`Processing folder ${folderPath}:`, folders[folderPath]);\r\n    const folderContent = folders[folderPath].join(\"\\n\\n\");\r\n    await generateFolderDocumentation(folderPath, folderContent).then(\r\n      (res) => (foldersDocumentation[folderPath] = res)\r\n    );\r\n  }\r\n  return foldersDocumentation;\r\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\r\n  const FunctionStartTime = new Date();\r\n  console.log(\"start generateFolderDocumentation\", FunctionStartTime);\r\n\r\n  let systemPrompt = `You are a helpful documentation assistant that helps to write documentation in \r\n  just one paragraph based on the documentation \r\n  of the files that are inside that folder.`;\r\n\r\n  systemPrompt += `\\nPrevent any prose in your response. Please, be concise.`;\r\n  let userPrompt = `Write a documentation for the following folder called \"${folderPath}\" in a concise manner.\r\n  You will be given the documentation of the files that are inside the folder.\r\n  What I am going to give you now is the documentation of files inside the folder \"${folderPath}\". Keep in mind that you should document the folder \r\n  using the documentation of the files inside that folder. The documentation of the files inside the folder \"${folderPath}\" is the following:\\n\r\n  ${folderContent}`;\r\n  //console.log(`Folder ${folderPath} has contents: ${folderContent}`);\r\n  let response;\r\n\r\n  try {\r\n    if (onlyLogs) {\r\n      response = null;\r\n    } else {\r\n      response = await client2.chat.completions.create({\r\n        messages: [\r\n          {\r\n            role: \"system\",\r\n            content: systemPrompt,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: userPrompt,\r\n          },\r\n        ],\r\n        model,\r\n        temperature,\r\n        max_tokens,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error fn generateFolderDocumentation:`, error);\r\n    return \"\";\r\n  }\r\n\r\n  const tokensUsed = response?.usage.total_tokens || 0;\r\n  const inputTokens = response?.usage.prompt_tokens || 0;\r\n  totalTokensUsed += tokensUsed;\r\n\r\n  const FunctionEndTime = new Date();\r\n\r\n  timeElapsedInSecconds({\r\n    fnName: \"generateFolderDocumentation\",\r\n    startTime: FunctionStartTime,\r\n    endTime: FunctionEndTime,\r\n  });\r\n\r\n  /*console.log(\r\n    \"\\ngenerateFolderDocumentation\\n\",\r\n    \"prompt:\",\r\n    systemPrompt,\r\n    \"\\n\",\r\n    \"userPrompt:\",\r\n    userPrompt,\r\n    \"\\n\",\r\n    \"response:\",\r\n    response?.choices[0].message.content,\r\n    \"\\n\\n\",\r\n    \"Tokenized:\",\r\n    tokenizer({ fnName: \"generateFolderDocumentation\", content: systemPrompt }),\r\n    \"prompt_tokens:\",\r\n    inputTokens,\r\n    \"total_tokens:\",\r\n    response?.usage.total_tokens\r\n  );*/\r\n\r\n  return response?.choices[0].message.content;\r\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\r\n  //console.log(\"Folder:\", folderDocumentation);\r\n  //console.log(\"Files:\", filesDocumentation);\r\n  let wikiContent = `# Codebase Documentation`;\r\n  let promptSystem1 = `You are wikiGPT. You will provide a wikipedia style for the documentation of a repository. Given the folder documentation of and the file documentation of a whole repository , you will generate a wiki page.\r\n  Take into account that the whole documentation of a repository is made of the documentation of files and folders. Please be systematic and organized in your documentation and remember to give a markdown document and avoid prose.\r\n  The structure of the input given is 2 dictionaries (one for folders and one for files) where the key is the path of the folder or file and the value is the documentation of the folder or file.`;\r\n\r\n  let promptUser1 = `I need you to create a wikipedia page in markdown format given the documentation of all of a repository and it's components (documentation of the folders and files).\r\n   Avoid prose like in a wikipedia page and remember it has to be in markdown format. Don't add code to the documentation. The documentation of files and folders corresponds to dictionaries where\r\n   the key is the path of the folder or file and the value is the documentation of the folder or file. Please keep this in mind. The documentation of the folder is the following: \\n\\n${JSON.stringify(\r\n     folderDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n\r\n   The documentation of the files is the following: \\n\\n${JSON.stringify(\r\n     filesDocumentation,\r\n     null,\r\n     2\r\n   )} \\n\\n Remember to use both documentations (files and folders) to create the wiki page. \r\n   The most important thing is that the documentation is accurate. The structure of the wiki should be something like an overview of what the whole repo does and then a detailed explanation of each folder but only the most relevant files.`;\r\n  //console.log(\"PromptSystem :\", promptSystem1);\r\n  //console.log(\"PromptUser :\", promptUser1);\r\n\r\n  const completion = await client2.chat.completions.create({\r\n    messages: [\r\n      {\r\n        role: \"system\",\r\n        content: promptSystem1,\r\n      },\r\n      {\r\n        role: \"user\",\r\n        content: promptUser1,\r\n      },\r\n    ],\r\n    model: model,\r\n  });\r\n\r\n  wikiContent += completion.choices[0].message.content;\r\n  return wikiContent;\r\n}\r\n",
    "codeNoBody": "import { AllowedTypes } from \"../model/consts\";\r\nconst fs2 = require(\"fs\").promises;\r\nconst path2 = require(\"path\");\r\nconst OpenAI2 = require(\"openai\");\r\nconst { Tiktoken } = require(\"tiktoken/lite\");\r\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");\r\n\r\n/*Problems:\r\n-- links include links of files, which were supposed to not be included\r\n-- how to summarize files that don't have sub nodes so they don't have documentation? (like jest.config.js)\r\n-- include label \"defines\" in links\r\n-- originFile\r\n\r\n*/\r\n\r\ntype wikiNode = {\r\n  id: string;\r\n  alias: string;\r\n  language: string;\r\n  label: string;\r\n  type: AllowedTypes;\r\n  parent?: string; // optional\r\n  totalTokens: number;\r\n  inDegree: number;\r\n  outDegree: number;\r\n  code: string;\r\n  summary?: string; // optional\r\n  importStatements: string[];\r\n  codeNoBody: string;\r\n  originFile: string;\r\n};\r\n\r\ntype wikiLink = {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n};\r\n\r\nconst client2 = new OpenAI2({\r\n  apiKey: \"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\",\r\n});\r\n\r\n// Settings\r\n\r\n// LLM settings\r\nconst model = \"gpt-3.5-turbo\";\r\nconst temperature = 0;\r\nconst max_tokens = 1024;\r\nconst response_format = { type: \"json_object\" };\r\n\r\nconst onlyLogs = false;\r\n// Prompts\r\n\r\n// Folders references\r\n//const projectId = \"codebase-index-ts\";\r\nconst projectId = \"judini-python-main\";\r\nconst folder_path = `../../test_files/`;\r\n\r\nconst nodesPath: string = `${folder_path}/${projectId}/nodes.json`;\r\nconst linksPath: string = `${folder_path}/${projectId}/links.json`;\r\n\r\nlet totalTokensUsed = 0;\r\n\r\n// Utils\r\nconst timeElapsedInSecconds = ({\r\n  fnName,\r\n  startTime,\r\n  endTime,\r\n}: {\r\n  fnName: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n}) => {\n//...\n};\r\n\r\nconst tokenizer = ({\r\n  fnName,\r\n  content,\r\n}: {\r\n  fnName: string;\r\n  content: string;\r\n}) => {\n//...\n};\r\n\r\n(async () => {\r\n  const startTime = new Date();\r\n  const nodesWithFiles: wikiNode[] = await readJson(nodesPath); //nodes including the ones that are files\r\n  const nodes = nodesWithFiles.filter((item: any) => item.type !== \"file\"); //nodes that are not file\r\n\r\n  await fs2.writeFile(\"myNodes.json\", JSON.stringify(nodes, null, 2));\r\n  const links: wikiLink[] = await readJson(linksPath);\r\n  const { callGraph, defineGraph, wholeGraph } = buildGraphs(nodes, links); //call graph between nodes,not including files.\r\n\r\n  await fs2.writeFile(\"callGraph.json\", JSON.stringify(callGraph, null, 2));\r\n  //await fs2.writeFile(\"defineGraph.json\", JSON.stringify(defineGraph, null, 2));\r\n  //await fs2.writeFile(\"wholeGraph.json\", JSON.stringify(wholeGraph, null, 2));\r\n  const startNodes = findStartNodes(callGraph); //leaf nodes\r\n\r\n  await fs2.writeFile(\"startNodes.json\", JSON.stringify(startNodes, null, 2));\r\n  //const usedNodes = await readJson(\"usedNodes.json\");\r\n\r\n  const usedNodes = await bfs(nodesWithFiles, startNodes, callGraph, nodes); //only nodes with documentation. INcludes \"calls\" and \"defines\"\r\n  await fs2.writeFile(\"usedNodes.json\", JSON.stringify(usedNodes, null, 2));\r\n\r\n  const fileToNodes = nodesWithFiles\r\n    .filter((item: wikiNode) => item.type === \"file\")\r\n    .reduce((acc: any, item: any) => {\r\n      acc[item.label] = []; //label so that includes the extension (type of language)\r\n      return acc;\r\n    }, {});\r\n  console.log(fileToNodes);\r\n  const filesDocumentation = await classifyAndDocumentFiles(\r\n    fileToNodes,\r\n    nodesWithFiles,\r\n    usedNodes\r\n  );\r\n  await fs2.writeFile(\r\n    \"filesDocumentation.json\",\r\n    JSON.stringify(filesDocumentation, null, 2)\r\n  );\r\n  //console.log(\"Files Doc: \", filesDocumentation);\r\n  const folderDocumentation = await documentFolders(filesDocumentation);\r\n  //console.log(\"Folder Doc:\", folderDocumentation);\r\n  await fs2.writeFile(\r\n    \"folderDocumentation.json\",\r\n    JSON.stringify(folderDocumentation, null, 2)\r\n  );\r\n  let wikiContent = await buildWiki(filesDocumentation, folderDocumentation);\r\n  await fs2.writeFile(\"wikiPage.md\", wikiContent);\r\n  console.log(\"Total tokens used: \", totalTokensUsed);\r\n  const endTime = new Date();\r\n  timeElapsedInSecconds({ fnName: \"Total Execution Time\", startTime, endTime });\r\n})();\r\n\r\nfunction findFileParent(nodesWithFiles: wikiNode[], node: wikiNode) {\n//...\n}\r\n\r\nasync function readJson(filePath: string) {\n//...\n}\r\n\r\nfunction buildGraphs(nodes: wikiNode[], links: wikiLink[]) {\n//...\n}\r\nfunction findStartNodes(callGraph: { [key: string]: string[] }) {\n//...\n}\r\n\r\nasync function bfs(\r\n  nodesWithFiles: wikiNode[],\r\n  startNodes: string[],\r\n  wholeGraph: { [key: string]: string[] },\r\n  nodes: wikiNode[]\r\n): Promise<wikiNode[]> {\n//...\n}\r\n\r\n// 1. Genera la documentacion de un nodo; todos los nodos en node.json pero que no son files y que tienen links con label 'calls'\r\nasync function generateNodeDocumentation(\r\n  nodesWithFiles: wikiNode[],\r\n  node: wikiNode,\r\n  calledNodesSummary: string\r\n) {\n//...\n}\r\n\r\nasync function classifyAndDocumentFiles(\r\n  fileToNodes: {\r\n    [filePath: string]: wikiNode[];\r\n  },\r\n  nodesWithFiles: wikiNode[],\r\n  usedNodes: wikiNode[]\r\n): Promise<{ [filePath: string]: string }> {\n//...\n}\r\n\r\n// 2. generateFileDocumentation: Genera la documentacion de un archivo.\r\nasync function generateFileDocumentation(\r\n  fileNode: wikiNode,\r\n  filePath: string,\r\n  fileContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function documentFolders(filesDocumentation: any) {\n//...\n}\r\n\r\n// 3. generateFolderDocumentation: Genera la documentacion de un folder.\r\nasync function generateFolderDocumentation(\r\n  folderPath: string,\r\n  folderContent: string\r\n): Promise<string> {\n//...\n}\r\n\r\nasync function buildWiki(\r\n  filesDocumentation: {\r\n    [folderPath: string]: string;\r\n  },\r\n  folderDocumentation: {\r\n    [folderPath: string]: string;\r\n  }\r\n) {\n//...\n}",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\src\\wiki\\wikiGuille.ts",
    "originFile": "",
    "generatedDocumentation": "# Wiki for `wikiGuille.ts`\n\n## Overview\nThe `wikiGuille.ts` file is a critical component of the `codebase-index-ts` project. Its primary purpose is to generate comprehensive documentation for a code repository by analyzing its structure, relationships, and contents. The file leverages the OpenAI API to create detailed, Wikipedia-style markdown documentation for both files and folders within the repository.\n\n## Main Features and Purpose\n\n### Initialization and Configuration\n- **OpenAI Client**: The file initializes an OpenAI client (`client2`) using the GPT-3.5-turbo model to generate documentation.\n- **Settings**: Various settings are defined, including model parameters like `temperature`, `max_tokens`, and `response_format`.\n\n### Data Structures\n- **Types**:\n  - `wikiNode`: Represents a node in the wiki with properties such as `id`, `alias`, `language`, `label`, `type`, `parent`, `totalTokens`, `inDegree`, `outDegree`, `code`, `summary`, `importStatements`, `codeNoBody`, and `originFile`.\n  - `wikiLink`: Represents a link between nodes with properties `source`, `target`, and `label`.\n\n### File Paths\n- **Project and Folder Paths**:\n  - `projectId`: Specifies the project ID for which documentation is being generated.\n  - `folder_path`: Defines the base path for test files.\n  - `nodesPath` and `linksPath`: Paths to JSON files containing node and link information, respectively.\n\n### Utility Functions\n- **timeElapsedInSecconds**: Calculates and logs the time elapsed between two dates.\n- **tokenizer**: Tokenizes content for processing by the OpenAI API.\n- **readJson**: Reads and parses JSON files.\n\n### Core Functions\n- **buildGraphs**: Constructs call, define, and whole graphs from nodes and links.\n- **findStartNodes**: Identifies nodes that do not call any other nodes.\n- **bfs**: Performs a breadth-first search to traverse and document nodes.\n- **generateNodeDocumentation**: Generates documentation for individual nodes.\n- **classifyAndDocumentFiles**: Classifies nodes by file and generates documentation for each file.\n- **generateFileDocumentation**: Generates documentation for individual files.\n- **documentFolders**: Organizes file documentation into folders and generates folder-level documentation.\n- **generateFolderDocumentation**: Generates documentation for folders based on their contents.\n- **buildWiki**: Combines file and folder documentation to create a structured wiki page.\n\n### Main Execution\nThe main execution block performs the following steps:\n1. Reads node and link data from JSON files.\n2. Filters and processes nodes to exclude files.\n3. Builds call graphs and identifies start nodes.\n4. Performs a breadth-first search to document nodes.\n5. Classifies nodes by file and generates file documentation.\n6. Organizes file documentation into folders and generates folder-level documentation.\n7. Builds the final wiki page by combining file and folder documentation.\n8. Logs the total tokens used and the time elapsed for the entire process.\n\n## Important Definitions\n- **client2**: An instance of the OpenAI client used for generating documentation.\n- **totalTokensUsed**: A counter for the total number of tokens used during the documentation process.\n- **nodesPath** and **linksPath**: Paths to JSON files containing node and link information.\n- **buildGraphs**: Constructs various graphs to represent relationships between nodes.\n- **findStartNodes**: Identifies nodes that do not call any other nodes.\n- **bfs**: Performs a breadth-first search to traverse and document nodes.\n- **classifyAndDocumentFiles**: Classifies nodes by file and generates documentation for each file.\n- **documentFolders**: Organizes file documentation into folders and generates folder-level documentation.\n- **buildWiki**: Combines file and folder documentation to create a structured wiki page.\n\n## Conclusion\nThe `wikiGuille.ts` file is designed to automate the generation of detailed documentation for a code repository. By leveraging the OpenAI API, it creates structured and comprehensive markdown documentation for both files and folders, providing an organized overview of the repository's components and their relationships.",
    "importStatements": "import { AllowedTypes } from \"../model/consts\";\nconst fs2 = require(\"fs\").promises;\nconst path2 = require(\"path\");\nconst OpenAI2 = require(\"openai\");\nconst { Tiktoken } = require(\"tiktoken/lite\");\nconst cl100k_base = require(\"tiktoken/encoders/cl100k_base.json\");"
  },
  {
    "id": "a4404725-99ef-481a-b442-e351807fb9a7",
    "fullName": "\\tests\\c.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "58cc83f8-24e1-4771-80a6-a8e41b2edd0b",
    "fullName": "\\tests\\c.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "2f74573c-53dc-4bd9-af44-5bb6e28124cd",
    "fullName": "\\tests\\c.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n    #include <stdio.h>\r\n    #include \"myHeader.h\"\r\n    #include \"../otherFolder/otherHeader.h\"\r\n    `\r\n\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c')\r\n    fileNode.generateImports()\r\n\r\n    const expectedImports = [\r\n        new ImportStatement(\"<stdio.h>\", [], \"<stdio.h>\", undefined,\r\n          `#include <stdio.h>`),\r\n        new ImportStatement(\"myHeader.h\", [], \"/my/path/myHeader::header\", undefined,\r\n          `#include \"myHeader.h\"`),\r\n        new ImportStatement(\"../otherFolder/otherHeader.h\", [], \"/my/otherFolder/otherHeader::header\", undefined,\r\n          `#include \"../otherFolder/otherHeader.h\"`),\r\n      ];\r\n      expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n})\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nint x = 10;\r\nfloat y = 3.14;\r\nint* p = &x;\r\n\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'c');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::p`,\r\n            type: 'assignment',\r\n            name: 'p',\r\n            label: 'p',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int* p = &x;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::y`,\r\n            type: 'assignment',\r\n            name: 'y',\r\n            label: 'y',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'float y = 3.14;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::x`,\r\n            type: 'assignment',\r\n            name: 'x',\r\n            label: 'x',\r\n            language: 'c',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: 'int x = 10;',\r\n            parent: '/my/path/file',\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(3);\r\n});\r\n\r\ntest(\"Function Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Calculates the sum of two integers.\r\n * @param a The first integer.\r\n * @param b The second integer.\r\n * @return The sum of a and b.\r\n */\r\nint add(int a, int b) {\r\n    return a + b;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::add`,\r\n      type: \"function\",\r\n      name: \"add\",\r\n      label: \"add\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Calculates the sum of two integers.\\n * @param a The first integer.\\n * @param b The second integer.\\n * @return The sum of a and b.\\n */`,\r\n      code: \"int add(int a, int b) {\\n    return a + b;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: [],\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Struct Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a point in a 2D plane.\r\n */\r\nstruct Point {\r\n    int x;\r\n    int y;\r\n}\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\",\r\n      label: \"Point\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a point in a 2D plane.\\n */`,\r\n      code: \"struct Point {\\n    int x;\\n    int y;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest(\"Union Definition\", () => {\r\n  const fileContent = `\r\n/**\r\n * Represents a value that can be either an integer or a floating-point number.\r\n */\r\nunion Value {\r\n    int intValue;\r\n    double floatValue;\r\n};\r\n`;\r\n  const fileNode = new Node(`${rootFolderPath}/file`, fileContent, \"file\", \"c\");\r\n  fileNode.getChildrenDefinitions();\r\n\r\n  const expectedChildren = [\r\n    {\r\n      id: `${fileNode.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\",\r\n      label: \"Value\",\r\n      language: \"c\",\r\n      exportable: false,\r\n      documentation: `/**\\n * Represents a value that can be either an integer or a floating-point number.\\n */`,\r\n      code: \"union Value {\\n    int intValue;\\n    double floatValue;\\n}\",\r\n      parent: fileNode.id,\r\n      inDegree: 0,\r\n      outDegree: 1,\r\n      children: []\r\n    }\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(fileNode.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\", \"label\", \"language\", \"exportable\", \"documentation\", \"code\", \"parent\", \"inDegree\", \"outDegree\", \"children\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(fileNode.inDegree).toBe(1);\r\n});\r\n\r\n\r\ntest('Header file', () => {\r\n  const fileContent = `\r\ntypedef struct Point {\r\n    int x;\r\n    int y;\r\n} Point;\r\n\r\ntypedef union Value {\r\n    int intValue;\r\n    double floatValue;\r\n} Value;\r\n\r\nvoid function();\r\n`\r\n\r\n  const node = new Node(`${rootFolderPath}/file::header`, fileContent, \"header\", \"c\");\r\n  node.getChildrenDefinitions();\r\n  const expectedChildren = [\r\n    {\r\n      id: `${node.id}::function`,\r\n      type: \"function\",\r\n      name: \"function\"\r\n    },\r\n    {\r\n      id: `${node.id}::Value`,\r\n      type: \"union\",\r\n      name: \"Value\"\r\n    },\r\n    {\r\n      id: `${node.id}::Point`,\r\n      type: \"struct\",\r\n      name: \"Point\"\r\n    },\r\n  ];\r\n\r\n  const fileNodeChildrenSimplified = Object.values(node.children).map((n) =>\r\n    n.simplify([\"id\", \"type\", \"name\"])\r\n  );\r\n\r\n  expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n  expect(node.inDegree).toBe(3);\r\n})\r\n\r\ntest('Calls', () => {\r\n  const header1 = `\r\nint add(int a, int b);\r\n`\r\n\r\n\r\n  const fileContent1 = `\r\n#include \"file1.h\"\r\n\r\nint add(int a, int b) {\r\n  return a + b;\r\n}\r\n`\r\n\r\n  const fileContent2 = `\r\n#include <stdio.h>\r\n#include \"file1.h\"\r\n\r\nint x = 10;\r\nint y = 20;\r\n\r\nint main() {\r\n  int sum = add(x, y);\r\n  int diff = subtract(x, y);\r\n  printf(\"The sum of %d and %d is %d\\\\n\", x, y, sum);\r\n  printf(\"The difference of %d and %d is %d\\\\n\", x, y, diff);\r\n  return 0;\r\n}\r\n`;\r\n\r\n  const headerNode1 = new Node(`${rootFolderPath}/file1::header`, header1, 'header', 'c')\r\n  const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'c')\r\n  const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'c')\r\n  const allFiles = [`${rootFolderPath}/file1.c`, `${rootFolderPath}/file2.c`]\r\n\r\n  headerNode1.generateImports()\r\n  fileNode1.generateImports()\r\n  fileNode2.generateImports()\r\n  headerNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode1.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  fileNode2.resolveImportStatementsPath(rootFolderPath, allFiles)\r\n  \r\n  const nodesMapHeader = headerNode1.getChildrenDefinitions()\r\n  const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n  const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n\r\n  const fileNodesMap: { [id: string]: Node } = {}\r\n  fileNodesMap[headerNode1.id] = headerNode1\r\n  fileNodesMap[fileNode1.id] = fileNode1\r\n  fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n  nodesMapHeader[headerNode1.id] = headerNode1\r\n  nodesMap1[fileNode1.id] = fileNode1\r\n  nodesMap2[fileNode2.id] = fileNode2\r\n\r\n  const nodesMap = { ...nodesMapHeader, ...nodesMap1, ...nodesMap2 }\r\n  const codebase = new Codebase(rootFolderPath)\r\n  codebase.nodesMap = nodesMap\r\n\r\n  codebase.resolveImportStatementsNodes()\r\n  codebase.getCalls(fileNodesMap)\r\n\r\n  const mainCalls = codebase.getNode(`${rootFolderPath}/file2::main`)?.simplify(['calls']);\r\n  const expectedMainCalls = [`${rootFolderPath}/file1::add`, `${rootFolderPath}/file2::x`, `${rootFolderPath}/file2::y`];\r\n  expect(mainCalls?.calls).toStrictEqual(expectedMainCalls);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\c.test.ts",
    "originFile": "",
    "generatedDocumentation": "# Wiki for `c.test.ts`\n\n## Overview\nThe `c.test.ts` file is part of the test suite for the `codebase-index-ts` project. This file contains a series of unit tests designed to validate the functionality of the `Node` and `Codebase` classes, specifically focusing on parsing and analyzing C language code files. The tests ensure that the codebase indexing and analysis features work correctly for various C language constructs such as import statements, assignments, function definitions, structs, unions, and function calls.\n\n## Main Features and Purpose\nThe primary purpose of `c.test.ts` is to verify that the `Node` class can correctly parse and identify different elements within C files and that the `Codebase` class can manage and resolve relationships between these elements. The tests cover the following main features:\n\n1. **Import Statements Parsing**:\n   - Tests the ability to parse and identify `#include` statements in C files.\n   - Validates that the `Node` class can generate the correct `ImportStatement` objects.\n\n2. **Assignments Parsing**:\n   - Tests the parsing of variable assignments in C files.\n   - Ensures that the `Node` class can correctly identify and represent assignment statements.\n\n3. **Function Definitions**:\n   - Tests the parsing of function definitions, including documentation comments.\n   - Ensures that the `Node` class can correctly identify and represent function definitions.\n\n4. **Struct Definitions**:\n   - Tests the parsing of `struct` definitions in C files.\n   - Ensures that the `Node` class can correctly identify and represent struct definitions.\n\n5. **Union Definitions**:\n   - Tests the parsing of `union` definitions in C files.\n   - Ensures that the `Node` class can correctly identify and represent union definitions.\n\n6. **Header Files**:\n   - Tests the parsing of C header files, including typedefs for structs and unions.\n   - Ensures that the `Node` class can correctly identify and represent elements within header files.\n\n7. **Function Calls**:\n   - Tests the ability to resolve and identify function calls within C files.\n   - Ensures that the `Codebase` class can correctly resolve import statements and identify function calls across different files.\n\n## Important Definitions Inside the File\n- **nodeAttributes**: An array of attributes used to simplify the representation of nodes for comparison in tests.\n  ```typescript\n  const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree'];\n  ```\n\n- **rootFolderPath**: The root path used for creating file nodes in the tests.\n  ```typescript\n  const rootFolderPath = '/my/path';\n  ```\n\n- **Node Class**: Represents a node in the codebase, which can be a file, function, struct, union, etc. The class provides methods to parse and identify different elements within the code.\n\n- **Codebase Class**: Manages a collection of nodes and provides methods to resolve relationships between nodes, such as import statements and function calls.\n\n## Test Cases\n1. **Import Statements**:\n   - Validates the parsing of `#include` statements and the creation of `ImportStatement` objects.\n   - Example:\n     ```typescript\n     test('Import Statements', () => {\n         // Test content and expected results\n     });\n     ```\n\n2. **Assignments**:\n   - Validates the parsing of variable assignments and the creation of corresponding node representations.\n   - Example:\n     ```typescript\n     test('Assignments', () => {\n         // Test content and expected results\n     });\n     ```\n\n3. **Function Definition**:\n   - Validates the parsing of function definitions, including documentation comments.\n   - Example:\n     ```typescript\n     test(\"Function Definition\", () => {\n         // Test content and expected results\n     });\n     ```\n\n4. **Struct Definition**:\n   - Validates the parsing of `struct` definitions.\n   - Example:\n     ```typescript\n     test(\"Struct Definition\", () => {\n         // Test content and expected results\n     });\n     ```\n\n5. **Union Definition**:\n   - Validates the parsing of `union` definitions.\n   - Example:\n     ```typescript\n     test(\"Union Definition\", () => {\n         // Test content and expected results\n     });\n     ```\n\n6. **Header File**:\n   - Validates the parsing of C header files and the identification of elements within them.\n   - Example:\n     ```typescript\n     test('Header file', () => {\n         // Test content and expected results\n     });\n     ```\n\n7. **Calls**:\n   - Validates the resolution of function calls across different files.\n   - Example:\n     ```typescript\n     test('Calls', () => {\n         // Test content and expected results\n     });\n     ```\n\nBy covering these aspects, the `c.test.ts` file ensures that the `Node` and `Codebase` classes can accurately parse, represent, and manage C language code elements, which is crucial for the overall functionality of the `codebase-index-ts` project.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "183a45d5-86a5-408a-a961-0be265b7e7bc",
    "fullName": "\\tests\\java.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "fc5daeda-a1a6-40d9-9999-cac1feab1b6d",
    "fullName": "\\tests\\java.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "9cd26382-aba6-44c4-82ef-86716144a9c9",
    "fullName": "\\tests\\java.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport myModule.myClass1;\r\nimport myModule2.myClass2;\r\nimport myModule3.*;\r\nimport initFile.myClass;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/myModule.java`, `${rootFolderPath}/myModule2.java`, `${rootFolderPath}/myModule3.java`, `${rootFolderPath}/initFile.java`]);\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('myModule', [new ImportName('myClass1')], `${rootFolderPath}/myModule`, undefined,\r\n                `import myModule.myClass1;`),\r\n        new ImportStatement('myModule2', [new ImportName('myClass2')], `${rootFolderPath}/myModule2`, undefined,\r\n                `import myModule2.myClass2;`),\r\n        new ImportStatement('myModule3', [], `${rootFolderPath}/myModule3`, 'myModule3',\r\n            `import myModule3.*;`),\r\n        new ImportStatement('initFile', [new ImportName('myClass')], `${rootFolderPath}/initFile`, undefined,\r\n    \t\t`import initFile.myClass;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\n// En java no se manejan los assignments \"globales\" como tal, si no que se utilizan\r\n// variables estticas dentro de una clase\r\n// test('Assignments', () => {})\r\n\r\n// En java no existen funciones como tal\r\n// test('Function definition', () => {})\r\n\r\n// En java el constructor se llama igual que la clase\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\npackage file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    fileNode.getChildrenDefinitions()\r\n    const packageChildren = Object.values(fileNode.children)[0];\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren: Node = Object.values(packageChildren.children)[0];\r\n    const classChildrenSimplified = classNodeChildren.simplify([...nodeAttributes, 'children'])\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren.children).map(n => n.simplify(nodeAttributes));\r\n    \r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::file`,\r\n            type: 'package',\r\n            name: 'file',\r\n            label: 'file',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"\",\r\n            code: `package file;\r\n\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}`,\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass`],\r\n        },\r\n    ];\r\n\r\n    const expectedClass = \r\n        {\r\n            id: `${fileNode.id}::FooClass`,\r\n            type: 'class',\r\n            name: 'FooClass',\r\n            label: 'FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The FooClass documentation\\n */\",\r\n            code: \"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: `${fileNode.id}::file`,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::FooClass.bar`, `${fileNode.id}::FooClass.FooClass`],\r\n        };\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::FooClass.bar`,\r\n            type: 'method',\r\n            name: 'FooClass.bar',\r\n            label: 'FooClass.bar',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public int bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::FooClass.FooClass`,\r\n            type: 'method',\r\n            name: 'FooClass.FooClass',\r\n            label: 'FooClass.FooClass',\r\n            language: 'java',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"public class FooClass\\n    ...\\n    public FooClass() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::FooClass`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The FooClass documentation\r\n */\r\npublic class FooClass {\r\n\r\n    private int foo = 1;\r\n\r\n    public FooClass() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    public int bar() {\r\n        return 1;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'java');\r\n    \r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::FooClass`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::FooClass.bar`];\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"public class FooClass {\\n    private int foo = 1;\\n\\n    public FooClass() {\\n        this.foo = 1;\\n    }\\n\\n    public int bar() {\\n        //...\\n    }\\n}\");\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"public class FooClass\\n    ...\\n    public int bar() {\\n    //...\\n    }\");\r\n});\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\npackage file1;\r\n\r\npublic class Foo {\r\n    private int baz = 1;\r\n\r\n    public Foo() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    public int method() {\r\n        return 1;\r\n    }\r\n\r\n    public int method2() {\r\n        return this.method();\r\n    }\r\n}`;\r\n\r\n    const fileContent2 = `\r\nimport file1.Foo;\r\n\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        Foo fooVar = new Foo();\r\n        fooVar.method();\r\n    }\r\n}`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'java');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'java');\r\n    const allFiles = [`${rootFolderPath}/file1.java`, `${rootFolderPath}/file2.java`];\r\n\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n\r\n    fileNode1.name = `${rootFolderPath}/file1.java`\r\n    fileNode2.name = `${rootFolderPath}/file2.java`\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n    \r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap);\r\n\r\n    const method2Calls = codebase.getNode(`file1::Foo.method2`)?.simplify(['calls']);\r\n    const mainCalls = codebase.getNode(`${rootFolderPath}/file2::Test.main`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`file1::Foo.method`, `file1::Foo`]);\r\n    expect(mainCalls?.calls).toStrictEqual([`file1::Foo`, `file1::Foo.method`]);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\java.test.ts",
    "originFile": "",
    "generatedDocumentation": "# `java.test.ts` File Wiki\n\n## Overview\nThe `java.test.ts` file is part of the test suite for the `codebase-index-ts` repository. This file contains unit tests designed to validate the functionality of the codebase model, particularly focusing on Java source files. The tests ensure that the codebase model correctly parses and interprets Java code, including import statements, class definitions, method calls, and other structural elements.\n\n## Main Features\n### Import Statements Test\n- **Purpose**: Validates the parsing and resolution of import statements in a Java file.\n- **Key Components**:\n  - `fileContent`: A string representing the content of a Java file with various import statements.\n  - `fileNode`: A `Node` object representing the Java file.\n  - `generateImports()`: Method to generate import statements from the file content.\n  - `resolveImportStatementsPath()`: Method to resolve the paths of the imported modules.\n  - **Expected Outcome**: The `fileNode.importStatements` should match the expected import statements array.\n\n### Class Definition Test\n- **Purpose**: Ensures that the parser correctly identifies and structures class definitions, including their methods and attributes.\n- **Key Components**:\n  - `fileContent`: A string representing a Java file with a class definition.\n  - `fileNode`: A `Node` object representing the Java file.\n  - `getChildrenDefinitions()`: Method to extract and structure the class and its components.\n  - **Expected Outcome**: The structure of the class and its methods should match the expected simplified node attributes and children.\n\n### Code Without Body Test\n- **Purpose**: Tests the ability to retrieve the code structure without the method bodies.\n- **Key Components**:\n  - `fileContent`: A string representing a Java file with a class and methods.\n  - `fileNode`: A `Node` object representing the Java file.\n  - `getCodeWithoutBody()`: Method to retrieve the code structure without method bodies.\n  - **Expected Outcome**: The code structure without bodies should match the expected strings.\n\n### Calls Test\n- **Purpose**: Validates the detection and resolution of method calls within and across Java files.\n- **Key Components**:\n  - `fileContent1` and `fileContent2`: Strings representing two Java files with interdependent method calls.\n  - `fileNode1` and `fileNode2`: `Node` objects representing the Java files.\n  - `generateImports()`: Method to generate import statements.\n  - `getChildrenDefinitions()`: Method to extract and structure the class and its components.\n  - `Codebase`: An object representing the entire codebase, used to resolve spaces and import statements.\n  - `getCalls()`: Method to retrieve method calls within the codebase.\n  - **Expected Outcome**: The method calls should be correctly identified and resolved, matching the expected calls array.\n\n## Important Definitions\n- **Node**: Represents a file or a structural element within a file, such as a class or method.\n- **ImportStatement**: Represents an import statement in a Java file, including the module and imported classes.\n- **Codebase**: Represents the entire codebase, managing nodes and resolving dependencies and calls.\n- **nodeAttributes**: An array of attributes used to simplify and compare nodes.\n\n## Conclusion\nThe `java.test.ts` file is essential for ensuring that the `codebase-index-ts` model accurately parses and interprets Java source files. By validating import statements, class definitions, method structures, and method calls, these tests help maintain the integrity and functionality of the codebase model.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
  },
  {
    "id": "ca9c45ea-a6da-4fc4-a7ab-c58628ccd0a9",
    "fullName": "\\tests\\javascript.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "f274e7e0-9fc0-4bfd-b83e-64f435467433",
    "fullName": "\\tests\\javascript.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "c06058ff-01a2-46b3-8ea2-3f9197d712bc",
    "fullName": "\\tests\\javascript.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\nimport { myFunction } from './myModule';\r\nimport { myClass2 as myClass2Alias, myClass3 } from '../myModule2';\r\nimport * as myModule3Alias from 'myModule3';\r\nimport { myFunction as myFunctionAlias } from 'initFile';\r\nconst myModule = require('./myModule');\r\nconst var = require('./../myModule').var;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.js`, `${rootFolderPath}/myModule3.js`, `${rootFolderPath}/initFile/index.js`])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('./myModule', [new ImportName('myFunction')],\r\n                `/my/path/myModule`, undefined, `import { myFunction } from './myModule';`),\r\n        new ImportStatement('../myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')],\r\n                '/my/myModule2', undefined, `import { myClass2 as myClass2Alias, myClass3 } from '../myModule2';`),\r\n        new ImportStatement('myModule3', [],\r\n                '/my/path/myModule3', 'myModule3Alias', `import * as myModule3Alias from 'myModule3';`),\r\n        new ImportStatement('initFile', [new ImportName('myFunction', 'myFunctionAlias')],\r\n                '/my/path/initFile/index', 'initFile', `import { myFunction as myFunctionAlias } from 'initFile';`),\r\n        new ImportStatement('./myModule', [],\r\n                '/my/path/myModule', 'myModule', `const myModule = require('./myModule');`),\r\n        new ImportStatement('./../myModule', [new ImportName('var')],\r\n            '/my/myModule', './../myModule', `const var = require('./../myModule').var;`)\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Assignments', () => {\r\n    const fileContent = `\r\nconst myModule = require('./myModule');\r\n\r\nexport const foo = 1\r\n\r\nconst bar = new Hono()\r\nbar.get('/', async (c) => {\r\n    return c.text('Hello, World!')\r\n})\r\n\r\nexport { bar as cbar }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::cbar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'cbar', // this is the name of the exported variable\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"bar = new Hono()\\nbar.get('/', async (c) => {\\n    return c.text('Hello, World!')\\n})\",\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n});\r\n\r\ntest('Function definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo documentation\r\n */\r\nfunction foo() {\r\n    return bar;\r\n}\r\n\r\nexport function bar() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"function bar() {\\n    /**\\n     * The baz documentation\\n     */\\n    function baz() {\\n        return 1;\\n    }\\n    return baz();\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: `/**\\n * The foo documentation\\n */`,\r\n            code: 'function foo() {\\n    return bar;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'function baz() {\\n        return 1;\\n    }',\r\n        documentation: \"/**\\n     * The baz documentation\\n     */\"\r\n    })\r\n})\r\n\r\ntest('Class definition', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport { Foo as MyFoo }\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions()\r\n    fileNode.parseExportClauses()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'MyFoo',\r\n            language: 'javascript',\r\n            exportable: true,\r\n            documentation: \"/**\\n * The foo class\\n */\",\r\n            code: \"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        return 1;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::MyFoo.bar`, `${fileNode.id}::MyFoo.constructor`]\r\n        },\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::MyFoo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'MyFoo.bar',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    bar() {\\n        return 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::MyFoo.constructor`,\r\n            type: 'method',\r\n            name: 'Foo.constructor',\r\n            label: 'MyFoo.constructor',\r\n            language: 'javascript',\r\n            exportable: false,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    constructor() {\\n        this.foo = 1;\\n    }\",\r\n            parent: `${fileNode.id}::MyFoo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ];\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\ntest('Code without body', () => {\r\n    const fileContent = `\r\n/**\r\n * The foo class\r\n */\r\nclass Foo {\r\n\r\n    foo = 1;\r\n\r\n    constructor() {\r\n        this.foo = 1;\r\n    }\r\n\r\n    bar() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    /**\r\n     * The baz documentation\r\n     */\r\n    function baz() {\r\n        return 1;\r\n    }\r\n    return baz();\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'javascript');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`];\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`];\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`];\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo {\\n    foo = 1;\\n\\n    constructor() {\\n        this.foo = 1;\\n    }\\n\\n    bar() {\\n        //...\\n    }\\n}\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo\\n    ...\\n    bar() {\\n    //...\\n    }\");\r\n    // functions with children remain unchanged?\r\n    // expect(fooFunction.getCodeWithoutBody()).toBe(\"function foo() {\\n    function baz() {\\n    /**\\n     * The baz documentation\\n     */\\n        return 1;\\n    }\\n    return baz();\\n}\");\r\n})\r\n\r\ntest('Calls (TS)', () => {\r\n    const fileContent1 = `\r\nclass Foo {\r\n    constructor() {\r\n        this.baz = 1;\r\n    }\r\n\r\n    method() {\r\n        return 1;\r\n    }\r\n\r\n    method2() {\r\n        return this.method();\r\n    }\r\n}`\r\n\r\n    const fileContent2= `\r\nimport { Foo } from './file1'\r\n\r\nconst fooVar = new Foo();\r\n() => fooVar.method()\r\n\r\nfunction foo(param: Foo) {\r\n    return param.method2()\r\n}\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'typescript')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'typescript')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::fooVar`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\javascript.test.ts",
    "originFile": "",
    "generatedDocumentation": "# javascript.test.ts\n\n## Overview\nThe `javascript.test.ts` file is a comprehensive suite of tests designed to validate the functionality of the `codebase-index-ts` module, specifically focusing on the JavaScript and TypeScript code parsing and analysis capabilities. The tests ensure that the module correctly identifies and processes various code constructs such as import statements, assignments, function definitions, class definitions, and method calls.\n\n## Main Features and Purpose\n\n### Import Statements\n- **Test Case: `Import Statements`**\n  - **Purpose**: Validates the parsing and resolution of various import statements within a JavaScript file.\n  - **Key Operations**:\n    - Creates a `Node` instance representing a JavaScript file with multiple import statements.\n    - Calls `generateImports()` to parse the import statements.\n    - Calls `resolveImportStatementsPath()` to resolve the paths of the imported modules.\n    - Asserts that the parsed import statements match the expected output.\n\n### Assignments\n- **Test Case: `Assignments`**\n  - **Purpose**: Ensures that assignment statements and export clauses are correctly identified and processed.\n  - **Key Operations**:\n    - Creates a `Node` instance with assignment and export statements.\n    - Calls `getChildrenDefinitions()` to identify child nodes (assignments).\n    - Calls `parseExportClauses()` to process export statements.\n    - Asserts that the identified child nodes match the expected structure and attributes.\n\n### Function Definitions\n- **Test Case: `Function definition`**\n  - **Purpose**: Tests the identification and processing of function definitions, including nested functions and documentation comments.\n  - **Key Operations**:\n    - Creates a `Node` instance with function definitions.\n    - Calls `getChildrenDefinitions()` to identify child nodes (functions).\n    - Asserts that the identified function nodes match the expected structure and attributes.\n    - Verifies the correct documentation parsing for nested functions.\n\n### Class Definitions\n- **Test Case: `Class definition`**\n  - **Purpose**: Validates the parsing and processing of class definitions, including methods and constructors.\n  - **Key Operations**:\n    - Creates a `Node` instance with a class definition.\n    - Calls `getChildrenDefinitions()` to identify child nodes (class methods).\n    - Calls `parseExportClauses()` to process export statements.\n    - Asserts that the identified class and method nodes match the expected structure and attributes.\n\n### Code Without Body\n- **Test Case: `Code without body`**\n  - **Purpose**: Ensures that the `getCodeWithoutBody()` method correctly strips the body of class and method definitions.\n  - **Key Operations**:\n    - Creates a `Node` instance with class and function definitions.\n    - Calls `getChildrenDefinitions()` to identify child nodes.\n    - Asserts that the `getCodeWithoutBody()` method returns the expected code structure without the body content.\n\n### Calls (TypeScript)\n- **Test Case: `Calls (TS)`**\n  - **Purpose**: Tests the identification and resolution of method calls across multiple TypeScript files.\n  - **Key Operations**:\n    - Creates `Node` instances for two TypeScript files with class and function definitions.\n    - Calls `generateImports()` to parse import statements.\n    - Calls `getChildrenDefinitions()` to identify child nodes.\n    - Creates a `Codebase` instance and resolves import statements.\n    - Calls `getCalls()` to identify method calls.\n    - Asserts that the identified calls match the expected structure and attributes.\n\n## Important Definitions\n- **Node**: Represents a file or code construct (e.g., function, class) within the codebase.\n- **ImportStatement**: Represents an import statement within a file.\n- **ImportName**: Represents a named import within an import statement.\n- **Codebase**: Represents the entire codebase, managing nodes and their relationships.\n\n## Conclusion\nThe `javascript.test.ts` file is crucial for ensuring the robustness of the `codebase-index-ts` module. It rigorously tests the module's ability to parse and analyze JavaScript and TypeScript code, ensuring accurate identification of code constructs and their relationships.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "2102a247-314f-4edc-aa74-51032c66bbb2",
    "fullName": "\\tests\\php.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "5ba9fd15-6333-4593-b14e-73e5467aab7f",
    "fullName": "\\tests\\php.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "597e4189-a588-4d7b-a950-320984e6beac",
    "fullName": "\\tests\\php.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\"\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements', () => {\r\n    const fileContent = `\r\n<?php\r\ninclude 'file.php';\r\ninclude_once 'file2.php';\r\nrequire '../otherFolder/file3.php';\r\nrequire_once 'file4.php';\r\n\r\nuse MyProject\\\\Models\\\\User as UserModel;\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.generateImports();\r\n    fileNode.resolveImportStatementsPath(rootFolderPath,\r\n        [`${rootFolderPath}/file.php`,\r\n         `${rootFolderPath}/file2.php`,\r\n         `/my/otherFolder/file3.php`,\r\n         `${rootFolderPath}/file4.php`,])\r\n\r\n    const expectedImports = [\r\n        new ImportStatement('file.php', [], `${rootFolderPath}/file`, undefined,\r\n            `include 'file.php';`),\r\n        new ImportStatement('file2.php', [], `${rootFolderPath}/file2`, undefined,\r\n            `include_once 'file2.php';`),\r\n        new ImportStatement('../otherFolder/file3.php', [], `/my/otherFolder/file3`, undefined,\r\n            `require '../otherFolder/file3.php';`),\r\n        new ImportStatement('file4.php', [], `${rootFolderPath}/file4`, undefined,\r\n            `require_once 'file4.php';`),\r\n        new ImportStatement('MyProject\\\\Models', [new ImportName('User', 'UserModel')], 'MyProject\\\\Models', undefined,\r\n            `use MyProject\\\\Models\\\\User as UserModel;`),\r\n    ];\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports);\r\n});\r\n\r\ntest('Global Variable Assignments', () => {\r\n    const fileContent = `\r\n<?php\r\n\r\n$globalVar = 'Hello, World!';\r\n$globalFoo = 'Foo';\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::globalFoo`,\r\n            type: 'assignment',\r\n            name: 'globalFoo',\r\n            label: 'globalFoo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalFoo = \\'Foo\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::globalVar`,\r\n            type: 'assignment',\r\n            name: 'globalVar',\r\n            label: 'globalVar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: '$globalVar = \\'Hello, World!\\'',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ];\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes));\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\ntest('Function Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The foo function documentation\r\n */\r\nfunction foo() {\r\n    return \"foo\";\r\n}\r\n\r\n/**\r\n * The bar function documentation\r\n * @param int $x\r\n * @param int $y\r\n * @return int\r\n */\r\nfunction bar($x, $y) {\r\n    return $x + $y;\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The bar function documentation\\n * @param int $x\\n * @param int $y\\n * @return int\\n */',\r\n            code: 'function bar($x, $y) {\\n    return $x + $y;\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The foo function documentation\\n */',\r\n            code: 'function foo() {\\n    return \"foo\";\\n}',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren);\r\n    expect(fileNode.inDegree).toBe(2);\r\n});\r\n\r\n\r\ntest('Class Definition', () => {\r\n    const fileContent = `\r\n<?php\r\n/**\r\n * The Foo class documentation\r\n */\r\nclass Foo {\r\n    public $bar = 1;\r\n\r\n    /**\r\n     * The constructor documentation\r\n     * @param int $x\r\n     */\r\n    public function __construct($x) {\r\n        $this->bar = $x;\r\n    }\r\n\r\n    public function baz() {\r\n        return $this->bar;\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']));\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children;\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes));\r\n\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n * The Foo class documentation\\n */',\r\n            code: \"class Foo {\\n    public $bar = 1;\\n\\n    /**\\n     * The constructor documentation\\n     * @param int $x\\n     */\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\\n\\n    public function baz() {\\n        return $this->bar;\\n    }\\n}\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.baz`, `${fileNode.id}::Foo.__construct`]\r\n        }\r\n    ];\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.baz`,\r\n            type: 'method',\r\n            name: 'Foo.baz',\r\n            label: 'Foo.baz',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo\\n    ...\\n    public function baz() {\\n        return $this->bar;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__construct`,\r\n            type: 'method',\r\n            name: 'Foo.__construct',\r\n            label: 'Foo.__construct',\r\n            language: 'php',\r\n            exportable: true,\r\n            documentation: '/**\\n     * The constructor documentation\\n     * @param int $x\\n     */',\r\n            code: \"class Foo\\n    ...\\n    public function __construct($x) {\\n        $this->bar = $x;\\n    }\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        }\r\n    ];\r\n\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren);\r\n    expect(fileNode.inDegree).toBe(1);\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods);\r\n});\r\n\r\n\r\ntest('Namespace v1', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities;\r\n\r\nuse MyProject\\\\Models\\\\User;\r\n\r\nclass Helper {\r\n    public static function greet(User $user) {\r\n        return \"Hello, \" . $user->getName();\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: 'class Helper {\\n    public static function greet(User $user) {\\n        return \"Hello, \" . $user->getName();\\n    }\\n}',\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\n\r\ntest('Namespace v2', () => {\r\n    const fileContent = `\r\n<?php\r\nnamespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}\r\n`;\r\n    const fileNode = new Node(`${rootFolderPath}/Helper.php`, fileContent, 'file', 'php');\r\n    fileNode.getChildrenDefinitions();\r\n\r\n    const namespaceChildren = Object.values(fileNode.children)[0];\r\n    const namespaceChildrenSimplified = namespaceChildren.simplify(nodeAttributes)\r\n    const classChildrenSimplified = Object.values(namespaceChildren.children)[0].simplify(nodeAttributes)\r\n\r\n    const expectedNamespace = {\r\n        id: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        type: 'namespace',\r\n        name: 'MyProject\\\\Utilities',\r\n        label: 'MyProject\\\\Utilities',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `namespace MyProject\\\\Utilities {\r\n    class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }\r\n}`,\r\n        parent: fileNode.id,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n    const expectedClass = {\r\n        id: `${fileNode.id}::Helper`,\r\n        type: 'class',\r\n        name: 'Helper',\r\n        label: 'Helper',\r\n        language: 'php',\r\n        exportable: true,\r\n        documentation: '',\r\n        code: `class Helper {\r\n        public static function greet() {\r\n            return \"Hello, World\";\r\n        }\r\n    }`,\r\n        parent: `${fileNode.id}::MyProject\\\\Utilities`,\r\n        inDegree: 1,\r\n        outDegree: 1,\r\n    };\r\n\r\n\r\n\r\n    expect(namespaceChildrenSimplified).toStrictEqual(expectedNamespace);\r\n    expect(classChildrenSimplified).toStrictEqual(expectedClass);\r\n});\r\n\r\n\r\ntest('Calls', () => {\r\n    const fileContent1 = `\r\n<?php\r\nnamespace MyNamespace;\r\n\r\nclass Foo {\r\n    private $baz = 1;\r\n\r\n    public function __construct() {\r\n        $this->baz = 1;\r\n    }\r\n\r\n    public function method() {\r\n        return 1;\r\n    }\r\n\r\n    public function method2() {\r\n        return $this->method();\r\n    }\r\n}\r\n`;\r\n\r\n    const fileContent2 = `\r\n<?php\r\nrequire_once 'file1.php';\r\n\r\nuse MyNamespace\\\\Foo;\r\n\r\n$fooVar = new Foo();\r\n$fooVar->method();\r\n\r\nfunction foo(Foo $param) {\r\n    return $param->method2();\r\n}\r\n`;\r\n\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'php');\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'php');\r\n    fileNode1.generateImports();\r\n    fileNode2.generateImports();\r\n\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions();\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions();\r\n\r\n    const fileNodesMap: { [id: string]: Node } = {};\r\n    fileNodesMap[fileNode1.id] = fileNode1;\r\n    fileNodesMap[fileNode2.id] = fileNode2;\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1;\r\n    nodesMap2[fileNode2.id] = fileNode2;\r\n\r\n    const nodesMap = { ...nodesMap1, ...nodesMap2 };\r\n    const codebase = new Codebase(rootFolderPath);\r\n    codebase.nodesMap = nodesMap;\r\n\r\n    Object.values(nodesMap).forEach(n => {\r\n        // save space nodes\r\n        if (['namespace', 'package', 'mod'].includes(n.type)) codebase.addNodeToSpaceMap(n)\r\n    })\r\n\r\n    codebase.resolveSpaces()\r\n    codebase.resolveImportStatementsNodes();\r\n    codebase.getCalls(fileNodesMap, true);\r\n\r\n    const method2Calls = codebase.getNode(`MyNamespace::Foo.method2`)?.simplify(['calls']);\r\n    const fileCalls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls']);\r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls']);\r\n\r\n    expect(method2Calls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fileCalls?.calls).toStrictEqual([`MyNamespace::Foo.method`, `MyNamespace::Foo`]);\r\n    expect(fooCalls?.calls).toStrictEqual([`MyNamespace::Foo`, `MyNamespace::Foo.method2`]);\r\n});",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\php.test.ts",
    "originFile": "",
    "generatedDocumentation": "# `php.test.ts` Wiki\n\n## Overview\nThe `php.test.ts` file contains a suite of unit tests designed to validate the functionality of the `Node` and `Codebase` classes within a PHP codebase. These tests ensure that various aspects of PHP code, such as import statements, global variable assignments, function definitions, class definitions, namespaces, and method calls, are correctly parsed and represented within the codebase model.\n\n## Main Features and Purpose\nThe primary purpose of this file is to verify the correct behavior of the codebase indexing and parsing mechanisms for PHP files. It covers different PHP constructs and ensures that they are accurately represented in the internal model.\n\n### Import Statements Test\n- **Purpose**: Validates the parsing and resolution of PHP import statements (`include`, `include_once`, `require`, `require_once`, and `use`).\n- **Key Components**:\n  - `fileNode.generateImports()`: Generates import statements from the file content.\n  - `fileNode.resolveImportStatementsPath()`: Resolves the paths of the import statements.\n  - **Expected Output**: A list of `ImportStatement` objects representing the parsed import statements.\n\n### Global Variable Assignments Test\n- **Purpose**: Ensures that global variable assignments within a PHP file are correctly identified and represented.\n- **Key Components**:\n  - `fileNode.getChildrenDefinitions()`: Extracts definitions of global variables.\n  - **Expected Output**: A list of simplified node objects representing the global variable assignments.\n\n### Function Definition Test\n- **Purpose**: Verifies the correct parsing of function definitions, including their documentation, parameters, and return types.\n- **Key Components**:\n  - `fileNode.getChildrenDefinitions()`: Extracts function definitions from the file content.\n  - **Expected Output**: A list of simplified node objects representing the function definitions.\n\n### Class Definition Test\n- **Purpose**: Ensures that class definitions, including methods and properties, are correctly parsed and represented.\n- **Key Components**:\n  - `fileNode.getChildrenDefinitions()`: Extracts class definitions and their methods.\n  - **Expected Output**: A list of simplified node objects representing the class and its methods.\n\n### Namespace Tests (v1 and v2)\n- **Purpose**: Validates the parsing of namespaces and their contained classes and methods.\n- **Key Components**:\n  - `fileNode.getChildrenDefinitions()`: Extracts namespace and class definitions.\n  - **Expected Output**: Simplified node objects representing the namespace and its contained classes.\n\n### Calls Test\n- **Purpose**: Ensures that method calls within and across PHP files are correctly identified and linked.\n- **Key Components**:\n  - `codebase.getCalls()`: Resolves method calls and their relationships.\n  - **Expected Output**: Simplified node objects representing the method calls and their targets.\n\n## Important Definitions\n- **Node**: Represents a code element (e.g., file, function, class) within the codebase.\n- **ImportStatement**: Represents an import statement in the code, including its path and type.\n- **Codebase**: Represents the entire codebase, managing nodes and their relationships.\n\n## Conclusion\nThe `php.test.ts` file is crucial for ensuring the robustness of the codebase indexing and parsing system for PHP files. By covering various PHP constructs and their relationships, these tests help maintain the accuracy and reliability of the codebase model.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\""
  },
  {
    "id": "74e12dce-257b-44b0-a66a-2e885f4f38c9",
    "fullName": "\\tests\\python.test::nodeAttributes",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "codeNoBody": "const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "nodeAttributes",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test.ts",
    "generatedDocumentation": "Code: const nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']",
    "importStatements": ""
  },
  {
    "id": "bbf70c23-c90c-4351-8853-470e1e898fc3",
    "fullName": "\\tests\\python.test::rootFolderPath",
    "type": "assignment",
    "language": "typescript",
    "documentation": "",
    "code": "const rootFolderPath = '/my/path'",
    "codeNoBody": "const rootFolderPath = '/my/path'",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "rootFolderPath",
    "originFile": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test.ts",
    "generatedDocumentation": "Code: const rootFolderPath = '/my/path'",
    "importStatements": ""
  },
  {
    "id": "2c1f4a0a-e695-4583-aa4e-8099863dbd25",
    "fullName": "\\tests\\python.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\n\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})\r\n",
    "codeNoBody": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";\r\nconst rootFolderPath = '/my/path'\r\nconst nodeAttributes = ['id', 'type', 'name', 'label', 'language', 'exportable', 'documentation', 'code', 'parent', 'inDegree', 'outDegree']\r\n\r\ntest('Import Statements',  () => {\r\n    const fileContent = `\r\nfrom .myModule import myFunction\r\nfrom ..myModule2 import myClass2 as myClass2Alias, myClass3\r\nimport myModule3 as myModule3Alias\r\nfrom initFile import myFunction\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.generateImports()\r\n    fileNode.resolveImportStatementsPath(rootFolderPath, [`${rootFolderPath}/file.py`, `${rootFolderPath}/myModule3.py`, `${rootFolderPath}/initFile/__init__.py`])\r\n\r\n    const expectedImports: ImportStatement[] = [\r\n        new ImportStatement('.myModule', [new ImportName('myFunction')], `/my/path/myModule`,\r\n        undefined, `from .myModule import myFunction`),\r\n        new ImportStatement('..myModule2', [new ImportName('myClass3'), new ImportName('myClass2', 'myClass2Alias')], '/my/myModule2',\r\n        undefined, `from ..myModule2 import myClass2 as myClass2Alias, myClass3`),\r\n        // myModule3 exists in the same folder\r\n        new ImportStatement('myModule3', [], '/my/path/myModule3', 'myModule3Alias',\r\n            `import myModule3 as myModule3Alias`),\r\n        // initFile is a folder, but contains __init__.py\r\n        new ImportStatement('initFile', [new ImportName('myFunction')], '/my/path/initFile/__init__', 'initFile',\r\n            `from initFile import myFunction`),\r\n    ]\r\n    expect(fileNode.importStatements).toStrictEqual(expectedImports)\r\n})\r\n\r\ntest('Assignments',  () => {\r\n    const fileContent = `\r\nfoo = 1\r\n# the bar documentation\r\nbar = baz\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    \r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'assignment',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '# the bar documentation',\r\n            code: 'bar = baz',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'assignment',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: 'foo = 1',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n})\r\n\r\n\r\ntest('Function definition',  () => {\r\n    const fileContent = `\r\n@decorator\r\ndef foo():\r\n    '''The foo documentation'''\r\n    return bar\r\n\r\ndef bar():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const firstNodeChildren = Object.values(fileNode.children)[0].children[`${rootFolderPath}/file::baz`].simplify(['id', 'parent', 'code', 'documentation'])\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const expectedChildren = [\r\n        {\r\n            id: `${fileNode.id}::bar`,\r\n            type: 'function',\r\n            name: 'bar',\r\n            label: 'bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"def bar():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\",\r\n            parent: fileNode.id,\r\n            inDegree: 1,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::baz`]\r\n        },\r\n        {\r\n            id: `${fileNode.id}::foo`,\r\n            type: 'function',\r\n            name: 'foo',\r\n            label: 'foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: `'''The foo documentation'''`,\r\n            code: '@decorator\\ndef foo():\\n    \\n    return bar',\r\n            parent: fileNode.id,\r\n            inDegree: 0,\r\n            outDegree: 1,\r\n            children: []\r\n        },\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedChildren)\r\n    expect(fileNode.inDegree).toBe(2)\r\n    expect(firstNodeChildren).toStrictEqual({\r\n        id: `${rootFolderPath}/file::baz`,\r\n        parent: `${fileNode.id}::bar`,\r\n        code: 'def baz():\\n        \\n        return 1',\r\n        documentation: \"'''The baz documentation'''\"\r\n    })\r\n})\r\n\r\ntest('Class definition',  () => {\r\n    const fileContent = `\r\nclass Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n    const classNodeChildren = Object.values(fileNode.children)[0].children\r\n    const fileNodeChildrenSimplified = Object.values(fileNode.children).map(n => n.simplify([...nodeAttributes, 'children']))\r\n    const classNodeMethodsSimplified = Object.values(classNodeChildren).map(n => n.simplify(nodeAttributes))\r\n    const expectedFileChildren = [\r\n        {\r\n            id: `${fileNode.id}::Foo`,\r\n            type: 'class',\r\n            name: 'Foo',\r\n            label: 'Foo',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: \"'''The foo class'''\",\r\n            code: \"class Foo:\\n    \\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        return 1\",\r\n            parent: fileNode.id,\r\n            inDegree: 2,\r\n            outDegree: 1,\r\n            children: [`${fileNode.id}::Foo.bar`, `${fileNode.id}::Foo.__init__`]\r\n        },\r\n    ]\r\n\r\n    const expectedMethods = [\r\n        {\r\n            id: `${fileNode.id}::Foo.bar`,\r\n            type: 'method',\r\n            name: 'Foo.bar',\r\n            label: 'Foo.bar',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def bar(self):\\n        return 1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n        {\r\n            id: `${fileNode.id}::Foo.__init__`,\r\n            type: 'method',\r\n            name: 'Foo.__init__',\r\n            label: 'Foo.__init__',\r\n            language: 'python',\r\n            exportable: true,\r\n            documentation: '',\r\n            code: \"class Foo:\\n    ...\\n    def __init__(self):\\n        self.foo=1\",\r\n            parent: `${fileNode.id}::Foo`,\r\n            inDegree: 0,\r\n            outDegree: 1\r\n        },\r\n\r\n    ]\r\n    expect(fileNodeChildrenSimplified).toStrictEqual(expectedFileChildren)\r\n    expect(fileNode.inDegree).toBe(1)\r\n    expect(classNodeMethodsSimplified).toStrictEqual(expectedMethods)\r\n})\r\n\r\n\r\n\r\ntest('Code without body',  () => {\r\n    const fileContent = `\r\n    class Foo:\r\n    '''The foo class'''\r\n    foo: int = 1\r\n\r\n    def __init__(self):\r\n        self.foo=1\r\n\r\n    def bar(self):\r\n        return 1\r\n        \r\ndef foo():\r\n    def baz():\r\n        '''The baz documentation'''\r\n        return 1\r\n    return baz()\r\n`\r\n    const fileNode = new Node(`${rootFolderPath}/file`, fileContent, 'file', 'python')\r\n    fileNode.getChildrenDefinitions()\r\n\r\n    const fooClass = fileNode.children[`${rootFolderPath}/file::Foo`]\r\n    const barMethod = fooClass.children[`${rootFolderPath}/file::Foo.bar`]\r\n    const fooFunction = fileNode.children[`${rootFolderPath}/file::foo`]\r\n\r\n    expect(fooClass.getCodeWithoutBody()).toBe(\"class Foo:\\n    foo: int = 1\\n\\n    def __init__(self):\\n        self.foo=1\\n\\n    def bar(self):\\n        \\n        ...\")\r\n    expect(barMethod.getCodeWithoutBody()).toBe(\"class Foo:\\n    ...\\n    def bar(self):\\n            ...\")\r\n    // functions with children remain unchanged?\r\n    expect(fooFunction.getCodeWithoutBody()).toBe(\"def foo():\\n    def baz():\\n        '''The baz documentation'''\\n        return 1\\n    return baz()\")\r\n})\r\n\r\n\r\ntest('Calls',  () => {\r\n    const fileContent1 = `\r\nclass Foo:\r\n    def __init__(self):\r\n        self.baz = 1\r\n    \r\n    def method(self):\r\n        pass\r\n\r\n    def method2(self):\r\n        self.method()\r\n    `\r\n    const fileContent2 = `\r\nfrom .file1 import Foo\r\n\r\nfoo_var = Foo()\r\nif True:\r\n    foo_var.method()\r\n\r\ndef foo(param: Foo):\r\n    return param.method2()\r\n`\r\n    const fileNode1 = new Node(`${rootFolderPath}/file1`, fileContent1, 'file', 'python')\r\n    const fileNode2 = new Node(`${rootFolderPath}/file2`, fileContent2, 'file', 'python')\r\n    fileNode1.generateImports()\r\n    fileNode2.generateImports()\r\n    const nodesMap1 = fileNode1.getChildrenDefinitions()\r\n    const nodesMap2 = fileNode2.getChildrenDefinitions()\r\n    \r\n    const fileNodesMap: {[id: string]: Node} = {}\r\n    fileNodesMap[fileNode1.id] = fileNode1\r\n    fileNodesMap[fileNode2.id] = fileNode2\r\n\r\n    nodesMap1[fileNode1.id] = fileNode1\r\n    nodesMap2[fileNode2.id] = fileNode2\r\n\r\n    const nodesMap = {...nodesMap1, ...nodesMap2}\r\n    const codebase = new Codebase(rootFolderPath)\r\n    codebase.nodesMap = nodesMap\r\n\r\n    codebase.resolveImportStatementsNodes()\r\n    codebase.getCalls(fileNodesMap)\r\n    \r\n    const method2Calls = codebase.getNode(`${rootFolderPath}/file1::Foo.method2`)?.simplify(['calls'])\r\n    const file2Calls = codebase.getNode(`${rootFolderPath}/file2`)?.simplify(['calls'])\r\n    const fooVarCalls = codebase.getNode(`${rootFolderPath}/file2::foo_var`)?.simplify(['calls']) \r\n    const fooCalls = codebase.getNode(`${rootFolderPath}/file2::foo`)?.simplify(['calls'])\r\n    \r\n    expect(file2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method`])\r\n    expect(fooVarCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`])\r\n    expect(method2Calls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo.method`, `${rootFolderPath}/file1::Foo`])\r\n    expect(fooCalls?.calls).toStrictEqual([`${rootFolderPath}/file1::Foo`, `${rootFolderPath}/file1::Foo.method2`])\r\n})",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\python.test.ts",
    "originFile": "",
    "generatedDocumentation": "# `python.test.ts` Wiki\n\n## Overview\nThe `python.test.ts` file is part of the test suite for the `codebase-index-ts` project. This file contains a series of unit tests designed to verify the functionality of the `Node` and `Codebase` classes when processing Python code files. The tests focus on various aspects of Python code parsing, including import statements, assignments, function definitions, class definitions, and method calls.\n\n## Main Features and Purpose\nThe primary purpose of this file is to ensure that the `Node` and `Codebase` classes correctly interpret and handle different Python code constructs. The tests cover the following main features:\n\n### 1. Import Statements\n- **Test:** `Import Statements`\n- **Purpose:** Validates the correct parsing and resolution of import statements in a Python file.\n- **Key Operations:**\n  - Parsing import statements from a given Python file content.\n  - Resolving the paths of the imported modules.\n  - Comparing the parsed import statements with the expected results.\n\n### 2. Assignments\n- **Test:** `Assignments`\n- **Purpose:** Ensures that assignment statements within a Python file are correctly identified and represented.\n- **Key Operations:**\n  - Extracting assignment statements and their attributes (e.g., documentation, code).\n  - Verifying the structure and attributes of the parsed assignments.\n\n### 3. Function Definitions\n- **Test:** `Function definition`\n- **Purpose:** Tests the parsing of function definitions, including nested functions and decorators.\n- **Key Operations:**\n  - Identifying function definitions and their attributes.\n  - Handling nested functions and decorators.\n  - Verifying the structure and attributes of the parsed functions.\n\n### 4. Class Definitions\n- **Test:** `Class definition`\n- **Purpose:** Validates the correct parsing of class definitions, including methods and class attributes.\n- **Key Operations:**\n  - Extracting class definitions and their attributes.\n  - Parsing methods within classes.\n  - Verifying the structure and attributes of the parsed classes and methods.\n\n### 5. Code Without Body\n- **Test:** `Code without body`\n- **Purpose:** Ensures that the code structure is correctly maintained even when the body of functions or methods is omitted.\n- **Key Operations:**\n  - Generating code representations without the bodies of functions or methods.\n  - Verifying the structure of the code without bodies.\n\n### 6. Calls\n- **Test:** `Calls`\n- **Purpose:** Tests the identification and resolution of function/method calls within and across Python files.\n- **Key Operations:**\n  - Parsing function/method calls.\n  - Resolving the nodes corresponding to the called functions/methods.\n  - Verifying the structure and attributes of the parsed calls.\n\n## Important Definitions\n- **Node:** Represents a code entity (e.g., file, function, class) within the codebase. It contains attributes like `id`, `type`, `name`, `label`, `language`, `exportable`, `documentation`, `code`, `parent`, `inDegree`, and `outDegree`.\n- **ImportStatement:** Represents an import statement in a Python file, including the module name, imported names, and resolved path.\n- **ImportName:** Represents a name imported from a module, optionally with an alias.\n- **Codebase:** Represents the entire codebase, managing the collection of nodes and their relationships.\n\n## Conclusion\nThe `python.test.ts` file is crucial for ensuring the robustness and correctness of the `Node` and `Codebase` classes in handling Python code. By covering a wide range of Python code constructs, these tests help maintain the integrity and functionality of the codebase indexing and parsing features.",
    "importStatements": "import { Codebase, Node, ImportStatement, ImportName } from \"../src/model/codebase\";"
  },
  {
    "id": "54a0e24a-c14d-4184-850b-436bff0b7cf6",
    "fullName": "\\tests\\utils.test",
    "type": "file",
    "language": "typescript",
    "documentation": "",
    "code": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('generateNodePrompts', async () => {\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n        const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n        // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n        // console.log(systemPrompt)\r\n        // console.log(userPrompt)\r\n        // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n        await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n        wikiutils.documentFolders(nodes, links, repoName)\r\n        // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })\r\n",
    "codeNoBody": "import * as utils from '../src/model/utils'\r\nimport { GraphLink, GraphNode } from '../src/utils/db'\r\nimport * as wikiutils from '../src/wiki/utils'\r\n// import Parser from 'tree-sitter'\r\n\r\n// cleanAndSplitContent\r\ndescribe('Common', () => {\r\n    test('cleanAndSplitContent: Get each element', () => {\r\n        const content = '[first, [second: third], (fourth)]'\r\n        const result = utils.cleanAndSplitContent(content)\r\n        expect(result).toStrictEqual(['first', 'second', 'third', 'fourth'])})\r\n})\r\n\r\ndescribe('Wiki', () => {\r\n    const nodes: GraphNode[] = [\r\n        { id: '1', fullName: 'src/File1::fun1', type: 'function', language: 'typescript', code: 'function fun1(x,y) { return fun3(x,y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 2, outDegree: 1, label: 'fun1',  },\r\n        { id: '2', fullName: 'src/File1::fun2', type: 'function', language: 'typescript', code: 'function fun2() { console.log(\"hello, world\") }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun2',  },\r\n        { id: '3', fullName: 'src/File1::fun3', type: 'function', language: 'typescript', code: 'function fun3(x,y) { return round(x+y) }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 1, outDegree: 0, label: 'fun3', },\r\n        { id: '4', fullName: 'src/File1::fun4', type: 'function', language: 'typescript', code: 'function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: '', totalTokens: 0, inDegree: 0, outDegree: 1, label: 'fun4', },\r\n        { id: '5', fullName: 'src/File1', type: 'file', language: 'typescript',\r\n            code: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { return fun3(x,y) }\\n\\n \\\r\n            function fun2() { console.log(\"hello, world\") }\\n\\n \\\r\n            function fun3(x,y) { return round(x+y) } \\n\\n \\\r\n            function fun4() { fun2();\\nreturn fun1(1,2); }',\r\n            codeNoBody: 'import { round } from \"@mathutils\"\\n\\n \\\r\n            function fun1(x,y) { //... }\\n\\n \\\r\n            function fun2() { //... }\\n\\n \\\r\n            function fun3(x,y) { //... } \\n\\n \\\r\n            function fun4() { //... }',\r\n            totalTokens: 0, inDegree: 0, outDegree: 1, label: 'File1.ts',\r\n            importStatements: 'import { round } from \"@mathutils\"', },\r\n    ];\r\n    \r\n    const repoName = 'mathUtils-test'\r\n\r\n    test('BFS v1', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['2', '4'],\r\n            2 : ['1'],\r\n            3 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS all to one', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '4'],\r\n            2 : ['3'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS v3', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '1', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['4'],\r\n            2 : ['2'],\r\n            3 : ['3', '1']\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS itself', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '2', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '3', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '4', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3', '4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('BFS circular', () => {\r\n\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '1', target: '2', label: 'calls' },\r\n            { id: 'l2', source: '2', target: '3', label: 'calls' },\r\n            { id: 'l2', source: '3', target: '4', label: 'calls' },\r\n            { id: 'l3', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const {graph } = wikiutils.buildGraphs(nodes, links)\r\n        const expectedResults = {\r\n            0 : ['5'],\r\n            1 : ['1', '2', '3'],\r\n            2 : ['4'],\r\n        }\r\n        expect(wikiutils.bfsLevels(nodes, graph)).toStrictEqual(expectedResults)\r\n    })\r\n\r\n    test('generateNodePrompts', async () => {\r\n        const links: GraphLink[] = [\r\n            { id: 'l1', source: '4', target: '2', label: 'calls' },\r\n            { id: 'l1', source: '4', target: '1', label: 'calls' },\r\n            { id: 'l2', source: '1', target: '3', label: 'calls' },\r\n            { id: 'l10', source: '5', target: '1', label: 'defines' },\r\n            { id: 'l11', source: '5', target: '2', label: 'defines' },\r\n            { id: 'l12', source: '5', target: '3', label: 'defines' },\r\n            { id: 'l13', source: '5', target: '4', label: 'defines' },\r\n        ];\r\n        const { graph } = wikiutils.buildGraphs(nodes, links) \r\n\r\n        const nodesByLevels = wikiutils.bfsLevels(nodes, graph)\r\n        // const { systemPrompt, userPrompt } = wikiutils.generateNodePrompts(nodes[0], nodes, graph);\r\n        // console.log(systemPrompt)\r\n        // console.log(userPrompt)\r\n        // await wikiutils.generateNodeDocumentation(nodes[0], nodes, graph, repoName)\r\n\r\n        await wikiutils.documentNodesByLevels(nodesByLevels, nodes, graph, repoName)\r\n\r\n        wikiutils.documentFolders(nodes, links, repoName)\r\n        // console.log({nodes: nodes.map(n => {return { name: n.fullName, generatedDocumentation: n.generatedDocumentation}})})\r\n    }, 20000)\r\n})\r\n\r\n// // renameSource\r\n// describe('JS/TS/TSX', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = './subFolder/myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.ts'\r\n//         const sourceModuleName = '../../myModule'\r\n//         const language = 'typescript'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n// describe('Python', () => {\r\n//     test('renameSource: Test module in the same folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a subfolder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '.subFolder.myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/folder/subFolder/myModule')\r\n//     })\r\n\r\n\r\n//     test('renameSource: Test module in a parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '..myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/my/myModule')\r\n//     })\r\n\r\n//     test('renameSource: Test module in a parent parent folder', () => {\r\n//         const filePath = '/my/folder/file.py'\r\n//         const sourceModuleName = '...myModule'\r\n//         const language = 'python'\r\n//         const result = utils.renameSource(filePath, sourceModuleName, language)\r\n//         expect(result).toBe('/myModule')\r\n//     })\r\n// })\r\n\r\n\r\n\r\n\r\n\r\n// captureQuery:\r\n// - importStatements\r\n// - constructorDefinitions\r\n// - definitionTemplate\r\n// - exportClauses\r\n// - extraAssignmentCode(name)\r\n// - calls\r\n// - assignments\r\n\r\n// describe('captureQuery',  () => {\r\n//     describe('importStatements', () => {\r\n//         test('JS/TS/TSX',  () => {\r\n//             const code = `import { function as aFunction } from 'myModule'\\nimport * as moduleAlias from 'myModule'\\nconst { function } = require('myModule')`\r\n//             const captures = utils.captureQuery('javascript', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `import { function as aFunction } from 'myModule'` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `import * as moduleAlias from 'myModule'` },\r\n//                 { type: 'alias', text: `moduleAlias` },\r\n//                 { type: 'module', text: `myModule` },\r\n//                 // third import\r\n//                 { type: 'import_statement', text: `const { function } = require('myModule')` },\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'function', text: `require`},\r\n//                 { type: 'module', text: `myModule` }\r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n\r\n//         test('Python',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n\r\n//     describe('constructorDefinitions', () => {\r\n//         test('JS/TS/TSX: Class',  () => {\r\n//             const code = `from myModule import function as aFunction\\nfrom myModule import *`\r\n//             const captures = utils.captureQuery('python', 'importStatements', code)\r\n//             const capturesShort = captures.map(c => { return {type: c.name, text: c.node.text} })\r\n//             const expectedCaptures = [\r\n//                 // first import: simple function with alias\r\n//                 { type: 'import_statement', text: `from myModule import function as aFunction` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'name', text: `function` },\r\n//                 { type: 'alias', text: `aFunction` },\r\n//                 // second import\r\n//                 { type: 'import_statement', text: `from myModule import *` },\r\n//                 { type: 'module', text: `myModule` }, // in Python module's name comes first\r\n//                 { type: 'wildcard', text: `*` } \r\n//             ]\r\n//             expect(capturesShort).toStrictEqual(expectedCaptures)\r\n//         })\r\n//     })\r\n// })",
    "totalTokens": 0,
    "inDegree": 0,
    "outDegree": 0,
    "label": "C:\\Users\\gmasc\\OneDrive\\Documentos\\CodeGPT\\Graphs\\codebase-index-ts\\tests\\utils.test.ts",
    "originFile": "",
    "generatedDocumentation": "## Overview of the `tests/utils.test.ts` File\n\nThe `utils.test.ts` file is part of the test suite for the `codebase-index-ts` repository. This file contains unit tests designed to validate the functionality of utility functions used within the project. The tests are written using the Jest testing framework and focus on various utility functions imported from different parts of the codebase.\n\n## Main Features and Purpose\n\n### Purpose\nThe primary purpose of this file is to ensure that the utility functions used in the project work as expected. It includes tests for functions that handle content cleaning, graph building, breadth-first search (BFS) traversal, and source renaming for different programming languages.\n\n### Structure\nThe file is organized into several `describe` blocks, each targeting a specific set of functionalities or modules. Each `describe` block contains multiple `test` cases that validate individual functions.\n\n### Key Sections and Tests\n\n#### Common Utilities\n- **cleanAndSplitContent**\n  - **Test:** `cleanAndSplitContent: Get each element`\n  - **Description:** This test checks the `cleanAndSplitContent` function from `utils` to ensure it correctly processes a string containing nested elements and splits it into individual elements.\n\n#### Wiki Utilities\n- **Graph Operations**\n  - **Test:** `BFS v1`, `BFS all to one`, `BFS v3`, `BFS itself`, `BFS circular`\n  - **Description:** These tests validate the BFS traversal logic implemented in the `wikiutils` module. They build graphs using nodes and links and then verify the BFS levels generated by the `bfsLevels` function.\n- **Documentation Generation**\n  - **Test:** `generateNodePrompts`\n  - **Description:** This test checks the documentation generation functionality for nodes in a graph. It uses the `documentNodesByLevels` and `documentFolders` functions to ensure documentation is correctly generated and organized.\n\n#### Source Renaming\n- **renameSource**\n  - **Tests:** Various tests for renaming source modules in JavaScript/TypeScript and Python.\n  - **Description:** These tests validate the `renameSource` function, ensuring it correctly renames source module paths based on the given file path and source module name. The tests cover different scenarios such as modules in the same folder, subfolders, and parent folders.\n\n#### Capture Queries\n- **importStatements**\n  - **Tests:** `JS/TS/TSX`, `Python`\n  - **Description:** These tests validate the `captureQuery` function for capturing import statements in JavaScript/TypeScript and Python code. The tests ensure that the function correctly identifies and captures different types of import statements.\n- **constructorDefinitions**\n  - **Test:** `JS/TS/TSX: Class`\n  - **Description:** This test checks the `captureQuery` function for capturing constructor definitions in JavaScript/TypeScript classes.\n\n## Important Definitions\n- **GraphNode and GraphLink**\n  - **Description:** These are TypeScript types representing nodes and links in a graph. They are used extensively in the tests to build and validate graph structures.\n- **wikiutils**\n  - **Description:** This module contains utility functions related to wiki operations, such as building graphs and generating documentation. Functions like `buildGraphs`, `bfsLevels`, and `documentNodesByLevels` are tested in this file.\n\n## Conclusion\nThe `utils.test.ts` file is crucial for maintaining the integrity of utility functions within the `codebase-index-ts` project. By thoroughly testing these functions, the file ensures that the core functionalities related to content processing, graph operations, and source renaming work as intended, thereby contributing to the overall robustness and reliability of the project.",
    "importStatements": "import * as utils from '../src/model/utils'\nimport { GraphLink, GraphNode } from '../src/utils/db'\nimport * as wikiutils from '../src/wiki/utils'"
  }
]